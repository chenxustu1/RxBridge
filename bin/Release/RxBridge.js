/**
 * @version 1.0.0.0
 * @author Lurium, LLC
 * @copyright Copyright Â© Lurium, LLC 2017
 * @compiler Bridge.NET 15.6.0
 */
Bridge.assembly("RxBridge", function ($asm, globals) {
    "use strict";

    Bridge.define("RxBridge.Environment", {
        statics: {
            getHasShutdownStarted: function () {
                return false;
            }
        }
    });

    Bridge.define("System.Collections.Generic.SortedDictionary$2", function (TKey, TValue) { return {
        inherits: [System.Collections.Generic.IEnumerable$1(System.Collections.Generic.KeyValuePair$2(TKey,TValue))],
        _set: null,
        config: {
            alias: [
            "getEnumerator", "System$Collections$Generic$IEnumerable$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$getEnumerator"
            ]
        },
        ctor: function () {
            this.$initialize();
            this._set = new (System.Collections.Generic.SortedDictionary$2.TreeSet$1(TKey,TValue,System.Collections.Generic.KeyValuePair$2(TKey,TValue)))(new (System.Collections.Generic.SortedDictionary$2.KeyValuePairComparer(TKey,TValue))());
        },
        getCount: function () {
            return this._set.getCount();
        },
        add: function (key, value) {
            this._set.add(new (System.Collections.Generic.KeyValuePair$2(TKey,TValue))(key, value));
        },
        remove: function (key) {
            return this._set.remove(new (System.Collections.Generic.KeyValuePair$2(TKey,TValue))(key, Bridge.getDefaultValue(TValue)));
        },
        getEnumerator: function () {
            return new (System.Collections.Generic.SortedDictionary$2.Enumerator(TKey,TValue)).$ctor1(this);
        },
        System$Collections$IEnumerable$getEnumerator: function () {
            return this.getEnumerator();
        }
    }; });

    Bridge.define("System.Collections.Generic.SortedDictionary$2.Enumerator", function (TKey, TValue) { return {
        inherits: [System.Collections.Generic.IEnumerator$1(System.Collections.Generic.KeyValuePair$2(TKey,TValue))],
        $kind: "struct",
        statics: {
            getDefaultValue: function () { return new (System.Collections.Generic.SortedDictionary$2.Enumerator(TKey,TValue))(); }
        },
        config: {
            alias: [
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "dispose", "System$IDisposable$dispose",
            "getCurrent", "System$Collections$Generic$IEnumerator$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$getCurrent$1"
            ],
            init: function () {
                this._treeEnum = new (System.Collections.Generic.SortedSet$1.Enumerator(System.Collections.Generic.KeyValuePair$2(TKey,TValue)))();
            }
        },
        $ctor1: function (dictionary) {
            this.$initialize();
            this._treeEnum = dictionary._set.getEnumerator().$clone();
        },
        ctor: function () {
            this.$initialize();
        },
        getCurrent: function () {
            return this._treeEnum.getCurrent();
        },
        System$Collections$IEnumerator$getCurrent: function () {
            return new (System.Collections.Generic.KeyValuePair$2(TKey,TValue))(this.getCurrent().key, this.getCurrent().value);
        },
        moveNext: function () {
            return this._treeEnum.moveNext();
        },
        dispose: function () {
            this._treeEnum.dispose();
        },
        reset: function () {
            this._treeEnum.reset();
        },
        System$Collections$IEnumerator$reset: function () {
            this._treeEnum.reset();
        },
        getHashCode: function () {
            var h = Bridge.addHash([3788985113, this._treeEnum]);
            return h;
        },
        equals: function (o) {
            if (!Bridge.is(o, System.Collections.Generic.SortedDictionary$2.Enumerator(TKey,TValue))) {
                return false;
            }
            return Bridge.equals(this._treeEnum, o._treeEnum);
        },
        $clone: function (to) {
            var s = to || new (System.Collections.Generic.SortedDictionary$2.Enumerator(TKey,TValue))();
            s._treeEnum = this._treeEnum.$clone();
            return s;
        }
    }; });

    Bridge.define("System.Collections.Generic.SortedDictionary$2.KeyValuePairComparer", function (TKey, TValue) { return {
        inherits: [System.Collections.Generic.Comparer$1(System.Collections.Generic.KeyValuePair$2(TKey,TValue))],
        _keyComparer: null,
        config: {
            alias: [
            "compare", "System$Collections$Generic$IComparer$1$System$Collections$Generic$KeyValuePair$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TValue) + "$compare"
            ],
            init: function () {
                this._keyComparer = new (System.Collections.Generic.Comparer$1(TKey))(System.Collections.Generic.Comparer$1.$default.fn);
            }
        },
        compare: function (x, y) {
            return this._keyComparer["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TKey) + "$compare"](x.key, y.key);
        }
    }; });

    Bridge.define("System.Collections.Generic.SortedSet$1", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerable$1(T)],
        statics: {
            getSibling: function (node, parent) {
                if (Bridge.referenceEquals(parent.left, node)) {
                    return parent.right;
                }
                return parent.left;
            },
            is2Node: function (node) {
                return System.Collections.Generic.SortedSet$1(T).isBlack(node) && System.Collections.Generic.SortedSet$1(T).isNullOrBlack(node.left) && System.Collections.Generic.SortedSet$1(T).isNullOrBlack(node.right);
            },
            is4Node: function (node) {
                return System.Collections.Generic.SortedSet$1(T).isRed(node.left) && System.Collections.Generic.SortedSet$1(T).isRed(node.right);
            },
            isBlack: function (node) {
                return (node != null && !node.isRed);
            },
            isNullOrBlack: function (node) {
                return (node == null || !node.isRed);
            },
            isRed: function (node) {
                return (node != null && node.isRed);
            },
            merge2Nodes: function (parent, child1, child2) {
                // combing two 2-nodes into a 4-node
                parent.isRed = false;
                child1.isRed = true;
                child2.isRed = true;
            },
            rotateLeft: function (node) {
                var x = node.right;
                node.right = x.left;
                x.left = node;

                return x;
            },
            rotateLeftRight: function (node) {
                var child = node.left;
                var grandChild = child.right;

                node.left = grandChild.right;
                grandChild.right = node;
                child.right = grandChild.left;
                grandChild.left = child;

                return grandChild;
            },
            rotateRight: function (node) {
                var x = node.left;
                node.left = x.right;
                x.right = node;

                return x;
            },
            rotateRightLeft: function (node) {
                var child = node.right;
                var grandChild = child.left;

                node.right = grandChild.left;
                grandChild.left = node;
                child.left = grandChild.right;
                grandChild.right = child;

                return grandChild;
            },
            rotationNeeded: function (parent, current, sibling) {
                if (System.Collections.Generic.SortedSet$1(T).isRed(sibling.left)) {
                    if (Bridge.referenceEquals(parent.left, current)) {
                        return System.Collections.Generic.TreeRotation.RightLeftRotation;
                    }

                    return System.Collections.Generic.TreeRotation.RightRotation;
                } else {
                    if (Bridge.referenceEquals(parent.left, current)) {
                        return System.Collections.Generic.TreeRotation.LeftRotation;
                    }

                    return System.Collections.Generic.TreeRotation.LeftRightRotation;
                }
            },
            split4Node: function (node) {
                node.isRed = true;
                node.left.isRed = false;
                node.right.isRed = false;
            },
            log2: function (value) {
                var c = 0;

                while (value > 0) {
                    c = (c + 1) | 0;
                    value = value >> 1;
                }

                return c;
            }
        },
        _comparer: null,
        _root: null,
        _count: 0,
        _version: 0,
        config: {
            alias: [
            "System$Collections$Generic$IEnumerable$1$T$getEnumerator", "System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$getEnumerator"
            ]
        },
        ctor: function (comparer) {
            this.$initialize();
            this._comparer = comparer;
        },
        getCount: function () {
            return this._count;
        },
        add: function (item) {
            return this.addIfNotPresent(item);
        },
        addIfNotPresent: function (item) {
            if (this._root == null) {
                this._root = new (System.Collections.Generic.SortedSet$1.Node(T)).$ctor1(item, false);
                this._count = 1;
                this._version = (this._version + 1) | 0;
                return true;
            }

            //
            // Search for a node at bottom to insert the new node. 
            // If we can guarantee the node we found is not a 4-node, it would be easy to do insertion.
            // We split 4-nodes along the search path.
            // 
            var current = this._root;
            var parent = { v : null };
            var grandParent = null;
            var greatGrandParent = null;

            //
            // Even if we don't actually add to the set, we may be altering its structure (by doing rotations
            // and such). so update version to disable any enumerators/subsets working on it.
            //
            this._version = (this._version + 1) | 0;

            var order = 0;
            while (current != null) {
                order = this._comparer["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare"](item, current.item);
                if (order === 0) {
                    // We could have changed root node to red during the search process.
                    // We need to set it to black before we return.
                    this._root.isRed = false;
                    return false;
                }

                // split a 4-node into two 2-nodes                
                if (System.Collections.Generic.SortedSet$1(T).is4Node(current)) {
                    System.Collections.Generic.SortedSet$1(T).split4Node(current);
                    // We could have introduced two consecutive red nodes after split. Fix that by rotation.
                    if (System.Collections.Generic.SortedSet$1(T).isRed(parent.v)) {
                        this.insertionBalance(current, parent, grandParent, greatGrandParent);
                    }
                }

                greatGrandParent = grandParent;
                grandParent = parent.v;
                parent.v = current;
                current = (order < 0) ? current.left : current.right;
            }


            var node = new (System.Collections.Generic.SortedSet$1.Node(T)).ctor(item);
            if (order > 0) {
                parent.v.right = node;
            } else {
                parent.v.left = node;
            }

            //
            // The new node will be red, so we will need to adjust the colors if parent node is also red.
            //
            if (parent.v.isRed) {
                this.insertionBalance(node, parent, grandParent, greatGrandParent);
            }

            //
            // Root node is always black.
            //
            this._root.isRed = false;
            this._count = (this._count + 1) | 0;
            return true;
        },
        remove: function (item) {
            return this.doRemove(item); // hack so it can be made non-virtual
        },
        doRemove: function (item) {
            if (this._root == null) {
                return false;
            }

            // Search for a node and then find its succesor. 
            // Then copy the item from the succesor to the matching node and delete the successor. 
            // If a node doesn't have a successor, we can replace it with its left child (if not empty.) 
            // or delete the matching node.
            // 
            // In top-down implementation, it is important to make sure the node to be deleted is not a 2-node.
            // Following code will make sure the node on the path is not a 2 Node. 

            //
            // Even if we don't actually remove from the set, we may be altering its structure (by doing rotations
            // and such). so update version to disable any enumerators/subsets working on it.
            //
            this._version = (this._version + 1) | 0;

            var current = this._root;
            var parent = null;
            var grandParent = null;
            var match = null;
            var parentOfMatch = null;
            var foundMatch = false;
            while (current != null) {
                if (System.Collections.Generic.SortedSet$1(T).is2Node(current)) { // fix up 2-Node
                    if (parent == null) { // current is root. Mark it as red
                        current.isRed = true;
                    } else {
                        var sibling = System.Collections.Generic.SortedSet$1(T).getSibling(current, parent);
                        if (sibling.isRed) {
                            // If parent is a 3-node, flip the orientation of the red link. 
                            // We can acheive this by a single rotation        
                            // This case is converted to one of other cased below.
                            if (Bridge.referenceEquals(parent.right, sibling)) {
                                System.Collections.Generic.SortedSet$1(T).rotateLeft(parent);
                            } else {
                                System.Collections.Generic.SortedSet$1(T).rotateRight(parent);
                            }

                            parent.isRed = true;
                            sibling.isRed = false; // parent's color
                            // sibling becomes child of grandParent or root after rotation. Update link from grandParent or root
                            this.replaceChildOfNodeOrRoot(grandParent, parent, sibling);
                            // sibling will become grandParent of current node 
                            grandParent = sibling;
                            if (Bridge.referenceEquals(parent, match)) {
                                parentOfMatch = sibling;
                            }

                            // update sibling, this is necessary for following processing
                            sibling = (Bridge.referenceEquals(parent.left, current)) ? parent.right : parent.left;
                        }

                        if (System.Collections.Generic.SortedSet$1(T).is2Node(sibling)) {
                            System.Collections.Generic.SortedSet$1(T).merge2Nodes(parent, current, sibling);
                        } else {
                            // current is a 2-node and sibling is either a 3-node or a 4-node.
                            // We can change the color of current to red by some rotation.
                            var rotation = System.Collections.Generic.SortedSet$1(T).rotationNeeded(parent, current, sibling);
                            var newGrandParent = null;
                            switch (rotation) {
                                case System.Collections.Generic.TreeRotation.RightRotation: 
                                    sibling.left.isRed = false;
                                    newGrandParent = System.Collections.Generic.SortedSet$1(T).rotateRight(parent);
                                    break;
                                case System.Collections.Generic.TreeRotation.LeftRotation: 
                                    sibling.right.isRed = false;
                                    newGrandParent = System.Collections.Generic.SortedSet$1(T).rotateLeft(parent);
                                    break;
                                case System.Collections.Generic.TreeRotation.RightLeftRotation: 
                                    newGrandParent = System.Collections.Generic.SortedSet$1(T).rotateRightLeft(parent);
                                    break;
                                case System.Collections.Generic.TreeRotation.LeftRightRotation: 
                                    newGrandParent = System.Collections.Generic.SortedSet$1(T).rotateLeftRight(parent);
                                    break;
                            }

                            newGrandParent.isRed = parent.isRed;
                            parent.isRed = false;
                            current.isRed = true;
                            this.replaceChildOfNodeOrRoot(grandParent, parent, newGrandParent);
                            if (Bridge.referenceEquals(parent, match)) {
                                parentOfMatch = newGrandParent;
                            }
                            grandParent = newGrandParent;
                        }
                    }
                }

                // we don't need to compare any more once we found the match
                var order = foundMatch ? -1 : this._comparer["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(T) + "$compare"](item, current.item);
                if (order === 0) {
                    // save the matching node
                    foundMatch = true;
                    match = current;
                    parentOfMatch = parent;
                }

                grandParent = parent;
                parent = current;

                if (order < 0) {
                    current = current.left;
                } else {
                    current = current.right; // continue the search in  right sub tree after we find a match
                }
            }

            // move successor to the matching node position and replace links
            if (match != null) {
                this.replaceNode(match, parentOfMatch, parent, grandParent);
                this._count = (this._count - 1) | 0;
            }

            if (this._root != null) {
                this._root.isRed = false;
            }

            return foundMatch;
        },
        getEnumerator: function () {
            return new (System.Collections.Generic.SortedSet$1.Enumerator(T)).$ctor1(this);
        },
        System$Collections$Generic$IEnumerable$1$T$getEnumerator: function () {
            return new (System.Collections.Generic.SortedSet$1.Enumerator(T)).$ctor1(this);
        },
        System$Collections$IEnumerable$getEnumerator: function () {
            return new (System.Collections.Generic.SortedSet$1.Enumerator(T)).$ctor1(this);
        },
        insertionBalance: function (current, parent, grandParent, greatGrandParent) {
            var parentIsOnRight = (Bridge.referenceEquals(grandParent.right, parent.v));
            var currentIsOnRight = (Bridge.referenceEquals(parent.v.right, current));

            var newChildOfGreatGrandParent;
            if (parentIsOnRight === currentIsOnRight) { // same orientation, single rotation
                newChildOfGreatGrandParent = currentIsOnRight ? System.Collections.Generic.SortedSet$1(T).rotateLeft(grandParent) : System.Collections.Generic.SortedSet$1(T).rotateRight(grandParent);
            } else { // different orientaton, double rotation
                newChildOfGreatGrandParent = currentIsOnRight ? System.Collections.Generic.SortedSet$1(T).rotateLeftRight(grandParent) : System.Collections.Generic.SortedSet$1(T).rotateRightLeft(grandParent);
                // current node now becomes the child of greatgrandparent 
                parent.v = greatGrandParent;
            }
            // grand parent will become a child of either parent of current.
            grandParent.isRed = true;
            newChildOfGreatGrandParent.isRed = false;

            this.replaceChildOfNodeOrRoot(greatGrandParent, grandParent, newChildOfGreatGrandParent);
        },
        replaceChildOfNodeOrRoot: function (parent, child, newChild) {
            if (parent != null) {
                if (Bridge.referenceEquals(parent.left, child)) {
                    parent.left = newChild;
                } else {
                    parent.right = newChild;
                }
            } else {
                this._root = newChild;
            }
        },
        replaceNode: function (match, parentOfMatch, successor, parentOfSuccessor) {
            if (Bridge.referenceEquals(successor, match)) { // this node has no successor, should only happen if right child of matching node is null.
                successor = match.left;
            } else {
                if (successor.right != null) {
                    successor.right.isRed = false;
                }

                if (!Bridge.referenceEquals(parentOfSuccessor, match)) { // detach succesor from its parent and set its right child
                    parentOfSuccessor.left = successor.right;
                    successor.right = match.right;
                }

                successor.left = match.left;
            }

            if (successor != null) {
                successor.isRed = match.isRed;
            }

            this.replaceChildOfNodeOrRoot(parentOfMatch, match, successor);
        },
        updateVersion: function () {
            this._version = (this._version + 1) | 0;
        }
    }; });

    Bridge.define("System.Collections.Generic.SortedSet$1.Enumerator", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerator$1(T)],
        $kind: "struct",
        statics: {
            getDefaultValue: function () { return new (System.Collections.Generic.SortedSet$1.Enumerator(T))(); }
        },
        _tree: null,
        _version: 0,
        _stack: null,
        _current: null,
        config: {
            alias: [
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "dispose", "System$IDisposable$dispose",
            "getCurrent", "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$getCurrent$1"
            ]
        },
        $ctor1: function (set) {
            this.$initialize();
            this._tree = set;
            this._version = this._tree._version;

            // 2lg(n + 1) is the maximum height
            this._stack = new (System.Collections.Generic.Stack$1(System.Collections.Generic.SortedSet$1.Node(T))).$ctor2(((2 * System.Collections.Generic.SortedSet$1(T).log2(((set.getCount() + 1) | 0))) | 0));
            this._current = null;
            this.intialize();
        },
        ctor: function () {
            this.$initialize();
        },
        getCurrent: function () {
            if (this._current != null) {
                return this._current.item;
            }

            return Bridge.getDefaultValue(T);
        },
        System$Collections$IEnumerator$getCurrent: function () {
            if (this._current == null) {
                throw new System.InvalidOperationException("Collection has changed during enumeration.");
            }

            return this._current.item;
        },
        getNotStartedOrEnded: function () {
            return this._current == null;
        },
        intialize: function () {
            this._current = null;

            var node = this._tree._root;
            var next = null, other = null;

            while (node != null) {
                next = node.left;
                other = node.right;

                this._stack.push(node);
                node = next;
            }
        },
        moveNext: function () {
            if (this._version !== this._tree._version) {
                throw new System.InvalidOperationException("Collection has changed during enumeration.");
            }

            if (this._stack.getCount() === 0) {
                this._current = null;
                return false;
            }

            this._current = this._stack.pop();

            var node = this._current.right;
            var next = null, other = null;

            while (node != null) {
                next = node.left;
                other = node.right;

                this._stack.push(node);
                node = next;
            }

            return true;
        },
        dispose: function () {
        },
        reset: function () {
            if (this._version !== this._tree._version) {
                throw new System.InvalidOperationException("Collection has changed during enumeration.");
            }

            this._stack.clear();
            this.intialize();
        },
        System$Collections$IEnumerator$reset: function () {
            this.reset();
        },
        getHashCode: function () {
            var h = Bridge.addHash([3788985113, this._tree, this._version, this._stack, this._current]);
            return h;
        },
        equals: function (o) {
            if (!Bridge.is(o, System.Collections.Generic.SortedSet$1.Enumerator(T))) {
                return false;
            }
            return Bridge.equals(this._tree, o._tree) && Bridge.equals(this._version, o._version) && Bridge.equals(this._stack, o._stack) && Bridge.equals(this._current, o._current);
        },
        $clone: function (to) {
            var s = to || new (System.Collections.Generic.SortedSet$1.Enumerator(T))();
            s._tree = this._tree;
            s._version = this._version;
            s._stack = this._stack;
            s._current = this._current;
            return s;
        }
    }; });

    Bridge.define("System.Collections.Generic.SortedSet$1.Node", function (T) { return {
        isRed: false,
        item: Bridge.getDefaultValue(T),
        left: null,
        right: null,
        ctor: function (item) {
            this.$initialize();
            // The default color will be red, we never need to create a black node directly.                
            this.item = item;
            this.isRed = true;
        },
        $ctor1: function (item, isRed) {
            this.$initialize();
            // The default color will be red, we never need to create a black node directly.                
            this.item = item;
            this.isRed = isRed;
        }
    }; });

    Bridge.define("System.Collections.Generic.TreeRotation", {
        $kind: "enum",
        statics: {
            LeftRotation: 1,
            RightRotation: 2,
            RightLeftRotation: 3,
            LeftRightRotation: 4
        }
    });

    Bridge.define("System.DateTimeExtensions", {
        statics: {
            toFileTime: function (dt) {
                return System.Int64(0);
            },
            specifyKind: function (unused_for_static, dt, kind) {
                if (kind === System.DateTimeKind.Utc) {
                    return Bridge.Date.toUTC(dt);
                } else {
                    if (kind === System.DateTimeKind.Local) {
                        return Bridge.Date.toLocal(dt);
                    } else {
                        return dt;
                    }
                }
            },
            kind: function (dt) {
                if (Bridge.equalsT(dt, Bridge.Date.toLocal(dt))) {
                    return System.DateTimeKind.Local;
                } else {
                    if (Bridge.equalsT(dt, Bridge.Date.toUTC(dt))) {
                        return System.DateTimeKind.Utc;
                    } else {
                        return System.DateTimeKind.Unspecified;
                    }
                }
            }
        }
    });

    Bridge.define("System.DateTimeKind", {
        $kind: "enum",
        statics: {
            Local: 0,
            Unspecified: 1,
            Utc: 2
        }
    });

    Bridge.define("System.DateTimeOffset", {
        inherits: function () { return [System.IComparable,System.IComparable$1(System.DateTimeOffset),System.IEquatable$1(System.DateTimeOffset)]; },
        $kind: "struct",
        statics: {
            MaxOffset: System.Int64([1488826368,117]),
            MinOffset: System.Int64([-1488826368,-118]),
            config: {
                init: function () {
                    this.minValue = new System.DateTimeOffset.$ctor5(System.Int64((new Date(-864e13)).getTime()).mul(10000), System.TimeSpan.zero);
                    this.maxValue = new System.DateTimeOffset.$ctor5(System.Int64((new Date(864e13)).getTime()).mul(10000), System.TimeSpan.zero);
                }
            },
            getNow: function () {
                return new System.DateTimeOffset.$ctor1(new Date());
            },
            getUtcNow: function () {
                return new System.DateTimeOffset.$ctor1(Bridge.Date.utcNow());
            },
            compare: function (first, second) {
                return Bridge.compare(first.getUtcDateTime(), second.getUtcDateTime());
            },
            equals: function (first, second) {
                return Bridge.equalsT(first.getUtcDateTime(), second.getUtcDateTime());
            },
            validateOffset: function (offset) {
                var ticks = offset.getTicks();
                if (ticks.mod(System.Int64(600000000)).ne(System.Int64(0))) {
                    /* BDS-*/ //throw new ArgumentException(Environment.GetResourceString("Argument_OffsetPrecision"), "offset");
                    /* BDS+*/
                    throw new System.ArgumentException("OffsetPrecision", "offset");
                }
                if (ticks.lt(System.DateTimeOffset.MinOffset) || ticks.gt(System.DateTimeOffset.MaxOffset)) {
                    /* BDS-*/ //throw new ArgumentOutOfRangeException("offset", Environment.GetResourceString("Argument_OffsetOutOfRange"));
                    /* BDS+*/
                    throw new System.ArgumentOutOfRangeException("offset", "OffsetOutOfRange");
                }
                return System.Int64.clip16(offset.getTicks().div(System.Int64(600000000)));
            },
            validateDate: function (dateTime, offset) {
                // The key validation is that both the UTC and clock times fit. The clock time is validated
                // by the DateTime constructor.
                /* BDS-*/ //Contract.Assert(offset.Ticks >= MinOffset && offset.Ticks <= MaxOffset, "Offset not validated.");
                // This operation cannot overflow because offset should have already been validated to be within
                // 14 hours and the DateTime instance is more than that distance from the boundaries of Int64.
                var utcTicks = System.Int64((dateTime).getTime()).mul(10000).sub(offset.getTicks());
                /* BDS-*/ //if (utcTicks < DateTime.MinTicks || utcTicks > DateTime.MaxTicks) {                
                /* BDS+*/
                if (utcTicks.lt(System.Int64((new Date(-864e13)).getTime()).mul(10000)) || utcTicks.gt(System.Int64((new Date(864e13)).getTime()).mul(10000))) {
                    /* BDS-*/ //throw new ArgumentOutOfRangeException("offset", Environment.GetResourceString("Argument_UTCOutOfRange"));                
                    /* BDS+*/
                    throw new System.ArgumentOutOfRangeException("offset", "UTCOutOfRange");
                }
                // make sure the Kind is set to Unspecified
                //
                return new Date(utcTicks.toNumber()/10000);
            },
            op_Implicit: function (dateTime) {
                return new System.DateTimeOffset.$ctor1(dateTime);
            },
            op_Addition: function (dateTimeOffset, timeSpan) {
                return new System.DateTimeOffset.$ctor2(Bridge.Date.adddt(dateTimeOffset.getClockDateTime(), timeSpan), dateTimeOffset.getOffset());
            },
            op_Subtraction: function (dateTimeOffset, timeSpan) {
                return new System.DateTimeOffset.$ctor2(Bridge.Date.subdt(dateTimeOffset.getClockDateTime(), timeSpan), dateTimeOffset.getOffset());
            },
            op_Subtraction$1: function (left, right) {
                return Bridge.Date.subdd(left.getUtcDateTime(), right.getUtcDateTime());
            },
            op_Equality: function (left, right) {
                return Bridge.equals(left.getUtcDateTime(), right.getUtcDateTime());
            },
            op_Inequality: function (left, right) {
                return !Bridge.equals(left.getUtcDateTime(), right.getUtcDateTime());
            },
            op_LessThan: function (left, right) {
                return Bridge.Date.lt(left.getUtcDateTime(), right.getUtcDateTime());
            },
            op_LessThanOrEqual: function (left, right) {
                return Bridge.Date.lte(left.getUtcDateTime(), right.getUtcDateTime());
            },
            op_GreaterThan: function (left, right) {
                return Bridge.Date.gt(left.getUtcDateTime(), right.getUtcDateTime());
            },
            op_GreaterThanOrEqual: function (left, right) {
                return Bridge.Date.gte(left.getUtcDateTime(), right.getUtcDateTime());
            },
            getDefaultValue: function () { return new System.DateTimeOffset(); }
        },
        m_offsetMinutes: 0,
        config: {
            alias: [
            "compareTo", "System$IComparable$1$System$DateTimeOffset$compareTo",
            "equalsT", "System$IEquatable$1$System$DateTimeOffset$equalsT"
            ],
            init: function () {
                this.m_dateTime = new Date(-864e13);
            }
        },
        $ctor5: function (ticks, offset) {
            this.$initialize();
            this.m_offsetMinutes = System.DateTimeOffset.validateOffset(offset);
            // Let the DateTime constructor do the range checks
            var dateTime = new Date(ticks.toNumber()/10000);
            this.m_dateTime = System.DateTimeOffset.validateDate(dateTime, offset);
        },
        $ctor1: function (dateTime) {
            this.$initialize();
            var offset;
            if (System.DateTimeExtensions.kind(dateTime) !== System.DateTimeKind.Utc) {
                // Local and Unspecified are both treated as Local
                /* BDS-*/ //offset = TimeZoneInfo.Local.GetUtcOffset(dateTime, TimeZoneInfoOptions.NoThrowOnInvalidTime);
                /* BDS+*/
                offset = System.TimeZone.currentTimeZone.getUtcOffset(dateTime);
            } else {
                offset = new System.TimeSpan(System.Int64(0));
            }
            this.m_offsetMinutes = System.DateTimeOffset.validateOffset(offset);
            this.m_dateTime = System.DateTimeOffset.validateDate(dateTime, offset);
        },
        $ctor2: function (dateTime, offset) {
            this.$initialize();
            if (System.DateTimeExtensions.kind(dateTime) === System.DateTimeKind.Local) {
                /* BDS-*/ //if (offset != TimeZoneInfo.Local.GetUtcOffset(dateTime, TimeZoneInfoOptions.NoThrowOnInvalidTime)) {
                /* BDS+*/
                if (System.TimeSpan.neq(offset, System.TimeZone.currentTimeZone.getUtcOffset(dateTime))) {
                    /* BDS-*/ //throw new ArgumentException(Environment.GetResourceString("Argument_OffsetLocalMismatch"), "offset");
                    /* BDS+*/
                    throw new System.ArgumentException("OffsetLocalMismatch", "offset");
                }
            } else if (System.DateTimeExtensions.kind(dateTime) === System.DateTimeKind.Utc) {
                if (System.TimeSpan.neq(offset, System.TimeSpan.zero)) {
                    /* BDS-*/ //throw new ArgumentException(Environment.GetResourceString("Argument_OffsetUtcMismatch"), "offset");
                    /* BDS+*/
                    throw new System.ArgumentException("OffsetUtcMismatch", "offset");
                }
            }
            this.m_offsetMinutes = System.DateTimeOffset.validateOffset(offset);
            this.m_dateTime = System.DateTimeOffset.validateDate(dateTime, offset);
        },
        $ctor4: function (year, month, day, hour, minute, second, offset) {
            this.$initialize();
            this.m_offsetMinutes = System.DateTimeOffset.validateOffset(offset);
            this.m_dateTime = System.DateTimeOffset.validateDate(new Date(year, month - 1, day, hour, minute, second), offset);
        },
        $ctor3: function (year, month, day, hour, minute, second, millisecond, offset) {
            this.$initialize();
            this.m_offsetMinutes = System.DateTimeOffset.validateOffset(offset);
            this.m_dateTime = System.DateTimeOffset.validateDate(new Date(year, month - 1, day, hour, minute, second, millisecond), offset);
        },
        ctor: function () {
            this.$initialize();
        },
        getDateTime: function () {
            return this.getClockDateTime();
        },
        getUtcDateTime: function () {
            /* BDS-*/ //Contract.Ensures(Contract.Result<DateTime>().Kind == DateTimeKind.Utc);
            return System.DateTimeExtensions.specifyKind(this.getDateTime(), this.m_dateTime, System.DateTimeKind.Utc);
        },
        getLocalDateTime: function () {
            /* BDS-*/ //Contract.Ensures(Contract.Result<DateTime>().Kind == DateTimeKind.Local);
            return Bridge.Date.toLocal(this.getUtcDateTime());
        },
        getClockDateTime: function () {
            return new Date(System.Int64(((Bridge.Date.adddt(this.m_dateTime, this.getOffset()))).getTime()).mul(10000).toNumber()/10000);
        },
        getDate: function () {
            var $t;
            return ($t=this.getClockDateTime(), new Date($t.getFullYear(), $t.getMonth(), $t.getDate()));
        },
        getDay: function () {
            /* BDS-*/ //Contract.Ensures(Contract.Result<int>() >= 1);
            /* BDS-*/ //Contract.Ensures(Contract.Result<int>() <= 31);
            return this.getClockDateTime().getDate();
        },
        getDayOfWeek: function () {
            /* BDS-*/ //Contract.Ensures(Contract.Result<DayOfWeek>() >= DayOfWeek.Sunday);
            /* BDS-*/ //Contract.Ensures(Contract.Result<DayOfWeek>() <= DayOfWeek.Saturday);
            return this.getClockDateTime().getDay();
        },
        getDayOfYear: function () {
            var $t;
            /* BDS-*/ //Contract.Ensures(Contract.Result<int>() >= 1);
            /* BDS-*/ //Contract.Ensures(Contract.Result<int>() <= 366);  // leap year
            return ($t=this.getClockDateTime(), Math.ceil(($t - new Date($t.getFullYear(), 0, 1)) / 864e5));
        },
        getHour: function () {
            /* BDS-*/ //Contract.Ensures(Contract.Result<int>() >= 0);
            /* BDS-*/ //Contract.Ensures(Contract.Result<int>() < 24);
            return this.getClockDateTime().getHours();
        },
        getMillisecond: function () {
            /* BDS-*/ //Contract.Ensures(Contract.Result<int>() >= 0);
            /* BDS-*/ //Contract.Ensures(Contract.Result<int>() < 1000);
            return this.getClockDateTime().getMilliseconds();
        },
        getMinute: function () {
            /* BDS-*/ //Contract.Ensures(Contract.Result<int>() >= 0);
            /* BDS-*/ //Contract.Ensures(Contract.Result<int>() < 60);
            return this.getClockDateTime().getMinutes();
        },
        getMonth: function () {
            /* BDS-*/ //Contract.Ensures(Contract.Result<int>() >= 1);
            return (this.getClockDateTime().getMonth() + 1);
        },
        getOffset: function () {
            return new System.TimeSpan(0, this.m_offsetMinutes, 0);
        },
        getSecond: function () {
            /* BDS-*/ //Contract.Ensures(Contract.Result<int>() >= 0);
            /* BDS-*/ //Contract.Ensures(Contract.Result<int>() < 60);
            return this.getClockDateTime().getSeconds();
        },
        getTicks: function () {
            return System.Int64((this.getClockDateTime()).getTime()).mul(10000);
        },
        getUtcTicks: function () {
            return System.Int64((this.getUtcDateTime()).getTime()).mul(10000);
        },
        getTimeOfDay: function () {
            return Bridge.Date.timeOfDay(this.getClockDateTime());
        },
        getYear: function () {
            /* BDS-*/ //Contract.Ensures(Contract.Result<int>() >= 1 && Contract.Result<int>() <= 9999);
            return this.getClockDateTime().getFullYear();
        },
        toOffset: function (offset) {
            return new System.DateTimeOffset.$ctor5(System.Int64(((Bridge.Date.adddt(this.m_dateTime, offset))).getTime()).mul(10000), offset);
        },
        add: function (timeSpan) {
            return new System.DateTimeOffset.$ctor2(new Date((this.getClockDateTime()).getTime() + ((timeSpan).ticks.div(10000).toNumber())), this.getOffset());
        },
        addDays: function (days) {
            return new System.DateTimeOffset.$ctor2(new Date(this.getClockDateTime().valueOf() + Math.round((days) * 864e5)), this.getOffset());
        },
        addHours: function (hours) {
            return new System.DateTimeOffset.$ctor2(new Date(this.getClockDateTime().valueOf() + Math.round((hours) * 36e5)), this.getOffset());
        },
        addMilliseconds: function (milliseconds) {
            return new System.DateTimeOffset.$ctor2(new Date(this.getClockDateTime().valueOf() + Math.round(milliseconds)), this.getOffset());
        },
        addMinutes: function (minutes) {
            return new System.DateTimeOffset.$ctor2(new Date(this.getClockDateTime().valueOf() + Math.round((minutes) * 6e4)), this.getOffset());
        },
        addMonths: function (months) {
            var $t;
            return new System.DateTimeOffset.$ctor2(($t=this.getClockDateTime(), new Date($t.getFullYear(), $t.getMonth() + months, $t.getDate(), $t.getHours(), $t.getMinutes(), $t.getSeconds(), $t.getMilliseconds())), this.getOffset());
        },
        addSeconds: function (seconds) {
            return new System.DateTimeOffset.$ctor2(new Date(this.getClockDateTime().valueOf() + Math.round((seconds) * 1e3)), this.getOffset());
        },
        addTicks: function (ticks) {
            return new System.DateTimeOffset.$ctor2(new Date(System.Int64((this.getClockDateTime()).getTime()).add((ticks).div(10000)).toNumber()), this.getOffset());
        },
        addYears: function (years) {
            var $t;
            return new System.DateTimeOffset.$ctor2(($t=this.getClockDateTime(), new Date($t.getFullYear() + years, $t.getMonth(), $t.getDate(), $t.getHours(), $t.getMinutes(), $t.getSeconds(), $t.getMilliseconds())), this.getOffset());
        },
        System$IComparable$compareTo: function (obj) {
            if (obj == null) {
                return 1;
            }
            if (!(Bridge.is(obj, System.DateTimeOffset))) {
                /* BDS-*/ //throw new ArgumentException(Environment.GetResourceString("Arg_MustBeDateTimeOffset"));
                /* BDS+*/
                throw new System.ArgumentException("MustBeDateTimeOffset");
            }

            var objUtc = System.Nullable.getValue(Bridge.cast(obj, System.DateTimeOffset)).getUtcDateTime();
            var utc = this.getUtcDateTime();
            if (Bridge.Date.gt(utc, objUtc)) {
                return 1;
            }
            if (Bridge.Date.lt(utc, objUtc)) {
                return -1;
            }
            return 0;
        },
        compareTo: function (other) {
            var otherUtc = other.getUtcDateTime();
            var utc = this.getUtcDateTime();
            if (Bridge.Date.gt(utc, otherUtc)) {
                return 1;
            }
            if (Bridge.Date.lt(utc, otherUtc)) {
                return -1;
            }
            return 0;
        },
        equals: function (obj) {
            if (Bridge.is(obj, System.DateTimeOffset)) {
                return Bridge.equalsT(this.getUtcDateTime(), System.Nullable.getValue(Bridge.cast(obj, System.DateTimeOffset)).getUtcDateTime());
            }
            return false;
        },
        equalsT: function (other) {
            return Bridge.equalsT(this.getUtcDateTime(), other.getUtcDateTime());
        },
        equalsExact: function (other) {
            //
            // returns true when the ClockDateTime, Kind, and Offset match
            //
            // currently the Kind should always be Unspecified, but there is always the possibility that a future version
            // of DateTimeOffset overloads the Kind field
            //
            return (Bridge.equals(this.getClockDateTime(), other.getClockDateTime()) && System.TimeSpan.eq(this.getOffset(), other.getOffset()) && System.DateTimeExtensions.kind(this.getClockDateTime()) === System.DateTimeExtensions.kind(other.getClockDateTime()));
        },
        getHashCode: function () {
            return Bridge.getHashCode(this.getUtcDateTime());
        },
        subtract$1: function (value) {
            return Bridge.Date.subdd(this.getUtcDateTime(), value.getUtcDateTime());
        },
        subtract: function (value) {
            return new System.DateTimeOffset.$ctor2(new Date(this.getClockDateTime() - new Date((value).ticks.div(10000).toNumber())), this.getOffset());
        },
        toLocalTime: function () {
            return new System.DateTimeOffset.$ctor1(Bridge.Date.toLocal(this.getUtcDateTime()));
        },
        toUniversalTime: function () {
            return new System.DateTimeOffset.$ctor1(this.getUtcDateTime());
        },
        $clone: function (to) {
            var s = to || new System.DateTimeOffset();
            s.m_dateTime = this.m_dateTime;
            s.m_offsetMinutes = this.m_offsetMinutes;
            return s;
        }
    });

    Bridge.define("System.GC", {
        statics: {
            suppressFinalize: function (obj) {
            }
        }
    });

    Bridge.define("System.IAsyncResult", {
        $kind: "interface"
    });

    Bridge.define("System.Interlocked", {
        statics: {
            compareExchange: function (T, location1, value, comparand) {
                var val = location1.v;
                if (Bridge.equals(location1.v, comparand)) {
                    location1.v = value;
                }
                return val;
            },
            exchange: function (T, location1, value) {
                var val = location1.v;
                location1.v = value;
                return val;
            },
            increment: function (location) {
                location.v = (location.v + 1) | 0;
                return location.v;
            },
            increment$1: function (location) {
                location.v = location.v.inc();
                return location.v;
            },
            decrement: function (location) {
                location.v = (location.v - 1) | 0;
                return location.v;
            },
            decrement$1: function (location) {
                location.v = location.v.dec();
                return location.v;
            }
        }
    });

    /** @namespace System */

    /**
     * Represents a push-style collection.
     *
     * @abstract
     * @public
     * @class System.IObservable$1
     */
    Bridge.definei("System.IObservable$1", function (T) { return {
        $kind: "interface",
        $variance: [1]
    }; });

    /**
     * Supports push-style iteration over an observable sequence.
     *
     * @abstract
     * @public
     * @class System.IObserver$1
     */
    Bridge.definei("System.IObserver$1", function (T) { return {
        $kind: "interface",
        $variance: [2]
    }; });

    Bridge.define("System.Lazy$1", function (T) { return {
        _lock: null,
        _value: null,
        _boxed: null,
        $ctor1: function (valueFactory, isThreadSafe) {
            this.$initialize();
            this._value = valueFactory;
            this._lock = (isThreadSafe) ? {  } : null;
        },
        ctor: function (valueFactory) {
            System.Lazy$1(T).$ctor1.call(this, valueFactory, true);
        },
        getIsValueCreated: function () {
            return this._boxed != null && Bridge.is(this._boxed, System.Lazy$1.Boxed(T));
        },
        getValue: function () {
            var boxed = null;
            if (this._boxed != null) {
                // Do a quick check up front for the fast path.
                boxed = Bridge.as(this._boxed, System.Lazy$1.Boxed(T));
                if (boxed != null) {
                    return boxed.value;
                }
                throw new System.Exception("this shouldn't happen");
            }
            return this.lazyInitValue();
        },
        lazyInitValue: function () {
            var boxed = null;
            if (this._lock == null) {
                boxed = new (System.Lazy$1.Boxed(T))(this._value());
            } else {
                this._lock;
                {
                    if (this._boxed == null) {
                        this._boxed = (boxed = new (System.Lazy$1.Boxed(T))(this._value()));
                    }
                }

                //bool locked = false;
                //try
                //{
                //   Monitor.Enter(_lock, ref locked);
                //   if(_boxed == null)
                //      _boxed = boxed = new Boxed(_value());
                //}
                //finally
                //{
                //   if(locked)
                //      Monitor.Exit(_lock);
                //}
            }
            return boxed.value;
        }
    }; });

    Bridge.define("System.Lazy$1.Boxed", function (T) { return {
        value: Bridge.getDefaultValue(T),
        ctor: function (value) {
            this.$initialize();
            this.value = value;
        }
    }; });

    Bridge.define("System.ObjectDisposedException", {
        inherits: [System.Exception],
        ctor: function (msg) {
            this.$initialize();
            System.Exception.ctor.call(this, msg);
        }
    });

    /**
     * @memberof System
     * @callback System.Action
     * @param   {T}       arg
     * @return  {void}
     */

    /**
     * Provides a set of static methods for subscribing delegates to observables.
     *
     * @static
     * @abstract
     * @public
     * @class System.ObservableExtensions
     */
    Bridge.define("System.ObservableExtensions", {
        statics: {
            /**
             * Subscribes to the observable sequence without specifying any handlers.
             This method can be used to evaluate the observable sequence for its side-effects only.
             *
             * @static
             * @public
             * @this System.ObservableExtensions
             * @memberof System.ObservableExtensions
             * @throws <b /> is null.
             * @param   {Function}                T         The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source    Observable sequence to subscribe to.
             * @return  {System.IDisposable}                IDisposable object used to unsubscribe from the observable sequence.
             */
            subscribe: function (T, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                //
                // [OK] Use of unsafe Subscribe: non-pretentious constructor for an observer; this overload is not to be used internally.
                //
                return source["System$IObservable$1$" + Bridge.getTypeAlias(T) + "$subscribe"](new (System.Reactive.AnonymousObserver$1(T)).$ctor3(System.Reactive.Stubs$1(T).ignore, System.Reactive.Stubs.throw, System.Reactive.Stubs.nop));
            },
            /**
             * Subscribes an element handler to an observable sequence.
             *
             * @static
             * @public
             * @this System.ObservableExtensions
             * @memberof System.ObservableExtensions
             * @throws <b /> or <b /> is null.
             * @param   {Function}                T         The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source    Observable sequence to subscribe to.
             * @param   {System.Action}           onNext    Action to invoke for each element in the observable sequence.
             * @return  {System.IDisposable}                IDisposable object used to unsubscribe from the observable sequence.
             */
            subscribe$1: function (T, source, onNext) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(onNext, null)) {
                    throw new System.ArgumentNullException("onNext");
                }

                //
                // [OK] Use of unsafe Subscribe: non-pretentious constructor for an observer; this overload is not to be used internally.
                //
                return source["System$IObservable$1$" + Bridge.getTypeAlias(T) + "$subscribe"](new (System.Reactive.AnonymousObserver$1(T)).$ctor3(onNext, System.Reactive.Stubs.throw, System.Reactive.Stubs.nop));
            },
            /**
             * Subscribes an element handler and an exception handler to an observable sequence.
             *
             * @static
             * @public
             * @this System.ObservableExtensions
             * @memberof System.ObservableExtensions
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                T          The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Observable sequence to subscribe to.
             * @param   {System.Action}           onNext     Action to invoke for each element in the observable sequence.
             * @param   {System.Action}           onError    Action to invoke upon exceptional termination of the observable sequence.
             * @return  {System.IDisposable}                 IDisposable object used to unsubscribe from the observable sequence.
             */
            subscribe$3: function (T, source, onNext, onError) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(onNext, null)) {
                    throw new System.ArgumentNullException("onNext");
                }
                if (Bridge.staticEquals(onError, null)) {
                    throw new System.ArgumentNullException("onError");
                }

                //
                // [OK] Use of unsafe Subscribe: non-pretentious constructor for an observer; this overload is not to be used internally.
                //
                return source["System$IObservable$1$" + Bridge.getTypeAlias(T) + "$subscribe"](new (System.Reactive.AnonymousObserver$1(T)).$ctor3(onNext, onError, System.Reactive.Stubs.nop));
            },
            /**
             * Subscribes an element handler and a completion handler to an observable sequence.
             *
             * @static
             * @public
             * @this System.ObservableExtensions
             * @memberof System.ObservableExtensions
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                T              The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source         Observable sequence to subscribe to.
             * @param   {System.Action}           onNext         Action to invoke for each element in the observable sequence.
             * @param   {System.Action}           onCompleted    Action to invoke upon graceful termination of the observable sequence.
             * @return  {System.IDisposable}                     IDisposable object used to unsubscribe from the observable sequence.
             */
            subscribe$2: function (T, source, onNext, onCompleted) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(onNext, null)) {
                    throw new System.ArgumentNullException("onNext");
                }
                if (Bridge.staticEquals(onCompleted, null)) {
                    throw new System.ArgumentNullException("onCompleted");
                }

                //
                // [OK] Use of unsafe Subscribe: non-pretentious constructor for an observer; this overload is not to be used internally.
                //
                return source["System$IObservable$1$" + Bridge.getTypeAlias(T) + "$subscribe"](new (System.Reactive.AnonymousObserver$1(T)).$ctor3(onNext, System.Reactive.Stubs.throw, onCompleted));
            },
            /**
             * Subscribes an element handler, an exception handler, and a completion handler to an observable sequence.
             *
             * @static
             * @public
             * @this System.ObservableExtensions
             * @memberof System.ObservableExtensions
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                T              The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source         Observable sequence to subscribe to.
             * @param   {System.Action}           onNext         Action to invoke for each element in the observable sequence.
             * @param   {System.Action}           onError        Action to invoke upon exceptional termination of the observable sequence.
             * @param   {System.Action}           onCompleted    Action to invoke upon graceful termination of the observable sequence.
             * @return  {System.IDisposable}                     IDisposable object used to unsubscribe from the observable sequence.
             */
            subscribe$4: function (T, source, onNext, onError, onCompleted) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(onNext, null)) {
                    throw new System.ArgumentNullException("onNext");
                }
                if (Bridge.staticEquals(onError, null)) {
                    throw new System.ArgumentNullException("onError");
                }
                if (Bridge.staticEquals(onCompleted, null)) {
                    throw new System.ArgumentNullException("onCompleted");
                }

                //
                // [OK] Use of unsafe Subscribe: non-pretentious constructor for an observer; this overload is not to be used internally.
                //
                return source["System$IObservable$1$" + Bridge.getTypeAlias(T) + "$subscribe"](new (System.Reactive.AnonymousObserver$1(T)).$ctor3(onNext, onError, onCompleted));
            },
            /**
             * Subscribes to the specified source, re-routing synchronous exceptions during invocation of the Subscribe method to the observer's OnError channel.
             This method is typically used when writing query operators.
             *
             * @static
             * @public
             * @this System.ObservableExtensions
             * @memberof System.ObservableExtensions
             * @throws <b /> or <b /> is null.
             * @param   {Function}                T           The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      Observable sequence to subscribe to.
             * @param   {System.IObserver$1}      observer    Observer that will be passed to the observable sequence, and that will be used for exception propagation.
             * @return  {System.IDisposable}                  IDisposable object used to unsubscribe from the observable sequence.
             */
            subscribeSafe: function (T, source, observer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (observer == null) {
                    throw new System.ArgumentNullException("observer");
                }

                //
                // The following types are white-listed and should not exhibit exceptional behavior
                // for regular operation circumstances.
                //
                if (Bridge.is(source, System.Reactive.ObservableBase$1(T))) {
                    return source["System$IObservable$1$" + Bridge.getTypeAlias(T) + "$subscribe"](observer);
                }

                var producer = Bridge.as(source, System.Reactive.IProducer$1(T));
                if (producer != null) {
                    return producer["System$Reactive$IProducer$1$" + Bridge.getTypeAlias(T) + "$subscribeRaw"](observer, false);
                }

                var d = System.Reactive.Disposables.Disposable.getEmpty();

                try {
                    d = source["System$IObservable$1$" + Bridge.getTypeAlias(T) + "$subscribe"](observer);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    //
                    // The effect of redirecting the exception to the OnError channel is automatic
                    // clean-up of query operator state for a large number of cases. For example,
                    // consider a binary and temporal query operator with the following Subscribe
                    // behavior (implemented using the Producer pattern with a Run method):
                    //
                    //   public IDisposable Run(...)
                    //   {
                    //       var tm = _scheduler.Schedule(_due, Tick);
                    //
                    //       var df = _fst.SubscribeSafe(new FstObserver(this, ...));
                    //       var ds = _snd.SubscribeSafe(new SndObserver(this, ...)); // <-- fails
                    //
                    //       return new CompositeDisposable(tm, df, ds);
                    //   }
                    //
                    // If the second subscription fails, we're not leaving the first subscription
                    // or the scheduled job hanging around. Instead, the OnError propagation to
                    // the SndObserver should take care of a Dispose call to the observer's parent
                    // object. The handshake between Producer and Sink objects will ultimately
                    // cause disposal of the CompositeDisposable that's returned from the method.
                    //
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](exception);
                }

                return d;
            }
        }
    });

    Bridge.define("System.Reactive.AnonymousEnumerable$1", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerable$1(T)],
        getEnumerator$1: null,
        config: {
            alias: [
            "getEnumerator", "System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$getEnumerator"
            ]
        },
        ctor: function (getEnumerator) {
            this.$initialize();
            this.getEnumerator$1 = getEnumerator;
        },
        getEnumerator: function () {
            return this.getEnumerator$1();
        },
        System$Collections$IEnumerable$getEnumerator: function () {
            return this.getEnumerator();
        }
    }; });

    /** @namespace System.Reactive */

    /**
     * Base class for implementation of query operators, providing a lightweight sink that can be disposed to mute the outgoing observer.
     *
     * @abstract
     * @class System.Reactive.Sink$1
     * @implements  System.IDisposable
     * @param   {Function}    [name]    Type of the resulting sequence's elements.
     */
    Bridge.define("System.Reactive.Sink$1", function (TSource) { return {
        inherits: [System.IDisposable],
        _cancel: null,
        _observer: null,
        config: {
            alias: [
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            this._observer = observer;
            this._cancel = cancel;
        },
        dispose: function () {
            this._observer = System.Reactive.NopObserver$1(TSource).instance;

            var cancel = System.Interlocked.exchange(System.IDisposable, Bridge.ref(this, "_cancel"), null);
            if (cancel != null) {
                cancel.System$IDisposable$dispose();
            }
        },
        getForwarder: function () {
            return new (System.Reactive.Sink$1.Impl(TSource))(this);
        }
    }; });

    /** @namespace System.Reactive.Concurrency */

    /**
     * Asynchronous lock.
     *
     * @public
     * @class System.Reactive.Concurrency.AsyncLock
     * @implements  System.IDisposable
     */
    Bridge.define("System.Reactive.Concurrency.AsyncLock", {
        inherits: [System.IDisposable],
        queue: null,
        isAcquired: false,
        hasFaulted: false,
        config: {
            alias: [
            "dispose", "System$IDisposable$dispose"
            ],
            init: function () {
                this.queue = new (System.Collections.Generic.Queue$1(Function)).ctor();
            }
        },
        /**
         * Queues the action for execution. If the caller acquires the lock and becomes the owner,
         the queue is processed. If the lock is already owned, the action is queued and will get
         processed by the owner.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.AsyncLock
         * @memberof System.Reactive.Concurrency.AsyncLock
         * @throws <b /> is null.
         * @param   {System.Action}    action    Action to queue for execution.
         * @return  {void}
         */
        wait: function (action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            var isOwner = false;
            this.queue;
            {
                if (!this.hasFaulted) {
                    this.queue.enqueue(action);
                    isOwner = !this.isAcquired;
                    this.isAcquired = true;
                }
            }

            if (isOwner) {
                while (true) {
                    var work = null;
                    this.queue;
                    {
                        if (this.queue.getCount() > 0) {
                            work = this.queue.dequeue();
                        } else {
                            this.isAcquired = false;
                            break;
                        }
                    }

                    try {
                        work();
                    }
                    catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        this.queue;
                        {
                            this.queue.clear();
                            this.hasFaulted = true;
                        }
                        throw $e1;
                    }
                }
            }
        },
        /**
         * Clears the work items in the queue and drops further work being queued.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.AsyncLock
         * @memberof System.Reactive.Concurrency.AsyncLock
         * @return  {void}
         */
        dispose: function () {
            this.queue;
            {
                this.queue.clear();
                this.hasFaulted = true;
            }
        }
    });

    Bridge.define("System.Reactive.IServiceProvider", {
        $kind: "interface"
    });

    /**
     * Represents an object that schedules units of work.
     *
     * @abstract
     * @public
     * @class System.Reactive.Concurrency.IScheduler
     */
    Bridge.define("System.Reactive.Concurrency.IScheduler", {
        $kind: "interface"
    });

    /**
     * Scheduler with support for starting long-running tasks.
     This type of scheduler can be used to run loops more efficiently instead of using recursive scheduling.
     *
     * @abstract
     * @public
     * @class System.Reactive.Concurrency.ISchedulerLongRunning
     */
    Bridge.define("System.Reactive.Concurrency.ISchedulerLongRunning", {
        $kind: "interface"
    });

    /**
     * Scheduler with support for running periodic tasks.
     This type of scheduler can be used to run timers more efficiently instead of using recursive scheduling.
     *
     * @abstract
     * @public
     * @class System.Reactive.Concurrency.ISchedulerPeriodic
     */
    Bridge.define("System.Reactive.Concurrency.ISchedulerPeriodic", {
        $kind: "interface"
    });

    /**
     * (Infrastructure) Concurrency abstraction layer.
     *
     * @static
     * @abstract
     * @class System.Reactive.Concurrency.ConcurrencyAbstractionLayer
     */
    Bridge.define("System.Reactive.Concurrency.ConcurrencyAbstractionLayer", {
        statics: {
            config: {
                properties: {
                    /**
                     * Gets the current CAL. If no CAL has been set yet, it will be initialized to the default.
                     *
                     * @static
                     * @public
                     * @this System.Reactive.Concurrency.ConcurrencyAbstractionLayer
                     * @memberof System.Reactive.Concurrency.ConcurrencyAbstractionLayer
                     * @function getCurrent
                     * @return  {System.Reactive.Concurrency.IConcurrencyAbstractionLayer}
                     */
                    /**
                     * Gets the current CAL. If no CAL has been set yet, it will be initialized to the default.
                     *
                     * @static
                     * @private
                     * @this System.Reactive.Concurrency.ConcurrencyAbstractionLayer
                     * @memberof System.Reactive.Concurrency.ConcurrencyAbstractionLayer
                     * @function setCurrent
                     * @param   {System.Reactive.Concurrency.IConcurrencyAbstractionLayer}    value
                     * @return  {void}
                     */
                    Current: null
                },
                init: function () {
                    this.Current = System.Reactive.Concurrency.ConcurrencyAbstractionLayer.initialize();
                }
            },
            initialize: function () { /// Type or member is obsolete


                return System.Reactive.PlatformServices.PlatformEnlightenmentProvider.getCurrent().System$Reactive$PlatformServices$IPlatformEnlightenmentProvider$getService(System.Reactive.Concurrency.IConcurrencyAbstractionLayer) || new System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer();
            }
        }
    });

    /**
     * Provider for IStopwatch objects.
     *
     * @abstract
     * @public
     * @class System.Reactive.Concurrency.IStopwatchProvider
     */
    Bridge.define("System.Reactive.Concurrency.IStopwatchProvider", {
        $kind: "interface"
    });

    /**
     * (Infrastructure) Concurrency abstraction layer interface.
     *
     * @abstract
     * @public
     * @class System.Reactive.Concurrency.IConcurrencyAbstractionLayer
     */
    Bridge.define("System.Reactive.Concurrency.IConcurrencyAbstractionLayer", {
        $kind: "interface"
    });

    Bridge.define("System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer.FastPeriodicTimer", {
        inherits: [System.IDisposable],
        _action: null,
        disposed: false,
        config: {
            alias: [
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function (action) {
            this.$initialize();
            this._action = action;

            System.Threading.Tasks.Task.run(Bridge.fn.bind(this, this.loop));
        },
        loop: function () {
            while (!this.disposed) {
                this._action();
            }
        },
        dispose: function () {
            this.disposed = true;
        }
    });

    Bridge.define("System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer.PeriodicTimer", {
        inherits: [System.IDisposable],
        statics: {
            s_timers: null,
            config: {
                init: function () {
                    this.s_timers = new (System.Collections.Generic.HashSet$1(System.Threading.Timer)).ctor();
                }
            }
        },
        _action: null,
        _timer: null,
        config: {
            alias: [
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function (action, period) {
            this.$initialize();
            this._action = action;
            this._timer = new System.Threading.Timer.$ctor3(Bridge.fn.bind(this, this.tick), null, period, period);

            System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer.PeriodicTimer.s_timers;
            {
                System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer.PeriodicTimer.s_timers.add(this._timer);
            }
        },
        tick: function (state) {
            this._action();
        },
        dispose: function () {
            var timer = null;

            System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer.PeriodicTimer.s_timers;
            {
                timer = this._timer;
                this._timer = null;

                if (timer != null) {
                    System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer.PeriodicTimer.s_timers.remove(timer);
                }
            }

            if (timer != null) {
                timer.dispose();
                this._action = System.Reactive.Stubs.nop;
            }
        }
    });

    Bridge.define("System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer.Timer", {
        inherits: [System.IDisposable],
        statics: {
            s_timers: null,
            config: {
                init: function () {
                    this.s_timers = new (System.Collections.Generic.HashSet$1(System.Threading.Timer)).ctor();
                }
            }
        },
        _action: null,
        _timer: null,
        _hasAdded: false,
        _hasRemoved: false,
        config: {
            alias: [
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function (action, state, dueTime) {
            this.$initialize();
            this._action = action;
            this._timer = new System.Threading.Timer.$ctor3(Bridge.fn.bind(this, this.tick), state, dueTime, System.TimeSpan.fromMilliseconds(-1));

            System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer.Timer.s_timers;
            {
                if (!this._hasRemoved) {
                    System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer.Timer.s_timers.add(this._timer);

                    this._hasAdded = true;
                }
            }
        },
        tick: function (state) {
            try {
                this._action(state);
            }
            finally {
                this.dispose();
            }
        },
        dispose: function () {
            this._action = System.Reactive.Stubs$1(Object).ignore;

            var timer = null;

            System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer.Timer.s_timers;
            {
                if (!this._hasRemoved) {
                    timer = this._timer;
                    this._timer = null;

                    if (this._hasAdded && timer != null) {
                        System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer.Timer.s_timers.remove(timer);
                    }

                    this._hasRemoved = true;
                }
            }

            if (timer != null) {
                timer.dispose();
            }
        }
    });

    /**
     * Abstraction for a stopwatch to compute time relative to a starting point.
     *
     * @abstract
     * @public
     * @class System.Reactive.Concurrency.IStopwatch
     */
    Bridge.define("System.Reactive.Concurrency.IStopwatch", {
        $kind: "interface"
    });

    /**
     * Represents a work item that has been scheduled.
     *
     * @abstract
     * @public
     * @class System.Reactive.Concurrency.IScheduledItem$1
     * @param   {Function}    [name]    Absolute time representation type.
     */
    Bridge.definei("System.Reactive.Concurrency.IScheduledItem$1", function (TAbsolute) { return {
        $kind: "interface"
    }; });

    /**
     * Represents a work item in the absolute time scheduler.
     *
     * @abstract
     * @private
     * @class System.Reactive.Concurrency.LocalScheduler.WorkItem
     * @implements  System.IComparable$1
     * @implements  System.IDisposable
     */
    Bridge.define("System.Reactive.Concurrency.LocalScheduler.WorkItem", {
        inherits: function () { return [System.IComparable$1(System.Reactive.Concurrency.LocalScheduler.WorkItem),System.IDisposable]; },
        _scheduler: null,
        _disposable: null,
        _hasRun: 0,
        config: {
            alias: [
            "compareTo", "System$IComparable$1$System$Reactive$Concurrency$LocalScheduler$WorkItem$compareTo",
            "dispose", "System$IDisposable$dispose"
            ],
            init: function () {
                this._dueTime = new System.DateTimeOffset();
            }
        },
        ctor: function (scheduler, dueTime) {
            this.$initialize();
            this._scheduler = scheduler;
            this._dueTime = dueTime.$clone();
            this._disposable = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._hasRun = 0;
        },
        getScheduler: function () {
            return this._scheduler;
        },
        getDueTime: function () {
            return this._dueTime.$clone();
        },
        invoke: function (scheduler) {
            //
            // Protect against possible maltreatment of the scheduler queues or races in
            // execution of a work item that got relocated across system clock changes.
            // Under no circumstance whatsoever we should run work twice. The monitor's
            // ref count should also be subject to this policy.
            //
            if (System.Interlocked.exchange(System.Int32, Bridge.ref(this, "_hasRun"), 1) === 0) {
                try {
                    if (!this._disposable.getIsDisposed()) {
                        this._disposable.setDisposable(this.invokeCore(scheduler));
                    }
                }
                finally {
                    System.Reactive.PlatformServices.SystemClock.release();
                }
            }
        },
        compareTo: function (other) {
            return new (System.Collections.Generic.Comparer$1(System.DateTimeOffset))(System.Collections.Generic.Comparer$1.$default.fn).compare(this._dueTime.$clone(), other._dueTime.$clone());
        },
        dispose: function () {
            this._disposable.dispose();
        }
    });

    /**
     * The <b>System.Reactive.Concurrency</b> namespace contains interfaces and classes that provide the scheduler infrastructure used by Reactive Extensions to construct and
     process event streams. Schedulers are used to parameterize the concurrency introduced by query operators, provide means to virtualize time, to process historical data,
     and to write unit tests for functionality built using Reactive Extensions constructs.
     *
     * @class System.Reactive.Concurrency.NamespaceDoc
     */
    Bridge.define("System.Reactive.Concurrency.NamespaceDoc");

    /**
     * @memberof System
     * @callback System.Func
     * @param   {TState}    arg
     * @return  {TState}
     */

    /**
     * Provides a set of static properties to access commonly used schedulers.
     *
     * @static
     * @abstract
     * @public
     * @class System.Reactive.Concurrency.Scheduler
     */
    Bridge.define("System.Reactive.Concurrency.Scheduler", {
        statics: {
            s_threadPool: null,
            s_newThread: null,
            OPTIMIZATIONS: null,
            config: {
                init: function () {
                    this.s_threadPool = new (System.Lazy$1(System.Reactive.Concurrency.IScheduler)).ctor($asm.$.System.Reactive.Concurrency.Scheduler.f1);
                    this.s_newThread = new (System.Lazy$1(System.Reactive.Concurrency.IScheduler)).ctor($asm.$.System.Reactive.Concurrency.Scheduler.f2);
                    this.OPTIMIZATIONS = [System.Reactive.Concurrency.ISchedulerLongRunning, System.Reactive.Concurrency.IStopwatchProvider, System.Reactive.Concurrency.ISchedulerPeriodic];
                }
            },
            /**
             * Gets the current time according to the local machine's system clock.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @function getNow
             * @return  {System.DateTimeOffset}
             */
            /**
             * Gets the current time according to the local machine's system clock.
             *
             * @instance
             * @function setNow
             */
            getNow: function () {
                return System.Reactive.PlatformServices.SystemClock.getUtcNow().$clone();
            },
            /**
             * Gets a scheduler that schedules work immediately on the current thread.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @function getImmediate
             * @return  {System.Reactive.Concurrency.ImmediateScheduler}
             */
            /**
             * Gets a scheduler that schedules work immediately on the current thread.
             *
             * @instance
             * @function setImmediate
             */
            getImmediate: function () {
                return System.Reactive.Concurrency.ImmediateScheduler.getInstance();
            },
            /**
             * Gets a scheduler that schedules work as soon as possible on the current thread.
             *
             * @static
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @function getCurrentThread
             * @return  {System.Reactive.Concurrency.CurrentThreadScheduler}
             */
            /**
             * Gets a scheduler that schedules work as soon as possible on the current thread.
             *
             * @instance
             * @function setCurrentThread
             */
            getCurrentThread: function () {
                return System.Reactive.Concurrency.CurrentThreadScheduler.getInstance();
            },
            /**
             * Gets a scheduler that schedules work on the platform's default scheduler.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @function getDefault
             * @return  {System.Reactive.Concurrency.DefaultScheduler}
             */
            /**
             * Gets a scheduler that schedules work on the platform's default scheduler.
             *
             * @instance
             * @function setDefault
             */
            getDefault: function () {
                return System.Reactive.Concurrency.DefaultScheduler.getInstance();
            },
            /**
             * Gets a scheduler that schedules work on the thread pool.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @function getThreadPool
             * @return  {System.Reactive.Concurrency.IScheduler}
             */
            /**
             * Gets a scheduler that schedules work on the thread pool.
             *
             * @instance
             * @function setThreadPool
             */
            getThreadPool: function () {
                return System.Reactive.Concurrency.Scheduler.s_threadPool.getValue();
            },
            /**
             * Gets a scheduler that schedules work on a new thread using default thread creation options.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @function getNewThread
             * @return  {System.Reactive.Concurrency.IScheduler}
             */
            /**
             * Gets a scheduler that schedules work on a new thread using default thread creation options.
             *
             * @instance
             * @function setNewThread
             */
            getNewThread: function () {
                return System.Reactive.Concurrency.Scheduler.s_newThread.getValue();
            },
            /**
             * Normalizes the specified TimeSpan value to a positive value.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @param   {System.TimeSpan}    timeSpan    The TimeSpan value to normalize.
             * @return  {System.TimeSpan}                The specified TimeSpan value if it is zero or positive; otherwise, TimeSpan.Zero.
             */
            normalize: function (timeSpan) {
                if (timeSpan.getTicks().lt(System.Int64(0))) {
                    return System.TimeSpan.zero;
                }
                return timeSpan;
            },
            initialize: function (name) { /// Type or member is obsolete


                var res = System.Reactive.PlatformServices.PlatformEnlightenmentProvider.getCurrent().System$Reactive$PlatformServices$IPlatformEnlightenmentProvider$getService(System.Reactive.Concurrency.IScheduler, [name]);
                if (res == null) {
                    throw new System.NotSupportedException(System.String.formatProvider(System.Globalization.CultureInfo.getCurrentCulture(), System.Reactive.Strings_Core.CANT_OBTAIN_SCHEDULER, name));
                }
                return res;
            },
            /**
             * Schedules an action to be executed recursively.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @throws <b /> or <b /> is null.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to execute the recursive action on.
             * @param   {System.Action}                             action       Action to execute recursively. The parameter passed to the action is used to trigger recursive scheduling of the action.
             * @return  {System.IDisposable}                                     The disposable object used to cancel the scheduled action (best effort).
             */
            schedule$1: function (scheduler, action) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException("action");
                }

                return System.Reactive.Concurrency.Scheduler.schedule$6(Function, scheduler, action, $asm.$.System.Reactive.Concurrency.Scheduler.f3);
            },
            /**
             * Schedules an action to be executed recursively.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TState       The type of the state passed to the scheduled action.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to execute the recursive action on.
             * @param   {TState}                                    state        State passed to the action to be executed.
             * @param   {System.Action}                             action       Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in recursive invocation state.
             * @return  {System.IDisposable}                                     The disposable object used to cancel the scheduled action (best effort).
             */
            schedule$6: function (TState, scheduler, state, action) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException("action");
                }

                return scheduler.System$Reactive$Concurrency$IScheduler$schedule(System.Reactive.Concurrency.Scheduler.Pair$2(TState,Function), Bridge.merge(new (System.Reactive.Concurrency.Scheduler.Pair$2(TState,Function))(), {
                    first: state,
                    second: action
                } ), function (scheduler, pair) { return System.Reactive.Concurrency.Scheduler.invokeRec1(TState, scheduler, pair); });
            },
            /**
             * Schedules an action to be executed recursively after a specified relative due time.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @throws <b /> or <b /> is null.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to execute the recursive action on.
             * @param   {System.TimeSpan}                           dueTime      Relative time after which to execute the action for the first time.
             * @param   {System.Action}                             action       Action to execute recursively. The parameter passed to the action is used to trigger recursive scheduling of the action at the specified relative time.
             * @return  {System.IDisposable}                                     The disposable object used to cancel the scheduled action (best effort).
             */
            schedule$5: function (scheduler, dueTime, action) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException("action");
                }

                return System.Reactive.Concurrency.Scheduler.schedule$8(Function, scheduler, action, dueTime, $asm.$.System.Reactive.Concurrency.Scheduler.f4);
            },
            /**
             * Schedules an action to be executed recursively after a specified relative due time.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TState       The type of the state passed to the scheduled action.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to execute the recursive action on.
             * @param   {TState}                                    state        State passed to the action to be executed.
             * @param   {System.TimeSpan}                           dueTime      Relative time after which to execute the action for the first time.
             * @param   {System.Action}                             action       Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in the recursive due time and invocation state.
             * @return  {System.IDisposable}                                     The disposable object used to cancel the scheduled action (best effort).
             */
            schedule$8: function (TState, scheduler, state, dueTime, action) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException("action");
                }

                return scheduler.System$Reactive$Concurrency$IScheduler$schedule$2(System.Reactive.Concurrency.Scheduler.Pair$2(TState,Function), Bridge.merge(new (System.Reactive.Concurrency.Scheduler.Pair$2(TState,Function))(), {
                    first: state,
                    second: action
                } ), dueTime, function (scheduler, pair) { return System.Reactive.Concurrency.Scheduler.invokeRec2(TState, scheduler, pair); });
            },
            /**
             * Schedules an action to be executed recursively at a specified absolute due time.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @throws <b /> or <b /> is null.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to execute the recursive action on.
             * @param   {System.DateTimeOffset}                     dueTime      Absolute time at which to execute the action for the first time.
             * @param   {System.Action}                             action       Action to execute recursively. The parameter passed to the action is used to trigger recursive scheduling of the action at the specified absolute time.
             * @return  {System.IDisposable}                                     The disposable object used to cancel the scheduled action (best effort).
             */
            schedule$3: function (scheduler, dueTime, action) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException("action");
                }

                return System.Reactive.Concurrency.Scheduler.schedule$7(Function, scheduler, action, dueTime.$clone(), $asm.$.System.Reactive.Concurrency.Scheduler.f5);
            },
            /**
             * Schedules an action to be executed recursively at a specified absolute due time.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TState       The type of the state passed to the scheduled action.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to execute the recursive action on.
             * @param   {TState}                                    state        State passed to the action to be executed.
             * @param   {System.DateTimeOffset}                     dueTime      Absolute time at which to execute the action for the first time.
             * @param   {System.Action}                             action       Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in the recursive due time and invocation state.
             * @return  {System.IDisposable}                                     The disposable object used to cancel the scheduled action (best effort).
             */
            schedule$7: function (TState, scheduler, state, dueTime, action) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException("action");
                }

                return scheduler.System$Reactive$Concurrency$IScheduler$schedule$1(System.Reactive.Concurrency.Scheduler.Pair$2(TState,Function), Bridge.merge(new (System.Reactive.Concurrency.Scheduler.Pair$2(TState,Function))(), {
                    first: state,
                    second: action
                } ), dueTime.$clone(), function (scheduler, pair) { return System.Reactive.Concurrency.Scheduler.invokeRec3(TState, scheduler, pair); });
            },
            /**
             * Schedules an action to be executed.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @throws <b /> or <b /> is null.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to execute the action on.
             * @param   {System.Action}                             action       Action to execute.
             * @return  {System.IDisposable}                                     The disposable object used to cancel the scheduled action (best effort).
             */
            schedule: function (scheduler, action) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException("action");
                }

                return scheduler.System$Reactive$Concurrency$IScheduler$schedule(Function, action, System.Reactive.Concurrency.Scheduler.invoke);
            },
            /**
             * Schedules an action to be executed after the specified relative due time.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @throws <b /> or <b /> is null.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to execute the action on.
             * @param   {System.TimeSpan}                           dueTime      Relative time after which to execute the action.
             * @param   {System.Action}                             action       Action to execute.
             * @return  {System.IDisposable}                                     The disposable object used to cancel the scheduled action (best effort).
             */
            schedule$4: function (scheduler, dueTime, action) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException("action");
                }

                return scheduler.System$Reactive$Concurrency$IScheduler$schedule$2(Function, action, dueTime, System.Reactive.Concurrency.Scheduler.invoke);
            },
            /**
             * Schedules an action to be executed at the specified absolute due time.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @throws <b /> or <b /> is null.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to execute the action on.
             * @param   {System.DateTimeOffset}                     dueTime      Absolute time at which to execute the action.
             * @param   {System.Action}                             action       Action to execute.
             * @return  {System.IDisposable}                                     The disposable object used to cancel the scheduled action (best effort).
             */
            schedule$2: function (scheduler, dueTime, action) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException("action");
                }

                return scheduler.System$Reactive$Concurrency$IScheduler$schedule$1(Function, action, dueTime.$clone(), System.Reactive.Concurrency.Scheduler.invoke);
            },
            invokeRec1: function (TState, scheduler, pair) {
                var group = new System.Reactive.Disposables.CompositeDisposable.$ctor3(1);
                var gate = {  };
                var state = pair.first;
                var action = pair.second;

                var recursiveAction = null;
                recursiveAction = function (state1) {
                    action(state1, function (state2) {
                        var isAdded = false;
                        var isDone = false;
                        var d = null;
                        d = scheduler.System$Reactive$Concurrency$IScheduler$schedule(TState, state2, function (scheduler1, state3) {
                            gate;
                            {
                                if (isAdded) {
                                    group.remove(d);
                                } else {
                                    isDone = true;
                                }
                            }
                            recursiveAction(state3);
                            return System.Reactive.Disposables.Disposable.getEmpty();
                        });

                        gate;
                        {
                            if (!isDone) {
                                group.add(d);
                                isAdded = true;
                            }
                        }
                    });
                };

                recursiveAction(state);

                return group;
            },
            invokeRec2: function (TState, scheduler, pair) {
                var group = new System.Reactive.Disposables.CompositeDisposable.$ctor3(1);
                var gate = {  };
                var state = pair.first;
                var action = pair.second;

                var recursiveAction = null;
                recursiveAction = function (state1) {
                    action(state1, function (state2, dueTime1) {
                        var isAdded = false;
                        var isDone = false;
                        var d = null;
                        d = scheduler.System$Reactive$Concurrency$IScheduler$schedule$2(TState, state2, dueTime1, function (scheduler1, state3) {
                            gate;
                            {
                                if (isAdded) {
                                    group.remove(d);
                                } else {
                                    isDone = true;
                                }
                            }
                            recursiveAction(state3);
                            return System.Reactive.Disposables.Disposable.getEmpty();
                        });

                        gate;
                        {
                            if (!isDone) {
                                group.add(d);
                                isAdded = true;
                            }
                        }
                    });
                };

                recursiveAction(state);

                return group;
            },
            invokeRec3: function (TState, scheduler, pair) {
                var group = new System.Reactive.Disposables.CompositeDisposable.$ctor3(1);
                var gate = {  };
                var state = pair.first;
                var action = pair.second;

                var recursiveAction = null;
                recursiveAction = function (state1) {
                    action(state1, function (state2, dueTime1) {
                        var isAdded = false;
                        var isDone = false;
                        var d = null;
                        d = scheduler.System$Reactive$Concurrency$IScheduler$schedule$1(TState, state2, dueTime1.$clone(), function (scheduler1, state3) {
                            gate;
                            {
                                if (isAdded) {
                                    group.remove(d);
                                } else {
                                    isDone = true;
                                }
                            }
                            recursiveAction(state3);
                            return System.Reactive.Disposables.Disposable.getEmpty();
                        });

                        gate;
                        {
                            if (!isDone) {
                                group.add(d);
                                isAdded = true;
                            }
                        }
                    });
                };

                recursiveAction(state);

                return group;
            },
            /**
             * Returns the ISchedulerLongRunning implementation of the specified scheduler, or null if no such implementation is available.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @param   {System.Reactive.Concurrency.IScheduler}               scheduler    Scheduler to get the ISchedulerLongRunning implementation for.
             * @return  {System.Reactive.Concurrency.ISchedulerLongRunning}                 The scheduler's ISchedulerLongRunning implementation if available; null otherwise.
             */
            asLongRunning: function (scheduler) {
                var svc = Bridge.as(scheduler, System.Reactive.IServiceProvider);
                if (svc != null) {
                    return Bridge.cast(svc.System$Reactive$IServiceProvider$getService(System.Reactive.Concurrency.ISchedulerLongRunning), System.Reactive.Concurrency.ISchedulerLongRunning);
                }

                return null;
            },
            /**
             * Returns the IStopwatchProvider implementation of the specified scheduler, or null if no such implementation is available.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @param   {System.Reactive.Concurrency.IScheduler}            scheduler    Scheduler to get the IStopwatchProvider implementation for.
             * @return  {System.Reactive.Concurrency.IStopwatchProvider}                 The scheduler's IStopwatchProvider implementation if available; null otherwise.
             */
            asStopwatchProvider: function (scheduler) {
                var svc = Bridge.as(scheduler, System.Reactive.IServiceProvider);
                if (svc != null) {
                    return Bridge.cast(svc.System$Reactive$IServiceProvider$getService(System.Reactive.Concurrency.IStopwatchProvider), System.Reactive.Concurrency.IStopwatchProvider);
                }

                return null;
            },
            /**
             * Returns the IStopwatchProvider implementation of the specified scheduler, or null if no such implementation is available.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @param   {System.Reactive.Concurrency.IScheduler}            scheduler    Scheduler to get the IStopwatchProvider implementation for.
             * @return  {System.Reactive.Concurrency.ISchedulerPeriodic}                 The scheduler's IStopwatchProvider implementation if available; null otherwise.
             */
            asPeriodic: function (scheduler) {
                var svc = Bridge.as(scheduler, System.Reactive.IServiceProvider);
                if (svc != null) {
                    return Bridge.cast(svc.System$Reactive$IServiceProvider$getService(System.Reactive.Concurrency.ISchedulerPeriodic), System.Reactive.Concurrency.ISchedulerPeriodic);
                }

                return null;
            },
            /**
             * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities.
             If the scheduler supports periodic scheduling, the request will be forwarded to the periodic scheduling implementation.
             If the scheduler provides stopwatch functionality, the periodic task will be emulated using recursive scheduling with a stopwatch to correct for time slippage.
             Otherwise, the periodic task will be emulated using recursive scheduling.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TState       The type of the state passed to the scheduled action.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    The scheduler to run periodic work on.
             * @param   {TState}                                    state        Initial state passed to the action upon the first iteration.
             * @param   {System.TimeSpan}                           period       Period for running the work periodically.
             * @param   {System.Func}                               action       Action to be executed, potentially updating the state.
             * @return  {System.IDisposable}                                     The disposable object used to cancel the scheduled recurring action (best effort).
             */
            schedulePeriodic$2: function (TState, scheduler, state, period, action) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (System.TimeSpan.lt(period, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("period");
                }
                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException("action");
                }

                return System.Reactive.Concurrency.Scheduler.schedulePeriodic_(TState, scheduler, state, period, action);
            },
            /**
             * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities.
             If the scheduler supports periodic scheduling, the request will be forwarded to the periodic scheduling implementation.
             If the scheduler provides stopwatch functionality, the periodic task will be emulated using recursive scheduling with a stopwatch to correct for time slippage.
             Otherwise, the periodic task will be emulated using recursive scheduling.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TState       The type of the state passed to the scheduled action.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to execute the action on.
             * @param   {TState}                                    state        State passed to the action to be executed.
             * @param   {System.TimeSpan}                           period       Period for running the work periodically.
             * @param   {System.Action}                             action       Action to be executed.
             * @return  {System.IDisposable}                                     The disposable object used to cancel the scheduled recurring action (best effort).
             */
            schedulePeriodic$1: function (TState, scheduler, state, period, action) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (System.TimeSpan.lt(period, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("period");
                }
                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException("action");
                }

                return System.Reactive.Concurrency.Scheduler.schedulePeriodic_(TState, scheduler, state, period, function (state_) {
                    action(state_);
                    return state_;
                });
            },
            /**
             * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities.
             If the scheduler supports periodic scheduling, the request will be forwarded to the periodic scheduling implementation.
             If the scheduler provides stopwatch functionality, the periodic task will be emulated using recursive scheduling with a stopwatch to correct for time slippage.
             Otherwise, the periodic task will be emulated using recursive scheduling.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to execute the action on.
             * @param   {System.TimeSpan}                           period       Period for running the work periodically.
             * @param   {System.Action}                             action       Action to be executed.
             * @return  {System.IDisposable}                                     The disposable object used to cancel the scheduled recurring action (best effort).
             */
            schedulePeriodic: function (scheduler, period, action) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (System.TimeSpan.lt(period, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("period");
                }
                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException("action");
                }

                return System.Reactive.Concurrency.Scheduler.schedulePeriodic_(Function, scheduler, action, period, $asm.$.System.Reactive.Concurrency.Scheduler.f6);
            },
            /**
             * Starts a new stopwatch object by dynamically discovering the scheduler's capabilities.
             If the scheduler provides stopwatch functionality, the request will be forwarded to the stopwatch provider implementation.
             Otherwise, the stopwatch will be emulated using the scheduler's notion of absolute time.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @throws <b /> is null.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to obtain a stopwatch for.
             * @return  {System.Reactive.Concurrency.IStopwatch}                 New stopwatch object; started at the time of the request.
             */
            startStopwatch: function (scheduler) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                //
                // All schedulers deriving from LocalScheduler will automatically pick up this
                // capability based on a local stopwatch, typically using QueryPerformanceCounter
                // through the System.Diagnostics.Stopwatch class.
                //
                // Notice virtual time schedulers do implement this facility starting from Rx v2.0,
                // using subtraction of their absolute time notion to compute elapsed time values.
                // This is fine because those schedulers do not allow the clock to go back in time.
                //
                // For schedulers that don't have a stopwatch, we have to pick some fallback logic
                // here. We could either dismiss the scheduler's notion of time and go for the CAL's
                // stopwatch facility, or go with a stopwatch based on "scheduler.Now", which has
                // the drawback of potentially going back in time:
                //
                //   - Using the CAL's stopwatch facility causes us to abondon the scheduler's
                //     potentially virtualized notion of time, always going for the local system
                //     time instead.
                //
                //   - Using the scheduler's Now property for calculations can break monotonicity,
                //     and there's no right answer on how to deal with jumps back in time.
                //
                // However, even the built-in stopwatch in the BCL can potentially fall back to
                // subtraction of DateTime values in case no high-resolution performance counter is
                // available, causing monotonicity to break down. We're not trying to solve this
                // problem there either (though we could check IsHighResolution and smoothen out
                // non-monotonic points somehow), so we pick the latter option as the lesser of
                // two evils (also because it should occur rarely).
                //
                // Users of the stopwatch retrieved by this method could detect non-sensical data
                // revealing a jump back in time, or implement custom fallback logic like the one
                // shown below.
                //
                var swp = System.Reactive.Concurrency.Scheduler.asStopwatchProvider(scheduler);
                if (swp != null) {
                    return swp.System$Reactive$Concurrency$IStopwatchProvider$startStopwatch();
                }

                return new System.Reactive.Concurrency.Scheduler.EmulatedStopwatch(scheduler);
            },
            schedulePeriodic_: function (TState, scheduler, state, period, action) {
                //
                // Design rationale:
                //
                //   In Rx v1.x, we employed recursive scheduling for periodic tasks. The following code
                //   fragment shows how the Timer (and hence Interval) function used to be implemented:
                //
                //     var p = Normalize(period);
                //
                //     return new AnonymousObservable<long>(observer =>
                //     {
                //         var d = dueTime;
                //         long count = 0;
                //         return scheduler.Schedule(d, self =>
                //         {
                //             if (p > TimeSpan.Zero)
                //             {
                //                 var now = scheduler.Now;
                //                 d = d + p;
                //                 if (d <= now)
                //                     d = now + p;
                //             }
                //
                //             observer.OnNext(count);
                //             count = unchecked(count + 1);
                //             self(d);
                //         });
                //     });
                //
                //   Despite the purity of this approach, it suffered from a set of drawbacks:
                //
                //    1) Usage of IScheduler.Now to correct for time drift did have a positive effect for
                //       a limited number of scenarios, in particular when a short period was used. The
                //       major issues with this are:
                //
                //       a) Relying on absolute time at the LINQ layer in Rx's layer map, causing issues
                //          when the system clock changes. Various customers hit this issue, reported to
                //          us on the MSDN forums. Basically, when the clock goes forward, the recursive
                //          loop wants to catch up as quickly as it can; when it goes backwards, a long
                //          silence will occur. (See 2 for a discussion of WP7 related fixes.)
                //
                //       b) Even if a) would be addressed by using Rx v2.0's capabilities to monitor for
                //          system clock changes, the solution would violate the reasonable expectation
                //          of operators overloads using TimeSpan *not* relying on absolute time.
                //
                //       c) Drift correction doesn't work for large periods when the system encounters
                //          systematic drift. For example, in the lab we've seen cases of drift up to
                //          tens of seconds on a 24 hour timeframe. Correcting for this drift by making
                //          a recursive call with a due time of 24 * 3600 with 10 seconds of adjustment
                //          won't fix systematic drift.
                //
                //    2) This implementation has been plagued with issues around application container
                //       lifecycle models, in particular Windows Phone 7's model of tombstoning and in
                //       particular its "dormant state". This feature was introduced in Mango to enable
                //       fast application switching. Essentially, the phone's OS puts the application
                //       in a suspended state when the user navigates "forward" (or takes an incoming
                //       call for instance). When the application is woken up again, threads are resumed
                //       and we're faced with an illusion of missed events due to the use of absolute
                //       time, not relative to how the application observes it. This caused nightmare
                //       scenarios of fast battery drain due to the flood of catch-up work.
                //
                //       See http://msdn.microsoft.com/en-us/library/ff817008(v=vs.92).aspx for more
                //       information on this.
                //
                //    3) Recursive scheduling imposes a non-trivial cost due to the creation of many
                //       single-shot timers and closures. For high frequency timers, this can cause a
                //       lot of churn in the GC, which we like to avoid (operators shouldn't have hidden
                //       linear - or worse - allocation cost).
                //
                //   Notice these drawbacks weren't limited to the use of Timer and Interval directly,
                //   as many operators such as Sample, Buffer, and Window used such sequences for their
                //   periodic behavior (typically by delegating to a more general overload).
                //
                //   As a result, in Rx v2.0, we took the decision to improve periodic timing based on
                //   the following design decisions:
                //
                //    1) When the scheduler has the ability to run a periodic task, it should implement
                //       the ISchedulerPeriodic interface and expose it through the IServiceProvider
                //       interface. Passing the intent of the user through all layers of Rx, down to the
                //       underlying infrastructure provides delegation of responsibilities. This allows
                //       the target scheduler to optimize execution in various ways, e.g. by employing
                //       techniques such as timer coalescing.
                //
                //       See http://www.bing.com/search?q=windows+timer+coalescing for information on
                //       techniques like timer coalescing which may be applied more aggressively in
                //       future OS releases in order to reduce power consumption.
                //
                //    2) Emulation of periodic scheduling is used to avoid breaking existing code that
                //       uses schedulers without this capability. We expect those fallback paths to be
                //       exercised rarely, though the use of DisableOptimizations can trigger them as
                //       well. In such cases we rely on stopwatches or a carefully crafted recursive
                //       scheme to deal with (or maximally compensate for) slippage or time. Behavior
                //       of periodic tasks is expected to be as follows:
                //
                //         timer ticks   0-------1-------2-------3-------4-------5-------6----...
                //                       |       |       |       +====+  +==+    |       |
                //         user code     +~~~|   +~|     +~~~~~~~~~~~|+~~~~|+~~| +~~~|   +~~|
                //
                //       rather than the following scheme, where time slippage is introduced by user
                //       code running on the scheduler:
                //
                //         timer ticks   0####-------1##-------2############-------3#####-----...
                //                       |           |         |                   |
                //         user code     +~~~|       +~|       +~~~~~~~~~~~|       +~~~~|
                //
                //       (Side-note: Unfortunately, we didn't reserve the name Interval for the latter
                //                   behavior, but used it as an alias for "periodic scheduling" with
                //                   the former behavior, delegating to the Timer implementation. One
                //                   can simulate this behavior using Generate, which uses tail calls.)
                //
                //       This behavior is important for operations like Sample, Buffer, and Window, all
                //       of which expect proper spacing of events, even if the user code takes a long
                //       time to complete (considered a bad practice nonetheless, cf. ObserveOn).
                //
                //    3) To deal with the issue of suspensions induced by application lifecycle events
                //       in Windows Phone and WinRT applications, we decided to hook available system
                //       events through IHostLifecycleNotifications, discovered through the PEP in order
                //       to maintain portability of the core of Rx.
                //

                var periodic = System.Reactive.Concurrency.Scheduler.asPeriodic(scheduler);
                if (periodic != null) {
                    return periodic.System$Reactive$Concurrency$ISchedulerPeriodic$schedulePeriodic(TState, state, period, action);
                }

                var swp = System.Reactive.Concurrency.Scheduler.asStopwatchProvider(scheduler);
                if (swp != null) {
                    var spr = new (System.Reactive.Concurrency.Scheduler.SchedulePeriodicStopwatch$1(TState))(scheduler, state, period, action, swp);
                    return spr.start();
                } else {
                    var spr1 = new (System.Reactive.Concurrency.Scheduler.SchedulePeriodicRecursive$1(TState))(scheduler, state, period, action);
                    return spr1.start();
                }
            },
            /**
             * Schedules an action to be executed.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @throws <b /> or <b /> is null.
             * @param   {System.Reactive.Concurrency.ISchedulerLongRunning}    scheduler    Scheduler to execute the action on.
             * @param   {System.Action}                                        action       Action to execute.
             * @return  {System.IDisposable}                                                The disposable object used to cancel the scheduled action (best effort).
             */
            scheduleLongRunning: function (scheduler, action) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException("action");
                }

                return scheduler.System$Reactive$Concurrency$ISchedulerLongRunning$scheduleLongRunning(Function, action, $asm.$.System.Reactive.Concurrency.Scheduler.f7);
            },
            invoke: function (scheduler, action) {
                action();
                return System.Reactive.Disposables.Disposable.getEmpty();
            },
            /**
             * Returns a scheduler that represents the original scheduler, without any of its interface-based optimizations (e.g. long running scheduling).
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @throws <b /> is null.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to disable all optimizations for.
             * @return  {System.Reactive.Concurrency.IScheduler}                 Proxy to the original scheduler but without any optimizations enabled.
             */
            disableOptimizations: function (scheduler) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return new System.Reactive.Concurrency.DisableOptimizationsScheduler.ctor(scheduler);
            },
            /**
             * Returns a scheduler that represents the original scheduler, without the specified set of interface-based optimizations (e.g. long running scheduling).
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @throws <b /> or <b /> is null.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler                 Scheduler to disable the specified optimizations for.
             * @param   {Array.<Function>}                          optimizationInterfaces    Types of the optimization interfaces that have to be disabled.
             * @return  {System.Reactive.Concurrency.IScheduler}                              Proxy to the original scheduler but without the specified optimizations enabled.
             */
            disableOptimizations$1: function (scheduler, optimizationInterfaces) {
                if (optimizationInterfaces === void 0) { optimizationInterfaces = []; }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (optimizationInterfaces == null) {
                    throw new System.ArgumentNullException("optimizationInterfaces");
                }

                return new System.Reactive.Concurrency.DisableOptimizationsScheduler.$ctor1(scheduler, optimizationInterfaces);
            },
            /**
             * Returns a scheduler that wraps the original scheduler, adding exception handling for scheduled actions.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Scheduler
             * @memberof System.Reactive.Concurrency.Scheduler
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TException    Type of the exception to check for.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler     Scheduler to apply an exception filter for.
             * @param   {System.Func}                               handler       Handler that's run if an exception is caught. The exception will be rethrown if the handler returns false.
             * @return  {System.Reactive.Concurrency.IScheduler}                  Wrapper around the original scheduler, enforcing exception handling.
             */
            catch: function (TException, scheduler, handler) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (Bridge.staticEquals(handler, null)) {
                    throw new System.ArgumentNullException("handler");
                }

                return new (System.Reactive.Concurrency.CatchScheduler$1(TException))(scheduler, handler);
            }
        }
    });

    Bridge.ns("System.Reactive.Concurrency.Scheduler", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Concurrency.Scheduler, {
        f1: function () {
            return System.Reactive.Concurrency.Scheduler.initialize("ThreadPool");
        },
        f2: function () {
            return System.Reactive.Concurrency.Scheduler.initialize("NewThread");
        },
        f3: function (_action, self) {
            _action(function () {
                self(_action);
            });
        },
        f4: function (_action, self) {
            _action(function (dt) {
                self(_action, dt);
            });
        },
        f5: function (_action, self) {
            _action(function (dt) {
                self(_action, dt.$clone());
            });
        },
        f6: function (a) {
            a();
            return a;
        },
        f7: function (a, c) {
            a(c);
        }
    });

    Bridge.define("System.Reactive.Concurrency.Scheduler.Pair$2", function (T1, T2) { return {
        $kind: "struct",
        statics: {
            getDefaultValue: function () { return new (System.Reactive.Concurrency.Scheduler.Pair$2(T1,T2))(); }
        },
        first: Bridge.getDefaultValue(T1),
        second: Bridge.getDefaultValue(T2),
        ctor: function () {
            this.$initialize();
        },
        getHashCode: function () {
            var h = Bridge.addHash([1919508816, this.first, this.second]);
            return h;
        },
        equals: function (o) {
            if (!Bridge.is(o, System.Reactive.Concurrency.Scheduler.Pair$2(T1,T2))) {
                return false;
            }
            return Bridge.equals(this.first, o.first) && Bridge.equals(this.second, o.second);
        },
        $clone: function (to) {
            var s = to || new (System.Reactive.Concurrency.Scheduler.Pair$2(T1,T2))();
            s.first = this.first;
            s.second = this.second;
            return s;
        }
    }; });

    Bridge.define("System.Reactive.Concurrency.Scheduler.SchedulePeriodicRecursive$1", function (TState) { return {
        statics: {
            TICK: 0,
            DISPATCH_START: 1,
            DISPATCH_END: 2
        },
        _scheduler: null,
        _action: null,
        _state: Bridge.getDefaultValue(TState),
        _pendingTickCount: 0,
        _cancel: null,
        config: {
            init: function () {
                this._period = new System.TimeSpan();
            }
        },
        ctor: function (scheduler, state, period, action) {
            this.$initialize();
            this._scheduler = scheduler;
            this._period = period;
            this._action = action;

            this._state = state;
        },
        start: function () {
            this._pendingTickCount = 0;

            var d = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._cancel = d;

            d.setDisposable(System.Reactive.Concurrency.Scheduler.schedule$8(System.Int32, this._scheduler, System.Reactive.Concurrency.Scheduler.SchedulePeriodicRecursive$1(TState).TICK, this._period, Bridge.fn.bind(this, this.tick)));

            return d;
        },
        tick: function (command, recurse) {
            switch (command) {
                case System.Reactive.Concurrency.Scheduler.SchedulePeriodicRecursive$1(TState).TICK: 
                    //
                    // Ticks keep going at the specified periodic rate. We do a head call such
                    // that no slippage is introduced because of DISPATCH_START work involving
                    // user code that may take arbitrarily long.
                    //
                    recurse(System.Reactive.Concurrency.Scheduler.SchedulePeriodicRecursive$1(TState).TICK, this._period);
                    //
                    // If we're not transitioning from 0 to 1 pending tick, another processing
                    // request is in flight which will see a non-zero pending tick count after
                    // doing the final decrement, causing it to reschedule immediately. We can
                    // safely bail out, delegating work to the catch-up tail calls.
                    //
                    if (System.Interlocked.increment(Bridge.ref(this, "_pendingTickCount")) === 1) {
                        try {
                            this._state = this._action(this._state);
                        }
                        catch (e) {
                            e = System.Exception.create(e);
                            this._cancel.System$IDisposable$dispose();
                            System.Reactive.ExceptionHelpers.throw(e);
                        }
                    }
                    //
                    // This is very subtle. We can't do a goto case DISPATCH_END here because it
                    // wouldn't introduce interleaving of periodic ticks that are due. In order
                    // to have best effort behavior for schedulers that don't have concurrency,
                    // we yield by doing a recursive call here. Notice this doesn't heal all of
                    // the problem, because the TICK commands that may be dispatched before the
                    // scheduled DISPATCH_END will do a "recurse(TICK, period)", which is relative
                    // from the point of entrance. Really all we're doing here is damage control
                    // for the case there's no stopwatch provider which should be rare (notice
                    // the LocalScheduler base class always imposes a stopwatch, but it can get
                    // disabled using DisableOptimizations; legacy implementations of schedulers
                    // from the v1.x days will not have a stopwatch).
                    //
                    recurse(System.Reactive.Concurrency.Scheduler.SchedulePeriodicRecursive$1(TState).DISPATCH_END, System.TimeSpan.zero);
                    break;
                case System.Reactive.Concurrency.Scheduler.SchedulePeriodicRecursive$1(TState).DISPATCH_START: 
                    try {
                        this._state = this._action(this._state);
                    }
                    catch (e1) {
                        e1 = System.Exception.create(e1);
                        this._cancel.System$IDisposable$dispose();
                        System.Reactive.ExceptionHelpers.throw(e1);
                    }
                    //
                    // This is very subtle. We can't do a goto case DISPATCH_END here because it
                    // wouldn't introduce interleaving of periodic ticks that are due. In order
                    // to have best effort behavior for schedulers that don't have concurrency,
                    // we yield by doing a recursive call here. Notice this doesn't heal all of
                    // the problem, because the TICK commands that may be dispatched before the
                    // scheduled DISPATCH_END will do a "recurse(TICK, period)", which is relative
                    // from the point of entrance. Really all we're doing here is damage control
                    // for the case there's no stopwatch provider which should be rare (notice
                    // the LocalScheduler base class always imposes a stopwatch, but it can get
                    // disabled using DisableOptimizations; legacy implementations of schedulers
                    // from the v1.x days will not have a stopwatch).
                    //
                    recurse(System.Reactive.Concurrency.Scheduler.SchedulePeriodicRecursive$1(TState).DISPATCH_END, System.TimeSpan.zero);
                    break;
                case System.Reactive.Concurrency.Scheduler.SchedulePeriodicRecursive$1(TState).DISPATCH_END: 
                    //
                    // If work was due while we were still running user code, the count will have
                    // been incremented by the periodic tick handler above. In that case, we will
                    // reschedule ourselves for dispatching work immediately.
                    //
                    // Notice we don't run a loop here, in order to allow interleaving of work on
                    // the scheduler by making recursive calls. In case we would use AsyncLock to
                    // ensure serialized execution the owner could get stuck in such a loop, thus
                    // we make tail calls to play nice with the scheduler.
                    //
                    if (System.Interlocked.decrement(Bridge.ref(this, "_pendingTickCount")) > 0) {
                        recurse(System.Reactive.Concurrency.Scheduler.SchedulePeriodicRecursive$1(TState).DISPATCH_START, System.TimeSpan.zero);
                    }
                    break;
            }
        }
    }; });

    Bridge.define("System.Reactive.Concurrency.Scheduler.SchedulePeriodicStopwatch$1", function (TState) { return {
        statics: {
            STOPPED: 0,
            RUNNING: 1,
            SUSPENDED: 2,
            DISPOSED: 3
        },
        _scheduler: null,
        _action: null,
        _stopwatchProvider: null,
        _state: Bridge.getDefaultValue(TState),
        _gate: null,
        _resumeEvent: null,
        _runState: 0,
        _stopwatch: null,
        config: {
            init: function () {
                this._period = new System.TimeSpan();
                this._gate = {  };
                this._resumeEvent = new System.Threading.AutoResetEvent(false);
                this._nextDue = new System.TimeSpan();
                this._suspendedAt = new System.TimeSpan();
                this._inactiveTime = new System.TimeSpan();
            }
        },
        ctor: function (scheduler, state, period, action, stopwatchProvider) {
            this.$initialize();
            this._scheduler = scheduler;
            this._period = period;
            this._action = action;
            this._stopwatchProvider = stopwatchProvider;

            this._state = state;
            this._runState = System.Reactive.Concurrency.Scheduler.SchedulePeriodicStopwatch$1(TState).STOPPED;
        },
        start: function () {
            this.registerHostLifecycleEventHandlers();

            this._stopwatch = this._stopwatchProvider.System$Reactive$Concurrency$IStopwatchProvider$startStopwatch();
            this._nextDue = this._period;
            this._runState = System.Reactive.Concurrency.Scheduler.SchedulePeriodicStopwatch$1(TState).RUNNING;

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(System.Reactive.Concurrency.Scheduler.schedule$5(this._scheduler, this._nextDue, Bridge.fn.bind(this, this.tick)), System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, this.cancel)));
        },
        tick: function (recurse) {
            this._nextDue = System.TimeSpan.add(this._nextDue, this._period);
            this._state = this._action(this._state);

            var next = Bridge.getDefaultValue(System.TimeSpan);

            while (true) {
                var shouldWaitForResume = false;

                this._gate;
                {
                    if (this._runState === System.Reactive.Concurrency.Scheduler.SchedulePeriodicStopwatch$1(TState).RUNNING) {
                        //
                        // This is the fast path. We just let the stopwatch continue to
                        // run while we're suspended, but compensate for time that was
                        // recorded as inactive based on cumulative deltas computed in
                        // the suspend and resume event handlers.
                        //
                        next = System.Reactive.Concurrency.Scheduler.normalize(System.TimeSpan.sub(this._nextDue, (System.TimeSpan.sub(this._stopwatch.System$Reactive$Concurrency$IStopwatch$getElapsed(), this._inactiveTime))));
                        break;
                    } else if (this._runState === System.Reactive.Concurrency.Scheduler.SchedulePeriodicStopwatch$1(TState).DISPOSED) {
                        //
                        // In case the periodic job gets disposed but we are currently
                        // waiting to come back out of suspension, we should make sure
                        // we don't remain blocked indefinitely. Hence, we set the event
                        // in the Cancel method and trap this case here to bail out from
                        // the scheduled work gracefully.
                        //
                        return;
                    } else {
                        //
                        // This is the least common case where we got suspended and need
                        // to block such that future reevaluations of the next due time
                        // will pick up the cumulative inactive time delta.
                        //
                        shouldWaitForResume = true;
                    }
                }

                //
                // Only happens in the SUSPENDED case; otherwise we will have broken from
                // the loop or have quit the Tick method. After returning from the wait,
                // we'll either be RUNNING again, quit due to a DISPOSED transition, or
                // be extremely unlucky to find ourselves SUSPENDED again and be blocked
                // once more.
                //
                if (shouldWaitForResume) {
                    this._resumeEvent.waitOne();
                }
            }

            recurse(next);
        },
        cancel: function () {
            this.unregisterHostLifecycleEventHandlers();

            this._gate;
            {
                this._runState = System.Reactive.Concurrency.Scheduler.SchedulePeriodicStopwatch$1(TState).DISPOSED;

                if (!RxBridge.Environment.getHasShutdownStarted()) {
                    this._resumeEvent.set();
                }
            }
        },
        suspending: function (sender, args) {
            //
            // The host is telling us we're about to be suspended. At this point, time
            // computations will still be in a valid range (next <= _period), but after
            // we're woken up again, Tick would start to go on a crucade to catch up.
            //
            // This has caused problems in the past, where the flood of events caused
            // batteries to drain etc (see design rationale discussion higher up).
            //
            // In order to mitigate this problem, we force Tick to suspend before its
            // next computation of the next due time. Notice we can't afford to block
            // during the Suspending event handler; the host expects us to respond to
            // this event quickly, such that we're not keeping the application from
            // suspending promptly.
            //
            this._gate;
            {
                if (this._runState === System.Reactive.Concurrency.Scheduler.SchedulePeriodicStopwatch$1(TState).RUNNING) {
                    this._suspendedAt = this._stopwatch.System$Reactive$Concurrency$IStopwatch$getElapsed();
                    this._runState = System.Reactive.Concurrency.Scheduler.SchedulePeriodicStopwatch$1(TState).SUSPENDED;

                    if (!RxBridge.Environment.getHasShutdownStarted()) {
                        this._resumeEvent.reset();
                    }
                }
            }
        },
        resuming: function (sender, args) {
            //
            // The host is telling us we're being resumed. At this point, code will
            // already be running in the process, so a past timer may still expire and
            // cause the code in Tick to run. Two interleavings are possible now:
            //
            //   1) We enter the gate first, and will adjust the cumulative inactive
            //      time delta used for correction. The code in Tick will have the
            //      illusion nothing happened and find itself RUNNING when entering
            //      the gate, resuming activities as before.
            //
            //   2) The code in Tick enters the gate first, and takes notice of the
            //      currently SUSPENDED state. It leaves the gate, entering the wait
            //      state for _resumeEvent. Next, we enter to adjust the cumulative
            //      inactive time delta, switch to the RUNNING state and signal the
            //      event for Tick to carry on and recompute its next due time based
            //      on the new cumulative delta.
            //
            this._gate;
            {
                if (this._runState === System.Reactive.Concurrency.Scheduler.SchedulePeriodicStopwatch$1(TState).SUSPENDED) {
                    this._inactiveTime = System.TimeSpan.add(this._inactiveTime, System.TimeSpan.sub(this._stopwatch.System$Reactive$Concurrency$IStopwatch$getElapsed(), this._suspendedAt));
                    this._runState = System.Reactive.Concurrency.Scheduler.SchedulePeriodicStopwatch$1(TState).RUNNING;

                    if (!RxBridge.Environment.getHasShutdownStarted()) {
                        this._resumeEvent.set();
                    }
                }
            }
        },
        registerHostLifecycleEventHandlers: function () {
            System.Reactive.PlatformServices.HostLifecycleService.addSuspending(Bridge.fn.bind(this, this.suspending));
            System.Reactive.PlatformServices.HostLifecycleService.addResuming(Bridge.fn.bind(this, this.resuming));
            System.Reactive.PlatformServices.HostLifecycleService.addRef();
        },
        unregisterHostLifecycleEventHandlers: function () {
            System.Reactive.PlatformServices.HostLifecycleService.removeSuspending(Bridge.fn.bind(this, this.suspending));
            System.Reactive.PlatformServices.HostLifecycleService.removeResuming(Bridge.fn.bind(this, this.resuming));
            System.Reactive.PlatformServices.HostLifecycleService.release();
        }
    }; });

    Bridge.define("System.Reactive.Concurrency.SchedulerDefaults", {
        statics: {
            getConstantTimeOperations: function () {
                return System.Reactive.Concurrency.ImmediateScheduler.getInstance();
            },
            getTailRecursion: function () {
                return System.Reactive.Concurrency.ImmediateScheduler.getInstance();
            },
            getIteration: function () {
                return System.Reactive.Concurrency.CurrentThreadScheduler.getInstance();
            },
            getTimeBasedOperations: function () {
                return System.Reactive.Concurrency.DefaultScheduler.getInstance();
            },
            getAsyncConversions: function () {
                return System.Reactive.Concurrency.DefaultScheduler.getInstance();
            }
        }
    });

    /**
     * Efficient scheduler queue that maintains scheduled items sorted by absolute time.
     *
     * @public
     * @class System.Reactive.Concurrency.SchedulerQueue$1
     * @param   {Function}    [name]    Absolute time representation type.
     */
    Bridge.define("System.Reactive.Concurrency.SchedulerQueue$1", function (TAbsolute) { return {
        _queue: null,
        /**
         * Creates a new scheduler queue with a default initial capacity.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.SchedulerQueue$1
         * @memberof System.Reactive.Concurrency.SchedulerQueue$1
         * @return  {void}
         */
        ctor: function () {
            System.Reactive.Concurrency.SchedulerQueue$1(TAbsolute).$ctor1.call(this, 1024);
        },
        /**
         * Creats a new scheduler queue with the specified initial capacity.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.SchedulerQueue$1
         * @memberof System.Reactive.Concurrency.SchedulerQueue$1
         * @throws <b /> is less than zero.
         * @param   {number}    capacity    Initial capacity of the scheduler queue.
         * @return  {void}
         */
        $ctor1: function (capacity) {
            this.$initialize();
            if (capacity < 0) {
                throw new System.ArgumentOutOfRangeException("capacity");
            }

            this._queue = new (System.Reactive.PriorityQueue$1(System.Reactive.Concurrency.ScheduledItem$1(TAbsolute))).$ctor1(capacity);
        },
        /**
         * Gets the number of scheduled items in the scheduler queue.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.SchedulerQueue$1
         * @memberof System.Reactive.Concurrency.SchedulerQueue$1
         * @function getCount
         * @return  {number}
         */
        /**
         * Gets the number of scheduled items in the scheduler queue.
         *
         * @instance
         * @function setCount
         */
        getCount: function () {
            return this._queue.getCount();
        },
        /**
         * Enqueues the specified work item to be scheduled.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.SchedulerQueue$1
         * @memberof System.Reactive.Concurrency.SchedulerQueue$1
         * @param   {System.Reactive.Concurrency.ScheduledItem$1}    scheduledItem    Work item to be scheduled.
         * @return  {void}
         */
        enqueue: function (scheduledItem) {
            this._queue.enqueue(scheduledItem);
        },
        /**
         * Removes the specified work item from the scheduler queue.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.SchedulerQueue$1
         * @memberof System.Reactive.Concurrency.SchedulerQueue$1
         * @param   {System.Reactive.Concurrency.ScheduledItem$1}    scheduledItem    Work item to be removed from the scheduler queue.
         * @return  {boolean}                                                         true if the item was found; false otherwise.
         */
        remove: function (scheduledItem) {
            return this._queue.remove(scheduledItem);
        },
        /**
         * Dequeues the next work item from the scheduler queue.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.SchedulerQueue$1
         * @memberof System.Reactive.Concurrency.SchedulerQueue$1
         * @return  {System.Reactive.Concurrency.ScheduledItem$1}        Next work item in the scheduler queue (removed).
         */
        dequeue: function () {
            return this._queue.dequeue();
        },
        /**
         * Peeks the next work item in the scheduler queue.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.SchedulerQueue$1
         * @memberof System.Reactive.Concurrency.SchedulerQueue$1
         * @return  {System.Reactive.Concurrency.ScheduledItem$1}        Next work item in the scheduler queue (not removed).
         */
        peek: function () {
            return this._queue.peek();
        }
    }; });

    /**
     * Provides basic synchronization and scheduling services for observable sequences.
     *
     * @static
     * @abstract
     * @public
     * @class System.Reactive.Concurrency.Synchronization
     */
    Bridge.define("System.Reactive.Concurrency.Synchronization", {
        statics: {
            /**
             * Wraps the source sequence in order to run its subscription and unsubscription logic on the specified scheduler.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Synchronization
             * @memberof System.Reactive.Concurrency.Synchronization
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to perform subscription and unsubscription actions on.
             * @return  {System.IObservable$1}                                   The source sequence whose subscriptions and unsubscriptions happen on the specified scheduler.
             */
            subscribeOn: function (TSource, source, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return new (System.Reactive.AnonymousObservable$1(TSource))(function (observer) {
                    var m = new System.Reactive.Disposables.SingleAssignmentDisposable();
                    var d = new System.Reactive.Disposables.SerialDisposable();
                    d.setDisposable(m);

                    m.setDisposable(System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                        d.setDisposable(new System.Reactive.Disposables.ScheduledDisposable(scheduler, System.ObservableExtensions.subscribeSafe(TSource, source, observer)));
                    }));

                    return d;
                });
            },
            /**
             * Wraps the source sequence in order to run its observer callbacks on the specified scheduler.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Synchronization
             * @memberof System.Reactive.Concurrency.Synchronization
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to notify observers on.
             * @return  {System.IObservable$1}                                   The source sequence whose observations happen on the specified scheduler.
             */
            observeOn: function (TSource, source, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return new (System.Reactive.Concurrency.ObserveOn$1(TSource))(source, scheduler);
            },
            /**
             * Wraps the source sequence in order to ensure observer callbacks are properly serialized.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Synchronization
             * @memberof System.Reactive.Concurrency.Synchronization
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence.
             * @return  {System.IObservable$1}               The source sequence whose outgoing calls to observers are synchronized.
             */
            synchronize: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return new (System.Reactive.Concurrency.Synchronize$1(TSource)).ctor(source);
            },
            /**
             * Wraps the source sequence in order to ensure observer callbacks are synchronized using the specified gate object.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.Synchronization
             * @memberof System.Reactive.Concurrency.Synchronization
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence.
             * @param   {Object}                  gate       Gate object to synchronize each observer call on.
             * @return  {System.IObservable$1}               The source sequence whose outgoing calls to observers are synchronized on the given gate object.
             */
            synchronize$1: function (TSource, source, gate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (gate == null) {
                    throw new System.ArgumentNullException("gate");
                }

                return new (System.Reactive.Concurrency.Synchronize$1(TSource)).$ctor1(source, gate);
            }
        }
    });

    /**
     * Provides a set of extension methods for virtual time scheduling.
     *
     * @static
     * @abstract
     * @public
     * @class System.Reactive.Concurrency.VirtualTimeSchedulerExtensions
     */
    Bridge.define("System.Reactive.Concurrency.VirtualTimeSchedulerExtensions", {
        statics: {
            /**
             * Schedules an action to be executed at dueTime.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.VirtualTimeSchedulerExtensions
             * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerExtensions
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                                  TAbsolute    Absolute time representation type.
             * @param   {Function}                                                  TRelative    Relative time representation type.
             * @param   {System.Reactive.Concurrency.VirtualTimeSchedulerBase$2}    scheduler    Scheduler to execute the action on.
             * @param   {TRelative}                                                 dueTime      Relative time after which to execute the action.
             * @param   {System.Action}                                             action       Action to be executed.
             * @return  {System.IDisposable}                                                     The disposable object used to cancel the scheduled action (best effort).
             */
            scheduleRelative: function (TAbsolute, TRelative, scheduler, dueTime, action) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException("action");
                }

                return scheduler.scheduleRelative(Function, action, dueTime, System.Reactive.Concurrency.VirtualTimeSchedulerExtensions.invoke);
            },
            /**
             * Schedules an action to be executed at dueTime.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.VirtualTimeSchedulerExtensions
             * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerExtensions
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                                  TAbsolute    Absolute time representation type.
             * @param   {Function}                                                  TRelative    Relative time representation type.
             * @param   {System.Reactive.Concurrency.VirtualTimeSchedulerBase$2}    scheduler    Scheduler to execute the action on.
             * @param   {TAbsolute}                                                 dueTime      Absolute time at which to execute the action.
             * @param   {System.Action}                                             action       Action to be executed.
             * @return  {System.IDisposable}                                                     The disposable object used to cancel the scheduled action (best effort).
             */
            scheduleAbsolute: function (TAbsolute, TRelative, scheduler, dueTime, action) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException("action");
                }

                return scheduler.scheduleAbsolute(Function, action, dueTime, System.Reactive.Concurrency.VirtualTimeSchedulerExtensions.invoke);
            },
            invoke: function (scheduler, action) {
                action();
                return System.Reactive.Disposables.Disposable.getEmpty();
            }
        }
    });

    Bridge.define("System.Reactive.Constants_Core", {
        statics: {
            OBSOLETE_REFACTORING: "This property is no longer supported due to refactoring of the API surface and elimination of platform-specific dependencies.",
            OBSOLETE_SCHEDULER_NEWTHREAD: "This property is no longer supported due to refactoring of the API surface and elimination of platform-specific dependencies. Please add a reference to the System.Reactive.PlatformServices assembly for your target platform and use NewThreadScheduler.Default to obtain an instance of this scheduler type.",
            OBSOLETE_SCHEDULER_TASKPOOL: "This property is no longer supported due to refactoring of the API surface and elimination of platform-specific dependencies. Please add a reference to the System.Reactive.PlatformServices assembly for your target platform and use TaskPoolScheduler.Default to obtain an instance of this scheduler type.",
            OBSOLETE_SCHEDULER_THREADPOOL: "This property is no longer supported due to refactoring of the API surface and elimination of platform-specific dependencies. Consider using Scheduler.Default to obtain the platform's most appropriate pool-based scheduler. In order to access a specific pool-based scheduler, please add a reference to the System.Reactive.PlatformServices assembly for your target platform and use the appropriate scheduler in the System.Reactive.Concurrency namespace.",
            OBSOLETE_SCHEDULEREQUIRED: "This instance property is no longer supported. Use CurrentThreadScheduler.IsScheduleRequired instead."
        }
    });

    Bridge.define("System.Reactive.Constants_Linq");

    /** @namespace System.Reactive.Disposables */

    /**
     * Disposable resource with disposal state tracking.
     *
     * @abstract
     * @public
     * @class System.Reactive.Disposables.ICancelable
     * @implements  System.IDisposable
     */
    Bridge.define("System.Reactive.Disposables.ICancelable", {
        inherits: [System.IDisposable],
        $kind: "interface"
    });

    /**
     * Represents a disposable that does nothing on disposal.
     *
     * @class System.Reactive.Disposables.DefaultDisposable
     * @implements  System.IDisposable
     */
    Bridge.define("System.Reactive.Disposables.DefaultDisposable", {
        inherits: [System.IDisposable],
        statics: {
            /**
             * Singleton default disposable.
             *
             * @instance
             */
            instance: null,
            config: {
                init: function () {
                    this.instance = new System.Reactive.Disposables.DefaultDisposable();
                }
            }
        },
        config: {
            alias: [
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function () {
            this.$initialize();
        },
        /**
         * Does nothing.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.DefaultDisposable
         * @memberof System.Reactive.Disposables.DefaultDisposable
         * @return  {void}
         */
        dispose: function () {
            // no op
        }
    });

    /**
     * Provides a set of static methods for creating Disposables.
     *
     * @static
     * @abstract
     * @public
     * @class System.Reactive.Disposables.Disposable
     */
    Bridge.define("System.Reactive.Disposables.Disposable", {
        statics: {
            /**
             * Gets the disposable that does nothing when disposed.
             *
             * @static
             * @public
             * @this System.Reactive.Disposables.Disposable
             * @memberof System.Reactive.Disposables.Disposable
             * @function getEmpty
             * @return  {System.IDisposable}
             */
            /**
             * Gets the disposable that does nothing when disposed.
             *
             * @instance
             * @function setEmpty
             */
            getEmpty: function () {
                return System.Reactive.Disposables.DefaultDisposable.instance;
            },
            /**
             * Creates a disposable object that invokes the specified action when disposed.
             *
             * @static
             * @public
             * @this System.Reactive.Disposables.Disposable
             * @memberof System.Reactive.Disposables.Disposable
             * @throws <b /> is null.
             * @param   {System.Action}         dispose    Action to run during the first call to {@link }. The action is guaranteed to be run at most once.
             * @return  {System.IDisposable}               The disposable object that runs the given action upon disposal.
             */
            create: function (dispose) {
                if (Bridge.staticEquals(dispose, null)) {
                    throw new System.ArgumentNullException("dispose");
                }

                return new System.Reactive.Disposables.AnonymousDisposable(dispose);
            }
        }
    });

    /**
     * The <b>System.Reactive.Disposables</b> namespace contains interfaces and classes that provide a compositional set of constructs used to deal with resource and subscription
     management in Reactive Extensions. Those types are used extensively within the implementation of Reactive Extensions and are useful when writing custom query operators or
     schedulers.
     *
     * @class System.Reactive.Disposables.NamespaceDoc
     */
    Bridge.define("System.Reactive.Disposables.NamespaceDoc");

    Bridge.define("System.Reactive.Disposables.RefCountDisposable.InnerDisposable", {
        inherits: [System.IDisposable],
        _parent: null,
        config: {
            alias: [
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function (parent) {
            this.$initialize();
            this._parent = parent;
        },
        dispose: function () {
            var parent = System.Interlocked.exchange(System.Reactive.Disposables.RefCountDisposable, Bridge.ref(this, "_parent"), null);
            if (parent != null) {
                parent.release();
            }
        }
    });

    Bridge.define("System.Reactive.Either$2", function (TLeft, TRight) { return {
        statics: {
            createLeft: function (value) {
                return new (System.Reactive.Either$2.Left(TLeft,TRight))(value);
            },
            createRight: function (value) {
                return new (System.Reactive.Either$2.Right(TLeft,TRight))(value);
            }
        },
        ctor: function () {
            this.$initialize();
        }
    }; });

    /**
     * Represents a .NET event invocation consisting of the strongly typed object that raised the event and the data that was generated by the event.
     *
     * @abstract
     * @public
     * @class System.Reactive.IEventPattern$2
     * @param   {Function}    [name]    The type of the sender that raised the event.
     This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see Covariance and Contravariance in Generics.
     * @param   {Function}    [name]    The type of the event data generated by the event.
     This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see Covariance and Contravariance in Generics.
     */
    Bridge.definei("System.Reactive.IEventPattern$2", function (TSender, TEventArgs) { return {
        $kind: "interface",
        $variance: [1,1]
    }; });

    /**
     * Base class for classes that expose an observable sequence as a well-known event pattern (sender, event arguments).
     Contains functionality to maintain a map of event handler delegates to observable sequence subscriptions. Subclasses
     should only add an event with custom add and remove methods calling into the base class's operations.
     *
     * @abstract
     * @public
     * @class System.Reactive.EventPatternSourceBase$2
     * @param   {Function}    [name]    The type of the sender that raises the event.
     * @param   {Function}    [name]    The type of the event data generated by the event.
     */
    Bridge.define("System.Reactive.EventPatternSourceBase$2", function (TSender, TEventArgs) { return {
        _source: null,
        _subscriptions: null,
        _invokeHandler: null,
        /**
         * Creates a new event pattern source.
         *
         * @instance
         * @protected
         * @this System.Reactive.EventPatternSourceBase$2
         * @memberof System.Reactive.EventPatternSourceBase$2
         * @throws <b /> or <b /> is null.
         * @param   {System.IObservable$1}    source           Source sequence to expose as an event.
         * @param   {System.Action}           invokeHandler    Delegate used to invoke the event for each element of the sequence.
         * @return  {void}
         */
        ctor: function (source, invokeHandler) {
            this.$initialize();
            if (source == null) {
                throw new System.ArgumentNullException("source");
            }
            if (Bridge.staticEquals(invokeHandler, null)) {
                throw new System.ArgumentNullException("invokeHandler");
            }

            this._source = source;
            this._invokeHandler = invokeHandler;
            this._subscriptions = new (System.Collections.Generic.Dictionary$2(Function,System.Collections.Generic.Stack$1(System.IDisposable)))();
        },
        /**
         * Adds the specified event handler, causing a subscription to the underlying source.
         *
         * @instance
         * @protected
         * @this System.Reactive.EventPatternSourceBase$2
         * @memberof System.Reactive.EventPatternSourceBase$2
         * @throws <b /> or <b /> is null.
         * @param   {Function}         handler    Event handler to add. The same delegate should be passed to the Remove operation in order to remove the event handler.
         * @param   {System.Action}    invoke     Invocation delegate to raise the event in the derived class.
         * @return  {void}
         */
        add: function (handler, invoke) {
            if (Bridge.staticEquals(handler, null)) {
                throw new System.ArgumentNullException("handler");
            }
            if (Bridge.staticEquals(invoke, null)) {
                throw new System.ArgumentNullException("invoke");
            }

            var gate = {  };
            var isAdded = false;
            var isDone = false;

            var remove = Bridge.fn.bind(this, function () {
                gate;
                {
                    if (isAdded) {
                        this.remove(handler);
                    } else {
                        isDone = true;
                    }
                }
            });

            //
            // [OK] Use of unsafe Subscribe: non-pretentious wrapper of an observable in an event; exceptions can occur during +=.
            //
            var d = System.ObservableExtensions.subscribe$4(System.Reactive.EventPattern$2(TSender,TEventArgs), this._source, Bridge.fn.bind(this, function (x) {
                this._invokeHandler(invoke, x);
            }), function (ex) {
                remove();
                System.Reactive.ExceptionHelpers.throw(ex);
            }, function () {
                remove();
            });

            gate;
            {
                if (!isDone) {
                    this.add$1(handler, d);
                    isAdded = true;
                }
            }
        },
        add$1: function (handler, disposable) {
            this._subscriptions;
            {
                var l = { v : new (System.Collections.Generic.Stack$1(System.IDisposable)).ctor() };
                if (!this._subscriptions.tryGetValue(handler, l)) {
                    this._subscriptions.set(handler, (l.v = new (System.Collections.Generic.Stack$1(System.IDisposable)).ctor()));
                }

                l.v.push(disposable);
            }
        },
        /**
         * Removes the specified event handler, causing a disposal of the corresponding subscription to the underlying source that was created during the Add operation.
         *
         * @instance
         * @protected
         * @this System.Reactive.EventPatternSourceBase$2
         * @memberof System.Reactive.EventPatternSourceBase$2
         * @throws <b /> is null.
         * @param   {Function}    handler    Event handler to remove. This should be the same delegate as one that was passed to the Add operation.
         * @return  {void}
         */
        remove: function (handler) {
            if (Bridge.staticEquals(handler, null)) {
                throw new System.ArgumentNullException("handler");
            }

            var d = null;

            this._subscriptions;
            {
                var l = { v : new (System.Collections.Generic.Stack$1(System.IDisposable)).ctor() };
                if (this._subscriptions.tryGetValue(handler, l)) {
                    d = l.v.pop();
                    if (l.v.getCount() === 0) {
                        this._subscriptions.remove(handler);
                    }
                }
            }

            if (d != null) {
                d.System$IDisposable$dispose();
            }
        }
    }; });

    /**
     * Represents a data stream signaling its elements by means of an event.
     *
     * @abstract
     * @public
     * @class System.Reactive.IEventSource$1
     * @param   {Function}    [name]    The type of the event data generated by the event.
     This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see Covariance and Contravariance in Generics.
     */
    Bridge.definei("System.Reactive.IEventSource$1", function (T) { return {
        $kind: "interface"
    }; });

    Bridge.define("System.Reactive.ExceptionHelpers", {
        statics: {
            s_services: null,
            config: {
                init: function () {
                    this.s_services = new (System.Lazy$1(System.Reactive.PlatformServices.IExceptionServices)).ctor(System.Reactive.ExceptionHelpers.initialize);
                }
            },
            throw: function (exception) {
                System.Reactive.ExceptionHelpers.s_services.getValue().System$Reactive$PlatformServices$IExceptionServices$rethrow(exception);
            },
            throwIfNotNull: function (exception) {
                if (exception != null) {
                    System.Reactive.ExceptionHelpers.s_services.getValue().System$Reactive$PlatformServices$IExceptionServices$rethrow(exception);
                }
            },
            initialize: function () { /// Type or member is obsolete


                return System.Reactive.PlatformServices.PlatformEnlightenmentProvider.getCurrent().System$Reactive$PlatformServices$IPlatformEnlightenmentProvider$getService(System.Reactive.PlatformServices.IExceptionServices) || new System.Reactive.PlatformServices.DefaultExceptionServices();
            }
        }
    });

    Bridge.define("System.Reactive.Helpers", {
        statics: {
            getLength: function (T, source) {
                var array = Bridge.as(source, Array);
                if (array != null) {
                    return array.length;
                }

                var list = Bridge.as(source, System.Collections.Generic.IList$1(T));
                if (list != null) {
                    return System.Array.getCount(list, T);
                }

                return null;
            },
            unpack: function (T, source) {
                var hasOpt = Bridge.getDefaultValue(Boolean);

                do {
                    hasOpt = false;

                    var $eval = Bridge.as(source, System.Reactive.IEvaluatableObservable$1(T));
                    if ($eval != null) {
                        source = $eval["System$Reactive$IEvaluatableObservable$1$" + Bridge.getTypeAlias(T) + "$eval"]();
                        hasOpt = true;
                    }
                } while (hasOpt);

                return source;
            }
        }
    });

    Bridge.definei("System.Reactive.IConcatenatable$1", function (TSource) { return {
        $kind: "interface"
    }; });

    Bridge.definei("System.Reactive.IEvaluatableObservable$1", function (T) { return {
        $kind: "interface"
    }; });

    /**
     * Represents a data stream signaling its elements by means of an event.
     *
     * @abstract
     * @public
     * @class System.Reactive.IEventPatternSource$1
     * @param   {Function}    [name]    The type of the event data generated by the event.
     */
    Bridge.definei("System.Reactive.IEventPatternSource$1", function (TEventArgs) { return {
        $kind: "interface"
    }; });

    Bridge.define("System.Reactive.ImmutableList$1", function (T) { return {
        statics: {
            empty: null,
            config: {
                init: function () {
                    this.empty = new (System.Reactive.ImmutableList$1(T)).ctor();
                }
            }
        },
        _data: null,
        ctor: function () {
            this.$initialize();
            this._data = System.Array.init(0, function (){
                return Bridge.getDefaultValue(T);
            });
        },
        $ctor1: function (data) {
            this.$initialize();
            this._data = data;
        },
        getData: function () {
            return this._data;
        },
        add: function (value) {
            var newData = System.Array.init(((this._data.length + 1) | 0), function (){
                return Bridge.getDefaultValue(T);
            });

            System.Array.copy(this._data, 0, newData, 0, this._data.length);
            newData[this._data.length] = value;

            return new (System.Reactive.ImmutableList$1(T)).$ctor1(newData);
        },
        remove: function (value) {
            var i = this.indexOf(value);
            if (i < 0) {
                return this;
            }

            var length = this._data.length;
            if (length === 1) {
                return System.Reactive.ImmutableList$1(T).empty;
            }

            var newData = System.Array.init(((length - 1) | 0), function (){
                return Bridge.getDefaultValue(T);
            });

            System.Array.copy(this._data, 0, newData, 0, i);
            System.Array.copy(this._data, ((i + 1) | 0), newData, i, ((((length - i) | 0) - 1) | 0));

            return new (System.Reactive.ImmutableList$1(T)).$ctor1(newData);
        },
        indexOf: function (value) {
            for (var i = 0; i < this._data.length; i = (i + 1) | 0) {
                if (Bridge.equals(this._data[i], value)) {
                    return i;
                }
            }

            return -1;
        }
    }; });

    /**
     * Provides a mechanism for receiving push-based notifications and returning a response.
     *
     * @abstract
     * @public
     * @class System.Reactive.IObserver$2
     * @param   {Function}    [name]    The type of the elements received by the observer.
     This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see Covariance and Contravariance in Generics.
     * @param   {Function}    [name]    The type of the result returned from the observer's notification handlers.
     This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see Covariance and Contravariance in Generics.
     */
    Bridge.definei("System.Reactive.IObserver$2", function (TValue, TResult) { return {
        $kind: "interface",
        $variance: [2,1]
    }; });

    Bridge.define("System.Reactive.Joins.ActivePlan", {
        joinObservers: null,
        config: {
            init: function () {
                this.joinObservers = new (System.Collections.Generic.Dictionary$2(System.Reactive.Joins.IJoinObserver,System.Reactive.Joins.IJoinObserver))();
            }
        },
        addJoinObserver: function (joinObserver) {
            this.joinObservers.add(joinObserver, joinObserver);
        },
        dequeue: function () {
            var $t;
            $t = Bridge.getEnumerator(this.joinObservers.getValues(), System.Reactive.Joins.IJoinObserver);
            while ($t.moveNext()) {
                var joinObserver = $t.getCurrent();
                joinObserver.System$Reactive$Joins$IJoinObserver$dequeue();
            }
        }
    });

    Bridge.define("System.Reactive.Joins.IJoinObserver", {
        inherits: [System.IDisposable],
        $kind: "interface"
    });

    /**
     * Represents a notification to an observer.
     *
     * @abstract
     * @public
     * @class System.Reactive.Notification$1
     * @implements  System.IEquatable$1
     * @param   {Function}    [name]    The type of the elements received by the observer.
     */
    Bridge.define("System.Reactive.Notification$1", function (T) { return {
        inherits: function () { return [System.IEquatable$1(System.Reactive.Notification$1(T))]; },
        statics: {
            /**
             * Determines whether the two specified Notification&lt;T&gt; objects have the same observer message payload.
             *
             * @static
             * @public
             * @this System.Reactive.Notification$1
             * @memberof System.Reactive.Notification$1
             * @param   {System.Reactive.Notification$1}    left     The first Notification&lt;T&gt; to compare, or null.
             * @param   {System.Reactive.Notification$1}    right    The second Notification&lt;T&gt; to compare, or null.
             * @return  {boolean}                                    true if the first Notification&lt;T&gt; value has the same observer message payload as the second Notification&lt;T&gt; value; otherwise, false.
             */
            op_Equality: function (left, right) {
                if (Bridge.referenceEquals(left, right)) {
                    return true;
                }

                if (left == null || right == null) {
                    return false;
                }

                return left.equalsT(right);
            }/**
             * Determines whether the two specified Notification&lt;T&gt; objects have a different observer message payload.
             *
             * @static
             * @public
             * @this System.Reactive.Notification$1
             * @memberof System.Reactive.Notification$1
             * @param   {System.Reactive.Notification$1}    left     The first Notification&lt;T&gt; to compare, or null.
             * @param   {System.Reactive.Notification$1}    right    The second Notification&lt;T&gt; to compare, or null.
             * @return  {boolean}                                    true if the first Notification&lt;T&gt; value has a different observer message payload as the second Notification&lt;T&gt; value; otherwise, false.
             */
            ,
            op_Inequality: function (left, right) {
                return !(System.Reactive.Notification$1(T).op_Equality(left, right));
            }
        },
        /**
         * Default constructor used by derived types.
         *
         * @instance
         * @this System.Reactive.Notification$1
         * @memberof System.Reactive.Notification$1
         * @return  {void}
         */
        ctor: function () {
            this.$initialize();
        },
        /**
         * Determines whether the specified System.Object is equal to the current Notification&lt;T&gt;.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1
         * @memberof System.Reactive.Notification$1
         * @param   {Object}     obj    The System.Object to compare with the current Notification&lt;T&gt;.
         * @return  {boolean}           true if the specified System.Object is equal to the current Notification&lt;T&gt;; otherwise, false.
         */
        equals: function (obj) {
            return this.equalsT(Bridge.as(obj, System.Reactive.Notification$1(T)));
        },
        /**
         * Returns an observable sequence with a single notification, using the immediate scheduler.
         *
         * @instance
         * @public
         * @this System.Reactive.Notification$1
         * @memberof System.Reactive.Notification$1
         * @return  {System.IObservable$1}        The observable sequence that surfaces the behavior of the notification upon subscription.
         */
        toObservable: function () {
            return this.toObservable$1(System.Reactive.Concurrency.ImmediateScheduler.getInstance());
        },
        /**
         * Returns an observable sequence with a single notification.
         *
         * @instance
         * @public
         * @this System.Reactive.Notification$1
         * @memberof System.Reactive.Notification$1
         * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to send out the notification calls on.
         * @return  {System.IObservable$1}                                   The observable sequence that surfaces the behavior of the notification upon subscription.
         */
        toObservable$1: function (scheduler) {
            if (scheduler == null) {
                throw new System.ArgumentNullException("scheduler");
            }

            return new (System.Reactive.AnonymousObservable$1(T))(Bridge.fn.bind(this, function (observer) {
                return System.Reactive.Concurrency.Scheduler.schedule(scheduler, Bridge.fn.bind(this, function () {
                    this.accept$3(observer);
                    if (this.getKind() === System.Reactive.NotificationKind.OnNext) {
                        observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
                    }
                }));
            }));
        }
    }; });

    /** @namespace System.Reactive.Joins */

    /**
     * The <b>System.Reactive.Joins</b> namespace contains classes used to express join patterns over observable sequences using fluent method syntax.
     *
     * @class System.Reactive.Joins.NamespaceDoc
     */
    Bridge.define("System.Reactive.Joins.NamespaceDoc");

    /**
     * Abstract base class for join patterns.
     *
     * @abstract
     * @public
     * @class System.Reactive.Joins.Pattern
     */
    Bridge.define("System.Reactive.Joins.Pattern", {
        ctor: function () {
            this.$initialize();
        }
    });

    /**
     * Represents an execution plan for join patterns.
     *
     * @abstract
     * @public
     * @class System.Reactive.Joins.Plan$1
     * @param   {Function}    [name]    The type of the results produced by the plan.
     */
    Bridge.define("System.Reactive.Joins.Plan$1", function (TResult) { return {
        statics: {
            createObserver: function (TSource, externalSubscriptions, observable, onError) {
                var observer = null;
                var nonGeneric = { v : null };
                if (!externalSubscriptions.tryGetValue(observable, nonGeneric)) {
                    observer = new (System.Reactive.Joins.JoinObserver$1(TSource))(observable, onError);
                    externalSubscriptions.add(observable, observer);
                } else {
                    observer = Bridge.cast(nonGeneric.v, System.Reactive.Joins.JoinObserver$1(TSource));
                }
                return observer;
            }
        },
        ctor: function () {
            this.$initialize();
        }
    }; });

    Bridge.define("System.Reactive.Linq.IQueryServices", {
        $kind: "interface"
    });

    /** @namespace System.Reactive.Linq */

    /**
     * Provides functionality to evaluate queries against a specific data source wherein the type of the data is not specified.
     *
     * @abstract
     * @public
     * @class System.Reactive.Linq.IQbservable
     */
    Bridge.define("System.Reactive.Linq.IQbservable", {
        $kind: "interface"
    });

    /**
     * Defines methods to create and execute queries that are described by an IQbservable object.
     *
     * @abstract
     * @public
     * @class System.Reactive.Linq.IQbservableProvider
     */
    Bridge.define("System.Reactive.Linq.IQbservableProvider", {
        $kind: "interface"
    });

    /**
     * Internal interface describing the LINQ to Events query language.
     *
     * @abstract
     * @class System.Reactive.Linq.IQueryLanguage
     */
    Bridge.define("System.Reactive.Linq.IQueryLanguage", {
        $kind: "interface"
    });

    /**
     * Attribute applied to static classes providing expression tree forms of query methods,
     mapping those to the corresponding methods for local query execution on the specified
     target class type.
     *
     * @public
     * @class System.Reactive.Linq.LocalQueryMethodImplementationTypeAttribute
     * @augments System.Attribute
     */
    Bridge.define("System.Reactive.Linq.LocalQueryMethodImplementationTypeAttribute", {
        inherits: [System.Attribute],
        _targetType: null,
        /**
         * Creates a new mapping to the specified local execution query method implementation type.
         *
         * @instance
         * @public
         * @this System.Reactive.Linq.LocalQueryMethodImplementationTypeAttribute
         * @memberof System.Reactive.Linq.LocalQueryMethodImplementationTypeAttribute
         * @param   {Function}    targetType    Type with query methods for local execution.
         * @return  {void}
         */
        ctor: function (targetType) {
            this.$initialize();
            System.Attribute.ctor.call(this);
            this._targetType = targetType;
        },
        /**
         * Gets the type with the implementation of local query methods.
         *
         * @instance
         * @public
         * @this System.Reactive.Linq.LocalQueryMethodImplementationTypeAttribute
         * @memberof System.Reactive.Linq.LocalQueryMethodImplementationTypeAttribute
         * @function getTargetType
         * @return  {Function}
         */
        /**
         * Gets the type with the implementation of local query methods.
         *
         * @instance
         * @function setTargetType
         */
        getTargetType: function () {
            return this._targetType;
        }
    });

    /**
     * The <b>System.Reactive.Linq</b> namespace contains interfaces and classes that support expressing queries over observable sequences, using Language Integrated Query (LINQ).
     Query operators are made available as extension methods for IObservable&lt;T&gt; and IQbservable&lt;T&gt; defined on the Observable and Qbservable classes, respectively.
     *
     * @class System.Reactive.Linq.NamespaceDoc
     */
    Bridge.define("System.Reactive.Linq.NamespaceDoc");

    Bridge.define("System.Reactive.Linq.Observable", {
        statics: {
            s_impl: null,
            config: {
                init: function () {
                    this.s_impl = System.Reactive.Linq.QueryServices.getQueryImpl(System.Reactive.Linq.IQueryLanguage, new System.Reactive.Linq.QueryLanguage());
                }
            },
            /**
             * Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.
             For aggregation behavior with incremental intermediate results, see {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource        The type of the elements in the source sequence.
             * @param   {Function}                TAccumulate    The type of the result of the aggregation.
             * @param   {System.IObservable$1}    source         An observable sequence to aggregate over.
             * @param   {TAccumulate}             seed           The initial accumulator value.
             * @param   {System.Func}             accumulator    An accumulator function to be invoked on each element.
             * @return  {System.IObservable$1}                   An observable sequence containing a single element with the final accumulator value.
             */
            aggregate$1: function (TSource, TAccumulate, source, seed, accumulator) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(accumulator, null)) {
                    throw new System.ArgumentNullException("accumulator");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$aggregate$1(TSource, TAccumulate, source, seed, accumulator);
            },
            /**
             * Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value,
             and the specified result selector function is used to select the result value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource           The type of the elements in the source sequence.
             * @param   {Function}                TAccumulate       The type of the accumulator value.
             * @param   {Function}                TResult           The type of the resulting value.
             * @param   {System.IObservable$1}    source            An observable sequence to aggregate over.
             * @param   {TAccumulate}             seed              The initial accumulator value.
             * @param   {System.Func}             accumulator       An accumulator function to be invoked on each element.
             * @param   {System.Func}             resultSelector    A function to transform the final accumulator value into the result value.
             * @return  {System.IObservable$1}                      An observable sequence containing a single element with the final accumulator value.
             */
            aggregate$2: function (TSource, TAccumulate, TResult, source, seed, accumulator, resultSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(accumulator, null)) {
                    throw new System.ArgumentNullException("accumulator");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$aggregate$2(TSource, TAccumulate, TResult, source, seed, accumulator, resultSelector);
            },
            /**
             * Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence.
             For aggregation behavior with incremental intermediate results, see {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @param   {Function}                TSource        The type of the elements in the source sequence and the result of the aggregation.
             * @param   {System.IObservable$1}    source         An observable sequence to aggregate over.
             * @param   {System.Func}             accumulator    An accumulator function to be invoked on each element.
             * @return  {System.IObservable$1}                   An observable sequence containing a single element with the final accumulator value.
             */
            aggregate: function (TSource, source, accumulator) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(accumulator, null)) {
                    throw new System.ArgumentNullException("accumulator");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$aggregate(TSource, source, accumulator);
            },
            /**
             * Determines whether all elements of an observable sequence satisfy a condition.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       An observable sequence whose elements to apply the predicate to.
             * @param   {System.Func}             predicate    A function to test each element for a condition.
             * @return  {System.IObservable$1}                 An observable sequence containing a single element determining whether all elements in the source sequence pass the test in the specified predicate.
             */
            all: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$all(TSource, source, predicate);
            },
            /**
             * Determines whether an observable sequence contains any elements.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     An observable sequence to check for non-emptiness.
             * @return  {System.IObservable$1}               An observable sequence containing a single element determining whether the source sequence contains any elements.
             */
            any: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$any(TSource, source);
            },
            /**
             * Determines whether any element of an observable sequence satisfies a condition.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       An observable sequence whose elements to apply the predicate to.
             * @param   {System.Func}             predicate    A function to test each element for a condition.
             * @return  {System.IObservable$1}                 An observable sequence containing a single element determining whether any elements in the source sequence pass the test in the specified predicate.
             */
            any$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$any$1(TSource, source, predicate);
            },
            /**
             * Computes the average of an observable sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to calculate the average of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the average of the sequence of values.
             */
            average$2: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$2(source);
            },
            /**
             * Computes the average of an observable sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to calculate the average of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the average of the sequence of values.
             */
            average$18: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$18(source);
            },
            /**
             * Computes the average of an observable sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @throws (Asynchronous) The sum of the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to calculate the average of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the average of the sequence of values.
             */
            average: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average(source);
            },
            /**
             * Computes the average of an observable sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @throws (Asynchronous) The sum of the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to calculate the average of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the average of the sequence of values.
             */
            average$3: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$3(source);
            },
            /**
             * Computes the average of an observable sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @throws (Asynchronous) The sum of the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to calculate the average of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the average of the sequence of values.
             */
            average$4: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$4(source);
            },
            /**
             * Computes the average of an observable sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to calculate the average of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the average of the sequence of values, or null if the source sequence is empty or contains only values that are null.
             */
            average$10: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$10(source);
            },
            /**
             * Computes the average of an observable sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to calculate the average of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the average of the sequence of values, or null if the source sequence is empty or contains only values that are null.
             */
            average$16: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$16(source);
            },
            /**
             * Computes the average of an observable sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @throws (Asynchronous) The sum of the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to calculate the average of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the average of the sequence of values, or null if the source sequence is empty or contains only values that are null.
             */
            average$8: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$8(source);
            },
            /**
             * Computes the average of an observable sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @throws (Asynchronous) The sum of the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to calculate the average of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the average of the sequence of values, or null if the source sequence is empty or contains only values that are null.
             */
            average$11: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$11(source);
            },
            /**
             * Computes the average of an observable sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @throws (Asynchronous) The sum of the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to calculate the average of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the average of the sequence of values, or null if the source sequence is empty or contains only values that are null.
             */
            average$12: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$12(source);
            },
            /**
             * Computes the average of an observable sequence of {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @throws (Asynchronous) The sum of the projected values for the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to calculate the average of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the average of the sequence of values.
             */
            average$1: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$1(TSource, source, selector);
            },
            /**
             * Computes the average of an observable sequence of {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to calculate the average of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the average of the sequence of values.
             */
            average$5: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$5(TSource, source, selector);
            },
            /**
             * Computes the average of an observable sequence of {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to calculate the average of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the average of the sequence of values.
             */
            average$19: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$19(TSource, source, selector);
            },
            /**
             * Computes the average of an observable sequence of {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @throws (Asynchronous) The sum of the projected values for the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to calculate the average of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the average of the sequence of values.
             */
            average$6: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$6(TSource, source, selector);
            },
            /**
             * Computes the average of an observable sequence of {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @throws (Asynchronous) The sum of the projected values for the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to calculate the average of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the average of the sequence of values.
             */
            average$7: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$7(TSource, source, selector);
            },
            /**
             * Computes the average of an observable sequence of nullable {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @throws (Asynchronous) The sum of the projected values for the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to calculate the average of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the average of the sequence of values, or null if the source sequence is empty or contains only values that are null.
             */
            average$9: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$9(TSource, source, selector);
            },
            /**
             * Computes the average of an observable sequence of nullable {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to calculate the average of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the average of the sequence of values, or null if the source sequence is empty or contains only values that are null.
             */
            average$13: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$13(TSource, source, selector);
            },
            /**
             * Computes the average of an observable sequence of nullable {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to calculate the average of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the average of the sequence of values, or null if the source sequence is empty or contains only values that are null.
             */
            average$17: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$17(TSource, source, selector);
            },
            /**
             * Computes the average of an observable sequence of nullable {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @throws (Asynchronous) The sum of the projected values for the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to calculate the average of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the average of the sequence of values, or null if the source sequence is empty or contains only values that are null.
             */
            average$14: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$14(TSource, source, selector);
            },
            /**
             * Computes the average of an observable sequence of nullable {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @throws (Asynchronous) The sum of the projected values for the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to calculate the average of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the average of the sequence of values, or null if the source sequence is empty or contains only values that are null.
             */
            average$15: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$average$15(TSource, source, selector);
            },
            /**
             * Determines whether an observable sequence contains a specified element by using the default equality comparer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     An observable sequence in which to locate a value.
             * @param   {TSource}                 value      The value to locate in the source sequence.
             * @return  {System.IObservable$1}               An observable sequence containing a single element determining whether the source sequence contains an element that has the specified value.
             */
            contains: function (TSource, source, value) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$contains(TSource, source, value);
            },
            /**
             * Determines whether an observable sequence contains a specified element by using a specified System.Collections.Generic.IEqualityComparer&lt;T&gt;.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                          TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                              source      An observable sequence in which to locate a value.
             * @param   {TSource}                                           value       The value to locate in the source sequence.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer    An equality comparer to compare elements.
             * @return  {System.IObservable$1}                                          An observable sequence containing a single element determining whether the source sequence contains an element that has the specified value.
             */
            contains$1: function (TSource, source, value, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$contains$1(TSource, source, value, comparer);
            },
            /**
             * Returns an observable sequence containing an {@link } that represents the total number of elements in an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The number of elements in the source sequence is larger than {@link OverflowException}.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     An observable sequence that contains elements to be counted.
             * @return  {System.IObservable$1}               An observable sequence containing a single element with the number of elements in the input sequence.
             */
            count: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$count(TSource, source);
            },
            /**
             * Returns an observable sequence containing an {@link } that represents how many elements in the specified observable sequence satisfy a condition.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       An observable sequence that contains elements to be counted.
             * @param   {System.Func}             predicate    A function to test each element for a condition.
             * @return  {System.IObservable$1}                 An observable sequence containing a single element with a number that represents how many elements in the input sequence satisfy the condition in the predicate function.
             */
            count$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$count$1(TSource, source, predicate);
            },
            /**
             * Returns the element at a specified index in a sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than zero.
             * @throws (Asynchronous) <b /> is greater than or equal to the number of elements in the source sequence.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Observable sequence to return the element from.
             * @param   {number}                  index      The zero-based index of the element to retrieve.
             * @return  {System.IObservable$1}               An observable sequence that produces the element at the specified position in the source sequence.
             */
            elementAt: function (TSource, source, index) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException("index");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$elementAt(TSource, source, index);
            },
            /**
             * Returns the element at a specified index in a sequence or a default value if the index is out of range.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than zero.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Observable sequence to return the element from.
             * @param   {number}                  index      The zero-based index of the element to retrieve.
             * @return  {System.IObservable$1}               An observable sequence that produces the element at the specified position in the source sequence, or a default value if the index is outside the bounds of the source sequence.
             */
            elementAtOrDefault: function (TSource, source, index) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException("index");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$elementAtOrDefault(TSource, source, index);
            },
            /**
             * Returns the first element of an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source observable sequence.
             * @return  {System.IObservable$1}               Sequence containing the first element in the observable sequence.
             */
            firstAsync: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$firstAsync(TSource, source);
            },
            /**
             * Returns the first element of an observable sequence that satisfies the condition in the predicate.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) No element satisfies the condition in the predicate. -or- The source sequence is empty.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       Source observable sequence.
             * @param   {System.Func}             predicate    A predicate function to evaluate for elements in the source sequence.
             * @return  {System.IObservable$1}                 Sequence containing the first element in the observable sequence that satisfies the condition in the predicate.
             */
            firstAsync$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$firstAsync$1(TSource, source, predicate);
            },
            /**
             * Returns the first element of an observable sequence, or a default value if no such element exists.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source observable sequence.
             * @return  {System.IObservable$1}               Sequence containing the first element in the observable sequence, or a default value if no such element exists.
             */
            firstOrDefaultAsync: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$firstOrDefaultAsync(TSource, source);
            },
            /**
             * Returns the first element of an observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       Source observable sequence.
             * @param   {System.Func}             predicate    A predicate function to evaluate for elements in the source sequence.
             * @return  {System.IObservable$1}                 Sequence containing the first element in the observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
             */
            firstOrDefaultAsync$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$firstOrDefaultAsync$1(TSource, source, predicate);
            },
            /**
             * Determines whether an observable sequence is empty.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     An observable sequence to check for emptiness.
             * @return  {System.IObservable$1}               An observable sequence containing a single element determining whether the source sequence is empty.
             */
            isEmpty: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$isEmpty(TSource, source);
            },
            /**
             * Returns the last element of an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The source sequence is empty.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source observable sequence.
             * @return  {System.IObservable$1}               Sequence containing the last element in the observable sequence.
             */
            lastAsync: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$lastAsync(TSource, source);
            },
            /**
             * Returns the last element of an observable sequence that satisfies the condition in the predicate.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) No element satisfies the condition in the predicate. -or- The source sequence is empty.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       Source observable sequence.
             * @param   {System.Func}             predicate    A predicate function to evaluate for elements in the source sequence.
             * @return  {System.IObservable$1}                 Sequence containing the last element in the observable sequence that satisfies the condition in the predicate.
             */
            lastAsync$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$lastAsync$1(TSource, source, predicate);
            },
            /**
             * Returns the last element of an observable sequence, or a default value if no such element exists.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source observable sequence.
             * @return  {System.IObservable$1}               Sequence containing the last element in the observable sequence, or a default value if no such element exists.
             */
            lastOrDefaultAsync: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$lastOrDefaultAsync(TSource, source);
            },
            /**
             * Returns the last element of an observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       Source observable sequence.
             * @param   {System.Func}             predicate    A predicate function to evaluate for elements in the source sequence.
             * @return  {System.IObservable$1}                 Sequence containing the last element in the observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
             */
            lastOrDefaultAsync$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$lastOrDefaultAsync$1(TSource, source, predicate);
            },
            /**
             * Returns an observable sequence containing an {@link } that represents the total number of elements in an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The number of elements in the source sequence is larger than {@link OverflowException}.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     An observable sequence that contains elements to be counted.
             * @return  {System.IObservable$1}               An observable sequence containing a single element with the number of elements in the input sequence.
             */
            longCount: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$longCount(TSource, source);
            },
            /**
             * Returns an observable sequence containing an {@link } that represents how many elements in the specified observable sequence satisfy a condition.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       An observable sequence that contains elements to be counted.
             * @param   {System.Func}             predicate    A function to test each element for a condition.
             * @return  {System.IObservable$1}                 An observable sequence containing a single element with a number that represents how many elements in the input sequence satisfy the condition in the predicate function.
             */
            longCount$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$longCount$1(TSource, source, predicate);
            },
            /**
             * Returns the maximum element in an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     An observable sequence to determine the maximum element of.
             * @return  {System.IObservable$1}               An observable sequence containing a single element with the maximum element in the source sequence.
             */
            max: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max(TSource, source);
            },
            /**
             * Returns the maximum value in an observable sequence according to the specified comparer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source      An observable sequence to determine the maximum element of.
             * @param   {System.Collections.Generic.IComparer$1}    comparer    Comparer used to compare elements.
             * @return  {System.IObservable$1}                                  An observable sequence containing a single element with the maximum element in the source sequence.
             */
            max$1: function (TSource, source, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$1(TSource, source, comparer);
            },
            /**
             * Returns the maximum value in an observable sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to determine the maximum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the maximum value in the source sequence.
             */
            max$6: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$6(source);
            },
            /**
             * Returns the maximum value in an observable sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to determine the maximum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the maximum value in the source sequence.
             */
            max$22: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$22(source);
            },
            /**
             * Returns the maximum value in an observable sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to determine the maximum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the maximum value in the source sequence.
             */
            max$4: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$4(source);
            },
            /**
             * Returns the maximum value in an observable sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to determine the maximum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the maximum value in the source sequence.
             */
            max$8: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$8(source);
            },
            /**
             * Returns the maximum value in an observable sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to determine the maximum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the maximum value in the source sequence.
             */
            max$10: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$10(source);
            },
            /**
             * Returns the maximum value in an observable sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to determine the maximum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the maximum value in the source sequence.
             */
            max$14: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$14(source);
            },
            /**
             * Returns the maximum value in an observable sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to determine the maximum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the maximum value in the source sequence.
             */
            max$20: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$20(source);
            },
            /**
             * Returns the maximum value in an observable sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to determine the maximum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the maximum value in the source sequence.
             */
            max$12: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$12(source);
            },
            /**
             * Returns the maximum value in an observable sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to determine the maximum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the maximum value in the source sequence.
             */
            max$16: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$16(source);
            },
            /**
             * Returns the maximum value in an observable sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to determine the maximum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the maximum value in the source sequence.
             */
            max$18: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$18(source);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the maximum value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {Function}                TResult     The type of the objects derived from the elements in the source sequence to determine the maximum of.
             * @param   {System.IObservable$1}    source      An observable sequence to determine the mimimum element of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value that corresponds to the maximum element in the source sequence.
             */
            max$2: function (TSource, TResult, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$2(TSource, TResult, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the maximum value according to the specified comparer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TSource     The type of the elements in the source sequence.
             * @param   {Function}                                  TResult     The type of the objects derived from the elements in the source sequence to determine the maximum of.
             * @param   {System.IObservable$1}                      source      An observable sequence to determine the mimimum element of.
             * @param   {System.Func}                               selector    A transform function to apply to each element.
             * @param   {System.Collections.Generic.IComparer$1}    comparer    Comparer used to compare elements.
             * @return  {System.IObservable$1}                                  An observable sequence containing a single element with the value that corresponds to the maximum element in the source sequence.
             */
            max$3: function (TSource, TResult, source, selector, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$3(TSource, TResult, source, selector, comparer);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the maximum {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the maximum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the maximum value in the source sequence.
             */
            max$7: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$7(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the maximum {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the maximum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the maximum value in the source sequence.
             */
            max$23: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$23(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the maximum {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the maximum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the maximum value in the source sequence.
             */
            max$5: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$5(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the maximum {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the maximum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the maximum value in the source sequence.
             */
            max$9: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$9(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the maximum {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the maximum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the maximum value in the source sequence.
             */
            max$11: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$11(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the maximum nullable {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the maximum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the maximum value in the source sequence.
             */
            max$15: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$15(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the maximum nullable {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the maximum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the maximum value in the source sequence.
             */
            max$21: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$21(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the maximum nullable {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the maximum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the maximum value in the source sequence.
             */
            max$13: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$13(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the maximum nullable {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the maximum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the maximum value in the source sequence.
             */
            max$17: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$17(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the maximum nullable {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the maximum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the maximum value in the source sequence.
             */
            max$19: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$max$19(TSource, source, selector);
            },
            /**
             * Returns the elements in an observable sequence with the maximum key value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource        The type of the elements in the source sequence.
             * @param   {Function}                TKey           The type of the key computed for each element in the source sequence.
             * @param   {System.IObservable$1}    source         An observable sequence to get the maximum elements for.
             * @param   {System.Func}             keySelector    Key selector function.
             * @return  {System.IObservable$1}                   An observable sequence containing a list of zero or more elements that have a maximum key value.
             */
            maxBy: function (TSource, TKey, source, keySelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$maxBy(TSource, TKey, source, keySelector);
            },
            /**
             * Returns the elements in an observable sequence with the maximum key value according to the specified comparer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TSource        The type of the elements in the source sequence.
             * @param   {Function}                                  TKey           The type of the key computed for each element in the source sequence.
             * @param   {System.IObservable$1}                      source         An observable sequence to get the maximum elements for.
             * @param   {System.Func}                               keySelector    Key selector function.
             * @param   {System.Collections.Generic.IComparer$1}    comparer       Comparer used to compare key values.
             * @return  {System.IObservable$1}                                     An observable sequence containing a list of zero or more elements that have a maximum key value.
             */
            maxBy$1: function (TSource, TKey, source, keySelector, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$maxBy$1(TSource, TKey, source, keySelector, comparer);
            },
            /**
             * Returns the minimum element in an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     An observable sequence to determine the mimimum element of.
             * @return  {System.IObservable$1}               An observable sequence containing a single element with the minimum element in the source sequence.
             */
            min: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min(TSource, source);
            },
            /**
             * Returns the minimum element in an observable sequence according to the specified comparer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source      An observable sequence to determine the mimimum element of.
             * @param   {System.Collections.Generic.IComparer$1}    comparer    Comparer used to compare elements.
             * @return  {System.IObservable$1}                                  An observable sequence containing a single element with the minimum element in the source sequence.
             */
            min$1: function (TSource, source, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$1(TSource, source, comparer);
            },
            /**
             * Returns the minimum value in an observable sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to determine the minimum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the minimum value in the source sequence.
             */
            min$6: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$6(source);
            },
            /**
             * Returns the minimum value in an observable sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to determine the minimum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the minimum value in the source sequence.
             */
            min$22: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$22(source);
            },
            /**
             * Returns the minimum value in an observable sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to determine the minimum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the minimum value in the source sequence.
             */
            min$4: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$4(source);
            },
            /**
             * Returns the minimum value in an observable sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to determine the minimum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the minimum value in the source sequence.
             */
            min$8: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$8(source);
            },
            /**
             * Returns the minimum value in an observable sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to determine the minimum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the minimum value in the source sequence.
             */
            min$10: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$10(source);
            },
            /**
             * Returns the minimum value in an observable sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to determine the minimum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the minimum value in the source sequence.
             */
            min$14: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$14(source);
            },
            /**
             * Returns the minimum value in an observable sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to determine the minimum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the minimum value in the source sequence.
             */
            min$20: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$20(source);
            },
            /**
             * Returns the minimum value in an observable sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to determine the minimum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the minimum value in the source sequence.
             */
            min$12: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$12(source);
            },
            /**
             * Returns the minimum value in an observable sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to determine the minimum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the minimum value in the source sequence.
             */
            min$16: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$16(source);
            },
            /**
             * Returns the minimum value in an observable sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to determine the minimum value of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the minimum value in the source sequence.
             */
            min$18: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$18(source);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the minimum value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {Function}                TResult     The type of the objects derived from the elements in the source sequence to determine the minimum of.
             * @param   {System.IObservable$1}    source      An observable sequence to determine the mimimum element of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value that corresponds to the minimum element in the source sequence.
             */
            min$2: function (TSource, TResult, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$2(TSource, TResult, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the minimum value according to the specified comparer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TSource     The type of the elements in the source sequence.
             * @param   {Function}                                  TResult     The type of the objects derived from the elements in the source sequence to determine the minimum of.
             * @param   {System.IObservable$1}                      source      An observable sequence to determine the mimimum element of.
             * @param   {System.Func}                               selector    A transform function to apply to each element.
             * @param   {System.Collections.Generic.IComparer$1}    comparer    Comparer used to compare elements.
             * @return  {System.IObservable$1}                                  An observable sequence containing a single element with the value that corresponds to the minimum element in the source sequence.
             */
            min$3: function (TSource, TResult, source, selector, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$3(TSource, TResult, source, selector, comparer);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the minimum {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the minimum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the minimum value in the source sequence.
             */
            min$7: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$7(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the minimum {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the minimum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the minimum value in the source sequence.
             */
            min$23: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$23(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the minimum {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the minimum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the minimum value in the source sequence.
             */
            min$5: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$5(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the minimum {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the minimum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the minimum value in the source sequence.
             */
            min$9: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$9(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the minimum {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the minimum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the minimum value in the source sequence.
             */
            min$11: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$11(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the minimum nullable {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the minimum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the minimum value in the source sequence.
             */
            min$15: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$15(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the minimum nullable {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the minimum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the minimum value in the source sequence.
             */
            min$21: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$21(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the minimum nullable {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the minimum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the minimum value in the source sequence.
             */
            min$13: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$13(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the minimum nullable {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the minimum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the minimum value in the source sequence.
             */
            min$17: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$17(TSource, source, selector);
            },
            /**
             * Invokes a transform function on each element of a sequence and returns the minimum nullable {@link } value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values to determine the minimum value of.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the value of type {@link } that corresponds to the minimum value in the source sequence.
             */
            min$19: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$min$19(TSource, source, selector);
            },
            /**
             * Returns the elements in an observable sequence with the minimum key value.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource        The type of the elements in the source sequence.
             * @param   {Function}                TKey           The type of the key computed for each element in the source sequence.
             * @param   {System.IObservable$1}    source         An observable sequence to get the minimum elements for.
             * @param   {System.Func}             keySelector    Key selector function.
             * @return  {System.IObservable$1}                   An observable sequence containing a list of zero or more elements that have a minimum key value.
             */
            minBy: function (TSource, TKey, source, keySelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$minBy(TSource, TKey, source, keySelector);
            },
            /**
             * Returns the elements in an observable sequence with the minimum key value according to the specified comparer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TSource        The type of the elements in the source sequence.
             * @param   {Function}                                  TKey           The type of the key computed for each element in the source sequence.
             * @param   {System.IObservable$1}                      source         An observable sequence to get the minimum elements for.
             * @param   {System.Func}                               keySelector    Key selector function.
             * @param   {System.Collections.Generic.IComparer$1}    comparer       Comparer used to compare key values.
             * @return  {System.IObservable$1}                                     An observable sequence containing a list of zero or more elements that have a minimum key value.
             */
            minBy$1: function (TSource, TKey, source, keySelector, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$minBy$1(TSource, TKey, source, keySelector, comparer);
            },
            /**
             * Determines whether two sequences are equal by comparing the elements pairwise.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    first      First observable sequence to compare.
             * @param   {System.IObservable$1}    second     Second observable sequence to compare.
             * @return  {System.IObservable$1}               An observable sequence that contains a single element which indicates whether both sequences are of equal length and their corresponding elements are equal according to the default equality comparer for their type.
             */
            sequenceEqual$2: function (TSource, first, second) {
                if (first == null) {
                    throw new System.ArgumentNullException("first");
                }
                if (second == null) {
                    throw new System.ArgumentNullException("second");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sequenceEqual$2(TSource, first, second);
            },
            /**
             * Determines whether two sequences are equal by comparing the elements pairwise using a specified equality comparer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                          TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                              first       First observable sequence to compare.
             * @param   {System.IObservable$1}                              second      Second observable sequence to compare.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer    Comparer used to compare elements of both sequences.
             * @return  {System.IObservable$1}                                          An observable sequence that contains a single element which indicates whether both sequences are of equal length and their corresponding elements are equal according to the specified equality comparer.
             */
            sequenceEqual$3: function (TSource, first, second, comparer) {
                if (first == null) {
                    throw new System.ArgumentNullException("first");
                }
                if (second == null) {
                    throw new System.ArgumentNullException("second");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sequenceEqual$3(TSource, first, second, comparer);
            },
            /**
             * Determines whether an observable and enumerable sequence are equal by comparing the elements pairwise.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                    TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                        first      First observable sequence to compare.
             * @param   {System.Collections.Generic.IEnumerable$1}    second     Second observable sequence to compare.
             * @return  {System.IObservable$1}                                   An observable sequence that contains a single element which indicates whether both sequences are of equal length and their corresponding elements are equal according to the default equality comparer for their type.
             */
            sequenceEqual: function (TSource, first, second) {
                if (first == null) {
                    throw new System.ArgumentNullException("first");
                }
                if (second == null) {
                    throw new System.ArgumentNullException("second");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sequenceEqual(TSource, first, second);
            },
            /**
             * Determines whether an observable and enumerable sequence are equal by comparing the elements pairwise using a specified equality comparer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                          TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                              first       First observable sequence to compare.
             * @param   {System.Collections.Generic.IEnumerable$1}          second      Second observable sequence to compare.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer    Comparer used to compare elements of both sequences.
             * @return  {System.IObservable$1}                                          An observable sequence that contains a single element which indicates whether both sequences are of equal length and their corresponding elements are equal according to the specified equality comparer.
             */
            sequenceEqual$1: function (TSource, first, second, comparer) {
                if (first == null) {
                    throw new System.ArgumentNullException("first");
                }
                if (second == null) {
                    throw new System.ArgumentNullException("second");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sequenceEqual$1(TSource, first, second, comparer);
            },
            /**
             * Returns the only element of an observable sequence, and reports an exception if there is not exactly one element in the observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The source sequence contains more than one element. -or- The source sequence is empty.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source observable sequence.
             * @return  {System.IObservable$1}               Sequence containing the single element in the observable sequence.
             */
            singleAsync: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$singleAsync(TSource, source);
            },
            /**
             * Returns the only element of an observable sequence that satisfies the condition in the predicate, and reports an exception if there is not exactly one element in the observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) No element satisfies the condition in the predicate. -or- More than one element satisfies the condition in the predicate. -or- The source sequence is empty.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       Source observable sequence.
             * @param   {System.Func}             predicate    A predicate function to evaluate for elements in the source sequence.
             * @return  {System.IObservable$1}                 Sequence containing the single element in the observable sequence that satisfies the condition in the predicate.
             */
            singleAsync$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$singleAsync$1(TSource, source, predicate);
            },
            /**
             * Returns the only element of an observable sequence, or a default value if the observable sequence is empty; this method reports an exception if there is more than one element in the observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The source sequence contains more than one element.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source observable sequence.
             * @return  {System.IObservable$1}               Sequence containing the single element in the observable sequence, or a default value if no such element exists.
             */
            singleOrDefaultAsync: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$singleOrDefaultAsync(TSource, source);
            },
            /**
             * Returns the only element of an observable sequence that matches the predicate, or a default value if no such element exists; this method reports an exception if there is more than one element in the observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The sequence contains more than one element that satisfies the condition in the predicate.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       Source observable sequence.
             * @param   {System.Func}             predicate    A predicate function to evaluate for elements in the source sequence.
             * @return  {System.IObservable$1}                 Sequence containing the single element in the observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
             */
            singleOrDefaultAsync$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$singleOrDefaultAsync$1(TSource, source, predicate);
            },
            /**
             * Computes the sum of a sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to calculate the sum of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$2: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$2(source);
            },
            /**
             * Computes the sum of a sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to calculate the sum of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$18: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$18(source);
            },
            /**
             * Computes the sum of a sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The sum of the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to calculate the sum of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum(source);
            },
            /**
             * Computes the sum of a sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The sum of the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to calculate the sum of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$4: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$4(source);
            },
            /**
             * Computes the sum of a sequence of {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The sum of the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {System.IObservable$1}    source    A sequence of {@link } values to calculate the sum of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$6: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$6(source);
            },
            /**
             * Computes the sum of a sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to calculate the sum of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$10: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$10(source);
            },
            /**
             * Computes the sum of a sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to calculate the sum of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$16: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$16(source);
            },
            /**
             * Computes the sum of a sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The sum of the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to calculate the sum of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$8: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$8(source);
            },
            /**
             * Computes the sum of a sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The sum of the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to calculate the sum of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$12: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$12(source);
            },
            /**
             * Computes the sum of a sequence of nullable {@link } values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) The sum of the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {System.IObservable$1}    source    A sequence of nullable {@link } values to calculate the sum of.
             * @return  {System.IObservable$1}              An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$14: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$14(source);
            },
            /**
             * Computes the sum of a sequence of {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values that are used to calculate a sum.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$3: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$3(TSource, source, selector);
            },
            /**
             * Computes the sum of a sequence of {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values that are used to calculate a sum.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$19: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$19(TSource, source, selector);
            },
            /**
             * Computes the sum of a sequence of {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The sum of the projected values for the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values that are used to calculate a sum.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$1: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$1(TSource, source, selector);
            },
            /**
             * Computes the sum of a sequence of {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The sum of the projected values for the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values that are used to calculate a sum.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$5: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$5(TSource, source, selector);
            },
            /**
             * Computes the sum of a sequence of {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The sum of the projected values for the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values that are used to calculate a sum.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$7: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$7(TSource, source, selector);
            },
            /**
             * Computes the sum of a sequence of nullable {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values that are used to calculate a sum.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$11: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$11(TSource, source, selector);
            },
            /**
             * Computes the sum of a sequence of nullable {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values that are used to calculate a sum.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$17: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$17(TSource, source, selector);
            },
            /**
             * Computes the sum of a sequence of nullable {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The sum of the projected values for the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values that are used to calculate a sum.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$9: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$9(TSource, source, selector);
            },
            /**
             * Computes the sum of a sequence of nullable {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The sum of the projected values for the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values that are used to calculate a sum.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$13: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$13(TSource, source, selector);
            },
            /**
             * Computes the sum of a sequence of nullable {@link } values that are obtained by invoking a transform function on each element of the input sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) The sum of the projected values for the elements in the source sequence is larger than {@link OverflowException}.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of values that are used to calculate a sum.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence containing a single element with the sum of the values in the source sequence.
             */
            sum$15: function (TSource, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sum$15(TSource, source, selector);
            },
            /**
             * Creates an array from an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     The source observable sequence to get an array of elements for.
             * @return  {System.IObservable$1}               An observable sequence containing a single element with an array containing all the elements of the source sequence.
             */
            toArray: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$toArray(TSource, source);
            },
            /**
             * Creates a dictionary from an observable sequence according to a specified key selector function.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource        The type of the elements in the source sequence.
             * @param   {Function}                TKey           The type of the dictionary key computed for each element in the source sequence.
             * @param   {System.IObservable$1}    source         An observable sequence to create a dictionary for.
             * @param   {System.Func}             keySelector    A function to extract a key from each element.
             * @return  {System.IObservable$1}                   An observable sequence containing a single element with a dictionary mapping unique key values onto the corresponding source sequence's element.
             */
            toDictionary: function (TSource, TKey, source, keySelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$toDictionary(TSource, TKey, source, keySelector);
            },
            /**
             * Creates a dictionary from an observable sequence according to a specified key selector function, and a comparer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                          TSource        The type of the elements in the source sequence.
             * @param   {Function}                                          TKey           The type of the dictionary key computed for each element in the source sequence.
             * @param   {System.IObservable$1}                              source         An observable sequence to create a dictionary for.
             * @param   {System.Func}                                       keySelector    A function to extract a key from each element.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer       An equality comparer to compare keys.
             * @return  {System.IObservable$1}                                             An observable sequence containing a single element with a dictionary mapping unique key values onto the corresponding source sequence's element.
             */
            toDictionary$1: function (TSource, TKey, source, keySelector, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$toDictionary$1(TSource, TKey, source, keySelector, comparer);
            },
            /**
             * Creates a dictionary from an observable sequence according to a specified key selector function, and an element selector function.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource            The type of the elements in the source sequence.
             * @param   {Function}                TKey               The type of the dictionary key computed for each element in the source sequence.
             * @param   {Function}                TElement           The type of the dictionary value computed for each element in the source sequence.
             * @param   {System.IObservable$1}    source             An observable sequence to create a dictionary for.
             * @param   {System.Func}             keySelector        A function to extract a key from each element.
             * @param   {System.Func}             elementSelector    A transform function to produce a result element value from each element.
             * @return  {System.IObservable$1}                       An observable sequence containing a single element with a dictionary mapping unique key values onto the corresponding source sequence's element.
             */
            toDictionary$2: function (TSource, TKey, TElement, source, keySelector, elementSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (Bridge.staticEquals(elementSelector, null)) {
                    throw new System.ArgumentNullException("elementSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$toDictionary$2(TSource, TKey, TElement, source, keySelector, elementSelector);
            },
            /**
             * Creates a dictionary from an observable sequence according to a specified key selector function, a comparer, and an element selector function.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                                          TSource            The type of the elements in the source sequence.
             * @param   {Function}                                          TKey               The type of the dictionary key computed for each element in the source sequence.
             * @param   {Function}                                          TElement           The type of the dictionary value computed for each element in the source sequence.
             * @param   {System.IObservable$1}                              source             An observable sequence to create a dictionary for.
             * @param   {System.Func}                                       keySelector        A function to extract a key from each element.
             * @param   {System.Func}                                       elementSelector    A transform function to produce a result element value from each element.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer           An equality comparer to compare keys.
             * @return  {System.IObservable$1}                                                 An observable sequence containing a single element with a dictionary mapping unique key values onto the corresponding source sequence's element.
             */
            toDictionary$3: function (TSource, TKey, TElement, source, keySelector, elementSelector, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (Bridge.staticEquals(elementSelector, null)) {
                    throw new System.ArgumentNullException("elementSelector");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$toDictionary$3(TSource, TKey, TElement, source, keySelector, elementSelector, comparer);
            },
            /**
             * Creates a list from an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     The source observable sequence to get a list of elements for.
             * @return  {System.IObservable$1}               An observable sequence containing a single element with a list containing all the elements of the source sequence.
             */
            toList: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$toList(TSource, source);
            },
            /**
             * Creates a lookup from an observable sequence according to a specified key selector function.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource        The type of the elements in the source sequence.
             * @param   {Function}                TKey           The type of the lookup key computed for each element in the source sequence.
             * @param   {System.IObservable$1}    source         An observable sequence to create a lookup for.
             * @param   {System.Func}             keySelector    A function to extract a key from each element.
             * @return  {System.IObservable$1}                   An observable sequence containing a single element with a lookup mapping unique key values onto the corresponding source sequence's elements.
             */
            toLookup: function (TSource, TKey, source, keySelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$toLookup(TSource, TKey, source, keySelector);
            },
            /**
             * Creates a lookup from an observable sequence according to a specified key selector function, and a comparer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                          TSource        The type of the elements in the source sequence.
             * @param   {Function}                                          TKey           The type of the lookup key computed for each element in the source sequence.
             * @param   {System.IObservable$1}                              source         An observable sequence to create a lookup for.
             * @param   {System.Func}                                       keySelector    A function to extract a key from each element.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer       An equality comparer to compare keys.
             * @return  {System.IObservable$1}                                             An observable sequence containing a single element with a lookup mapping unique key values onto the corresponding source sequence's elements.
             */
            toLookup$1: function (TSource, TKey, source, keySelector, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$toLookup$1(TSource, TKey, source, keySelector, comparer);
            },
            /**
             * Creates a lookup from an observable sequence according to a specified key selector function, and an element selector function.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource            The type of the elements in the source sequence.
             * @param   {Function}                TKey               The type of the lookup key computed for each element in the source sequence.
             * @param   {Function}                TElement           The type of the lookup value computed for each element in the source sequence.
             * @param   {System.IObservable$1}    source             An observable sequence to create a lookup for.
             * @param   {System.Func}             keySelector        A function to extract a key from each element.
             * @param   {System.Func}             elementSelector    A transform function to produce a result element value from each element.
             * @return  {System.IObservable$1}                       An observable sequence containing a single element with a lookup mapping unique key values onto the corresponding source sequence's elements.
             */
            toLookup$2: function (TSource, TKey, TElement, source, keySelector, elementSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (Bridge.staticEquals(elementSelector, null)) {
                    throw new System.ArgumentNullException("elementSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$toLookup$2(TSource, TKey, TElement, source, keySelector, elementSelector);
            },
            /**
             * Creates a lookup from an observable sequence according to a specified key selector function, a comparer, and an element selector function.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                                          TSource            The type of the elements in the source sequence.
             * @param   {Function}                                          TKey               The type of the lookup key computed for each element in the source sequence.
             * @param   {Function}                                          TElement           The type of the lookup value computed for each element in the source sequence.
             * @param   {System.IObservable$1}                              source             An observable sequence to create a lookup for.
             * @param   {System.Func}                                       keySelector        A function to extract a key from each element.
             * @param   {System.Func}                                       elementSelector    A transform function to produce a result element value from each element.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer           An equality comparer to compare keys.
             * @return  {System.IObservable$1}                                                 An observable sequence containing a single element with a lookup mapping unique key values onto the corresponding source sequence's elements.
             */
            toLookup$3: function (TSource, TKey, TElement, source, keySelector, elementSelector, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (Bridge.staticEquals(elementSelector, null)) {
                    throw new System.ArgumentNullException("elementSelector");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$toLookup$3(TSource, TKey, TElement, source, keySelector, elementSelector, comparer);
            },
            /**
             * Multicasts the source sequence notifications through the specified subject to the resulting connectable observable. Upon connection of the
             connectable observable, the subject is subscribed to the source exactly one, and messages are forwarded to the observers registered with
             the connectable observable. For specializations with fixed subject types, see Publish, PublishLast, and Replay.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                             TSource    The type of the elements in the source sequence.
             * @param   {Function}                                             TResult    The type of the elements in the result sequence.
             * @param   {System.IObservable$1}                                 source     Source sequence whose elements will be pushed into the specified subject.
             * @param   {System.Reactive.Subjects.ISubject$2}                  subject    Subject to push source elements into.
             * @return  {System.Reactive.Subjects.IConnectableObservable$1}               A connectable observable sequence that upon connection causes the source sequence to push results into the specified subject.
             */
            multicast$1: function (TSource, TResult, source, subject) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (subject == null) {
                    throw new System.ArgumentNullException("subject");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$multicast$1(TSource, TResult, source, subject);
            },
            /**
             * Multicasts the source sequence notifications through an instantiated subject into all uses of the sequence within a selector function. Each
             subscription to the resulting sequence causes a separate multicast invocation, exposing the sequence resulting from the selector function's
             invocation. For specializations with fixed subject types, see Publish, PublishLast, and Replay.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource            The type of the elements in the source sequence.
             * @param   {Function}                TIntermediate      The type of the elements produced by the intermediate subject.
             * @param   {Function}                TResult            The type of the elements in the result sequence.
             * @param   {System.IObservable$1}    source             Source sequence which will be multicasted in the specified selector function.
             * @param   {System.Func}             subjectSelector    Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function.
             * @param   {System.Func}             selector           Selector function which can use the multicasted source sequence subject to the policies enforced by the created subject.
             * @return  {System.IObservable$1}                       An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
             */
            multicast: function (TSource, TIntermediate, TResult, source, subjectSelector, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(subjectSelector, null)) {
                    throw new System.ArgumentNullException("subjectSelector");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$multicast(TSource, TIntermediate, TResult, source, subjectSelector, selector);
            },
            /**
             * Returns a connectable observable sequence that shares a single subscription to the underlying sequence.
             This operator is a specialization of Multicast using a regular {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                             TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                                 source     Source sequence whose elements will be multicasted through a single shared subscription.
             * @return  {System.Reactive.Subjects.IConnectableObservable$1}               A connectable observable sequence that shares a single subscription to the underlying sequence.
             * @see {@link System.Reactive.Subjects.Subject<T>}
             */
            publish$2: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$publish$2(TSource, source);
            },
            /**
             * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence.
             This operator is a specialization of Multicast using a regular {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {Function}                TResult     The type of the elements in the result sequence.
             * @param   {System.IObservable$1}    source      Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {System.Func}             selector    Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
             * @return  {System.IObservable$1}                An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
             * @see {@link System.Reactive.Subjects.Subject<T>}
             */
            publish: function (TSource, TResult, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$publish(TSource, TResult, source, selector);
            },
            /**
             * Returns a connectable observable sequence that shares a single subscription to the underlying sequence and starts with initialValue.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                             TSource         The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                                 source          Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {TSource}                                              initialValue    Initial value received by observers upon subscription.
             * @return  {System.Reactive.Subjects.IConnectableObservable$1}                    A connectable observable sequence that shares a single subscription to the underlying sequence.
             * @see {@link System.Reactive.Subjects.BehaviorSubject<T>}
             */
            publish$3: function (TSource, source, initialValue) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$publish$3(TSource, source, initialValue);
            },
            /**
             * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence and starts with initialValue.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource         The type of the elements in the source sequence.
             * @param   {Function}                TResult         The type of the elements in the result sequence.
             * @param   {System.IObservable$1}    source          Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {System.Func}             selector        Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive immediately receive the initial value, followed by all notifications of the source from the time of the subscription on.
             * @param   {TSource}                 initialValue    Initial value received by observers upon subscription.
             * @return  {System.IObservable$1}                    An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
             * @see {@link System.Reactive.Subjects.BehaviorSubject<T>}
             */
            publish$1: function (TSource, TResult, source, selector, initialValue) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$publish$1(TSource, TResult, source, selector, initialValue);
            },
            /**
             * Returns a connectable observable sequence that shares a single subscription to the underlying sequence containing only the last notification.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                             TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                                 source     Source sequence whose elements will be multicasted through a single shared subscription.
             * @return  {System.Reactive.Subjects.IConnectableObservable$1}               A connectable observable sequence that shares a single subscription to the underlying sequence.
             * @see {@link System.Reactive.Subjects.AsyncSubject<T>}
             */
            publishLast$1: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$publishLast$1(TSource, source);
            },
            /**
             * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence containing only the last notification.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {Function}                TResult     The type of the elements in the result sequence.
             * @param   {System.IObservable$1}    source      Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {System.Func}             selector    Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will only receive the last notification of the source.
             * @return  {System.IObservable$1}                An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
             * @see {@link System.Reactive.Subjects.AsyncSubject<T>}
             */
            publishLast: function (TSource, TResult, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$publishLast(TSource, TResult, source, selector);
            },
            /**
             * Returns an observable sequence that stays connected to the source as long as there is at least one subscription to the observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                             TSource    The type of the elements in the source sequence.
             * @param   {System.Reactive.Subjects.IConnectableObservable$1}    source     Connectable observable sequence.
             * @return  {System.IObservable$1}                                            An observable sequence that stays connected to the source as long as there is at least one subscription to the observable sequence.
             */
            refCount: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$refCount(TSource, source);
            },
            /**
             * Returns a connectable observable sequence that shares a single subscription to the underlying sequence replaying all notifications.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                             TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                                 source     Source sequence whose elements will be multicasted through a single shared subscription.
             * @return  {System.Reactive.Subjects.IConnectableObservable$1}               A connectable observable sequence that shares a single subscription to the underlying sequence.
             * @see {@link System.Reactive.Subjects.ReplaySubject<T>}
             */
            replay$8: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$replay$8(TSource, source);
            },
            /**
             * Returns a connectable observable sequence that shares a single subscription to the underlying sequence replaying all notifications.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                             TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                                 source       Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {System.Reactive.Concurrency.IScheduler}               scheduler    Scheduler where connected observers will be invoked on.
             * @return  {System.Reactive.Subjects.IConnectableObservable$1}                 A connectable observable sequence that shares a single subscription to the underlying sequence.
             * @see {@link System.Reactive.Subjects.ReplaySubject<T>}
             */
            replay$13: function (TSource, source, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$replay$13(TSource, source, scheduler);
            },
            /**
             * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying all notifications.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {Function}                TResult     The type of the elements in the result sequence.
             * @param   {System.IObservable$1}    source      Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {System.Func}             selector    Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source.
             * @return  {System.IObservable$1}                An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
             * @see {@link System.Reactive.Subjects.ReplaySubject<T>}
             */
            replay: function (TSource, TResult, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$replay(TSource, TResult, source, selector);
            },
            /**
             * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying all notifications.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {Function}                                  TResult      The type of the elements in the result sequence.
             * @param   {System.IObservable$1}                      source       Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {System.Func}                               selector     Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler where connected observers within the selector function will be invoked on.
             * @return  {System.IObservable$1}                                   An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
             * @see {@link System.Reactive.Subjects.ReplaySubject<T>}
             */
            replay$5: function (TSource, TResult, source, selector, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$replay$5(TSource, TResult, source, selector, scheduler);
            },
            /**
             * Returns a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                             TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                                 source     Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {System.TimeSpan}                                      window     Maximum time length of the replay buffer.
             * @return  {System.Reactive.Subjects.IConnectableObservable$1}               A connectable observable sequence that shares a single subscription to the underlying sequence.
             * @see {@link System.Reactive.Subjects.ReplaySubject<T>}
             */
            replay$14: function (TSource, source, $window) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt($window, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("window");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$replay$14(TSource, source, $window);
            },
            /**
             * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {Function}                TResult     The type of the elements in the result sequence.
             * @param   {System.IObservable$1}    source      Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {System.Func}             selector    Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source subject to the specified replay buffer trimming policy.
             * @param   {System.TimeSpan}         window      Maximum time length of the replay buffer.
             * @return  {System.IObservable$1}                An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
             * @see {@link System.Reactive.Subjects.ReplaySubject<T>}
             */
            replay$6: function (TSource, TResult, source, selector, $window) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }
                if (System.TimeSpan.lt($window, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("window");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$replay$6(TSource, TResult, source, selector, $window);
            },
            /**
             * Returns a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                             TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                                 source       Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {System.TimeSpan}                                      window       Maximum time length of the replay buffer.
             * @param   {System.Reactive.Concurrency.IScheduler}               scheduler    Scheduler where connected observers will be invoked on.
             * @return  {System.Reactive.Subjects.IConnectableObservable$1}                 A connectable observable sequence that shares a single subscription to the underlying sequence.
             * @see {@link System.Reactive.Subjects.ReplaySubject<T>}
             */
            replay$15: function (TSource, source, $window, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt($window, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("window");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$replay$15(TSource, source, $window, scheduler);
            },
            /**
             * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {Function}                                  TResult      The type of the elements in the result sequence.
             * @param   {System.IObservable$1}                      source       Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {System.Func}                               selector     Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source subject to the specified replay buffer trimming policy.
             * @param   {System.TimeSpan}                           window       Maximum time length of the replay buffer.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler where connected observers within the selector function will be invoked on.
             * @return  {System.IObservable$1}                                   An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
             * @see {@link System.Reactive.Subjects.ReplaySubject<T>}
             */
            replay$7: function (TSource, TResult, source, selector, $window, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }
                if (System.TimeSpan.lt($window, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("window");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$replay$7(TSource, TResult, source, selector, $window, scheduler);
            },
            /**
             * Returns a connectable observable sequence that shares a single subscription to the underlying sequence replaying bufferSize notifications.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than zero.
             * @param   {Function}                                             TSource       The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                                 source        Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {number}                                               bufferSize    Maximum element count of the replay buffer.
             * @param   {System.Reactive.Concurrency.IScheduler}               scheduler     Scheduler where connected observers will be invoked on.
             * @return  {System.Reactive.Subjects.IConnectableObservable$1}                  A connectable observable sequence that shares a single subscription to the underlying sequence.
             * @see {@link System.Reactive.Subjects.ReplaySubject<T>}
             */
            replay$10: function (TSource, source, bufferSize, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (bufferSize < 0) {
                    throw new System.ArgumentOutOfRangeException("bufferSize");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$replay$10(TSource, source, bufferSize, scheduler);
            },
            /**
             * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum element count for the replay buffer.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @throws <b /> is less than zero.
             * @param   {Function}                                  TSource       The type of the elements in the source sequence.
             * @param   {Function}                                  TResult       The type of the elements in the result sequence.
             * @param   {System.IObservable$1}                      source        Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {System.Func}                               selector      Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source subject to the specified replay buffer trimming policy.
             * @param   {number}                                    bufferSize    Maximum element count of the replay buffer.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler     Scheduler where connected observers within the selector function will be invoked on.
             * @return  {System.IObservable$1}                                    An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
             * @see {@link System.Reactive.Subjects.ReplaySubject<T>}
             */
            replay$2: function (TSource, TResult, source, selector, bufferSize, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }
                if (bufferSize < 0) {
                    throw new System.ArgumentOutOfRangeException("bufferSize");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$replay$2(TSource, TResult, source, selector, bufferSize, scheduler);
            },
            /**
             * Returns a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum element count for the replay buffer.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than zero.
             * @param   {Function}                                             TSource       The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                                 source        Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {number}                                               bufferSize    Maximum element count of the replay buffer.
             * @return  {System.Reactive.Subjects.IConnectableObservable$1}                  A connectable observable sequence that shares a single subscription to the underlying sequence.
             * @see {@link System.Reactive.Subjects.ReplaySubject<T>}
             */
            replay$9: function (TSource, source, bufferSize) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (bufferSize < 0) {
                    throw new System.ArgumentOutOfRangeException("bufferSize");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$replay$9(TSource, source, bufferSize);
            },
            /**
             * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum element count for the replay buffer.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than zero.
             * @param   {Function}                TSource       The type of the elements in the source sequence.
             * @param   {Function}                TResult       The type of the elements in the result sequence.
             * @param   {System.IObservable$1}    source        Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {System.Func}             selector      Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source subject to the specified replay buffer trimming policy.
             * @param   {number}                  bufferSize    Maximum element count of the replay buffer.
             * @return  {System.IObservable$1}                  An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
             * @see {@link System.Reactive.Subjects.ReplaySubject<T>}
             */
            replay$1: function (TSource, TResult, source, selector, bufferSize) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }
                if (bufferSize < 0) {
                    throw new System.ArgumentOutOfRangeException("bufferSize");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$replay$1(TSource, TResult, source, selector, bufferSize);
            },
            /**
             * Returns a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length and element count for the replay buffer.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than zero.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                             TSource       The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                                 source        Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {number}                                               bufferSize    Maximum element count of the replay buffer.
             * @param   {System.TimeSpan}                                      window        Maximum time length of the replay buffer.
             * @return  {System.Reactive.Subjects.IConnectableObservable$1}                  A connectable observable sequence that shares a single subscription to the underlying sequence.
             * @see {@link System.Reactive.Subjects.ReplaySubject<T>}
             */
            replay$11: function (TSource, source, bufferSize, $window) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (bufferSize < 0) {
                    throw new System.ArgumentOutOfRangeException("bufferSize");
                }
                if (System.TimeSpan.lt($window, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("window");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$replay$11(TSource, source, bufferSize, $window);
            },
            /**
             * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length and element count for the replay buffer.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than zero.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                TSource       The type of the elements in the source sequence.
             * @param   {Function}                TResult       The type of the elements in the result sequence.
             * @param   {System.IObservable$1}    source        Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {System.Func}             selector      Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source subject to the specified replay buffer trimming policy.
             * @param   {number}                  bufferSize    Maximum element count of the replay buffer.
             * @param   {System.TimeSpan}         window        Maximum time length of the replay buffer.
             * @return  {System.IObservable$1}                  An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
             * @see {@link System.Reactive.Subjects.ReplaySubject<T>}
             */
            replay$3: function (TSource, TResult, source, selector, bufferSize, $window) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }
                if (bufferSize < 0) {
                    throw new System.ArgumentOutOfRangeException("bufferSize");
                }
                if (System.TimeSpan.lt($window, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("window");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$replay$3(TSource, TResult, source, selector, bufferSize, $window);
            },
            /**
             * Returns a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length and element count for the replay buffer.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than zero.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                             TSource       The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                                 source        Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {number}                                               bufferSize    Maximum element count of the replay buffer.
             * @param   {System.TimeSpan}                                      window        Maximum time length of the replay buffer.
             * @param   {System.Reactive.Concurrency.IScheduler}               scheduler     Scheduler where connected observers will be invoked on.
             * @return  {System.Reactive.Subjects.IConnectableObservable$1}                  A connectable observable sequence that shares a single subscription to the underlying sequence.
             * @see {@link System.Reactive.Subjects.ReplaySubject<T>}
             */
            replay$12: function (TSource, source, bufferSize, $window, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (bufferSize < 0) {
                    throw new System.ArgumentOutOfRangeException("bufferSize");
                }
                if (System.TimeSpan.lt($window, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("window");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$replay$12(TSource, source, bufferSize, $window, scheduler);
            },
            /**
             * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length and element count for the replay buffer.
             This operator is a specialization of Multicast using a {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @throws <b /> is less than zero.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TSource       The type of the elements in the source sequence.
             * @param   {Function}                                  TResult       The type of the elements in the result sequence.
             * @param   {System.IObservable$1}                      source        Source sequence whose elements will be multicasted through a single shared subscription.
             * @param   {System.Func}                               selector      Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source subject to the specified replay buffer trimming policy.
             * @param   {number}                                    bufferSize    Maximum element count of the replay buffer.
             * @param   {System.TimeSpan}                           window        Maximum time length of the replay buffer.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler     Scheduler where connected observers within the selector function will be invoked on.
             * @return  {System.IObservable$1}                                    An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
             * @see {@link System.Reactive.Subjects.ReplaySubject<T>}
             */
            replay$4: function (TSource, TResult, source, selector, bufferSize, $window, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }
                if (bufferSize < 0) {
                    throw new System.ArgumentOutOfRangeException("bufferSize");
                }
                if (System.TimeSpan.lt($window, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("window");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$replay$4(TSource, TResult, source, selector, bufferSize, $window, scheduler);
            },
            /**
             * Produces an enumerable sequence of consecutive (possibly empty) chunks of the source sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                    TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                        source     Source observable sequence.
             * @return  {System.Collections.Generic.IEnumerable$1}               The enumerable sequence that returns consecutive (possibly empty) chunks upon each iteration.
             */
            chunkify: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$chunkify(TSource, source);
            },
            /**
             * Produces an enumerable sequence that returns elements collected/aggregated from the source sequence between consecutive iterations.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                    TSource         The type of the elements in the source sequence.
             * @param   {Function}                                    TResult         The type of the elements produced by the merge operation during collection.
             * @param   {System.IObservable$1}                        source          Source observable sequence.
             * @param   {System.Func}                                 newCollector    Factory to create a new collector object.
             * @param   {System.Func}                                 merge           Merges a sequence element with the current collector.
             * @return  {System.Collections.Generic.IEnumerable$1}                    The enumerable sequence that returns collected/aggregated elements from the source sequence upon each iteration.
             */
            collect: function (TSource, TResult, source, newCollector, merge) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(newCollector, null)) {
                    throw new System.ArgumentNullException("newCollector");
                }
                if (Bridge.staticEquals(merge, null)) {
                    throw new System.ArgumentNullException("merge");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$collect(TSource, TResult, source, newCollector, merge);
            },
            /**
             * Produces an enumerable sequence that returns elements collected/aggregated from the source sequence between consecutive iterations.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                                    TSource                The type of the elements in the source sequence.
             * @param   {Function}                                    TResult                The type of the elements produced by the merge operation during collection.
             * @param   {System.IObservable$1}                        source                 Source observable sequence.
             * @param   {System.Func}                                 getInitialCollector    Factory to create the initial collector object.
             * @param   {System.Func}                                 merge                  Merges a sequence element with the current collector.
             * @param   {System.Func}                                 getNewCollector        Factory to replace the current collector by a new collector.
             * @return  {System.Collections.Generic.IEnumerable$1}                           The enumerable sequence that returns collected/aggregated elements from the source sequence upon each iteration.
             */
            collect$1: function (TSource, TResult, source, getInitialCollector, merge, getNewCollector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(getInitialCollector, null)) {
                    throw new System.ArgumentNullException("getInitialCollector");
                }
                if (Bridge.staticEquals(merge, null)) {
                    throw new System.ArgumentNullException("merge");
                }
                if (Bridge.staticEquals(getNewCollector, null)) {
                    throw new System.ArgumentNullException("getNewCollector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$collect$1(TSource, TResult, source, getInitialCollector, merge, getNewCollector);
            },
            /**
             * Returns the first element of an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws The source sequence is empty.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source observable sequence.
             * @return  {TSource}                            The first element in the observable sequence.
             * @see {@link Observable.FirstAsync{TSource}(IObservable{TSource})}
             */
            first: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$first(TSource, source);
            },
            /**
             * Returns the first element of an observable sequence that satisfies the condition in the predicate.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws No element satisfies the condition in the predicate. -or- The source sequence is empty.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       Source observable sequence.
             * @param   {System.Func}             predicate    A predicate function to evaluate for elements in the source sequence.
             * @return  {TSource}                              The first element in the observable sequence that satisfies the condition in the predicate.
             * @see {@link Observable.FirstAsync{TSource}(IObservable{TSource}, Func{TSource, bool})}
             */
            first$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$first$1(TSource, source, predicate);
            },
            /**
             * Returns the first element of an observable sequence, or a default value if no such element exists.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source observable sequence.
             * @return  {TSource}                            The first element in the observable sequence, or a default value if no such element exists.
             * @see {@link Observable.FirstOrDefaultAsync{TSource}(IObservable{TSource})}
             */
            firstOrDefault: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$firstOrDefault(TSource, source);
            },
            /**
             * Returns the first element of an observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       Source observable sequence.
             * @param   {System.Func}             predicate    A predicate function to evaluate for elements in the source sequence.
             * @return  {TSource}                              The first element in the observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
             * @see {@link Observable.FirstOrDefaultAsync{TSource}(IObservable{TSource}, Func{TSource, bool})}
             */
            firstOrDefault$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$firstOrDefault$1(TSource, source, predicate);
            },
            /**
             * Invokes an action for each element in the observable sequence, and blocks until the sequence is terminated.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence.
             * @param   {System.Action}           onNext     Action to invoke for each element in the observable sequence.
             * @return  {void}
             */
            forEach: function (TSource, source, onNext) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(onNext, null)) {
                    throw new System.ArgumentNullException("onNext");
                }

                System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$forEach(TSource, source, onNext);
            },
            /**
             * Invokes an action for each element in the observable sequence, incorporating the element's index, and blocks until the sequence is terminated.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence.
             * @param   {System.Action}           onNext     Action to invoke for each element in the observable sequence.
             * @return  {void}
             */
            forEach$1: function (TSource, source, onNext) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(onNext, null)) {
                    throw new System.ArgumentNullException("onNext");
                }

                System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$forEach$1(TSource, source, onNext);
            },
            /**
             * Returns an enumerator that enumerates all values of the observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                    TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                        source     An observable sequence to get an enumerator for.
             * @return  {System.Collections.Generic.IEnumerator$1}               The enumerator that can be used to enumerate over the elements in the observable sequence.
             */
            getEnumerator: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$getEnumerator(TSource, source);
            },
            /**
             * Returns the last element of an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws The source sequence is empty.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source observable sequence.
             * @return  {TSource}                            The last element in the observable sequence.
             * @see {@link Observable.LastAsync{TSource}(IObservable{TSource})}
             */
            last: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$last(TSource, source);
            },
            /**
             * Returns the last element of an observable sequence that satisfies the condition in the predicate.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws No element satisfies the condition in the predicate. -or- The source sequence is empty.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       Source observable sequence.
             * @param   {System.Func}             predicate    A predicate function to evaluate for elements in the source sequence.
             * @return  {TSource}                              The last element in the observable sequence that satisfies the condition in the predicate.
             * @see {@link Observable.LastAsync{TSource}(IObservable{TSource}, Func{TSource, bool})}
             */
            last$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$last$1(TSource, source, predicate);
            },
            /**
             * Returns the last element of an observable sequence, or a default value if no such element exists.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source observable sequence.
             * @return  {TSource}                            The last element in the observable sequence, or a default value if no such element exists.
             * @see {@link Observable.LastOrDefaultAsync{TSource}(IObservable{TSource})}
             */
            lastOrDefault: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$lastOrDefault(TSource, source);
            },
            /**
             * Returns the last element of an observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       Source observable sequence.
             * @param   {System.Func}             predicate    A predicate function to evaluate for elements in the source sequence.
             * @return  {TSource}                              The last element in the observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
             * @see {@link Observable.LastOrDefaultAsync{TSource}(IObservable{TSource}, Func{TSource, bool})}
             */
            lastOrDefault$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$lastOrDefault$1(TSource, source, predicate);
            },
            /**
             * Returns an enumerable sequence whose enumeration returns the latest observed element in the source observable sequence.
             Enumerators on the resulting sequence will never produce the same element repeatedly, and will block until the next element becomes available.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @param   {Function}                                    TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                        source     Source observable sequence.
             * @return  {System.Collections.Generic.IEnumerable$1}               The enumerable sequence that returns the last sampled element upon each iteration and subsequently blocks until the next element in the observable source sequence becomes available.
             */
            latest: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$latest(TSource, source);
            },
            /**
             * Returns an enumerable sequence whose enumeration returns the most recently observed element in the source observable sequence, using the specified initial value in case no element has been sampled yet.
             Enumerators on the resulting sequence never block and can produce the same element repeatedly.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                    TSource         The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                        source          Source observable sequence.
             * @param   {TSource}                                     initialValue    Initial value that will be yielded by the enumerable sequence if no element has been sampled yet.
             * @return  {System.Collections.Generic.IEnumerable$1}                    The enumerable sequence that returns the last sampled element upon each iteration.
             */
            mostRecent: function (TSource, source, initialValue) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$mostRecent(TSource, source, initialValue);
            },
            /**
             * Returns an enumerable sequence whose enumeration blocks until the next element in the source observable sequence becomes available.
             Enumerators on the resulting sequence will block until the next element becomes available.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                    TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                        source     Source observable sequence.
             * @return  {System.Collections.Generic.IEnumerable$1}               The enumerable sequence that blocks upon each iteration until the next element in the observable source sequence becomes available.
             */
            next: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$next(TSource, source);
            },
            /**
             * Returns the only element of an observable sequence, and throws an exception if there is not exactly one element in the observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws The source sequence contains more than one element. -or- The source sequence is empty.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source observable sequence.
             * @return  {TSource}                            The single element in the observable sequence.
             * @see {@link Observable.SingleAsync{TSource}(IObservable{TSource})}
             */
            single: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$single(TSource, source);
            },
            /**
             * Returns the only element of an observable sequence that satisfies the condition in the predicate, and throws an exception if there is not exactly one element matching the predicate in the observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws No element satisfies the condition in the predicate. -or- More than one element satisfies the condition in the predicate. -or- The source sequence is empty.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       Source observable sequence.
             * @param   {System.Func}             predicate    A predicate function to evaluate for elements in the source sequence.
             * @return  {TSource}                              The single element in the observable sequence that satisfies the condition in the predicate.
             * @see {@link Observable.SingleAsync{TSource}(IObservable{TSource}, Func{TSource, bool})}
             */
            single$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$single$1(TSource, source, predicate);
            },
            /**
             * Returns the only element of an observable sequence, or a default value if the observable sequence is empty; this method throws an exception if there is more than one element in the observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws The source sequence contains more than one element.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source observable sequence.
             * @return  {TSource}                            The single element in the observable sequence, or a default value if no such element exists.
             * @see {@link Observable.SingleOrDefaultAsync{TSource}(IObservable{TSource})}
             */
            singleOrDefault: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$singleOrDefault(TSource, source);
            },
            /**
             * Returns the only element of an observable sequence that satisfies the condition in the predicate, or a default value if no such element exists; this method throws an exception if there is more than one element matching the predicate in the observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws The sequence contains more than one element that satisfies the condition in the predicate.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       Source observable sequence.
             * @param   {System.Func}             predicate    A predicate function to evaluate for elements in the source sequence.
             * @return  {TSource}                              The single element in the observable sequence that satisfies the condition in the predicate, or a default value if no such element exists.
             * @see {@link Observable.SingleOrDefaultAsync{TSource}(IObservable{TSource}, Func{TSource, bool})}
             */
            singleOrDefault$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$singleOrDefault$1(TSource, source, predicate);
            },
            /**
             * Waits for the observable sequence to complete and returns the last element of the sequence.
             If the sequence terminates with an OnError notification, the exception is thrown.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws The source sequence is empty.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source observable sequence.
             * @return  {TSource}                            The last element in the observable sequence.
             */
            wait: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$wait(TSource, source);
            },
            /**
             * Wraps the source sequence in order to run its observer callbacks on the specified scheduler.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to notify observers on.
             * @return  {System.IObservable$1}                                   The source sequence whose observations happen on the specified scheduler.
             */
            observeOn: function (TSource, source, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$observeOn(TSource, source, scheduler);
            },
            /**
             * Wraps the source sequence in order to run its subscription and unsubscription logic on the specified scheduler. This operation is not commonly used;
             see the remarks section for more information on the distinction between SubscribeOn and ObserveOn.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to perform subscription and unsubscription actions on.
             * @return  {System.IObservable$1}                                   The source sequence whose subscriptions and unsubscriptions happen on the specified scheduler.
             */
            subscribeOn: function (TSource, source, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$subscribeOn(TSource, source, scheduler);
            },
            /**
             * Synchronizes the observable sequence such that observer notifications cannot be delivered concurrently.
             This overload is useful to "fix" an observable sequence that exhibits concurrent callbacks on individual observers, which is invalid behavior for the query processor.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence.
             * @return  {System.IObservable$1}               The source sequence whose outgoing calls to observers are synchronized.
             */
            synchronize: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$synchronize(TSource, source);
            },
            /**
             * Synchronizes the observable sequence such that observer notifications cannot be delivered concurrently, using the specified gate object.
             This overload is useful when writing n-ary query operators, in order to prevent concurrent callbacks from different sources by synchronizing on a common gate object.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence.
             * @param   {Object}                  gate       Gate object to synchronize each observer call on.
             * @return  {System.IObservable$1}               The source sequence whose outgoing calls to observers are synchronized on the given gate object.
             */
            synchronize$1: function (TSource, source, gate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (gate == null) {
                    throw new System.ArgumentNullException("gate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$synchronize$1(TSource, source, gate);
            },
            /**
             * Subscribes an observer to an enumerable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                    TSource     The type of the elements in the source sequence.
             * @param   {System.Collections.Generic.IEnumerable$1}    source      Enumerable sequence to subscribe to.
             * @param   {System.IObserver$1}                          observer    Observer that will receive notifications from the enumerable sequence.
             * @return  {System.IDisposable}                                      Disposable object that can be used to unsubscribe the observer from the enumerable
             */
            subscribe: function (TSource, source, observer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (observer == null) {
                    throw new System.ArgumentNullException("observer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$subscribe(TSource, source, observer);
            },
            /**
             * Subscribes an observer to an enumerable sequence, using the specified scheduler to run the enumeration loop.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                    TSource      The type of the elements in the source sequence.
             * @param   {System.Collections.Generic.IEnumerable$1}    source       Enumerable sequence to subscribe to.
             * @param   {System.IObserver$1}                          observer     Observer that will receive notifications from the enumerable sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}      scheduler    Scheduler to perform the enumeration on.
             * @return  {System.IDisposable}                                       Disposable object that can be used to unsubscribe the observer from the enumerable
             */
            subscribe$1: function (TSource, source, observer, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (observer == null) {
                    throw new System.ArgumentNullException("observer");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$subscribe$1(TSource, source, observer, scheduler);
            },
            /**
             * Converts an observable sequence to an enumerable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                    TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                        source     An observable sequence to convert to an enumerable sequence.
             * @return  {System.Collections.Generic.IEnumerable$1}               The enumerable sequence containing the elements in the observable sequence.
             */
            toEnumerable: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$toEnumerable(TSource, source);
            },
            /**
             * Exposes an observable sequence as an object with an Action-based .NET event.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.IObservable$1}              source    Observable source sequence.
             * @return  {System.Reactive.IEventSource$1}              The event source object.
             */
            toEvent$1: function (source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$toEvent$1(source);
            },
            /**
             * Exposes an observable sequence as an object with an Action&lt;TSource&gt;-based .NET event.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                          TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}              source     Observable source sequence.
             * @return  {System.Reactive.IEventSource$1}               The event source object.
             */
            toEvent: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$toEvent(TSource, source);
            },
            /**
             * Exposes an observable sequence as an object with a .NET event, conforming to the standard .NET event pattern.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                 TEventArgs    The type of the event data generated by the event.
             * @param   {System.IObservable$1}                     source        Observable source sequence.
             * @return  {System.Reactive.IEventPatternSource$1}                  The event source object.
             */
            toEventPattern: function (TEventArgs, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$toEventPattern(TEventArgs, source);
            },
            /**
             * Converts an enumerable sequence to an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                    TSource    The type of the elements in the source sequence.
             * @param   {System.Collections.Generic.IEnumerable$1}    source     Enumerable sequence to convert to an observable sequence.
             * @return  {System.IObservable$1}                                   The observable sequence whose elements are pulled from the given enumerable sequence.
             */
            toObservable: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$toObservable(TSource, source);
            },
            /**
             * Converts an enumerable sequence to an observable sequence, using the specified scheduler to run the enumeration loop.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                    TSource      The type of the elements in the source sequence.
             * @param   {System.Collections.Generic.IEnumerable$1}    source       Enumerable sequence to convert to an observable sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}      scheduler    Scheduler to run the enumeration of the input sequence on.
             * @return  {System.IObservable$1}                                     The observable sequence whose elements are pulled from the given enumerable sequence.
             */
            toObservable$1: function (TSource, source, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$toObservable$1(TSource, source, scheduler);
            },
            /**
             * Creates an observable sequence from a specified Subscribe method implementation.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TResult      The type of the elements in the produced sequence.
             * @param   {System.Func}             subscribe    Implementation of the resulting observable sequence's Subscribe method.
             * @return  {System.IObservable$1}                 The observable sequence with the specified implementation for the Subscribe method.
             */
            create$1: function (TResult, subscribe) {
                if (Bridge.staticEquals(subscribe, null)) {
                    throw new System.ArgumentNullException("subscribe");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$create$1(TResult, subscribe);
            },
            /**
             * Creates an observable sequence from a specified Subscribe method implementation.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TResult      The type of the elements in the produced sequence.
             * @param   {System.Func}             subscribe    Implementation of the resulting observable sequence's Subscribe method, returning an Action delegate that will be wrapped in an IDisposable.
             * @return  {System.IObservable$1}                 The observable sequence with the specified implementation for the Subscribe method.
             */
            create: function (TResult, subscribe) {
                if (Bridge.staticEquals(subscribe, null)) {
                    throw new System.ArgumentNullException("subscribe");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$create(TResult, subscribe);
            },
            /**
             * Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TResult              The type of the elements in the sequence returned by the factory function, and in the resulting sequence.
             * @param   {System.Func}             observableFactory    Observable factory function to invoke for each observer that subscribes to the resulting sequence.
             * @return  {System.IObservable$1}                         An observable sequence whose observers trigger an invocation of the given observable factory function.
             */
            defer: function (TResult, observableFactory) {
                if (Bridge.staticEquals(observableFactory, null)) {
                    throw new System.ArgumentNullException("observableFactory");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$defer(TResult, observableFactory);
            },
            /**
             * Returns an empty observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @param   {Function}                TResult    The type used for the IObservable&lt;T&gt; type parameter of the resulting sequence.
             * @return  {System.IObservable$1}               An observable sequence with no elements.
             */
            empty: function (TResult) {
                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$empty(TResult);
            },
            /**
             * Returns an empty observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @param   {Function}                TResult    The type used for the IObservable&lt;T&gt; type parameter of the resulting sequence.
             * @param   {TResult}                 witness    Object solely used to infer the type of the <b>witness</b> type parameter. This parameter is typically used when creating a sequence of anonymously typed elements.
             * @return  {System.IObservable$1}               An observable sequence with no elements.
             */
            empty$1: function (TResult, witness) {
                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$empty(TResult); // Pure inference - no specialized target method.
            },
            /**
             * Returns an empty observable sequence, using the specified scheduler to send out the single OnCompleted message.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                  TResult      The type used for the IObservable&lt;T&gt; type parameter of the resulting sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to send the termination call on.
             * @return  {System.IObservable$1}                                   An observable sequence with no elements.
             */
            empty$2: function (TResult, scheduler) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$empty$1(TResult, scheduler);
            },
            /**
             * Returns an empty observable sequence, using the specified scheduler to send out the single OnCompleted message.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                  TResult      The type used for the IObservable&lt;T&gt; type parameter of the resulting sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to send the termination call on.
             * @param   {TResult}                                   witness      Object solely used to infer the type of the <b>witness</b> type parameter. This parameter is typically used when creating a sequence of anonymously typed elements.
             * @return  {System.IObservable$1}                                   An observable sequence with no elements.
             */
            empty$3: function (TResult, scheduler, witness) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$empty$1(TResult, scheduler); // Pure inference - no specialized target method.
            },
            /**
             * Generates an observable sequence by running a state-driven loop producing the sequence's elements.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TState            The type of the state used in the generator loop.
             * @param   {Function}                TResult           The type of the elements in the produced sequence.
             * @param   {TState}                  initialState      Initial state.
             * @param   {System.Func}             condition         Condition to terminate generation (upon returning false).
             * @param   {System.Func}             iterate           Iteration step function.
             * @param   {System.Func}             resultSelector    Selector function for results produced in the sequence.
             * @return  {System.IObservable$1}                      The generated sequence.
             */
            generate: function (TState, TResult, initialState, condition, iterate, resultSelector) {
                if (Bridge.staticEquals(condition, null)) {
                    throw new System.ArgumentNullException("condition");
                }
                if (Bridge.staticEquals(iterate, null)) {
                    throw new System.ArgumentNullException("iterate");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$generate(TState, TResult, initialState, condition, iterate, resultSelector);
            },
            /**
             * Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TState            The type of the state used in the generator loop.
             * @param   {Function}                                  TResult           The type of the elements in the produced sequence.
             * @param   {TState}                                    initialState      Initial state.
             * @param   {System.Func}                               condition         Condition to terminate generation (upon returning false).
             * @param   {System.Func}                               iterate           Iteration step function.
             * @param   {System.Func}                               resultSelector    Selector function for results produced in the sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler         Scheduler on which to run the generator loop.
             * @return  {System.IObservable$1}                                        The generated sequence.
             */
            generate$1: function (TState, TResult, initialState, condition, iterate, resultSelector, scheduler) {
                if (Bridge.staticEquals(condition, null)) {
                    throw new System.ArgumentNullException("condition");
                }
                if (Bridge.staticEquals(iterate, null)) {
                    throw new System.ArgumentNullException("iterate");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$generate$1(TState, TResult, initialState, condition, iterate, resultSelector, scheduler);
            },
            /**
             * Generates an observable sequence by running a state-driven and temporal loop producing the sequence's elements.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TState            The type of the state used in the generator loop.
             * @param   {Function}                TResult           The type of the elements in the produced sequence.
             * @param   {TState}                  initialState      Initial state.
             * @param   {System.Func}             condition         Condition to terminate generation (upon returning false).
             * @param   {System.Func}             iterate           Iteration step function.
             * @param   {System.Func}             resultSelector    Selector function for results produced in the sequence.
             * @param   {System.Func}             timeSelector      Time selector function to control the speed of values being produced each iteration.
             * @return  {System.IObservable$1}                      The generated sequence.
             */
            generate$4: function (TState, TResult, initialState, condition, iterate, resultSelector, timeSelector) {
                if (Bridge.staticEquals(condition, null)) {
                    throw new System.ArgumentNullException("condition");
                }
                if (Bridge.staticEquals(iterate, null)) {
                    throw new System.ArgumentNullException("iterate");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }
                if (Bridge.staticEquals(timeSelector, null)) {
                    throw new System.ArgumentNullException("timeSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$generate$4(TState, TResult, initialState, condition, iterate, resultSelector, timeSelector);
            },
            /**
             * Generates an observable sequence by running a state-driven and temporal loop producing the sequence's elements, using the specified scheduler to run timers and to send out observer messages.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TState            The type of the state used in the generator loop.
             * @param   {Function}                                  TResult           The type of the elements in the produced sequence.
             * @param   {TState}                                    initialState      Initial state.
             * @param   {System.Func}                               condition         Condition to terminate generation (upon returning false).
             * @param   {System.Func}                               iterate           Iteration step function.
             * @param   {System.Func}                               resultSelector    Selector function for results produced in the sequence.
             * @param   {System.Func}                               timeSelector      Time selector function to control the speed of values being produced each iteration.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler         Scheduler on which to run the generator loop.
             * @return  {System.IObservable$1}                                        The generated sequence.
             */
            generate$5: function (TState, TResult, initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
                if (Bridge.staticEquals(condition, null)) {
                    throw new System.ArgumentNullException("condition");
                }
                if (Bridge.staticEquals(iterate, null)) {
                    throw new System.ArgumentNullException("iterate");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }
                if (Bridge.staticEquals(timeSelector, null)) {
                    throw new System.ArgumentNullException("timeSelector");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$generate$5(TState, TResult, initialState, condition, iterate, resultSelector, timeSelector, scheduler);
            },
            /**
             * Generates an observable sequence by running a state-driven and temporal loop producing the sequence's elements.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TState            The type of the state used in the generator loop.
             * @param   {Function}                TResult           The type of the elements in the produced sequence.
             * @param   {TState}                  initialState      Initial state.
             * @param   {System.Func}             condition         Condition to terminate generation (upon returning false).
             * @param   {System.Func}             iterate           Iteration step function.
             * @param   {System.Func}             resultSelector    Selector function for results produced in the sequence.
             * @param   {System.Func}             timeSelector      Time selector function to control the speed of values being produced each iteration.
             * @return  {System.IObservable$1}                      The generated sequence.
             */
            generate$2: function (TState, TResult, initialState, condition, iterate, resultSelector, timeSelector) {
                if (Bridge.staticEquals(condition, null)) {
                    throw new System.ArgumentNullException("condition");
                }
                if (Bridge.staticEquals(iterate, null)) {
                    throw new System.ArgumentNullException("iterate");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }
                if (Bridge.staticEquals(timeSelector, null)) {
                    throw new System.ArgumentNullException("timeSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$generate$2(TState, TResult, initialState, condition, iterate, resultSelector, timeSelector);
            },
            /**
             * Generates an observable sequence by running a state-driven and temporal loop producing the sequence's elements, using the specified scheduler to run timers and to send out observer messages.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TState            The type of the state used in the generator loop.
             * @param   {Function}                                  TResult           The type of the elements in the produced sequence.
             * @param   {TState}                                    initialState      Initial state.
             * @param   {System.Func}                               condition         Condition to terminate generation (upon returning false).
             * @param   {System.Func}                               iterate           Iteration step function.
             * @param   {System.Func}                               resultSelector    Selector function for results produced in the sequence.
             * @param   {System.Func}                               timeSelector      Time selector function to control the speed of values being produced each iteration.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler         Scheduler on which to run the generator loop.
             * @return  {System.IObservable$1}                                        The generated sequence.
             */
            generate$3: function (TState, TResult, initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
                if (Bridge.staticEquals(condition, null)) {
                    throw new System.ArgumentNullException("condition");
                }
                if (Bridge.staticEquals(iterate, null)) {
                    throw new System.ArgumentNullException("iterate");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }
                if (Bridge.staticEquals(timeSelector, null)) {
                    throw new System.ArgumentNullException("timeSelector");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$generate$3(TState, TResult, initialState, condition, iterate, resultSelector, timeSelector, scheduler);
            },
            /**
             * Returns a non-terminating observable sequence, which can be used to denote an infinite duration (e.g. when using reactive joins).
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @param   {Function}                TResult    The type used for the IObservable&lt;T&gt; type parameter of the resulting sequence.
             * @return  {System.IObservable$1}               An observable sequence whose observers will never get called.
             */
            never: function (TResult) {
                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$never(TResult);
            },
            /**
             * Returns a non-terminating observable sequence, which can be used to denote an infinite duration (e.g. when using reactive joins).
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @param   {Function}                TResult    The type used for the IObservable&lt;T&gt; type parameter of the resulting sequence.
             * @param   {TResult}                 witness    Object solely used to infer the type of the <b>witness</b> type parameter. This parameter is typically used when creating a sequence of anonymously typed elements.
             * @return  {System.IObservable$1}               An observable sequence whose observers will never get called.
             */
            never$1: function (TResult, witness) {
                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$never(TResult); // Pure inference - no specialized target method.
            },
            /**
             * Generates an observable sequence of integral numbers within a specified range.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is less than zero. -or- <b /> + <b /> - 1 is larger than {@link ArgumentOutOfRangeException}.
             * @param   {number}                  start    The value of the first integer in the sequence.
             * @param   {number}                  count    The number of sequential integers to generate.
             * @return  {System.IObservable$1}             An observable sequence that contains a range of sequential integral numbers.
             */
            range: function (start, count) {
                var max = System.Int64(start).add(System.Int64(count)).sub(System.Int64(1));
                if (count < 0 || max.gt(System.Int64(2147483647))) {
                    throw new System.ArgumentOutOfRangeException("count");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$range(start, count);
            },
            /**
             * Generates an observable sequence of integral numbers within a specified range, using the specified scheduler to send out observer messages.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is less than zero. -or- <b /> + <b /> - 1 is larger than {@link ArgumentOutOfRangeException}.
             * @throws <b /> is null.
             * @param   {number}                                    start        The value of the first integer in the sequence.
             * @param   {number}                                    count        The number of sequential integers to generate.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the generator loop on.
             * @return  {System.IObservable$1}                                   An observable sequence that contains a range of sequential integral numbers.
             */
            range$1: function (start, count, scheduler) {
                var max = System.Int64(start).add(System.Int64(count)).sub(System.Int64(1));
                if (count < 0 || max.gt(System.Int64(2147483647))) {
                    throw new System.ArgumentOutOfRangeException("count");
                }

                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$range$1(start, count, scheduler);
            },
            /**
             * Generates an observable sequence that repeats the given element infinitely.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @param   {Function}                TResult    The type of the element that will be repeated in the produced sequence.
             * @param   {TResult}                 value      Element to repeat.
             * @return  {System.IObservable$1}               An observable sequence that repeats the given element infinitely.
             */
            repeat: function (TResult, value) {
                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$repeat(TResult, value);
            },
            /**
             * Generates an observable sequence that repeats the given element infinitely, using the specified scheduler to send out observer messages.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                  TResult      The type of the element that will be repeated in the produced sequence.
             * @param   {TResult}                                   value        Element to repeat.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the producer loop on.
             * @return  {System.IObservable$1}                                   An observable sequence that repeats the given element infinitely.
             */
            repeat$3: function (TResult, value, scheduler) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$repeat$3(TResult, value, scheduler);
            },
            /**
             * Generates an observable sequence that repeats the given element the specified number of times.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is less than zero.
             * @param   {Function}                TResult        The type of the element that will be repeated in the produced sequence.
             * @param   {TResult}                 value          Element to repeat.
             * @param   {number}                  repeatCount    Number of times to repeat the element.
             * @return  {System.IObservable$1}                   An observable sequence that repeats the given element the specified number of times.
             */
            repeat$1: function (TResult, value, repeatCount) {
                if (repeatCount < 0) {
                    throw new System.ArgumentOutOfRangeException("repeatCount");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$repeat$1(TResult, value, repeatCount);
            },
            /**
             * Generates an observable sequence that repeats the given element the specified number of times, using the specified scheduler to send out observer messages.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is less than zero.
             * @throws <b /> is null.
             * @param   {Function}                                  TResult        The type of the element that will be repeated in the produced sequence.
             * @param   {TResult}                                   value          Element to repeat.
             * @param   {number}                                    repeatCount    Number of times to repeat the element.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler      Scheduler to run the producer loop on.
             * @return  {System.IObservable$1}                                     An observable sequence that repeats the given element the specified number of times.
             */
            repeat$2: function (TResult, value, repeatCount, scheduler) {
                if (repeatCount < 0) {
                    throw new System.ArgumentOutOfRangeException("repeatCount");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$repeat$2(TResult, value, repeatCount, scheduler);
            },
            /**
             * Repeats the observable sequence indefinitely.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Observable sequence to repeat.
             * @return  {System.IObservable$1}               The observable sequence producing the elements of the given sequence repeatedly and sequentially.
             */
            repeat$4: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$repeat$4(TSource, source);
            },
            /**
             * Repeats the observable sequence a specified number of times.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than zero.
             * @param   {Function}                TSource        The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source         Observable sequence to repeat.
             * @param   {number}                  repeatCount    Number of times to repeat the sequence.
             * @return  {System.IObservable$1}                   The observable sequence producing the elements of the given sequence repeatedly.
             */
            repeat$5: function (TSource, source, repeatCount) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (repeatCount < 0) {
                    throw new System.ArgumentOutOfRangeException("repeatCount");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$repeat$5(TSource, source, repeatCount);
            },
            /**
             * Returns an observable sequence that contains a single element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @param   {Function}                TResult    The type of the element that will be returned in the produced sequence.
             * @param   {TResult}                 value      Single element in the resulting observable sequence.
             * @return  {System.IObservable$1}               An observable sequence containing the single specified element.
             */
            return: function (TResult, value) {
                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$return(TResult, value);
            },
            /**
             * Returns an observable sequence that contains a single element, using the specified scheduler to send out observer messages.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                  TResult      The type of the element that will be returned in the produced sequence.
             * @param   {TResult}                                   value        Single element in the resulting observable sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to send the single element on.
             * @return  {System.IObservable$1}                                   An observable sequence containing the single specified element.
             */
            return$1: function (TResult, value, scheduler) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$return$1(TResult, value, scheduler);
            },
            /**
             * Returns an observable sequence that terminates with an exception.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TResult      The type used for the IObservable&lt;T&gt; type parameter of the resulting sequence.
             * @param   {System.Exception}        exception    Exception object used for the sequence's termination.
             * @return  {System.IObservable$1}                 The observable sequence that terminates exceptionally with the specified exception object.
             */
            throw: function (TResult, exception) {
                if (exception == null) {
                    throw new System.ArgumentNullException("exception");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$throw(TResult, exception);
            },
            /**
             * Returns an observable sequence that terminates with an exception.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TResult      The type used for the IObservable&lt;T&gt; type parameter of the resulting sequence.
             * @param   {System.Exception}        exception    Exception object used for the sequence's termination.
             * @param   {TResult}                 witness      Object solely used to infer the type of the <b>witness</b> type parameter. This parameter is typically used when creating a sequence of anonymously typed elements.
             * @return  {System.IObservable$1}                 The observable sequence that terminates exceptionally with the specified exception object.
             */
            throw$1: function (TResult, exception, witness) {
                if (exception == null) {
                    throw new System.ArgumentNullException("exception");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$throw(TResult, exception); // Pure inference - no specialized target method.
            },
            /**
             * Returns an observable sequence that terminates with an exception, using the specified scheduler to send out the single OnError message.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TResult      The type used for the IObservable&lt;T&gt; type parameter of the resulting sequence.
             * @param   {System.Exception}                          exception    Exception object used for the sequence's termination.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to send the exceptional termination call on.
             * @return  {System.IObservable$1}                                   The observable sequence that terminates exceptionally with the specified exception object.
             */
            throw$2: function (TResult, exception, scheduler) {
                if (exception == null) {
                    throw new System.ArgumentNullException("exception");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$throw$1(TResult, exception, scheduler);
            },
            /**
             * Returns an observable sequence that terminates with an exception, using the specified scheduler to send out the single OnError message.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TResult      The type used for the IObservable&lt;T&gt; type parameter of the resulting sequence.
             * @param   {System.Exception}                          exception    Exception object used for the sequence's termination.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to send the exceptional termination call on.
             * @param   {TResult}                                   witness      Object solely used to infer the type of the <b>witness</b> type parameter. This parameter is typically used when creating a sequence of anonymously typed elements.
             * @return  {System.IObservable$1}                                   The observable sequence that terminates exceptionally with the specified exception object.
             */
            throw$3: function (TResult, exception, scheduler, witness) {
                if (exception == null) {
                    throw new System.ArgumentNullException("exception");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$throw$1(TResult, exception, scheduler); // Pure inference - no specialized target method.
            },
            /**
             * Constructs an observable sequence that depends on a resource object, whose lifetime is tied to the resulting observable sequence's lifetime.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TResult              The type of the elements in the produced sequence.
             * @param   {Function}                TResource            The type of the resource used during the generation of the resulting sequence. Needs to implement {@link }.
             * @param   {System.Func}             resourceFactory      Factory function to obtain a resource object.
             * @param   {System.Func}             observableFactory    Factory function to obtain an observable sequence that depends on the obtained resource.
             * @return  {System.IObservable$1}                         An observable sequence whose lifetime controls the lifetime of the dependent resource object.
             */
            using: function (TResult, TResource, resourceFactory, observableFactory) {
                if (Bridge.staticEquals(resourceFactory, null)) {
                    throw new System.ArgumentNullException("resourceFactory");
                }
                if (Bridge.staticEquals(observableFactory, null)) {
                    throw new System.ArgumentNullException("observableFactory");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$using(TResult, TResource, resourceFactory, observableFactory);
            },
            /**
             * Converts a .NET event, conforming to the standard .NET event pattern based on {@link }, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {System.Action}           addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}           removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @return  {System.IObservable$1}                     The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$10: function (addHandler, removeHandler) {
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$10(addHandler, removeHandler);
            },
            /**
             * Converts a .NET event, conforming to the standard .NET event pattern based on {@link }, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {System.Action}                             addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}                             removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler        The scheduler to run the add and remove event handler logic on.
             * @return  {System.IObservable$1}                                       The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$11: function (addHandler, removeHandler, scheduler) {
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$11(addHandler, removeHandler, scheduler);
            },
            /**
             * Converts a .NET event, conforming to the standard .NET event pattern based on a supplied event delegate type, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TDelegate        The delegate type of the event to be converted.
             * @param   {Function}                TEventArgs       The type of the event data generated by the event.
             * @param   {System.Action}           addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}           removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @return  {System.IObservable$1}                     The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$6: function (TDelegate, TEventArgs, addHandler, removeHandler) {
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$6(TDelegate, TEventArgs, addHandler, removeHandler);
            },
            /**
             * Converts a .NET event, conforming to the standard .NET event pattern based on a supplied event delegate type, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TDelegate        The delegate type of the event to be converted.
             * @param   {Function}                                  TEventArgs       The type of the event data generated by the event.
             * @param   {System.Action}                             addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}                             removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler        The scheduler to run the add and remove event handler logic on.
             * @return  {System.IObservable$1}                                       The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$7: function (TDelegate, TEventArgs, addHandler, removeHandler, scheduler) {
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$7(TDelegate, TEventArgs, addHandler, removeHandler, scheduler);
            },
            /**
             * Converts a .NET event, conforming to the standard .NET event pattern based on {@link }, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TDelegate        The delegate type of the event to be converted.
             * @param   {Function}                TEventArgs       The type of the event data generated by the event.
             * @param   {System.Func}             conversion       A function used to convert the given event handler to a delegate compatible with the underlying .NET event. The resulting delegate is used in calls to the addHandler and removeHandler action parameters.
             * @param   {System.Action}           addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}           removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @return  {System.IObservable$1}                     The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$8: function (TDelegate, TEventArgs, conversion, addHandler, removeHandler) {
                if (Bridge.staticEquals(conversion, null)) {
                    throw new System.ArgumentNullException("conversion");
                }
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$8(TDelegate, TEventArgs, conversion, addHandler, removeHandler);
            },
            /**
             * Converts a .NET event, conforming to the standard .NET event pattern based on {@link }, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TDelegate        The delegate type of the event to be converted.
             * @param   {Function}                                  TEventArgs       The type of the event data generated by the event.
             * @param   {System.Func}                               conversion       A function used to convert the given event handler to a delegate compatible with the underlying .NET event. The resulting delegate is used in calls to the addHandler and removeHandler action parameters.
             * @param   {System.Action}                             addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}                             removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler        The scheduler to run the add and remove event handler logic on.
             * @return  {System.IObservable$1}                                       The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$9: function (TDelegate, TEventArgs, conversion, addHandler, removeHandler, scheduler) {
                if (Bridge.staticEquals(conversion, null)) {
                    throw new System.ArgumentNullException("conversion");
                }
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$9(TDelegate, TEventArgs, conversion, addHandler, removeHandler, scheduler);
            },
            /**
             * Converts a .NET event, conforming to the standard .NET event pattern based on a supplied event delegate type with a strongly typed sender parameter, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TDelegate        The delegate type of the event to be converted.
             * @param   {Function}                TSender          The type of the sender that raises the event.
             * @param   {Function}                TEventArgs       The type of the event data generated by the event.
             * @param   {System.Action}           addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}           removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @return  {System.IObservable$1}                     The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$20: function (TDelegate, TSender, TEventArgs, addHandler, removeHandler) {
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$20(TDelegate, TSender, TEventArgs, addHandler, removeHandler);
            },
            /**
             * Converts a .NET event, conforming to the standard .NET event pattern based on a supplied event delegate type with a strongly typed sender parameter, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TDelegate        The delegate type of the event to be converted.
             * @param   {Function}                                  TSender          The type of the sender that raises the event.
             * @param   {Function}                                  TEventArgs       The type of the event data generated by the event.
             * @param   {System.Action}                             addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}                             removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler        The scheduler to run the add and remove event handler logic on.
             * @return  {System.IObservable$1}                                       The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$21: function (TDelegate, TSender, TEventArgs, addHandler, removeHandler, scheduler) {
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$21(TDelegate, TSender, TEventArgs, addHandler, removeHandler, scheduler);
            },
            /**
             * Converts a .NET event, conforming to the standard .NET event pattern based on {@link }, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @param   {Function}                TEventArgs       The type of the event data generated by the event.
             * @param   {System.Action}           addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}           removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @return  {System.IObservable$1}                     The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern: function (TEventArgs, addHandler, removeHandler) {
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern(TEventArgs, addHandler, removeHandler);
            },
            /**
             * Converts a .NET event, conforming to the standard .NET event pattern based on {@link }, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @param   {Function}                                  TEventArgs       The type of the event data generated by the event.
             * @param   {System.Action}                             addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}                             removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler        The scheduler to run the add and remove event handler logic on.
             * @return  {System.IObservable$1}                                       The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$1: function (TEventArgs, addHandler, removeHandler, scheduler) {
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$1(TEventArgs, addHandler, removeHandler, scheduler);
            },
            /**
             * Converts an instance .NET event, conforming to the standard .NET event pattern with an {@link } parameter, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             Reflection is used to discover the event based on the target object type and the specified event name.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws The event could not be found. -or- The event does not conform to the standard .NET event pattern.
             * @param   {Object}                  target       Object instance that exposes the event to convert.
             * @param   {string}                  eventName    Name of the event to convert.
             * @return  {System.IObservable$1}                 The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$12: function (target, eventName) {
                if (target == null) {
                    throw new System.ArgumentNullException("target");
                }
                if (eventName == null) {
                    throw new System.ArgumentNullException("eventName");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$12(target, eventName);
            },
            /**
             * Converts an instance .NET event, conforming to the standard .NET event pattern with an {@link } parameter, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             Reflection is used to discover the event based on the target object type and the specified event name.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @throws The event could not be found. -or- The event does not conform to the standard .NET event pattern.
             * @param   {Object}                                    target       Object instance that exposes the event to convert.
             * @param   {string}                                    eventName    Name of the event to convert.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    The scheduler to run the add and remove event handler logic on.
             * @return  {System.IObservable$1}                                   The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$13: function (target, eventName, scheduler) {
                if (target == null) {
                    throw new System.ArgumentNullException("target");
                }
                if (eventName == null) {
                    throw new System.ArgumentNullException("eventName");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$13(target, eventName, scheduler);
            },
            /**
             * Converts an instance .NET event, conforming to the standard .NET event pattern with strongly typed event arguments, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             Reflection is used to discover the event based on the target object type and the specified event name.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws The event could not be found. -or- The event does not conform to the standard .NET event pattern. -or- The event's second argument type is not assignable to TEventArgs.
             * @param   {Function}                TEventArgs    The type of the event data generated by the event.
             * @param   {Object}                  target        Object instance that exposes the event to convert.
             * @param   {string}                  eventName     Name of the event to convert.
             * @return  {System.IObservable$1}                  The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$2: function (TEventArgs, target, eventName) {
                if (target == null) {
                    throw new System.ArgumentNullException("target");
                }
                if (eventName == null) {
                    throw new System.ArgumentNullException("eventName");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$2(TEventArgs, target, eventName);
            },
            /**
             * Converts an instance .NET event, conforming to the standard .NET event pattern with strongly typed event arguments, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             Reflection is used to discover the event based on the target object type and the specified event name.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @throws The event could not be found. -or- The event does not conform to the standard .NET event pattern. -or- The event's second argument type is not assignable to TEventArgs.
             * @param   {Function}                                  TEventArgs    The type of the event data generated by the event.
             * @param   {Object}                                    target        Object instance that exposes the event to convert.
             * @param   {string}                                    eventName     Name of the event to convert.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler     The scheduler to run the add and remove event handler logic on.
             * @return  {System.IObservable$1}                                    The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$3: function (TEventArgs, target, eventName, scheduler) {
                if (target == null) {
                    throw new System.ArgumentNullException("target");
                }
                if (eventName == null) {
                    throw new System.ArgumentNullException("eventName");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$3(TEventArgs, target, eventName, scheduler);
            },
            /**
             * Converts an instance .NET event, conforming to the standard .NET event pattern with a strongly typed sender and strongly typed event arguments, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             Reflection is used to discover the event based on the target object type and the specified event name.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws The event could not be found. -or- The event does not conform to the standard .NET event pattern. -or- The event's first argument type is not assignable to TSender. -or- The event's second argument type is not assignable to TEventArgs.
             * @param   {Function}                TSender       The type of the sender that raises the event.
             * @param   {Function}                TEventArgs    The type of the event data generated by the event.
             * @param   {Object}                  target        Object instance that exposes the event to convert.
             * @param   {string}                  eventName     Name of the event to convert.
             * @return  {System.IObservable$1}                  The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$16: function (TSender, TEventArgs, target, eventName) {
                if (target == null) {
                    throw new System.ArgumentNullException("target");
                }
                if (eventName == null) {
                    throw new System.ArgumentNullException("eventName");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$16(TSender, TEventArgs, target, eventName);
            },
            /**
             * Converts an instance .NET event, conforming to the standard .NET event pattern with a strongly typed sender and strongly typed event arguments, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             Reflection is used to discover the event based on the target object type and the specified event name.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @throws The event could not be found. -or- The event does not conform to the standard .NET event pattern. -or- The event's first argument type is not assignable to TSender. -or- The event's second argument type is not assignable to TEventArgs.
             * @param   {Function}                                  TSender       The type of the sender that raises the event.
             * @param   {Function}                                  TEventArgs    The type of the event data generated by the event.
             * @param   {Object}                                    target        Object instance that exposes the event to convert.
             * @param   {string}                                    eventName     Name of the event to convert.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler     The scheduler to run the add and remove event handler logic on.
             * @return  {System.IObservable$1}                                    The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$17: function (TSender, TEventArgs, target, eventName, scheduler) {
                if (target == null) {
                    throw new System.ArgumentNullException("target");
                }
                if (eventName == null) {
                    throw new System.ArgumentNullException("eventName");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$17(TSender, TEventArgs, target, eventName, scheduler);
            },
            /**
             * Converts a static .NET event, conforming to the standard .NET event pattern with an {@link } parameter, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             Reflection is used to discover the event based on the specified type and the specified event name.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws The event could not be found. -or- The event does not conform to the standard .NET event pattern.
             * @param   {Function}                type         Type that exposes the static event to convert.
             * @param   {string}                  eventName    Name of the event to convert.
             * @return  {System.IObservable$1}                 The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$14: function (type, eventName) {
                if (type == null) {
                    throw new System.ArgumentNullException("type");
                }
                if (eventName == null) {
                    throw new System.ArgumentNullException("eventName");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$14(type, eventName);
            },
            /**
             * Converts a static .NET event, conforming to the standard .NET event pattern with an {@link } parameter, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             Reflection is used to discover the event based on the specified type and the specified event name.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @throws The event could not be found. -or- The event does not conform to the standard .NET event pattern.
             * @param   {Function}                                  type         Type that exposes the static event to convert.
             * @param   {string}                                    eventName    Name of the event to convert.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    The scheduler to run the add and remove event handler logic on.
             * @return  {System.IObservable$1}                                   The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$15: function (type, eventName, scheduler) {
                if (type == null) {
                    throw new System.ArgumentNullException("type");
                }
                if (eventName == null) {
                    throw new System.ArgumentNullException("eventName");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$15(type, eventName, scheduler);
            },
            /**
             * Converts a static .NET event, conforming to the standard .NET event pattern with strongly typed event arguments, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             Reflection is used to discover the event based on the specified type and the specified event name.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws The event could not be found. -or- The event does not conform to the standard .NET event pattern. -or- The event's second argument type is not assignable to TEventArgs.
             * @param   {Function}                TEventArgs    The type of the event data generated by the event.
             * @param   {Function}                type          Type that exposes the static event to convert.
             * @param   {string}                  eventName     Name of the event to convert.
             * @return  {System.IObservable$1}                  The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$4: function (TEventArgs, type, eventName) {
                if (type == null) {
                    throw new System.ArgumentNullException("type");
                }
                if (eventName == null) {
                    throw new System.ArgumentNullException("eventName");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$4(TEventArgs, type, eventName);
            },
            /**
             * Converts a static .NET event, conforming to the standard .NET event pattern with strongly typed event arguments, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             Reflection is used to discover the event based on the specified type and the specified event name.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @throws The event could not be found. -or- The event does not conform to the standard .NET event pattern. -or- The event's second argument type is not assignable to TEventArgs.
             * @param   {Function}                                  TEventArgs    The type of the event data generated by the event.
             * @param   {Function}                                  type          Type that exposes the static event to convert.
             * @param   {string}                                    eventName     Name of the event to convert.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler     The scheduler to run the add and remove event handler logic on.
             * @return  {System.IObservable$1}                                    The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$5: function (TEventArgs, type, eventName, scheduler) {
                if (type == null) {
                    throw new System.ArgumentNullException("type");
                }
                if (eventName == null) {
                    throw new System.ArgumentNullException("eventName");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$5(TEventArgs, type, eventName, scheduler);
            },
            /**
             * Converts a static .NET event, conforming to the standard .NET event pattern with a strongly typed sender and strongly typed event arguments, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             Reflection is used to discover the event based on the specified type and the specified event name.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws The event could not be found. -or- The event does not conform to the standard .NET event pattern. -or- The event's first argument type is not assignable to TSender. -or- The event's second argument type is not assignable to TEventArgs.
             * @param   {Function}                TSender       The type of the sender that raises the event.
             * @param   {Function}                TEventArgs    The type of the event data generated by the event.
             * @param   {Function}                type          Type that exposes the static event to convert.
             * @param   {string}                  eventName     Name of the event to convert.
             * @return  {System.IObservable$1}                  The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$18: function (TSender, TEventArgs, type, eventName) {
                if (type == null) {
                    throw new System.ArgumentNullException("type");
                }
                if (eventName == null) {
                    throw new System.ArgumentNullException("eventName");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$18(TSender, TEventArgs, type, eventName);
            },
            /**
             * Converts a static .NET event, conforming to the standard .NET event pattern with a strongly typed sender and strongly typed event arguments, to an observable sequence.
             Each event invocation is surfaced through an OnNext message in the resulting sequence.
             Reflection is used to discover the event based on the specified type and the specified event name.
             For conversion of events that don't conform to the standard .NET event pattern, use any of the FromEvent overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @throws The event could not be found. -or- The event does not conform to the standard .NET event pattern. -or- The event's first argument type is not assignable to TSender. -or- The event's second argument type is not assignable to TEventArgs.
             * @param   {Function}                                  TSender       The type of the sender that raises the event.
             * @param   {Function}                                  TEventArgs    The type of the event data generated by the event.
             * @param   {Function}                                  type          Type that exposes the static event to convert.
             * @param   {string}                                    eventName     Name of the event to convert.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler     The scheduler to run the add and remove event handler logic on.
             * @return  {System.IObservable$1}                                    The observable sequence that contains data representations of invocations of the underlying .NET event.
             * @see {@link Observable.ToEventPattern}
             */
            fromEventPattern$19: function (TSender, TEventArgs, type, eventName, scheduler) {
                if (type == null) {
                    throw new System.ArgumentNullException("type");
                }
                if (eventName == null) {
                    throw new System.ArgumentNullException("eventName");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEventPattern$19(TSender, TEventArgs, type, eventName, scheduler);
            },
            /**
             * Converts a .NET event to an observable sequence, using a conversion function to obtain the event delegate. Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events conforming to the standard .NET event pattern, use any of the FromEventPattern overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TDelegate        The delegate type of the event to be converted.
             * @param   {Function}                TEventArgs       The type of the event data generated by the event.
             * @param   {System.Func}             conversion       A function used to convert the given event handler to a delegate compatible with the underlying .NET event. The resulting delegate is used in calls to the addHandler and removeHandler action parameters.
             * @param   {System.Action}           addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}           removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @return  {System.IObservable$1}                     The observable sequence that contains the event argument objects passed to the invocations of the underlying .NET event.
             * @see {@link Observable.ToEvent}
             */
            fromEvent$4: function (TDelegate, TEventArgs, conversion, addHandler, removeHandler) {
                if (Bridge.staticEquals(conversion, null)) {
                    throw new System.ArgumentNullException("conversion");
                }
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEvent$4(TDelegate, TEventArgs, conversion, addHandler, removeHandler);
            },
            /**
             * Converts a .NET event to an observable sequence, using a conversion function to obtain the event delegate. Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events conforming to the standard .NET event pattern, use any of the FromEventPattern overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TDelegate        The delegate type of the event to be converted.
             * @param   {Function}                                  TEventArgs       The type of the event data generated by the event.
             * @param   {System.Func}                               conversion       A function used to convert the given event handler to a delegate compatible with the underlying .NET event. The resulting delegate is used in calls to the addHandler and removeHandler action parameters.
             * @param   {System.Action}                             addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}                             removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler        The scheduler to run the add and remove event handler logic on.
             * @return  {System.IObservable$1}                                       The observable sequence that contains the event argument objects passed to the invocations of the underlying .NET event.
             * @see {@link Observable.ToEvent}
             */
            fromEvent$5: function (TDelegate, TEventArgs, conversion, addHandler, removeHandler, scheduler) {
                if (Bridge.staticEquals(conversion, null)) {
                    throw new System.ArgumentNullException("conversion");
                }
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEvent$5(TDelegate, TEventArgs, conversion, addHandler, removeHandler, scheduler);
            },
            /**
             * Converts a .NET event to an observable sequence, using a supplied event delegate type. Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events conforming to the standard .NET event pattern, use any of the FromEventPattern overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TDelegate        The delegate type of the event to be converted.
             * @param   {Function}                TEventArgs       The type of the event data generated by the event.
             * @param   {System.Action}           addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}           removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @return  {System.IObservable$1}                     The observable sequence that contains the event argument objects passed to the invocations of the underlying .NET event.
             * @see {@link Observable.ToEvent}
             */
            fromEvent$2: function (TDelegate, TEventArgs, addHandler, removeHandler) {
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEvent$2(TDelegate, TEventArgs, addHandler, removeHandler);
            },
            /**
             * Converts a .NET event to an observable sequence, using a supplied event delegate type. Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events conforming to the standard .NET event pattern, use any of the FromEventPattern overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TDelegate        The delegate type of the event to be converted.
             * @param   {Function}                                  TEventArgs       The type of the event data generated by the event.
             * @param   {System.Action}                             addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}                             removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler        The scheduler to run the add and remove event handler logic on.
             * @return  {System.IObservable$1}                                       The observable sequence that contains the event argument objects passed to the invocations of the underlying .NET event.
             * @see {@link Observable.ToEvent}
             */
            fromEvent$3: function (TDelegate, TEventArgs, addHandler, removeHandler, scheduler) {
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEvent$3(TDelegate, TEventArgs, addHandler, removeHandler, scheduler);
            },
            /**
             * Converts a generic Action-based .NET event to an observable sequence. Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events conforming to the standard .NET event pattern, use any of the FromEventPattern overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TEventArgs       The type of the event data generated by the event.
             * @param   {System.Action}           addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}           removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @return  {System.IObservable$1}                     The observable sequence that contains the event argument objects passed to the invocations of the underlying .NET event.
             * @see {@link Observable.ToEvent}
             */
            fromEvent: function (TEventArgs, addHandler, removeHandler) {
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEvent(TEventArgs, addHandler, removeHandler);
            },
            /**
             * Converts a generic Action-based .NET event to an observable sequence. Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events conforming to the standard .NET event pattern, use any of the FromEventPattern overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TEventArgs       The type of the event data generated by the event.
             * @param   {System.Action}                             addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}                             removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler        The scheduler to run the add and remove event handler logic on.
             * @return  {System.IObservable$1}                                       The observable sequence that contains the event argument objects passed to the invocations of the underlying .NET event.
             * @see {@link Observable.ToEvent}
             */
            fromEvent$1: function (TEventArgs, addHandler, removeHandler, scheduler) {
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEvent$1(TEventArgs, addHandler, removeHandler, scheduler);
            },
            /**
             * Converts an Action-based .NET event to an observable sequence. Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events conforming to the standard .NET event pattern, use any of the FromEventPattern overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {System.Action}           addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}           removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @return  {System.IObservable$1}                     The observable sequence that contains the event argument objects passed to the invocations of the underlying .NET event.
             * @see {@link Observable.ToEvent}
             */
            fromEvent$6: function (addHandler, removeHandler) {
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEvent$6(addHandler, removeHandler);
            },
            /**
             * Converts an Action-based .NET event to an observable sequence. Each event invocation is surfaced through an OnNext message in the resulting sequence.
             For conversion of events conforming to the standard .NET event pattern, use any of the FromEventPattern overloads instead.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {System.Action}                             addHandler       Action that attaches the given event handler to the underlying .NET event.
             * @param   {System.Action}                             removeHandler    Action that detaches the given event handler from the underlying .NET event.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler        The scheduler to run the add and remove event handler logic on.
             * @return  {System.IObservable$1}                                       The observable sequence that contains the event argument objects passed to the invocations of the underlying .NET event.
             * @see {@link Observable.ToEvent}
             */
            fromEvent$7: function (addHandler, removeHandler, scheduler) {
                if (Bridge.staticEquals(addHandler, null)) {
                    throw new System.ArgumentNullException("addHandler");
                }
                if (Bridge.staticEquals(removeHandler, null)) {
                    throw new System.ArgumentNullException("removeHandler");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$fromEvent$7(addHandler, removeHandler, scheduler);
            },
            /**
             * Uses <b /> to determine which source in <b /> to return, choosing <b /> if no match is found.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                    TValue           The type of the value returned by the selector function, used to look up the resulting source.
             * @param   {Function}                                    TResult          The type of the elements in the result sequence.
             * @param   {System.Func}                                 selector         Selector function invoked to determine the source to lookup in the <b>selector</b> dictionary.
             * @param   {System.Collections.Generic.IDictionary$2}    sources          Dictionary of sources to select from based on the <b>sources</b> invocation result.
             * @param   {System.IObservable$1}                        defaultSource    Default source to select in case no matching source in <b>defaultSource</b> is found.
             * @return  {System.IObservable$1}                                         The observable sequence retrieved from the <b /> dictionary based on the <b /> invocation result, or <b /> if no match is found.
             */
            case$1: function (TValue, TResult, selector, sources, defaultSource) {
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }
                if (defaultSource == null) {
                    throw new System.ArgumentNullException("defaultSource");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$case$1(TValue, TResult, selector, sources, defaultSource);
            },
            /**
             * Uses <b /> to determine which source in <b /> to return, choosing an empty sequence on the specified scheduler if no match is found.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                    TValue       The type of the value returned by the selector function, used to look up the resulting source.
             * @param   {Function}                                    TResult      The type of the elements in the result sequence.
             * @param   {System.Func}                                 selector     Selector function invoked to determine the source to lookup in the <b>selector</b> dictionary.
             * @param   {System.Collections.Generic.IDictionary$2}    sources      Dictionary of sources to select from based on the <b>sources</b> invocation result.
             * @param   {System.Reactive.Concurrency.IScheduler}      scheduler    Scheduler to generate an empty sequence on in case no matching source in <b>scheduler</b> is found.
             * @return  {System.IObservable$1}                                     The observable sequence retrieved from the <b /> dictionary based on the <b /> invocation result, or an empty sequence if no match is found.
             */
            case$2: function (TValue, TResult, selector, sources, scheduler) {
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$case$2(TValue, TResult, selector, sources, scheduler);
            },
            /**
             * Uses <b /> to determine which source in <b /> to return, choosing an empty sequence if no match is found.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                    TValue      The type of the value returned by the selector function, used to look up the resulting source.
             * @param   {Function}                                    TResult     The type of the elements in the result sequence.
             * @param   {System.Func}                                 selector    Selector function invoked to determine the source to lookup in the <b>selector</b> dictionary.
             * @param   {System.Collections.Generic.IDictionary$2}    sources     Dictionary of sources to select from based on the <b>sources</b> invocation result.
             * @return  {System.IObservable$1}                                    The observable sequence retrieved from the <b /> dictionary based on the <b /> invocation result, or an empty sequence if no match is found.
             */
            case: function (TValue, TResult, selector, sources) {
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$case(TValue, TResult, selector, sources);
            },
            /**
             * Repeats the given <b /> as long as the specified <b /> holds, where the <b /> is evaluated after each repeated <b /> completed.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       Source to repeat as long as the <b>source</b> function evaluates to true.
             * @param   {System.Func}             condition    Condition that will be evaluated upon the completion of an iteration through the <b>condition</b>, to determine whether repetition of the source is required.
             * @return  {System.IObservable$1}                 The observable sequence obtained by concatenating the <b /> sequence as long as the <b /> holds.
             */
            doWhile: function (TSource, source, condition) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(condition, null)) {
                    throw new System.ArgumentNullException("condition");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$doWhile(TSource, source, condition);
            },
            /**
             * Concatenates the observable sequences obtained by running the <b /> for each element in the given enumerable <b />.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                    TSource           The type of the elements in the enumerable source sequence.
             * @param   {Function}                                    TResult           The type of the elements in the observable result sequence.
             * @param   {System.Collections.Generic.IEnumerable$1}    source            Enumerable source for which each element will be mapped onto an observable source that will be concatenated in the result sequence.
             * @param   {System.Func}                                 resultSelector    Function to select an observable source for each element in the <b>resultSelector</b>.
             * @return  {System.IObservable$1}                                          The observable sequence obtained by concatenating the sources returned by <b /> for each element in the <b />.
             */
            for: function (TSource, TResult, source, resultSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$for(TSource, TResult, source, resultSelector);
            },
            /**
             * If the specified <b /> evaluates true, select the <b /> sequence. Otherwise, select the <b /> sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TResult       The type of the elements in the result sequence.
             * @param   {System.Func}             condition     Condition evaluated to decide which sequence to return.
             * @param   {System.IObservable$1}    thenSource    Sequence returned in case <b>thenSource</b> evaluates true.
             * @param   {System.IObservable$1}    elseSource    Sequence returned in case <b>elseSource</b> evaluates false.
             * @return  {System.IObservable$1}                  <b /> if <b /> evaluates true; <b /> otherwise.
             */
            if$1: function (TResult, condition, thenSource, elseSource) {
                if (Bridge.staticEquals(condition, null)) {
                    throw new System.ArgumentNullException("condition");
                }
                if (thenSource == null) {
                    throw new System.ArgumentNullException("thenSource");
                }
                if (elseSource == null) {
                    throw new System.ArgumentNullException("elseSource");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$if$1(TResult, condition, thenSource, elseSource);
            },
            /**
             * If the specified <b /> evaluates true, select the <b /> sequence. Otherwise, return an empty sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TResult       The type of the elements in the result sequence.
             * @param   {System.Func}             condition     Condition evaluated to decide which sequence to return.
             * @param   {System.IObservable$1}    thenSource    Sequence returned in case <b>thenSource</b> evaluates true.
             * @return  {System.IObservable$1}                  <b /> if <b /> evaluates true; an empty sequence otherwise.
             */
            if: function (TResult, condition, thenSource) {
                if (Bridge.staticEquals(condition, null)) {
                    throw new System.ArgumentNullException("condition");
                }
                if (thenSource == null) {
                    throw new System.ArgumentNullException("thenSource");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$if(TResult, condition, thenSource);
            },
            /**
             * If the specified <b /> evaluates true, select the <b /> sequence. Otherwise, return an empty sequence generated on the specified scheduler.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TResult       The type of the elements in the result sequence.
             * @param   {System.Func}                               condition     Condition evaluated to decide which sequence to return.
             * @param   {System.IObservable$1}                      thenSource    Sequence returned in case <b>thenSource</b> evaluates true.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler     Scheduler to generate an empty sequence on in case <b>scheduler</b> evaluates false.
             * @return  {System.IObservable$1}                                    <b /> if <b /> evaluates true; an empty sequence otherwise.
             */
            if$2: function (TResult, condition, thenSource, scheduler) {
                if (Bridge.staticEquals(condition, null)) {
                    throw new System.ArgumentNullException("condition");
                }
                if (thenSource == null) {
                    throw new System.ArgumentNullException("thenSource");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$if$2(TResult, condition, thenSource, scheduler);
            },
            /**
             * Repeats the given <b /> as long as the specified <b /> holds, where the <b /> is evaluated before each repeated <b /> is subscribed to.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.Func}             condition    Condition that will be evaluated before subscription to the <b>condition</b>, to determine whether repetition of the source is required.
             * @param   {System.IObservable$1}    source       Source to repeat as long as the <b>source</b> function evaluates to true.
             * @return  {System.IObservable$1}                 The observable sequence obtained by concatenating the <b /> sequence as long as the <b /> holds.
             */
            while: function (TSource, condition, source) {
                if (Bridge.staticEquals(condition, null)) {
                    throw new System.ArgumentNullException("condition");
                }
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$while(TSource, condition, source);
            },
            /**
             * Creates a pattern that matches when both observable sequences have an available element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                           TLeft     The type of the elements in the left sequence.
             * @param   {Function}                           TRight    The type of the elements in the right sequence.
             * @param   {System.IObservable$1}               left      Observable sequence to match with the right sequence.
             * @param   {System.IObservable$1}               right     Observable sequence to match with the left sequence.
             * @return  {System.Reactive.Joins.Pattern$2}              Pattern object that matches when both observable sequences have an available element.
             */
            and: function (TLeft, TRight, left, right) {
                if (left == null) {
                    throw new System.ArgumentNullException("left");
                }
                if (right == null) {
                    throw new System.ArgumentNullException("right");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$and(TLeft, TRight, left, right);
            },
            /**
             * Matches when the observable sequence has an available element and projects the element by invoking the selector function.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                        TSource     The type of the elements in the source sequence.
             * @param   {Function}                        TResult     The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}            source      Observable sequence to apply the selector on.
             * @param   {System.Func}                     selector    Selector that will be invoked for elements in the source sequence.
             * @return  {System.Reactive.Joins.Plan$1}                Plan that produces the projected results, to be fed (with other plans) to the When operator.
             */
            then: function (TSource, TResult, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$then(TSource, TResult, source, selector);
            },
            /**
             * Joins together the results from several patterns.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                TResult    The type of the elements in the result sequence, obtained from the specified patterns.
             * @param   {Array.<System.Reactive.Joins.Plan$1>}    plans      A series of plans created by use of the Then operator on patterns.
             * @return  {System.IObservable$1}                               An observable sequence with the results from matching several patterns.
             */
            when$1: function (TResult, plans) {
                if (plans === void 0) { plans = []; }
                if (plans == null) {
                    throw new System.ArgumentNullException("plans");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$when$1(TResult, plans);
            },
            /**
             * Joins together the results from several patterns.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                    TResult    The type of the elements in the result sequence, obtained from the specified patterns.
             * @param   {System.Collections.Generic.IEnumerable$1}    plans      A series of plans created by use of the Then operator on patterns.
             * @return  {System.IObservable$1}                                   An observable sequence with the results form matching several patterns.
             */
            when: function (TResult, plans) {
                if (plans == null) {
                    throw new System.ArgumentNullException("plans");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$when(TResult, plans);
            },
            /**
             * Propagates the observable sequence that reacts first.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequences.
             * @param   {System.IObservable$1}    first      First observable sequence.
             * @param   {System.IObservable$1}    second     Second observable sequence.
             * @return  {System.IObservable$1}               An observable sequence that surfaces either of the given sequences, whichever reacted first.
             */
            amb$1: function (TSource, first, second) {
                if (first == null) {
                    throw new System.ArgumentNullException("first");
                }
                if (second == null) {
                    throw new System.ArgumentNullException("second");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$amb$1(TSource, first, second);
            },
            /**
             * Propagates the observable sequence that reacts first.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                        TSource    The type of the elements in the source sequences.
             * @param   {Array.<System.IObservable$1>}    sources    Observable sources competing to react first.
             * @return  {System.IObservable$1}                       An observable sequence that surfaces any of the given sequences, whichever reacted first.
             */
            amb$2: function (TSource, sources) {
                if (sources === void 0) { sources = []; }
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$amb$2(TSource, sources);
            },
            /**
             * Propagates the observable sequence that reacts first.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                    TSource    The type of the elements in the source sequences.
             * @param   {System.Collections.Generic.IEnumerable$1}    sources    Observable sources competing to react first.
             * @return  {System.IObservable$1}                                   An observable sequence that surfaces any of the given sequences, whichever reacted first.
             */
            amb: function (TSource, sources) {
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$amb(TSource, sources);
            },
            /**
             * Projects each element of an observable sequence into consecutive non-overlapping buffers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource                  The type of the elements in the source sequence, and in the lists in the result sequence.
             * @param   {Function}                TBufferClosing           The type of the elements in the sequences indicating buffer closing events.
             * @param   {System.IObservable$1}    source                   Source sequence to produce buffers over.
             * @param   {System.Func}             bufferClosingSelector    A function invoked to define the boundaries of the produced buffers. A new buffer is started when the previous one is closed.
             * @return  {System.IObservable$1}                             An observable sequence of buffers.
             */
            buffer$8: function (TSource, TBufferClosing, source, bufferClosingSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(bufferClosingSelector, null)) {
                    throw new System.ArgumentNullException("bufferClosingSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$buffer$8(TSource, TBufferClosing, source, bufferClosingSelector);
            },
            /**
             * Projects each element of an observable sequence into zero or more buffers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource                  The type of the elements in the source sequence, and in the lists in the result sequence.
             * @param   {Function}                TBufferOpening           The type of the elements in the sequence indicating buffer opening events, also passed to the closing selector to obtain a sequence of buffer closing events.
             * @param   {Function}                TBufferClosing           The type of the elements in the sequences indicating buffer closing events.
             * @param   {System.IObservable$1}    source                   Source sequence to produce buffers over.
             * @param   {System.IObservable$1}    bufferOpenings           Observable sequence whose elements denote the creation of new buffers.
             * @param   {System.Func}             bufferClosingSelector    A function invoked to define the closing of each produced buffer.
             * @return  {System.IObservable$1}                             An observable sequence of buffers.
             */
            buffer$10: function (TSource, TBufferOpening, TBufferClosing, source, bufferOpenings, bufferClosingSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (bufferOpenings == null) {
                    throw new System.ArgumentNullException("bufferOpenings");
                }
                if (Bridge.staticEquals(bufferClosingSelector, null)) {
                    throw new System.ArgumentNullException("bufferClosingSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$buffer$10(TSource, TBufferOpening, TBufferClosing, source, bufferOpenings, bufferClosingSelector);
            },
            /**
             * Projects each element of an observable sequence into consecutive non-overlapping buffers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource             The type of the elements in the source sequence, and in the lists in the result sequence.
             * @param   {Function}                TBufferBoundary     The type of the elements in the sequences indicating buffer boundary events.
             * @param   {System.IObservable$1}    source              Source sequence to produce buffers over.
             * @param   {System.IObservable$1}    bufferBoundaries    Sequence of buffer boundary markers. The current buffer is closed and a new buffer is opened upon receiving a boundary marker.
             * @return  {System.IObservable$1}                        An observable sequence of buffers.
             */
            buffer$9: function (TSource, TBufferBoundary, source, bufferBoundaries) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (bufferBoundaries == null) {
                    throw new System.ArgumentNullException("bufferBoundaries");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$buffer$9(TSource, TBufferBoundary, source, bufferBoundaries);
            },
            /**
             * Projects each element of an observable sequence into consecutive non-overlapping buffers which are produced based on element count information.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than or equal to zero.
             * @param   {Function}                TSource    The type of the elements in the source sequence, and in the lists in the result sequence.
             * @param   {System.IObservable$1}    source     Source sequence to produce buffers over.
             * @param   {number}                  count      Length of each buffer.
             * @return  {System.IObservable$1}               An observable sequence of buffers.
             */
            buffer: function (TSource, source, count) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (count <= 0) {
                    throw new System.ArgumentOutOfRangeException("count");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$buffer(TSource, source, count);
            },
            /**
             * Projects each element of an observable sequence into zero or more buffers which are produced based on element count information.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> or <b /> is less than or equal to zero.
             * @param   {Function}                TSource    The type of the elements in the source sequence, and in the lists in the result sequence.
             * @param   {System.IObservable$1}    source     Source sequence to produce buffers over.
             * @param   {number}                  count      Length of each buffer.
             * @param   {number}                  skip       Number of elements to skip between creation of consecutive buffers.
             * @return  {System.IObservable$1}               An observable sequence of buffers.
             */
            buffer$1: function (TSource, source, count, skip) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (count <= 0) {
                    throw new System.ArgumentOutOfRangeException("count");
                }
                if (skip <= 0) {
                    throw new System.ArgumentOutOfRangeException("skip");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$buffer$1(TSource, source, count, skip);
            },
            /**
             * Projects each element of an observable sequence into consecutive non-overlapping buffers which are produced based on timing information.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                TSource     The type of the elements in the source sequence, and in the lists in the result sequence.
             * @param   {System.IObservable$1}    source      Source sequence to produce buffers over.
             * @param   {System.TimeSpan}         timeSpan    Length of each buffer.
             * @return  {System.IObservable$1}                An observable sequence of buffers.
             */
            buffer$2: function (TSource, source, timeSpan) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(timeSpan, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("timeSpan");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$buffer$2(TSource, source, timeSpan);
            },
            /**
             * Projects each element of an observable sequence into consecutive non-overlapping buffers which are produced based on timing information, using the specified scheduler to run timers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence, and in the lists in the result sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to produce buffers over.
             * @param   {System.TimeSpan}                           timeSpan     Length of each buffer.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run buffering timers on.
             * @return  {System.IObservable$1}                                   An observable sequence of buffers.
             */
            buffer$5: function (TSource, source, timeSpan, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(timeSpan, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("timeSpan");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$buffer$5(TSource, source, timeSpan, scheduler);
            },
            /**
             * Projects each element of an observable sequence into zero or more buffers which are produced based on timing information.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> or <b /> is less than TimeSpan.Zero.
             * @param   {Function}                TSource      The type of the elements in the source sequence, and in the lists in the result sequence.
             * @param   {System.IObservable$1}    source       Source sequence to produce buffers over.
             * @param   {System.TimeSpan}         timeSpan     Length of each buffer.
             * @param   {System.TimeSpan}         timeShift    Interval between creation of consecutive buffers.
             * @return  {System.IObservable$1}                 An observable sequence of buffers.
             */
            buffer$6: function (TSource, source, timeSpan, timeShift) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(timeSpan, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("timeSpan");
                }
                if (System.TimeSpan.lt(timeShift, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("timeShift");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$buffer$6(TSource, source, timeSpan, timeShift);
            },
            /**
             * Projects each element of an observable sequence into zero or more buffers which are produced based on timing information, using the specified scheduler to run timers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> or <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence, and in the lists in the result sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to produce buffers over.
             * @param   {System.TimeSpan}                           timeSpan     Length of each buffer.
             * @param   {System.TimeSpan}                           timeShift    Interval between creation of consecutive buffers.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run buffering timers on.
             * @return  {System.IObservable$1}                                   An observable sequence of buffers.
             */
            buffer$7: function (TSource, source, timeSpan, timeShift, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(timeSpan, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("timeSpan");
                }
                if (System.TimeSpan.lt(timeShift, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("timeShift");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$buffer$7(TSource, source, timeSpan, timeShift, scheduler);
            },
            /**
             * Projects each element of an observable sequence into a buffer that's sent out when either it's full or a given amount of time has elapsed.
             A useful real-world analogy of this overload is the behavior of a ferry leaving the dock when all seats are taken, or at the scheduled time of departure, whichever event occurs first.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero. -or- <b /> is less than or equal to zero.
             * @param   {Function}                TSource     The type of the elements in the source sequence, and in the lists in the result sequence.
             * @param   {System.IObservable$1}    source      Source sequence to produce buffers over.
             * @param   {System.TimeSpan}         timeSpan    Maximum time length of a window.
             * @param   {number}                  count       Maximum element count of a window.
             * @return  {System.IObservable$1}                An observable sequence of buffers.
             */
            buffer$3: function (TSource, source, timeSpan, count) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(timeSpan, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("timeSpan");
                }
                if (count <= 0) {
                    throw new System.ArgumentOutOfRangeException("count");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$buffer$3(TSource, source, timeSpan, count);
            },
            /**
             * Projects each element of an observable sequence into a buffer that's sent out when either it's full or a given amount of time has elapsed, using the specified scheduler to run timers.
             A useful real-world analogy of this overload is the behavior of a ferry leaving the dock when all seats are taken, or at the scheduled time of departure, whichever event occurs first.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero. -or- <b /> is less than or equal to zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence, and in the lists in the result sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to produce buffers over.
             * @param   {System.TimeSpan}                           timeSpan     Maximum time length of a buffer.
             * @param   {number}                                    count        Maximum element count of a buffer.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run buffering timers on.
             * @return  {System.IObservable$1}                                   An observable sequence of buffers.
             */
            buffer$4: function (TSource, source, timeSpan, count, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(timeSpan, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("timeSpan");
                }
                if (count <= 0) {
                    throw new System.ArgumentOutOfRangeException("count");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$buffer$4(TSource, source, timeSpan, count, scheduler);
            },
            /**
             * Continues an observable sequence that is terminated by an exception of the specified type with the observable sequence produced by the handler.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource       The type of the elements in the source sequence and sequences returned by the exception handler function.
             * @param   {Function}                TException    The type of the exception to catch and handle. Needs to derive from {@link }.
             * @param   {System.IObservable$1}    source        Source sequence.
             * @param   {System.Func}             handler       Exception handler function, producing another observable sequence.
             * @return  {System.IObservable$1}                  An observable sequence containing the source sequence's elements, followed by the elements produced by the handler's resulting observable sequence in case an exception occurred.
             */
            catch$3: function (TSource, TException, source, handler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(handler, null)) {
                    throw new System.ArgumentNullException("handler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$catch$3(TSource, TException, source, handler);
            },
            /**
             * Continues an observable sequence that is terminated by an exception with the next observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence and handler sequence.
             * @param   {System.IObservable$1}    first      First observable sequence whose exception (if any) is caught.
             * @param   {System.IObservable$1}    second     Second observable sequence used to produce results when an error occurred in the first sequence.
             * @return  {System.IObservable$1}               An observable sequence containing the first sequence's elements, followed by the elements of the second sequence in case an exception occurred.
             */
            catch$1: function (TSource, first, second) {
                if (first == null) {
                    throw new System.ArgumentNullException("first");
                }
                if (second == null) {
                    throw new System.ArgumentNullException("second");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$catch$1(TSource, first, second);
            },
            /**
             * Continues an observable sequence that is terminated by an exception with the next observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                        TSource    The type of the elements in the source and handler sequences.
             * @param   {Array.<System.IObservable$1>}    sources    Observable sequences to catch exceptions for.
             * @return  {System.IObservable$1}                       An observable sequence containing elements from consecutive source sequences until a source sequence terminates successfully.
             */
            catch$2: function (TSource, sources) {
                if (sources === void 0) { sources = []; }
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$catch$2(TSource, sources);
            },
            /**
             * Continues an observable sequence that is terminated by an exception with the next observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                    TSource    The type of the elements in the source and handler sequences.
             * @param   {System.Collections.Generic.IEnumerable$1}    sources    Observable sequences to catch exceptions for.
             * @return  {System.IObservable$1}                                   An observable sequence containing elements from consecutive source sequences until a source sequence terminates successfully.
             */
            catch: function (TSource, sources) {
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$catch(TSource, sources);
            },
            /**
             * Merges two observable sequences into one observable sequence by using the selector function whenever one of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    first             First observable source.
             * @param   {System.IObservable$1}    second            Second observable source.
             * @param   {System.Func}             resultSelector    Function to invoke whenever either of the sources produces an element.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of both sources using the specified result selector function.
             */
            combineLatest$8: function (TSource1, TSource2, TResult, first, second, resultSelector) {
                if (first == null) {
                    throw new System.ArgumentNullException("first");
                }
                if (second == null) {
                    throw new System.ArgumentNullException("second");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest$8(TSource1, TSource2, TResult, first, second, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.Func}             resultSelector    Function to invoke whenever any of the sources produces an element.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            combineLatest$9: function (TSource1, TSource2, TSource3, TResult, source1, source2, source3, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest$9(TSource1, TSource2, TSource3, TResult, source1, source2, source3, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke whenever any of the sources produces an element.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            combineLatest$10: function (TSource1, TSource2, TSource3, TSource4, TResult, source1, source2, source3, source4, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest$10(TSource1, TSource2, TSource3, TSource4, TResult, source1, source2, source3, source4, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke whenever any of the sources produces an element.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            combineLatest$11: function (TSource1, TSource2, TSource3, TSource4, TSource5, TResult, source1, source2, source3, source4, source5, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest$11(TSource1, TSource2, TSource3, TSource4, TSource5, TResult, source1, source2, source3, source4, source5, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke whenever any of the sources produces an element.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            combineLatest$12: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TResult, source1, source2, source3, source4, source5, source6, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest$12(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TResult, source1, source2, source3, source4, source5, source6, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.Func}             resultSelector    Function to invoke whenever any of the sources produces an element.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            combineLatest$13: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TResult, source1, source2, source3, source4, source5, source6, source7, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest$13(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TResult, source1, source2, source3, source4, source5, source6, source7, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke whenever any of the sources produces an element.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            combineLatest$14: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TResult, source1, source2, source3, source4, source5, source6, source7, source8, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest$14(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TResult, source1, source2, source3, source4, source5, source6, source7, source8, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TSource9          The type of the elements in the ninth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.IObservable$1}    source9           Ninth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke whenever any of the sources produces an element.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            combineLatest$15: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (source9 == null) {
                    throw new System.ArgumentNullException("source9");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest$15(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TSource9          The type of the elements in the ninth source sequence.
             * @param   {Function}                TSource10         The type of the elements in the tenth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.IObservable$1}    source9           Ninth observable source.
             * @param   {System.IObservable$1}    source10          Tenth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke whenever any of the sources produces an element.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            combineLatest$1: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (source9 == null) {
                    throw new System.ArgumentNullException("source9");
                }
                if (source10 == null) {
                    throw new System.ArgumentNullException("source10");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest$1(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TSource9          The type of the elements in the ninth source sequence.
             * @param   {Function}                TSource10         The type of the elements in the tenth source sequence.
             * @param   {Function}                TSource11         The type of the elements in the eleventh source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.IObservable$1}    source9           Ninth observable source.
             * @param   {System.IObservable$1}    source10          Tenth observable source.
             * @param   {System.IObservable$1}    source11          Eleventh observable source.
             * @param   {System.Func}             resultSelector    Function to invoke whenever any of the sources produces an element.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            combineLatest$2: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (source9 == null) {
                    throw new System.ArgumentNullException("source9");
                }
                if (source10 == null) {
                    throw new System.ArgumentNullException("source10");
                }
                if (source11 == null) {
                    throw new System.ArgumentNullException("source11");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest$2(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TSource9          The type of the elements in the ninth source sequence.
             * @param   {Function}                TSource10         The type of the elements in the tenth source sequence.
             * @param   {Function}                TSource11         The type of the elements in the eleventh source sequence.
             * @param   {Function}                TSource12         The type of the elements in the twelfth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.IObservable$1}    source9           Ninth observable source.
             * @param   {System.IObservable$1}    source10          Tenth observable source.
             * @param   {System.IObservable$1}    source11          Eleventh observable source.
             * @param   {System.IObservable$1}    source12          Twelfth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke whenever any of the sources produces an element.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            combineLatest$3: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (source9 == null) {
                    throw new System.ArgumentNullException("source9");
                }
                if (source10 == null) {
                    throw new System.ArgumentNullException("source10");
                }
                if (source11 == null) {
                    throw new System.ArgumentNullException("source11");
                }
                if (source12 == null) {
                    throw new System.ArgumentNullException("source12");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest$3(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TSource9          The type of the elements in the ninth source sequence.
             * @param   {Function}                TSource10         The type of the elements in the tenth source sequence.
             * @param   {Function}                TSource11         The type of the elements in the eleventh source sequence.
             * @param   {Function}                TSource12         The type of the elements in the twelfth source sequence.
             * @param   {Function}                TSource13         The type of the elements in the thirteenth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.IObservable$1}    source9           Ninth observable source.
             * @param   {System.IObservable$1}    source10          Tenth observable source.
             * @param   {System.IObservable$1}    source11          Eleventh observable source.
             * @param   {System.IObservable$1}    source12          Twelfth observable source.
             * @param   {System.IObservable$1}    source13          Thirteenth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke whenever any of the sources produces an element.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            combineLatest$4: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (source9 == null) {
                    throw new System.ArgumentNullException("source9");
                }
                if (source10 == null) {
                    throw new System.ArgumentNullException("source10");
                }
                if (source11 == null) {
                    throw new System.ArgumentNullException("source11");
                }
                if (source12 == null) {
                    throw new System.ArgumentNullException("source12");
                }
                if (source13 == null) {
                    throw new System.ArgumentNullException("source13");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest$4(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TSource9          The type of the elements in the ninth source sequence.
             * @param   {Function}                TSource10         The type of the elements in the tenth source sequence.
             * @param   {Function}                TSource11         The type of the elements in the eleventh source sequence.
             * @param   {Function}                TSource12         The type of the elements in the twelfth source sequence.
             * @param   {Function}                TSource13         The type of the elements in the thirteenth source sequence.
             * @param   {Function}                TSource14         The type of the elements in the fourteenth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.IObservable$1}    source9           Ninth observable source.
             * @param   {System.IObservable$1}    source10          Tenth observable source.
             * @param   {System.IObservable$1}    source11          Eleventh observable source.
             * @param   {System.IObservable$1}    source12          Twelfth observable source.
             * @param   {System.IObservable$1}    source13          Thirteenth observable source.
             * @param   {System.IObservable$1}    source14          Fourteenth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke whenever any of the sources produces an element.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            combineLatest$5: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (source9 == null) {
                    throw new System.ArgumentNullException("source9");
                }
                if (source10 == null) {
                    throw new System.ArgumentNullException("source10");
                }
                if (source11 == null) {
                    throw new System.ArgumentNullException("source11");
                }
                if (source12 == null) {
                    throw new System.ArgumentNullException("source12");
                }
                if (source13 == null) {
                    throw new System.ArgumentNullException("source13");
                }
                if (source14 == null) {
                    throw new System.ArgumentNullException("source14");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest$5(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TSource9          The type of the elements in the ninth source sequence.
             * @param   {Function}                TSource10         The type of the elements in the tenth source sequence.
             * @param   {Function}                TSource11         The type of the elements in the eleventh source sequence.
             * @param   {Function}                TSource12         The type of the elements in the twelfth source sequence.
             * @param   {Function}                TSource13         The type of the elements in the thirteenth source sequence.
             * @param   {Function}                TSource14         The type of the elements in the fourteenth source sequence.
             * @param   {Function}                TSource15         The type of the elements in the fifteenth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.IObservable$1}    source9           Ninth observable source.
             * @param   {System.IObservable$1}    source10          Tenth observable source.
             * @param   {System.IObservable$1}    source11          Eleventh observable source.
             * @param   {System.IObservable$1}    source12          Twelfth observable source.
             * @param   {System.IObservable$1}    source13          Thirteenth observable source.
             * @param   {System.IObservable$1}    source14          Fourteenth observable source.
             * @param   {System.IObservable$1}    source15          Fifteenth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke whenever any of the sources produces an element.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            combineLatest$6: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TSource15, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (source9 == null) {
                    throw new System.ArgumentNullException("source9");
                }
                if (source10 == null) {
                    throw new System.ArgumentNullException("source10");
                }
                if (source11 == null) {
                    throw new System.ArgumentNullException("source11");
                }
                if (source12 == null) {
                    throw new System.ArgumentNullException("source12");
                }
                if (source13 == null) {
                    throw new System.ArgumentNullException("source13");
                }
                if (source14 == null) {
                    throw new System.ArgumentNullException("source14");
                }
                if (source15 == null) {
                    throw new System.ArgumentNullException("source15");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest$6(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TSource15, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TSource9          The type of the elements in the ninth source sequence.
             * @param   {Function}                TSource10         The type of the elements in the tenth source sequence.
             * @param   {Function}                TSource11         The type of the elements in the eleventh source sequence.
             * @param   {Function}                TSource12         The type of the elements in the twelfth source sequence.
             * @param   {Function}                TSource13         The type of the elements in the thirteenth source sequence.
             * @param   {Function}                TSource14         The type of the elements in the fourteenth source sequence.
             * @param   {Function}                TSource15         The type of the elements in the fifteenth source sequence.
             * @param   {Function}                TSource16         The type of the elements in the sixteenth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.IObservable$1}    source9           Ninth observable source.
             * @param   {System.IObservable$1}    source10          Tenth observable source.
             * @param   {System.IObservable$1}    source11          Eleventh observable source.
             * @param   {System.IObservable$1}    source12          Twelfth observable source.
             * @param   {System.IObservable$1}    source13          Thirteenth observable source.
             * @param   {System.IObservable$1}    source14          Fourteenth observable source.
             * @param   {System.IObservable$1}    source15          Fifteenth observable source.
             * @param   {System.IObservable$1}    source16          Sixteenth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke whenever any of the sources produces an element.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            combineLatest$7: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TSource15, TSource16, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, source16, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (source9 == null) {
                    throw new System.ArgumentNullException("source9");
                }
                if (source10 == null) {
                    throw new System.ArgumentNullException("source10");
                }
                if (source11 == null) {
                    throw new System.ArgumentNullException("source11");
                }
                if (source12 == null) {
                    throw new System.ArgumentNullException("source12");
                }
                if (source13 == null) {
                    throw new System.ArgumentNullException("source13");
                }
                if (source14 == null) {
                    throw new System.ArgumentNullException("source14");
                }
                if (source15 == null) {
                    throw new System.ArgumentNullException("source15");
                }
                if (source16 == null) {
                    throw new System.ArgumentNullException("source16");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest$7(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TSource15, TSource16, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, source16, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                    TSource           The type of the elements in the source sequences.
             * @param   {Function}                                    TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.Collections.Generic.IEnumerable$1}    sources           Observable sources.
             * @param   {System.Func}                                 resultSelector    Function to invoke whenever any of the sources produces an element. For efficiency, the input list is reused after the selector returns. Either aggregate or copy the values during the function call.
             * @return  {System.IObservable$1}                                          An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            combineLatest: function (TSource, TResult, sources, resultSelector) {
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest(TSource, TResult, sources, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by emitting a list with the latest source elements whenever any of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                    TSource    The type of the elements in the source sequences, and in the lists in the result sequence.
             * @param   {System.Collections.Generic.IEnumerable$1}    sources    Observable sources.
             * @return  {System.IObservable$1}                                   An observable sequence containing lists of the latest elements of the sources.
             */
            combineLatest$16: function (TSource, sources) {
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest$16(TSource, sources);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by emitting a list with the latest source elements whenever any of the observable sequences produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                        TSource    The type of the elements in the source sequences, and in the lists in the result sequence.
             * @param   {Array.<System.IObservable$1>}    sources    Observable sources.
             * @return  {System.IObservable$1}                       An observable sequence containing lists of the latest elements of the sources.
             */
            combineLatest$17: function (TSource, sources) {
                if (sources === void 0) { sources = []; }
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$combineLatest$17(TSource, sources);
            },
            /**
             * Concatenates the second observable sequence to the first observable sequence upon successful termination of the first.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequences.
             * @param   {System.IObservable$1}    first      First observable sequence.
             * @param   {System.IObservable$1}    second     Second observable sequence.
             * @return  {System.IObservable$1}               An observable sequence that contains the elements of the first sequence, followed by those of the second the sequence.
             */
            concat$1: function (TSource, first, second) {
                if (first == null) {
                    throw new System.ArgumentNullException("first");
                }
                if (second == null) {
                    throw new System.ArgumentNullException("second");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$concat$1(TSource, first, second);
            },
            /**
             * Concatenates all of the specified observable sequences, as long as the previous observable sequence terminated successfully.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                        TSource    The type of the elements in the source sequences.
             * @param   {Array.<System.IObservable$1>}    sources    Observable sequences to concatenate.
             * @return  {System.IObservable$1}                       An observable sequence that contains the elements of each given sequence, in sequential order.
             */
            concat$2: function (TSource, sources) {
                if (sources === void 0) { sources = []; }
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$concat$2(TSource, sources);
            },
            /**
             * Concatenates all observable sequences in the given enumerable sequence, as long as the previous observable sequence terminated successfully.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                    TSource    The type of the elements in the source sequences.
             * @param   {System.Collections.Generic.IEnumerable$1}    sources    Observable sequences to concatenate.
             * @return  {System.IObservable$1}                                   An observable sequence that contains the elements of each given sequence, in sequential order.
             */
            concat: function (TSource, sources) {
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$concat(TSource, sources);
            },
            /**
             * Concatenates all inner observable sequences, as long as the previous observable sequence terminated successfully.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequences.
             * @param   {System.IObservable$1}    sources    Observable sequence of inner observable sequences.
             * @return  {System.IObservable$1}               An observable sequence that contains the elements of each observed inner sequence, in sequential order.
             */
            concat$3: function (TSource, sources) {
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$concat$3(TSource, sources);
            },
            /**
             * Merges elements from all inner observable sequences into a single observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequences.
             * @param   {System.IObservable$1}    sources    Observable sequence of inner observable sequences.
             * @return  {System.IObservable$1}               The observable sequence that merges the elements of the inner sequences.
             */
            merge$7: function (TSource, sources) {
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$merge$7(TSource, sources);
            },
            /**
             * Merges elements from all inner observable sequences into a single observable sequence, limiting the number of concurrent subscriptions to inner sequences.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than or equal to zero.
             * @param   {Function}                TSource          The type of the elements in the source sequences.
             * @param   {System.IObservable$1}    sources          Observable sequence of inner observable sequences.
             * @param   {number}                  maxConcurrent    Maximum number of inner observable sequences being subscribed to concurrently.
             * @return  {System.IObservable$1}                     The observable sequence that merges the elements of the inner sequences.
             */
            merge$8: function (TSource, sources, maxConcurrent) {
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }
                if (maxConcurrent <= 0) {
                    throw new System.ArgumentOutOfRangeException("maxConcurrent");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$merge$8(TSource, sources, maxConcurrent);
            },
            /**
             * Merges elements from all observable sequences in the given enumerable sequence into a single observable sequence, limiting the number of concurrent subscriptions to inner sequences.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than or equal to zero.
             * @param   {Function}                                    TSource          The type of the elements in the source sequences.
             * @param   {System.Collections.Generic.IEnumerable$1}    sources          Enumerable sequence of observable sequences.
             * @param   {number}                                      maxConcurrent    Maximum number of observable sequences being subscribed to concurrently.
             * @return  {System.IObservable$1}                                         The observable sequence that merges the elements of the observable sequences.
             */
            merge$1: function (TSource, sources, maxConcurrent) {
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }
                if (maxConcurrent <= 0) {
                    throw new System.ArgumentOutOfRangeException("maxConcurrent");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$merge$1(TSource, sources, maxConcurrent);
            },
            /**
             * Merges elements from all observable sequences in the given enumerable sequence into a single observable sequence, limiting the number of concurrent subscriptions to inner sequences, and using the specified scheduler for enumeration of and subscription to the sources.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than or equal to zero.
             * @param   {Function}                                    TSource          The type of the elements in the source sequences.
             * @param   {System.Collections.Generic.IEnumerable$1}    sources          Enumerable sequence of observable sequences.
             * @param   {number}                                      maxConcurrent    Maximum number of observable sequences being subscribed to concurrently.
             * @param   {System.Reactive.Concurrency.IScheduler}      scheduler        Scheduler to run the enumeration of the sequence of sources on.
             * @return  {System.IObservable$1}                                         The observable sequence that merges the elements of the observable sequences.
             */
            merge$2: function (TSource, sources, maxConcurrent, scheduler) {
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }
                if (maxConcurrent <= 0) {
                    throw new System.ArgumentOutOfRangeException("maxConcurrent");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$merge$2(TSource, sources, maxConcurrent, scheduler);
            },
            /**
             * Merges elements from two observable sequences into a single observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequences.
             * @param   {System.IObservable$1}    first      First observable sequence.
             * @param   {System.IObservable$1}    second     Second observable sequence.
             * @return  {System.IObservable$1}               The observable sequence that merges the elements of the given sequences.
             */
            merge$4: function (TSource, first, second) {
                if (first == null) {
                    throw new System.ArgumentNullException("first");
                }
                if (second == null) {
                    throw new System.ArgumentNullException("second");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$merge$4(TSource, first, second);
            },
            /**
             * Merges elements from two observable sequences into a single observable sequence, using the specified scheduler for enumeration of and subscription to the sources.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TSource      The type of the elements in the source sequences.
             * @param   {System.IObservable$1}                      first        First observable sequence.
             * @param   {System.IObservable$1}                      second       Second observable sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler used to introduce concurrency for making subscriptions to the given sequences.
             * @return  {System.IObservable$1}                                   The observable sequence that merges the elements of the given sequences.
             */
            merge$5: function (TSource, first, second, scheduler) {
                if (first == null) {
                    throw new System.ArgumentNullException("first");
                }
                if (second == null) {
                    throw new System.ArgumentNullException("second");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$merge$5(TSource, first, second, scheduler);
            },
            /**
             * Merges elements from all of the specified observable sequences into a single observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                        TSource    The type of the elements in the source sequences.
             * @param   {Array.<System.IObservable$1>}    sources    Observable sequences.
             * @return  {System.IObservable$1}                       The observable sequence that merges the elements of the observable sequences.
             */
            merge$6: function (TSource, sources) {
                if (sources === void 0) { sources = []; }
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$merge$6(TSource, sources);
            },
            /**
             * Merges elements from all of the specified observable sequences into a single observable sequence, using the specified scheduler for enumeration of and subscription to the sources.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TSource      The type of the elements in the source sequences.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the enumeration of the sequence of sources on.
             * @param   {Array.<System.IObservable$1>}              sources      Observable sequences.
             * @return  {System.IObservable$1}                                   The observable sequence that merges the elements of the observable sequences.
             */
            merge$9: function (TSource, scheduler, sources) {
                if (sources === void 0) { sources = []; }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$merge$9(TSource, scheduler, sources);
            },
            /**
             * Merges elements from all observable sequences in the given enumerable sequence into a single observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                    TSource    The type of the elements in the source sequences.
             * @param   {System.Collections.Generic.IEnumerable$1}    sources    Enumerable sequence of observable sequences.
             * @return  {System.IObservable$1}                                   The observable sequence that merges the elements of the observable sequences.
             */
            merge: function (TSource, sources) {
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$merge(TSource, sources);
            },
            /**
             * Merges elements from all observable sequences in the given enumerable sequence into a single observable sequence, using the specified scheduler for enumeration of and subscription to the sources.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                    TSource      The type of the elements in the source sequences.
             * @param   {System.Collections.Generic.IEnumerable$1}    sources      Enumerable sequence of observable sequences.
             * @param   {System.Reactive.Concurrency.IScheduler}      scheduler    Scheduler to run the enumeration of the sequence of sources on.
             * @return  {System.IObservable$1}                                     The observable sequence that merges the elements of the observable sequences.
             */
            merge$3: function (TSource, sources, scheduler) {
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$merge$3(TSource, sources, scheduler);
            },
            /**
             * Concatenates the second observable sequence to the first observable sequence upon successful or exceptional termination of the first.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequences.
             * @param   {System.IObservable$1}    first      First observable sequence whose exception (if any) is caught.
             * @param   {System.IObservable$1}    second     Second observable sequence used to produce results after the first sequence terminates.
             * @return  {System.IObservable$1}               An observable sequence that concatenates the first and second sequence, even if the first sequence terminates exceptionally.
             */
            onErrorResumeNext$1: function (TSource, first, second) {
                if (first == null) {
                    throw new System.ArgumentNullException("first");
                }
                if (second == null) {
                    throw new System.ArgumentNullException("second");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$onErrorResumeNext$1(TSource, first, second);
            },
            /**
             * Concatenates all of the specified observable sequences, even if the previous observable sequence terminated exceptionally.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                        TSource    The type of the elements in the source sequences.
             * @param   {Array.<System.IObservable$1>}    sources    Observable sequences to concatenate.
             * @return  {System.IObservable$1}                       An observable sequence that concatenates the source sequences, even if a sequence terminates exceptionally.
             */
            onErrorResumeNext$2: function (TSource, sources) {
                if (sources === void 0) { sources = []; }
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$onErrorResumeNext$2(TSource, sources);
            },
            /**
             * Concatenates all observable sequences in the given enumerable sequence, even if the previous observable sequence terminated exceptionally.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                    TSource    The type of the elements in the source sequences.
             * @param   {System.Collections.Generic.IEnumerable$1}    sources    Observable sequences to concatenate.
             * @return  {System.IObservable$1}                                   An observable sequence that concatenates the source sequences, even if a sequence terminates exceptionally.
             */
            onErrorResumeNext: function (TSource, sources) {
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$onErrorResumeNext(TSource, sources);
            },
            /**
             * Returns the elements from the source observable sequence only after the other observable sequence produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {Function}                TOther     The type of the elements in the other sequence that indicates the end of skip behavior.
             * @param   {System.IObservable$1}    source     Source sequence to propagate elements for.
             * @param   {System.IObservable$1}    other      Observable sequence that triggers propagation of elements of the source sequence.
             * @return  {System.IObservable$1}               An observable sequence containing the elements of the source sequence starting from the point the other sequence triggered propagation.
             */
            skipUntil$2: function (TSource, TOther, source, other) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (other == null) {
                    throw new System.ArgumentNullException("other");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$skipUntil$2(TSource, TOther, source, other);
            },
            /**
             * Skips elements from the observable source sequence until the specified start time.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                 TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}     source       Source sequence to skip elements for.
             * @param   {System.DateTimeOffset}    startTime    Time to start taking elements from the source sequence. If this value is less than or equal to DateTimeOffset.UtcNow, no elements will be skipped.
             * @return  {System.IObservable$1}                  An observable sequence with the elements skipped until the specified start time.
             */
            skipUntil: function (TSource, source, startTime) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$skipUntil(TSource, source, startTime.$clone());
            },
            /**
             * Skips elements from the observable source sequence until the specified start time, using the specified scheduler to run timers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to skip elements for.
             * @param   {System.DateTimeOffset}                     startTime    Time to start taking elements from the source sequence. If this value is less than or equal to DateTimeOffset.UtcNow, no elements will be skipped.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the timer on.
             * @return  {System.IObservable$1}                                   An observable sequence with the elements skipped until the specified start time.
             */
            skipUntil$1: function (TSource, source, startTime, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$skipUntil$1(TSource, source, startTime.$clone(), scheduler);
            },
            /**
             * Transforms an observable sequence of observable sequences into an observable sequence 
             producing values only from the most recent observable sequence.
             Each time a new inner observable sequence is received, unsubscribe from the 
             previous inner observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequences.
             * @param   {System.IObservable$1}    sources    Observable sequence of inner observable sequences.
             * @return  {System.IObservable$1}               The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.
             */
            switch: function (TSource, sources) {
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$switch(TSource, sources);
            },
            /**
             * Returns the elements from the source observable sequence until the other observable sequence produces an element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {Function}                TOther     The type of the elements in the other sequence that indicates the end of take behavior.
             * @param   {System.IObservable$1}    source     Source sequence to propagate elements for.
             * @param   {System.IObservable$1}    other      Observable sequence that terminates propagation of elements of the source sequence.
             * @return  {System.IObservable$1}               An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation.
             */
            takeUntil$2: function (TSource, TOther, source, other) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (other == null) {
                    throw new System.ArgumentNullException("other");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$takeUntil$2(TSource, TOther, source, other);
            },
            /**
             * Takes elements for the specified duration until the specified end time.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                 TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}     source     Source sequence to take elements from.
             * @param   {System.DateTimeOffset}    endTime    Time to stop taking elements from the source sequence. If this value is less than or equal to DateTimeOffset.UtcNow, the result stream will complete immediately.
             * @return  {System.IObservable$1}                An observable sequence with the elements taken until the specified end time.
             */
            takeUntil: function (TSource, source, endTime) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$takeUntil(TSource, source, endTime.$clone());
            },
            /**
             * Takes elements for the specified duration until the specified end time, using the specified scheduler to run timers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to take elements from.
             * @param   {System.DateTimeOffset}                     endTime      Time to stop taking elements from the source sequence. If this value is less than or equal to DateTimeOffset.UtcNow, the result stream will complete immediately.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the timer on.
             * @return  {System.IObservable$1}                                   An observable sequence with the elements taken until the specified end time.
             */
            takeUntil$1: function (TSource, source, endTime, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$takeUntil$1(TSource, source, endTime.$clone(), scheduler);
            },
            /**
             * Projects each element of an observable sequence into consecutive non-overlapping windows.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource                  The type of the elements in the source sequence, and in the windows in the result sequence.
             * @param   {Function}                TWindowClosing           The type of the elements in the sequences indicating window closing events.
             * @param   {System.IObservable$1}    source                   Source sequence to produce windows over.
             * @param   {System.Func}             windowClosingSelector    A function invoked to define the boundaries of the produced windows. A new window is started when the previous one is closed.
             * @return  {System.IObservable$1}                             An observable sequence of windows.
             */
            window$8: function (TSource, TWindowClosing, source, windowClosingSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(windowClosingSelector, null)) {
                    throw new System.ArgumentNullException("windowClosingSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$window$8(TSource, TWindowClosing, source, windowClosingSelector);
            },
            /**
             * Projects each element of an observable sequence into zero or more windows.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource                  The type of the elements in the source sequence, and in the windows in the result sequence.
             * @param   {Function}                TWindowOpening           The type of the elements in the sequence indicating window opening events, also passed to the closing selector to obtain a sequence of window closing events.
             * @param   {Function}                TWindowClosing           The type of the elements in the sequences indicating window closing events.
             * @param   {System.IObservable$1}    source                   Source sequence to produce windows over.
             * @param   {System.IObservable$1}    windowOpenings           Observable sequence whose elements denote the creation of new windows.
             * @param   {System.Func}             windowClosingSelector    A function invoked to define the closing of each produced window.
             * @return  {System.IObservable$1}                             An observable sequence of windows.
             */
            window$10: function (TSource, TWindowOpening, TWindowClosing, source, windowOpenings, windowClosingSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (windowOpenings == null) {
                    throw new System.ArgumentNullException("windowOpenings");
                }
                if (Bridge.staticEquals(windowClosingSelector, null)) {
                    throw new System.ArgumentNullException("windowClosingSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$window$10(TSource, TWindowOpening, TWindowClosing, source, windowOpenings, windowClosingSelector);
            },
            /**
             * Projects each element of an observable sequence into consecutive non-overlapping windows.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource             The type of the elements in the source sequence, and in the windows in the result sequence.
             * @param   {Function}                TWindowBoundary     The type of the elements in the sequences indicating window boundary events.
             * @param   {System.IObservable$1}    source              Source sequence to produce windows over.
             * @param   {System.IObservable$1}    windowBoundaries    Sequence of window boundary markers. The current window is closed and a new window is opened upon receiving a boundary marker.
             * @return  {System.IObservable$1}                        An observable sequence of windows.
             */
            window$9: function (TSource, TWindowBoundary, source, windowBoundaries) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (windowBoundaries == null) {
                    throw new System.ArgumentNullException("windowBoundaries");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$window$9(TSource, TWindowBoundary, source, windowBoundaries);
            },
            /**
             * Projects each element of an observable sequence into consecutive non-overlapping windows which are produced based on element count information.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than or equal to zero.
             * @param   {Function}                TSource    The type of the elements in the source sequence, and in the windows in the result sequence.
             * @param   {System.IObservable$1}    source     Source sequence to produce windows over.
             * @param   {number}                  count      Length of each window.
             * @return  {System.IObservable$1}               An observable sequence of windows.
             */
            window: function (TSource, source, count) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (count <= 0) {
                    throw new System.ArgumentOutOfRangeException("count");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$window(TSource, source, count);
            },
            /**
             * Projects each element of an observable sequence into zero or more windows which are produced based on element count information.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> or <b /> is less than or equal to zero.
             * @param   {Function}                TSource    The type of the elements in the source sequence, and in the windows in the result sequence.
             * @param   {System.IObservable$1}    source     Source sequence to produce windows over.
             * @param   {number}                  count      Length of each window.
             * @param   {number}                  skip       Number of elements to skip between creation of consecutive windows.
             * @return  {System.IObservable$1}               An observable sequence of windows.
             */
            window$1: function (TSource, source, count, skip) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (count <= 0) {
                    throw new System.ArgumentOutOfRangeException("count");
                }
                if (skip <= 0) {
                    throw new System.ArgumentOutOfRangeException("skip");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$window$1(TSource, source, count, skip);
            },
            /**
             * Projects each element of an observable sequence into consecutive non-overlapping windows which are produced based on timing information.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                TSource     The type of the elements in the source sequence, and in the windows in the result sequence.
             * @param   {System.IObservable$1}    source      Source sequence to produce windows over.
             * @param   {System.TimeSpan}         timeSpan    Length of each window.
             * @return  {System.IObservable$1}                The sequence of windows.
             */
            window$2: function (TSource, source, timeSpan) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(timeSpan, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("timeSpan");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$window$2(TSource, source, timeSpan);
            },
            /**
             * Projects each element of an observable sequence into consecutive non-overlapping windows which are produced based on timing information, using the specified scheduler to run timers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence, and in the windows in the result sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to produce windows over.
             * @param   {System.TimeSpan}                           timeSpan     Length of each window.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run windowing timers on.
             * @return  {System.IObservable$1}                                   An observable sequence of windows.
             */
            window$5: function (TSource, source, timeSpan, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(timeSpan, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("timeSpan");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$window$5(TSource, source, timeSpan, scheduler);
            },
            /**
             * Projects each element of an observable sequence into zero or more windows which are produced based on timing information.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> or <b /> is less than TimeSpan.Zero.
             * @param   {Function}                TSource      The type of the elements in the source sequence, and in the windows in the result sequence.
             * @param   {System.IObservable$1}    source       Source sequence to produce windows over.
             * @param   {System.TimeSpan}         timeSpan     Length of each window.
             * @param   {System.TimeSpan}         timeShift    Interval between creation of consecutive windows.
             * @return  {System.IObservable$1}                 An observable sequence of windows.
             */
            window$6: function (TSource, source, timeSpan, timeShift) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(timeSpan, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("timeSpan");
                }
                if (System.TimeSpan.lt(timeShift, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("timeShift");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$window$6(TSource, source, timeSpan, timeShift);
            },
            /**
             * Projects each element of an observable sequence into zero or more windows which are produced based on timing information, using the specified scheduler to run timers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> or <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence, and in the windows in the result sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to produce windows over.
             * @param   {System.TimeSpan}                           timeSpan     Length of each window.
             * @param   {System.TimeSpan}                           timeShift    Interval between creation of consecutive windows.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run windowing timers on.
             * @return  {System.IObservable$1}                                   An observable sequence of windows.
             */
            window$7: function (TSource, source, timeSpan, timeShift, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(timeSpan, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("timeSpan");
                }
                if (System.TimeSpan.lt(timeShift, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("timeShift");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$window$7(TSource, source, timeSpan, timeShift, scheduler);
            },
            /**
             * Projects each element of an observable sequence into a window that is completed when either it's full or a given amount of time has elapsed.
             A useful real-world analogy of this overload is the behavior of a ferry leaving the dock when all seats are taken, or at the scheduled time of departure, whichever event occurs first.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero. -or- <b /> is less than or equal to zero.
             * @param   {Function}                TSource     The type of the elements in the source sequence, and in the windows in the result sequence.
             * @param   {System.IObservable$1}    source      Source sequence to produce windows over.
             * @param   {System.TimeSpan}         timeSpan    Maximum time length of a window.
             * @param   {number}                  count       Maximum element count of a window.
             * @return  {System.IObservable$1}                An observable sequence of windows.
             */
            window$3: function (TSource, source, timeSpan, count) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(timeSpan, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("timeSpan");
                }
                if (count <= 0) {
                    throw new System.ArgumentOutOfRangeException("count");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$window$3(TSource, source, timeSpan, count);
            },
            /**
             * Projects each element of an observable sequence into a window that is completed when either it's full or a given amount of time has elapsed, using the specified scheduler to run timers.
             A useful real-world analogy of this overload is the behavior of a ferry leaving the dock when all seats are taken, or at the scheduled time of departure, whichever event occurs first.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero. -or- <b /> is less than or equal to zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence, and in the windows in the result sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to produce windows over.
             * @param   {System.TimeSpan}                           timeSpan     Maximum time length of a window.
             * @param   {number}                                    count        Maximum element count of a window.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run windowing timers on.
             * @return  {System.IObservable$1}                                   An observable sequence of windows.
             */
            window$4: function (TSource, source, timeSpan, count, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(timeSpan, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("timeSpan");
                }
                if (count <= 0) {
                    throw new System.ArgumentOutOfRangeException("count");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$window$4(TSource, source, timeSpan, count, scheduler);
            },
            /**
             * Merges two observable sequences into one observable sequence by combining each element from the first source with the latest element from the second source, if any.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TFirst            The type of the elements in the first source sequence.
             * @param   {Function}                TSecond           The type of the elements in the second source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    first             First observable source.
             * @param   {System.IObservable$1}    second            Second observable source.
             * @param   {System.Func}             resultSelector    Function to invoke for each element from the first source combined with the latest element from the second source, if any.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining each element of the first source with the latest element from the second source, if any, using the specified result selector function.
             */
            withLatestFrom: function (TFirst, TSecond, TResult, first, second, resultSelector) {
                if (first == null) {
                    throw new System.ArgumentNullException("first");
                }
                if (second == null) {
                    throw new System.ArgumentNullException("second");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$withLatestFrom(TFirst, TSecond, TResult, first, second, resultSelector);
            },
            /**
             * Merges two observable sequences into one observable sequence by combining their elements in a pairwise fashion.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    first             First observable source.
             * @param   {System.IObservable$1}    second            Second observable source.
             * @param   {System.Func}             resultSelector    Function to invoke for each consecutive pair of elements from the first and second source.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of pairwise combining the elements of the first and second source using the specified result selector function.
             */
            zip$9: function (TSource1, TSource2, TResult, first, second, resultSelector) {
                if (first == null) {
                    throw new System.ArgumentNullException("first");
                }
                if (second == null) {
                    throw new System.ArgumentNullException("second");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$9(TSource1, TSource2, TResult, first, second, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.Func}             resultSelector    Function to invoke for each series of elements at corresponding indexes in the sources.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            zip$10: function (TSource1, TSource2, TSource3, TResult, source1, source2, source3, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$10(TSource1, TSource2, TSource3, TResult, source1, source2, source3, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke for each series of elements at corresponding indexes in the sources.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            zip$11: function (TSource1, TSource2, TSource3, TSource4, TResult, source1, source2, source3, source4, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$11(TSource1, TSource2, TSource3, TSource4, TResult, source1, source2, source3, source4, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke for each series of elements at corresponding indexes in the sources.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            zip$12: function (TSource1, TSource2, TSource3, TSource4, TSource5, TResult, source1, source2, source3, source4, source5, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$12(TSource1, TSource2, TSource3, TSource4, TSource5, TResult, source1, source2, source3, source4, source5, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke for each series of elements at corresponding indexes in the sources.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            zip$13: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TResult, source1, source2, source3, source4, source5, source6, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$13(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TResult, source1, source2, source3, source4, source5, source6, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.Func}             resultSelector    Function to invoke for each series of elements at corresponding indexes in the sources.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            zip$14: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TResult, source1, source2, source3, source4, source5, source6, source7, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$14(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TResult, source1, source2, source3, source4, source5, source6, source7, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke for each series of elements at corresponding indexes in the sources.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            zip$15: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TResult, source1, source2, source3, source4, source5, source6, source7, source8, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$15(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TResult, source1, source2, source3, source4, source5, source6, source7, source8, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TSource9          The type of the elements in the ninth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.IObservable$1}    source9           Ninth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke for each series of elements at corresponding indexes in the sources.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            zip$16: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (source9 == null) {
                    throw new System.ArgumentNullException("source9");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$16(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TSource9          The type of the elements in the ninth source sequence.
             * @param   {Function}                TSource10         The type of the elements in the tenth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.IObservable$1}    source9           Ninth observable source.
             * @param   {System.IObservable$1}    source10          Tenth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke for each series of elements at corresponding indexes in the sources.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            zip$1: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (source9 == null) {
                    throw new System.ArgumentNullException("source9");
                }
                if (source10 == null) {
                    throw new System.ArgumentNullException("source10");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$1(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TSource9          The type of the elements in the ninth source sequence.
             * @param   {Function}                TSource10         The type of the elements in the tenth source sequence.
             * @param   {Function}                TSource11         The type of the elements in the eleventh source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.IObservable$1}    source9           Ninth observable source.
             * @param   {System.IObservable$1}    source10          Tenth observable source.
             * @param   {System.IObservable$1}    source11          Eleventh observable source.
             * @param   {System.Func}             resultSelector    Function to invoke for each series of elements at corresponding indexes in the sources.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            zip$2: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (source9 == null) {
                    throw new System.ArgumentNullException("source9");
                }
                if (source10 == null) {
                    throw new System.ArgumentNullException("source10");
                }
                if (source11 == null) {
                    throw new System.ArgumentNullException("source11");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$2(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TSource9          The type of the elements in the ninth source sequence.
             * @param   {Function}                TSource10         The type of the elements in the tenth source sequence.
             * @param   {Function}                TSource11         The type of the elements in the eleventh source sequence.
             * @param   {Function}                TSource12         The type of the elements in the twelfth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.IObservable$1}    source9           Ninth observable source.
             * @param   {System.IObservable$1}    source10          Tenth observable source.
             * @param   {System.IObservable$1}    source11          Eleventh observable source.
             * @param   {System.IObservable$1}    source12          Twelfth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke for each series of elements at corresponding indexes in the sources.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            zip$3: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (source9 == null) {
                    throw new System.ArgumentNullException("source9");
                }
                if (source10 == null) {
                    throw new System.ArgumentNullException("source10");
                }
                if (source11 == null) {
                    throw new System.ArgumentNullException("source11");
                }
                if (source12 == null) {
                    throw new System.ArgumentNullException("source12");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$3(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TSource9          The type of the elements in the ninth source sequence.
             * @param   {Function}                TSource10         The type of the elements in the tenth source sequence.
             * @param   {Function}                TSource11         The type of the elements in the eleventh source sequence.
             * @param   {Function}                TSource12         The type of the elements in the twelfth source sequence.
             * @param   {Function}                TSource13         The type of the elements in the thirteenth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.IObservable$1}    source9           Ninth observable source.
             * @param   {System.IObservable$1}    source10          Tenth observable source.
             * @param   {System.IObservable$1}    source11          Eleventh observable source.
             * @param   {System.IObservable$1}    source12          Twelfth observable source.
             * @param   {System.IObservable$1}    source13          Thirteenth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke for each series of elements at corresponding indexes in the sources.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            zip$4: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (source9 == null) {
                    throw new System.ArgumentNullException("source9");
                }
                if (source10 == null) {
                    throw new System.ArgumentNullException("source10");
                }
                if (source11 == null) {
                    throw new System.ArgumentNullException("source11");
                }
                if (source12 == null) {
                    throw new System.ArgumentNullException("source12");
                }
                if (source13 == null) {
                    throw new System.ArgumentNullException("source13");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$4(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TSource9          The type of the elements in the ninth source sequence.
             * @param   {Function}                TSource10         The type of the elements in the tenth source sequence.
             * @param   {Function}                TSource11         The type of the elements in the eleventh source sequence.
             * @param   {Function}                TSource12         The type of the elements in the twelfth source sequence.
             * @param   {Function}                TSource13         The type of the elements in the thirteenth source sequence.
             * @param   {Function}                TSource14         The type of the elements in the fourteenth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.IObservable$1}    source9           Ninth observable source.
             * @param   {System.IObservable$1}    source10          Tenth observable source.
             * @param   {System.IObservable$1}    source11          Eleventh observable source.
             * @param   {System.IObservable$1}    source12          Twelfth observable source.
             * @param   {System.IObservable$1}    source13          Thirteenth observable source.
             * @param   {System.IObservable$1}    source14          Fourteenth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke for each series of elements at corresponding indexes in the sources.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            zip$5: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (source9 == null) {
                    throw new System.ArgumentNullException("source9");
                }
                if (source10 == null) {
                    throw new System.ArgumentNullException("source10");
                }
                if (source11 == null) {
                    throw new System.ArgumentNullException("source11");
                }
                if (source12 == null) {
                    throw new System.ArgumentNullException("source12");
                }
                if (source13 == null) {
                    throw new System.ArgumentNullException("source13");
                }
                if (source14 == null) {
                    throw new System.ArgumentNullException("source14");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$5(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TSource9          The type of the elements in the ninth source sequence.
             * @param   {Function}                TSource10         The type of the elements in the tenth source sequence.
             * @param   {Function}                TSource11         The type of the elements in the eleventh source sequence.
             * @param   {Function}                TSource12         The type of the elements in the twelfth source sequence.
             * @param   {Function}                TSource13         The type of the elements in the thirteenth source sequence.
             * @param   {Function}                TSource14         The type of the elements in the fourteenth source sequence.
             * @param   {Function}                TSource15         The type of the elements in the fifteenth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.IObservable$1}    source9           Ninth observable source.
             * @param   {System.IObservable$1}    source10          Tenth observable source.
             * @param   {System.IObservable$1}    source11          Eleventh observable source.
             * @param   {System.IObservable$1}    source12          Twelfth observable source.
             * @param   {System.IObservable$1}    source13          Thirteenth observable source.
             * @param   {System.IObservable$1}    source14          Fourteenth observable source.
             * @param   {System.IObservable$1}    source15          Fifteenth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke for each series of elements at corresponding indexes in the sources.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            zip$6: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TSource15, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (source9 == null) {
                    throw new System.ArgumentNullException("source9");
                }
                if (source10 == null) {
                    throw new System.ArgumentNullException("source10");
                }
                if (source11 == null) {
                    throw new System.ArgumentNullException("source11");
                }
                if (source12 == null) {
                    throw new System.ArgumentNullException("source12");
                }
                if (source13 == null) {
                    throw new System.ArgumentNullException("source13");
                }
                if (source14 == null) {
                    throw new System.ArgumentNullException("source14");
                }
                if (source15 == null) {
                    throw new System.ArgumentNullException("source15");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$6(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TSource15, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource1          The type of the elements in the first source sequence.
             * @param   {Function}                TSource2          The type of the elements in the second source sequence.
             * @param   {Function}                TSource3          The type of the elements in the third source sequence.
             * @param   {Function}                TSource4          The type of the elements in the fourth source sequence.
             * @param   {Function}                TSource5          The type of the elements in the fifth source sequence.
             * @param   {Function}                TSource6          The type of the elements in the sixth source sequence.
             * @param   {Function}                TSource7          The type of the elements in the seventh source sequence.
             * @param   {Function}                TSource8          The type of the elements in the eighth source sequence.
             * @param   {Function}                TSource9          The type of the elements in the ninth source sequence.
             * @param   {Function}                TSource10         The type of the elements in the tenth source sequence.
             * @param   {Function}                TSource11         The type of the elements in the eleventh source sequence.
             * @param   {Function}                TSource12         The type of the elements in the twelfth source sequence.
             * @param   {Function}                TSource13         The type of the elements in the thirteenth source sequence.
             * @param   {Function}                TSource14         The type of the elements in the fourteenth source sequence.
             * @param   {Function}                TSource15         The type of the elements in the fifteenth source sequence.
             * @param   {Function}                TSource16         The type of the elements in the sixteenth source sequence.
             * @param   {Function}                TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}    source1           First observable source.
             * @param   {System.IObservable$1}    source2           Second observable source.
             * @param   {System.IObservable$1}    source3           Third observable source.
             * @param   {System.IObservable$1}    source4           Fourth observable source.
             * @param   {System.IObservable$1}    source5           Fifth observable source.
             * @param   {System.IObservable$1}    source6           Sixth observable source.
             * @param   {System.IObservable$1}    source7           Seventh observable source.
             * @param   {System.IObservable$1}    source8           Eighth observable source.
             * @param   {System.IObservable$1}    source9           Ninth observable source.
             * @param   {System.IObservable$1}    source10          Tenth observable source.
             * @param   {System.IObservable$1}    source11          Eleventh observable source.
             * @param   {System.IObservable$1}    source12          Twelfth observable source.
             * @param   {System.IObservable$1}    source13          Thirteenth observable source.
             * @param   {System.IObservable$1}    source14          Fourteenth observable source.
             * @param   {System.IObservable$1}    source15          Fifteenth observable source.
             * @param   {System.IObservable$1}    source16          Sixteenth observable source.
             * @param   {System.Func}             resultSelector    Function to invoke for each series of elements at corresponding indexes in the sources.
             * @return  {System.IObservable$1}                      An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            zip$7: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TSource15, TSource16, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, source16, resultSelector) {
                if (source1 == null) {
                    throw new System.ArgumentNullException("source1");
                }
                if (source2 == null) {
                    throw new System.ArgumentNullException("source2");
                }
                if (source3 == null) {
                    throw new System.ArgumentNullException("source3");
                }
                if (source4 == null) {
                    throw new System.ArgumentNullException("source4");
                }
                if (source5 == null) {
                    throw new System.ArgumentNullException("source5");
                }
                if (source6 == null) {
                    throw new System.ArgumentNullException("source6");
                }
                if (source7 == null) {
                    throw new System.ArgumentNullException("source7");
                }
                if (source8 == null) {
                    throw new System.ArgumentNullException("source8");
                }
                if (source9 == null) {
                    throw new System.ArgumentNullException("source9");
                }
                if (source10 == null) {
                    throw new System.ArgumentNullException("source10");
                }
                if (source11 == null) {
                    throw new System.ArgumentNullException("source11");
                }
                if (source12 == null) {
                    throw new System.ArgumentNullException("source12");
                }
                if (source13 == null) {
                    throw new System.ArgumentNullException("source13");
                }
                if (source14 == null) {
                    throw new System.ArgumentNullException("source14");
                }
                if (source15 == null) {
                    throw new System.ArgumentNullException("source15");
                }
                if (source16 == null) {
                    throw new System.ArgumentNullException("source16");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$7(TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TSource15, TSource16, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, source16, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                    TSource           The type of the elements in the source sequences.
             * @param   {Function}                                    TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.Collections.Generic.IEnumerable$1}    sources           Observable sources.
             * @param   {System.Func}                                 resultSelector    Function to invoke for each series of elements at corresponding indexes in the sources.
             * @return  {System.IObservable$1}                                          An observable sequence containing the result of combining elements of the sources using the specified result selector function.
             */
            zip: function (TSource, TResult, sources, resultSelector) {
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip(TSource, TResult, sources, resultSelector);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by emitting a list with the elements of the observable sequences at corresponding indexes.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                                    TSource    The type of the elements in the source sequences, and in the lists in the result sequence.
             * @param   {System.Collections.Generic.IEnumerable$1}    sources    Observable sources.
             * @return  {System.IObservable$1}                                   An observable sequence containing lists of elements at corresponding indexes.
             */
            zip$17: function (TSource, sources) {
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$17(TSource, sources);
            },
            /**
             * Merges the specified observable sequences into one observable sequence by emitting a list with the elements of the observable sequences at corresponding indexes.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                        TSource    The type of the elements in the source sequences, and in the lists in the result sequence.
             * @param   {Array.<System.IObservable$1>}    sources    Observable sources.
             * @return  {System.IObservable$1}                       An observable sequence containing lists of elements at corresponding indexes.
             */
            zip$18: function (TSource, sources) {
                if (sources === void 0) { sources = []; }
                if (sources == null) {
                    throw new System.ArgumentNullException("sources");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$18(TSource, sources);
            },
            /**
             * Merges an observable sequence and an enumerable sequence into one observable sequence by using the selector function.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                    TSource1          The type of the elements in the first observable source sequence.
             * @param   {Function}                                    TSource2          The type of the elements in the second enumerable source sequence.
             * @param   {Function}                                    TResult           The type of the elements in the result sequence, returned by the selector function.
             * @param   {System.IObservable$1}                        first             First observable source.
             * @param   {System.Collections.Generic.IEnumerable$1}    second            Second enumerable source.
             * @param   {System.Func}                                 resultSelector    Function to invoke for each consecutive pair of elements from the first and second source.
             * @return  {System.IObservable$1}                                          An observable sequence containing the result of pairwise combining the elements of the first and second source using the specified result selector function.
             */
            zip$8: function (TSource1, TSource2, TResult, first, second, resultSelector) {
                if (first == null) {
                    throw new System.ArgumentNullException("first");
                }
                if (second == null) {
                    throw new System.ArgumentNullException("second");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$zip$8(TSource1, TSource2, TResult, first, second, resultSelector);
            },
            /**
             * Hides the identity of an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     An observable sequence whose identity to hide.
             * @return  {System.IObservable$1}               An observable sequence that hides the identity of the source sequence.
             */
            asObservable: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$asObservable(TSource, source);
            },
            /**
             * Dematerializes the explicit notification values of an observable sequence as implicit notifications.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements materialized in the source sequence notification objects.
             * @param   {System.IObservable$1}    source     An observable sequence containing explicit notification values which have to be turned into implicit notifications.
             * @return  {System.IObservable$1}               An observable sequence exhibiting the behavior corresponding to the source sequence's notification values.
             */
            dematerialize: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$dematerialize(TSource, source);
            },
            /**
             * Returns an observable sequence that contains only distinct contiguous elements.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     An observable sequence to retain distinct contiguous elements for.
             * @return  {System.IObservable$1}               An observable sequence only containing the distinct contiguous elements from the source sequence.
             */
            distinctUntilChanged: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$distinctUntilChanged(TSource, source);
            },
            /**
             * Returns an observable sequence that contains only distinct contiguous elements according to the comparer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                          TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                              source      An observable sequence to retain distinct contiguous elements for.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer    Equality comparer for source elements.
             * @return  {System.IObservable$1}                                          An observable sequence only containing the distinct contiguous elements from the source sequence.
             */
            distinctUntilChanged$1: function (TSource, source, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$distinctUntilChanged$1(TSource, source, comparer);
            },
            /**
             * Returns an observable sequence that contains only distinct contiguous elements according to the keySelector.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource        The type of the elements in the source sequence.
             * @param   {Function}                TKey           The type of the discriminator key computed for each element in the source sequence.
             * @param   {System.IObservable$1}    source         An observable sequence to retain distinct contiguous elements for, based on a computed key value.
             * @param   {System.Func}             keySelector    A function to compute the comparison key for each element.
             * @return  {System.IObservable$1}                   An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.
             */
            distinctUntilChanged$2: function (TSource, TKey, source, keySelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$distinctUntilChanged$2(TSource, TKey, source, keySelector);
            },
            /**
             * Returns an observable sequence that contains only distinct contiguous elements according to the keySelector and the comparer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                          TSource        The type of the elements in the source sequence.
             * @param   {Function}                                          TKey           The type of the discriminator key computed for each element in the source sequence.
             * @param   {System.IObservable$1}                              source         An observable sequence to retain distinct contiguous elements for, based on a computed key value.
             * @param   {System.Func}                                       keySelector    A function to compute the comparison key for each element.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer       Equality comparer for computed key values.
             * @return  {System.IObservable$1}                                             An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.
             */
            distinctUntilChanged$3: function (TSource, TKey, source, keySelector, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$distinctUntilChanged$3(TSource, TKey, source, keySelector, comparer);
            },
            /**
             * Invokes an action for each element in the observable sequence, and propagates all observer messages through the result sequence.
             This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence.
             * @param   {System.Action}           onNext     Action to invoke for each element in the observable sequence.
             * @return  {System.IObservable$1}               The source sequence with the side-effecting behavior applied.
             */
            do: function (TSource, source, onNext) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(onNext, null)) {
                    throw new System.ArgumentNullException("onNext");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$do(TSource, source, onNext);
            },
            /**
             * Invokes an action for each element in the observable sequence and invokes an action upon graceful termination of the observable sequence.
             This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource        The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source         Source sequence.
             * @param   {System.Action}           onNext         Action to invoke for each element in the observable sequence.
             * @param   {System.Action}           onCompleted    Action to invoke upon graceful termination of the observable sequence.
             * @return  {System.IObservable$1}                   The source sequence with the side-effecting behavior applied.
             */
            do$1: function (TSource, source, onNext, onCompleted) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(onNext, null)) {
                    throw new System.ArgumentNullException("onNext");
                }
                if (Bridge.staticEquals(onCompleted, null)) {
                    throw new System.ArgumentNullException("onCompleted");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$do$1(TSource, source, onNext, onCompleted);
            },
            /**
             * Invokes an action for each element in the observable sequence and invokes an action upon exceptional termination of the observable sequence.
             This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence.
             * @param   {System.Action}           onNext     Action to invoke for each element in the observable sequence.
             * @param   {System.Action}           onError    Action to invoke upon exceptional termination of the observable sequence.
             * @return  {System.IObservable$1}               The source sequence with the side-effecting behavior applied.
             */
            do$2: function (TSource, source, onNext, onError) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(onNext, null)) {
                    throw new System.ArgumentNullException("onNext");
                }
                if (Bridge.staticEquals(onError, null)) {
                    throw new System.ArgumentNullException("onError");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$do$2(TSource, source, onNext, onError);
            },
            /**
             * Invokes an action for each element in the observable sequence and invokes an action upon graceful or exceptional termination of the observable sequence.
             This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource        The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source         Source sequence.
             * @param   {System.Action}           onNext         Action to invoke for each element in the observable sequence.
             * @param   {System.Action}           onError        Action to invoke upon exceptional termination of the observable sequence.
             * @param   {System.Action}           onCompleted    Action to invoke upon graceful termination of the observable sequence.
             * @return  {System.IObservable$1}                   The source sequence with the side-effecting behavior applied.
             */
            do$3: function (TSource, source, onNext, onError, onCompleted) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(onNext, null)) {
                    throw new System.ArgumentNullException("onNext");
                }
                if (Bridge.staticEquals(onError, null)) {
                    throw new System.ArgumentNullException("onError");
                }
                if (Bridge.staticEquals(onCompleted, null)) {
                    throw new System.ArgumentNullException("onCompleted");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$do$3(TSource, source, onNext, onError, onCompleted);
            },
            /**
             * Invokes the observer's methods for each message in the source sequence.
             This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      Source sequence.
             * @param   {System.IObserver$1}      observer    Observer whose methods to invoke as part of the source sequence's observation.
             * @return  {System.IObservable$1}                The source sequence with the side-effecting behavior applied.
             */
            do$4: function (TSource, source, observer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (observer == null) {
                    throw new System.ArgumentNullException("observer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$do$4(TSource, source, observer);
            },
            /**
             * Invokes a specified action after the source observable sequence terminates gracefully or exceptionally.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource          The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source           Source sequence.
             * @param   {System.Action}           finallyAction    Action to invoke after the source observable sequence terminates.
             * @return  {System.IObservable$1}                     Source sequence with the action-invoking termination behavior applied.
             */
            finally: function (TSource, source, finallyAction) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(finallyAction, null)) {
                    throw new System.ArgumentNullException("finallyAction");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$finally(TSource, source, finallyAction);
            },
            /**
             * Ignores all elements in an observable sequence leaving only the termination messages.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence.
             * @return  {System.IObservable$1}               An empty observable sequence that signals termination, successful or exceptional, of the source sequence.
             */
            ignoreElements: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$ignoreElements(TSource, source);
            },
            /**
             * Materializes the implicit notifications of an observable sequence as explicit notification values.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     An observable sequence to get notification values for.
             * @return  {System.IObservable$1}               An observable sequence containing the materialized notification values from the source sequence.
             */
            materialize: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$materialize(TSource, source);
            },
            /**
             * Repeats the source observable sequence until it successfully terminates.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Observable sequence to repeat until it successfully terminates.
             * @return  {System.IObservable$1}               An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.
             */
            retry: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$retry(TSource, source);
            },
            /**
             * Repeats the source observable sequence the specified number of times or until it successfully terminates.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than zero.
             * @param   {Function}                TSource       The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source        Observable sequence to repeat until it successfully terminates.
             * @param   {number}                  retryCount    Number of times to repeat the sequence.
             * @return  {System.IObservable$1}                  An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.
             */
            retry$1: function (TSource, source, retryCount) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (retryCount < 0) {
                    throw new System.ArgumentOutOfRangeException("retryCount");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$retry$1(TSource, source, retryCount);
            },
            /**
             * Applies an accumulator function over an observable sequence and returns each intermediate result. The specified seed value is used as the initial accumulator value.
             For aggregation behavior with no intermediate results, see {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource        The type of the elements in the source sequence.
             * @param   {Function}                TAccumulate    The type of the result of the aggregation.
             * @param   {System.IObservable$1}    source         An observable sequence to accumulate over.
             * @param   {TAccumulate}             seed           The initial accumulator value.
             * @param   {System.Func}             accumulator    An accumulator function to be invoked on each element.
             * @return  {System.IObservable$1}                   An observable sequence containing the accumulated values.
             */
            scan$1: function (TSource, TAccumulate, source, seed, accumulator) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(accumulator, null)) {
                    throw new System.ArgumentNullException("accumulator");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$scan$1(TSource, TAccumulate, source, seed, accumulator);
            },
            /**
             * Applies an accumulator function over an observable sequence and returns each intermediate result.
             For aggregation behavior with no intermediate results, see {@link }.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource        The type of the elements in the source sequence and the result of the aggregation.
             * @param   {System.IObservable$1}    source         An observable sequence to accumulate over.
             * @param   {System.Func}             accumulator    An accumulator function to be invoked on each element.
             * @return  {System.IObservable$1}                   An observable sequence containing the accumulated values.
             */
            scan: function (TSource, source, accumulator) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(accumulator, null)) {
                    throw new System.ArgumentNullException("accumulator");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$scan(TSource, source, accumulator);
            },
            /**
             * Bypasses a specified number of elements at the end of an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than zero.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence.
             * @param   {number}                  count      Number of elements to bypass at the end of the source sequence.
             * @return  {System.IObservable$1}               An observable sequence containing the source sequence elements except for the bypassed ones at the end.
             */
            skipLast: function (TSource, source, count) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException("count");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$skipLast(TSource, source, count);
            },
            /**
             * Skips elements for the specified duration from the end of the observable source sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      Source sequence to skip elements for.
             * @param   {System.TimeSpan}         duration    Duration for skipping elements from the end of the sequence.
             * @return  {System.IObservable$1}                An observable sequence with the elements skipped during the specified duration from the end of the source sequence.
             */
            skipLast$1: function (TSource, source, duration) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(duration, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("duration");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$skipLast$1(TSource, source, duration);
            },
            /**
             * Skips elements for the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to skip elements for.
             * @param   {System.TimeSpan}                           duration     Duration for skipping elements from the end of the sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the timer on.
             * @return  {System.IObservable$1}                                   An observable sequence with the elements skipped during the specified duration from the end of the source sequence.
             */
            skipLast$2: function (TSource, source, duration, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(duration, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("duration");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$skipLast$2(TSource, source, duration, scheduler);
            },
            /**
             * Prepends a sequence of values to an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence to prepend values to.
             * @param   {Array.<TSource>}         values     Values to prepend to the specified sequence.
             * @return  {System.IObservable$1}               The source sequence prepended with the specified values.
             */
            startWith: function (TSource, source, values) {
                if (values === void 0) { values = []; }
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (values == null) {
                    throw new System.ArgumentNullException("values");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$startWith(TSource, source, values);
            },
            /**
             * Prepends a sequence of values to an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                    TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                        source     Source sequence to prepend values to.
             * @param   {System.Collections.Generic.IEnumerable$1}    values     Values to prepend to the specified sequence.
             * @return  {System.IObservable$1}                                   The source sequence prepended with the specified values.
             */
            startWith$1: function (TSource, source, values) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (values == null) {
                    throw new System.ArgumentNullException("values");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$startWith$1(TSource, source, values);
            },
            /**
             * Prepends a sequence of values to an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to prepend values to.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to emit the prepended values on.
             * @param   {Array.<TSource>}                           values       Values to prepend to the specified sequence.
             * @return  {System.IObservable$1}                                   The source sequence prepended with the specified values.
             */
            startWith$2: function (TSource, source, scheduler, values) {
                if (values === void 0) { values = []; }
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (values == null) {
                    throw new System.ArgumentNullException("values");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$startWith$2(TSource, source, scheduler, values);
            },
            /**
             * Prepends a sequence of values to an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                    TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                        source       Source sequence to prepend values to.
             * @param   {System.Reactive.Concurrency.IScheduler}      scheduler    Scheduler to emit the prepended values on.
             * @param   {System.Collections.Generic.IEnumerable$1}    values       Values to prepend to the specified sequence.
             * @return  {System.IObservable$1}                                     The source sequence prepended with the specified values.
             */
            startWith$3: function (TSource, source, scheduler, values) {
                //
                // NOTE: For some reason, someone introduced this signature which is inconsistent with the Rx pattern of putting the IScheduler last.
                //       We can't change it at this point because of compatibility.
                //

                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (values == null) {
                    throw new System.ArgumentNullException("values");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$startWith$3(TSource, source, scheduler, values);
            },
            /**
             * Returns a specified number of contiguous elements from the end of an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than zero.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence.
             * @param   {number}                  count      Number of elements to take from the end of the source sequence.
             * @return  {System.IObservable$1}               An observable sequence containing the specified number of elements from the end of the source sequence.
             */
            takeLast: function (TSource, source, count) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException("count");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$takeLast(TSource, source, count);
            },
            /**
             * Returns a specified number of contiguous elements from the end of an observable sequence, using the specified scheduler to drain the queue.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence.
             * @param   {number}                                    count        Number of elements to take from the end of the source sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler used to drain the queue upon completion of the source sequence.
             * @return  {System.IObservable$1}                                   An observable sequence containing the specified number of elements from the end of the source sequence.
             */
            takeLast$1: function (TSource, source, count, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException("count");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$takeLast$1(TSource, source, count, scheduler);
            },
            /**
             * Returns elements within the specified duration from the end of the observable source sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      Source sequence to take elements from.
             * @param   {System.TimeSpan}         duration    Duration for taking elements from the end of the sequence.
             * @return  {System.IObservable$1}                An observable sequence with the elements taken during the specified duration from the end of the source sequence.
             */
            takeLast$2: function (TSource, source, duration) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(duration, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("duration");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$takeLast$2(TSource, source, duration);
            },
            /**
             * Returns elements within the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to take elements from.
             * @param   {System.TimeSpan}                           duration     Duration for taking elements from the end of the sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the timer on.
             * @return  {System.IObservable$1}                                   An observable sequence with the elements taken during the specified duration from the end of the source sequence.
             */
            takeLast$3: function (TSource, source, duration, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(duration, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("duration");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$takeLast$3(TSource, source, duration, scheduler);
            },
            /**
             * Returns elements within the specified duration from the end of the observable source sequence, using the specified schedulers to run timers and to drain the collected elements.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TSource           The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source            Source sequence to take elements from.
             * @param   {System.TimeSpan}                           duration          Duration for taking elements from the end of the sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}    timerScheduler    Scheduler to run the timer on.
             * @param   {System.Reactive.Concurrency.IScheduler}    loopScheduler     Scheduler to drain the collected elements.
             * @return  {System.IObservable$1}                                        An observable sequence with the elements taken during the specified duration from the end of the source sequence.
             */
            takeLast$4: function (TSource, source, duration, timerScheduler, loopScheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(duration, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("duration");
                }
                if (timerScheduler == null) {
                    throw new System.ArgumentNullException("timerScheduler");
                }
                if (loopScheduler == null) {
                    throw new System.ArgumentNullException("loopScheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$takeLast$4(TSource, source, duration, timerScheduler, loopScheduler);
            },
            /**
             * Returns a list with the specified number of contiguous elements from the end of an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than zero.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence.
             * @param   {number}                  count      Number of elements to take from the end of the source sequence.
             * @return  {System.IObservable$1}               An observable sequence containing a single list with the specified number of elements from the end of the source sequence.
             */
            takeLastBuffer: function (TSource, source, count) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException("count");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$takeLastBuffer(TSource, source, count);
            },
            /**
             * Returns a list with the elements within the specified duration from the end of the observable source sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      Source sequence to take elements from.
             * @param   {System.TimeSpan}         duration    Duration for taking elements from the end of the sequence.
             * @return  {System.IObservable$1}                An observable sequence containing a single list with the elements taken during the specified duration from the end of the source sequence.
             */
            takeLastBuffer$1: function (TSource, source, duration) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(duration, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("duration");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$takeLastBuffer$1(TSource, source, duration);
            },
            /**
             * Returns a list with the elements within the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to take elements from.
             * @param   {System.TimeSpan}                           duration     Duration for taking elements from the end of the sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the timer on.
             * @return  {System.IObservable$1}                                   An observable sequence containing a single list with the elements taken during the specified duration from the end of the source sequence.
             */
            takeLastBuffer$2: function (TSource, source, duration, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(duration, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("duration");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$takeLastBuffer$2(TSource, source, duration, scheduler);
            },
            /**
             * Converts the elements of an observable sequence to the specified type.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TResult    The type to convert the elements in the source sequence to.
             * @param   {System.IObservable$1}    source     The observable sequence that contains the elements to be converted.
             * @return  {System.IObservable$1}               An observable sequence that contains each element of the source sequence converted to the specified type.
             */
            cast: function (TResult, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$cast(TResult, source);
            },
            /**
             * Returns the elements of the specified sequence or the type parameter's default value in a singleton sequence if the sequence is empty.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence (if any), whose default value will be taken if the sequence is empty.
             * @param   {System.IObservable$1}    source     The sequence to return a default value for if it is empty.
             * @return  {System.IObservable$1}               An observable sequence that contains the default value for the TSource type if the source is empty; otherwise, the elements of the source itself.
             */
            defaultIfEmpty: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$defaultIfEmpty(TSource, source);
            },
            /**
             * Returns the elements of the specified sequence or the specified value in a singleton sequence if the sequence is empty.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource         The type of the elements in the source sequence (if any), and the specified default value which will be taken if the sequence is empty.
             * @param   {System.IObservable$1}    source          The sequence to return the specified value for if it is empty.
             * @param   {TSource}                 defaultValue    The value to return if the sequence is empty.
             * @return  {System.IObservable$1}                    An observable sequence that contains the specified default value if the source is empty; otherwise, the elements of the source itself.
             */
            defaultIfEmpty$1: function (TSource, source, defaultValue) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$defaultIfEmpty$1(TSource, source, defaultValue);
            },
            /**
             * Returns an observable sequence that contains only distinct elements.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     An observable sequence to retain distinct elements for.
             * @return  {System.IObservable$1}               An observable sequence only containing the distinct elements from the source sequence.
             */
            distinct: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$distinct(TSource, source);
            },
            /**
             * Returns an observable sequence that contains only distinct elements according to the comparer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                          TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                              source      An observable sequence to retain distinct elements for.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer    Equality comparer for source elements.
             * @return  {System.IObservable$1}                                          An observable sequence only containing the distinct elements from the source sequence.
             */
            distinct$1: function (TSource, source, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$distinct$1(TSource, source, comparer);
            },
            /**
             * Returns an observable sequence that contains only distinct elements according to the keySelector.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource        The type of the elements in the source sequence.
             * @param   {Function}                TKey           The type of the discriminator key computed for each element in the source sequence.
             * @param   {System.IObservable$1}    source         An observable sequence to retain distinct elements for.
             * @param   {System.Func}             keySelector    A function to compute the comparison key for each element.
             * @return  {System.IObservable$1}                   An observable sequence only containing the distinct elements, based on a computed key value, from the source sequence.
             */
            distinct$2: function (TSource, TKey, source, keySelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$distinct$2(TSource, TKey, source, keySelector);
            },
            /**
             * Returns an observable sequence that contains only distinct elements according to the keySelector and the comparer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                          TSource        The type of the elements in the source sequence.
             * @param   {Function}                                          TKey           The type of the discriminator key computed for each element in the source sequence.
             * @param   {System.IObservable$1}                              source         An observable sequence to retain distinct elements for.
             * @param   {System.Func}                                       keySelector    A function to compute the comparison key for each element.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer       Equality comparer for source elements.
             * @return  {System.IObservable$1}                                             An observable sequence only containing the distinct elements, based on a computed key value, from the source sequence.
             */
            distinct$3: function (TSource, TKey, source, keySelector, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$distinct$3(TSource, TKey, source, keySelector, comparer);
            },
            /**
             * Groups the elements of an observable sequence according to a specified key selector function.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource        The type of the elements in the source sequence.
             * @param   {Function}                TKey           The type of the grouping key computed for each element in the source sequence.
             * @param   {System.IObservable$1}    source         An observable sequence whose elements to group.
             * @param   {System.Func}             keySelector    A function to extract the key for each element.
             * @return  {System.IObservable$1}                   A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
             */
            groupBy: function (TSource, TKey, source, keySelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$groupBy(TSource, TKey, source, keySelector);
            },
            /**
             * Groups the elements of an observable sequence according to a specified key selector function and comparer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                          TSource        The type of the elements in the source sequence.
             * @param   {Function}                                          TKey           The type of the grouping key computed for each element in the source sequence.
             * @param   {System.IObservable$1}                              source         An observable sequence whose elements to group.
             * @param   {System.Func}                                       keySelector    A function to extract the key for each element.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer       An equality comparer to compare keys with.
             * @return  {System.IObservable$1}                                             A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
             */
            groupBy$1: function (TSource, TKey, source, keySelector, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$groupBy$1(TSource, TKey, source, keySelector, comparer);
            },
            /**
             * Groups the elements of an observable sequence and selects the resulting elements by using a specified function.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource            The type of the elements in the source sequence.
             * @param   {Function}                TKey               The type of the grouping key computed for each element in the source sequence.
             * @param   {Function}                TElement           The type of the elements within the groups computed for each element in the source sequence.
             * @param   {System.IObservable$1}    source             An observable sequence whose elements to group.
             * @param   {System.Func}             keySelector        A function to extract the key for each element.
             * @param   {System.Func}             elementSelector    A function to map each source element to an element in an observable group.
             * @return  {System.IObservable$1}                       A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
             */
            groupBy$4: function (TSource, TKey, TElement, source, keySelector, elementSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (Bridge.staticEquals(elementSelector, null)) {
                    throw new System.ArgumentNullException("elementSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$groupBy$4(TSource, TKey, TElement, source, keySelector, elementSelector);
            },
            /**
             * Groups the elements of an observable sequence according to a specified key selector function and comparer and selects the resulting elements by using a specified function.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                                          TSource            The type of the elements in the source sequence.
             * @param   {Function}                                          TKey               The type of the grouping key computed for each element in the source sequence.
             * @param   {Function}                                          TElement           The type of the elements within the groups computed for each element in the source sequence.
             * @param   {System.IObservable$1}                              source             An observable sequence whose elements to group.
             * @param   {System.Func}                                       keySelector        A function to extract the key for each element.
             * @param   {System.Func}                                       elementSelector    A function to map each source element to an element in an observable group.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer           An equality comparer to compare keys with.
             * @return  {System.IObservable$1}                                                 A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
             */
            groupBy$5: function (TSource, TKey, TElement, source, keySelector, elementSelector, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (Bridge.staticEquals(elementSelector, null)) {
                    throw new System.ArgumentNullException("elementSelector");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$groupBy$5(TSource, TKey, TElement, source, keySelector, elementSelector, comparer);
            },
            /**
             * Groups the elements of an observable sequence with the specified initial capacity according to a specified key selector function.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than 0.
             * @param   {Function}                TSource        The type of the elements in the source sequence.
             * @param   {Function}                TKey           The type of the grouping key computed for each element in the source sequence.
             * @param   {System.IObservable$1}    source         An observable sequence whose elements to group.
             * @param   {System.Func}             keySelector    A function to extract the key for each element.
             * @param   {number}                  capacity       The initial number of elements that the underlying dictionary can contain.
             * @return  {System.IObservable$1}                   A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
             */
            groupBy$2: function (TSource, TKey, source, keySelector, capacity) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (capacity < 0) {
                    throw new System.ArgumentOutOfRangeException("capacity");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$groupBy$2(TSource, TKey, source, keySelector, capacity);
            },
            /**
             * Groups the elements of an observable sequence with the specified initial capacity according to a specified key selector function and comparer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @throws <b /> is less than 0.
             * @param   {Function}                                          TSource        The type of the elements in the source sequence.
             * @param   {Function}                                          TKey           The type of the grouping key computed for each element in the source sequence.
             * @param   {System.IObservable$1}                              source         An observable sequence whose elements to group.
             * @param   {System.Func}                                       keySelector    A function to extract the key for each element.
             * @param   {number}                                            capacity       The initial number of elements that the underlying dictionary can contain.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer       An equality comparer to compare keys with.
             * @return  {System.IObservable$1}                                             A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
             */
            groupBy$3: function (TSource, TKey, source, keySelector, capacity, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (capacity < 0) {
                    throw new System.ArgumentOutOfRangeException("capacity");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$groupBy$3(TSource, TKey, source, keySelector, capacity, comparer);
            },
            /**
             * Groups the elements of an observable sequence with the specified initial capacity and selects the resulting elements by using a specified function.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @throws <b /> is less than 0.
             * @param   {Function}                TSource            The type of the elements in the source sequence.
             * @param   {Function}                TKey               The type of the grouping key computed for each element in the source sequence.
             * @param   {Function}                TElement           The type of the elements within the groups computed for each element in the source sequence.
             * @param   {System.IObservable$1}    source             An observable sequence whose elements to group.
             * @param   {System.Func}             keySelector        A function to extract the key for each element.
             * @param   {System.Func}             elementSelector    A function to map each source element to an element in an observable group.
             * @param   {number}                  capacity           The initial number of elements that the underlying dictionary can contain.
             * @return  {System.IObservable$1}                       A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
             */
            groupBy$6: function (TSource, TKey, TElement, source, keySelector, elementSelector, capacity) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (Bridge.staticEquals(elementSelector, null)) {
                    throw new System.ArgumentNullException("elementSelector");
                }
                if (capacity < 0) {
                    throw new System.ArgumentOutOfRangeException("capacity");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$groupBy$6(TSource, TKey, TElement, source, keySelector, elementSelector, capacity);
            },
            /**
             * Groups the elements of an observable sequence with the specified initial capacity according to a specified key selector function and comparer and selects the resulting elements by using a specified function.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @throws <b /> is less than 0.
             * @param   {Function}                                          TSource            The type of the elements in the source sequence.
             * @param   {Function}                                          TKey               The type of the grouping key computed for each element in the source sequence.
             * @param   {Function}                                          TElement           The type of the elements within the groups computed for each element in the source sequence.
             * @param   {System.IObservable$1}                              source             An observable sequence whose elements to group.
             * @param   {System.Func}                                       keySelector        A function to extract the key for each element.
             * @param   {System.Func}                                       elementSelector    A function to map each source element to an element in an observable group.
             * @param   {number}                                            capacity           The initial number of elements that the underlying dictionary can contain.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer           An equality comparer to compare keys with.
             * @return  {System.IObservable$1}                                                 A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
             */
            groupBy$7: function (TSource, TKey, TElement, source, keySelector, elementSelector, capacity, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (Bridge.staticEquals(elementSelector, null)) {
                    throw new System.ArgumentNullException("elementSelector");
                }
                if (capacity < 0) {
                    throw new System.ArgumentOutOfRangeException("capacity");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$groupBy$7(TSource, TKey, TElement, source, keySelector, elementSelector, capacity, comparer);
            },
            /**
             * Groups the elements of an observable sequence according to a specified key selector function and comparer and selects the resulting elements by using a specified function.
             A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same
             key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                                          TSource             The type of the elements in the source sequence.
             * @param   {Function}                                          TKey                The type of the grouping key computed for each element in the source sequence.
             * @param   {Function}                                          TElement            The type of the elements within the groups computed for each element in the source sequence.
             * @param   {Function}                                          TDuration           The type of the elements in the duration sequences obtained for each group to denote its lifetime.
             * @param   {System.IObservable$1}                              source              An observable sequence whose elements to group.
             * @param   {System.Func}                                       keySelector         A function to extract the key for each element.
             * @param   {System.Func}                                       elementSelector     A function to map each source element to an element in an observable group.
             * @param   {System.Func}                                       durationSelector    A function to signal the expiration of a group.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer            An equality comparer to compare keys with.
             * @return  {System.IObservable$1}                                                  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
             If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encountered.
             */
            groupByUntil$5: function (TSource, TKey, TElement, TDuration, source, keySelector, elementSelector, durationSelector, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (Bridge.staticEquals(elementSelector, null)) {
                    throw new System.ArgumentNullException("elementSelector");
                }
                if (Bridge.staticEquals(durationSelector, null)) {
                    throw new System.ArgumentNullException("durationSelector");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$groupByUntil$5(TSource, TKey, TElement, TDuration, source, keySelector, elementSelector, durationSelector, comparer);
            },
            /**
             * Groups the elements of an observable sequence according to a specified key selector function and selects the resulting elements by using a specified function.
             A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same
             key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource             The type of the elements in the source sequence.
             * @param   {Function}                TKey                The type of the grouping key computed for each element in the source sequence.
             * @param   {Function}                TElement            The type of the elements within the groups computed for each element in the source sequence.
             * @param   {Function}                TDuration           The type of the elements in the duration sequences obtained for each group to denote its lifetime.
             * @param   {System.IObservable$1}    source              An observable sequence whose elements to group.
             * @param   {System.Func}             keySelector         A function to extract the key for each element.
             * @param   {System.Func}             elementSelector     A function to map each source element to an element in an observable group.
             * @param   {System.Func}             durationSelector    A function to signal the expiration of a group.
             * @return  {System.IObservable$1}                        A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
             If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.
             */
            groupByUntil$4: function (TSource, TKey, TElement, TDuration, source, keySelector, elementSelector, durationSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (Bridge.staticEquals(elementSelector, null)) {
                    throw new System.ArgumentNullException("elementSelector");
                }
                if (Bridge.staticEquals(durationSelector, null)) {
                    throw new System.ArgumentNullException("durationSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$groupByUntil$4(TSource, TKey, TElement, TDuration, source, keySelector, elementSelector, durationSelector);
            },
            /**
             * Groups the elements of an observable sequence according to a specified key selector function and comparer.
             A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same
             key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                                          TSource             The type of the elements in the source sequence.
             * @param   {Function}                                          TKey                The type of the grouping key computed for each element in the source sequence.
             * @param   {Function}                                          TDuration           The type of the elements in the duration sequences obtained for each group to denote its lifetime.
             * @param   {System.IObservable$1}                              source              An observable sequence whose elements to group.
             * @param   {System.Func}                                       keySelector         A function to extract the key for each element.
             * @param   {System.Func}                                       durationSelector    A function to signal the expiration of a group.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer            An equality comparer to compare keys with.
             * @return  {System.IObservable$1}                                                  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
             If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.
             */
            groupByUntil$1: function (TSource, TKey, TDuration, source, keySelector, durationSelector, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (Bridge.staticEquals(durationSelector, null)) {
                    throw new System.ArgumentNullException("durationSelector");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$groupByUntil$1(TSource, TKey, TDuration, source, keySelector, durationSelector, comparer);
            },
            /**
             * Groups the elements of an observable sequence according to a specified key selector function.
             A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same
             key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource             The type of the elements in the source sequence.
             * @param   {Function}                TKey                The type of the grouping key computed for each element in the source sequence.
             * @param   {Function}                TDuration           The type of the elements in the duration sequences obtained for each group to denote its lifetime.
             * @param   {System.IObservable$1}    source              An observable sequence whose elements to group.
             * @param   {System.Func}             keySelector         A function to extract the key for each element.
             * @param   {System.Func}             durationSelector    A function to signal the expiration of a group.
             * @return  {System.IObservable$1}                        A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
             If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.
             */
            groupByUntil: function (TSource, TKey, TDuration, source, keySelector, durationSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (Bridge.staticEquals(durationSelector, null)) {
                    throw new System.ArgumentNullException("durationSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$groupByUntil(TSource, TKey, TDuration, source, keySelector, durationSelector);
            },
            /**
             * Groups the elements of an observable sequence with the specified initial capacity according to a specified key selector function and comparer and selects the resulting elements by using a specified function.
             A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same
             key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @throws <b /> is less than 0.
             * @param   {Function}                                          TSource             The type of the elements in the source sequence.
             * @param   {Function}                                          TKey                The type of the grouping key computed for each element in the source sequence.
             * @param   {Function}                                          TElement            The type of the elements within the groups computed for each element in the source sequence.
             * @param   {Function}                                          TDuration           The type of the elements in the duration sequences obtained for each group to denote its lifetime.
             * @param   {System.IObservable$1}                              source              An observable sequence whose elements to group.
             * @param   {System.Func}                                       keySelector         A function to extract the key for each element.
             * @param   {System.Func}                                       elementSelector     A function to map each source element to an element in an observable group.
             * @param   {System.Func}                                       durationSelector    A function to signal the expiration of a group.
             * @param   {number}                                            capacity            The initial number of elements that the underlying dictionary can contain.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer            An equality comparer to compare keys with.
             * @return  {System.IObservable$1}                                                  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
             If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encountered.
             */
            groupByUntil$7: function (TSource, TKey, TElement, TDuration, source, keySelector, elementSelector, durationSelector, capacity, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (Bridge.staticEquals(elementSelector, null)) {
                    throw new System.ArgumentNullException("elementSelector");
                }
                if (Bridge.staticEquals(durationSelector, null)) {
                    throw new System.ArgumentNullException("durationSelector");
                }
                if (capacity < 0) {
                    throw new System.ArgumentOutOfRangeException("capacity");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$groupByUntil$7(TSource, TKey, TElement, TDuration, source, keySelector, elementSelector, durationSelector, capacity, comparer);
            },
            /**
             * Groups the elements of an observable sequence with the specified initial capacity according to a specified key selector function and selects the resulting elements by using a specified function.
             A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same
             key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @throws <b /> is less than 0.
             * @param   {Function}                TSource             The type of the elements in the source sequence.
             * @param   {Function}                TKey                The type of the grouping key computed for each element in the source sequence.
             * @param   {Function}                TElement            The type of the elements within the groups computed for each element in the source sequence.
             * @param   {Function}                TDuration           The type of the elements in the duration sequences obtained for each group to denote its lifetime.
             * @param   {System.IObservable$1}    source              An observable sequence whose elements to group.
             * @param   {System.Func}             keySelector         A function to extract the key for each element.
             * @param   {System.Func}             elementSelector     A function to map each source element to an element in an observable group.
             * @param   {System.Func}             durationSelector    A function to signal the expiration of a group.
             * @param   {number}                  capacity            The initial number of elements that the underlying dictionary can contain.
             * @return  {System.IObservable$1}                        A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
             If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.
             */
            groupByUntil$6: function (TSource, TKey, TElement, TDuration, source, keySelector, elementSelector, durationSelector, capacity) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (Bridge.staticEquals(elementSelector, null)) {
                    throw new System.ArgumentNullException("elementSelector");
                }
                if (Bridge.staticEquals(durationSelector, null)) {
                    throw new System.ArgumentNullException("durationSelector");
                }
                if (capacity < 0) {
                    throw new System.ArgumentOutOfRangeException("capacity");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$groupByUntil$6(TSource, TKey, TElement, TDuration, source, keySelector, elementSelector, durationSelector, capacity);
            },
            /**
             * Groups the elements of an observable sequence with the specified initial capacity according to a specified key selector function and comparer.
             A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same
             key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @throws <b /> is less than 0.
             * @param   {Function}                                          TSource             The type of the elements in the source sequence.
             * @param   {Function}                                          TKey                The type of the grouping key computed for each element in the source sequence.
             * @param   {Function}                                          TDuration           The type of the elements in the duration sequences obtained for each group to denote its lifetime.
             * @param   {System.IObservable$1}                              source              An observable sequence whose elements to group.
             * @param   {System.Func}                                       keySelector         A function to extract the key for each element.
             * @param   {System.Func}                                       durationSelector    A function to signal the expiration of a group.
             * @param   {number}                                            capacity            The initial number of elements that the underlying dictionary can contain.
             * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer            An equality comparer to compare keys with.
             * @return  {System.IObservable$1}                                                  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
             If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.
             */
            groupByUntil$3: function (TSource, TKey, TDuration, source, keySelector, durationSelector, capacity, comparer) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (Bridge.staticEquals(durationSelector, null)) {
                    throw new System.ArgumentNullException("durationSelector");
                }
                if (capacity < 0) {
                    throw new System.ArgumentOutOfRangeException("capacity");
                }
                if (comparer == null) {
                    throw new System.ArgumentNullException("comparer");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$groupByUntil$3(TSource, TKey, TDuration, source, keySelector, durationSelector, capacity, comparer);
            },
            /**
             * Groups the elements of an observable sequence with the specified initial capacity according to a specified key selector function.
             A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same
             key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @throws <b /> is less than 0.
             * @param   {Function}                TSource             The type of the elements in the source sequence.
             * @param   {Function}                TKey                The type of the grouping key computed for each element in the source sequence.
             * @param   {Function}                TDuration           The type of the elements in the duration sequences obtained for each group to denote its lifetime.
             * @param   {System.IObservable$1}    source              An observable sequence whose elements to group.
             * @param   {System.Func}             keySelector         A function to extract the key for each element.
             * @param   {System.Func}             durationSelector    A function to signal the expiration of a group.
             * @param   {number}                  capacity            The initial number of elements that the underlying dictionary can contain.
             * @return  {System.IObservable$1}                        A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
             If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.
             */
            groupByUntil$2: function (TSource, TKey, TDuration, source, keySelector, durationSelector, capacity) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(keySelector, null)) {
                    throw new System.ArgumentNullException("keySelector");
                }
                if (Bridge.staticEquals(durationSelector, null)) {
                    throw new System.ArgumentNullException("durationSelector");
                }
                if (capacity < 0) {
                    throw new System.ArgumentOutOfRangeException("capacity");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$groupByUntil$2(TSource, TKey, TDuration, source, keySelector, durationSelector, capacity);
            },
            /**
             * Correlates the elements of two sequences based on overlapping durations, and groups the results.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TLeft                    The type of the elements in the left source sequence.
             * @param   {Function}                TRight                   The type of the elements in the right source sequence.
             * @param   {Function}                TLeftDuration            The type of the elements in the duration sequence denoting the computed duration of each element in the left source sequence.
             * @param   {Function}                TRightDuration           The type of the elements in the duration sequence denoting the computed duration of each element in the right source sequence.
             * @param   {Function}                TResult                  The type of the elements in the result sequence, obtained by invoking the result selector function for source elements with overlapping duration.
             * @param   {System.IObservable$1}    left                     The left observable sequence to join elements for.
             * @param   {System.IObservable$1}    right                    The right observable sequence to join elements for.
             * @param   {System.Func}             leftDurationSelector     A function to select the duration of each element of the left observable sequence, used to determine overlap.
             * @param   {System.Func}             rightDurationSelector    A function to select the duration of each element of the right observable sequence, used to determine overlap.
             * @param   {System.Func}             resultSelector           A function invoked to compute a result element for any element of the left sequence with overlapping elements from the right observable sequence.
             * @return  {System.IObservable$1}                             An observable sequence that contains result elements computed from source elements that have an overlapping duration.
             */
            groupJoin: function (TLeft, TRight, TLeftDuration, TRightDuration, TResult, left, right, leftDurationSelector, rightDurationSelector, resultSelector) {
                if (left == null) {
                    throw new System.ArgumentNullException("left");
                }
                if (right == null) {
                    throw new System.ArgumentNullException("right");
                }
                if (Bridge.staticEquals(leftDurationSelector, null)) {
                    throw new System.ArgumentNullException("leftDurationSelector");
                }
                if (Bridge.staticEquals(rightDurationSelector, null)) {
                    throw new System.ArgumentNullException("rightDurationSelector");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$groupJoin(TLeft, TRight, TLeftDuration, TRightDuration, TResult, left, right, leftDurationSelector, rightDurationSelector, resultSelector);
            },
            /**
             * Correlates the elements of two sequences based on overlapping durations.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TLeft                    The type of the elements in the left source sequence.
             * @param   {Function}                TRight                   The type of the elements in the right source sequence.
             * @param   {Function}                TLeftDuration            The type of the elements in the duration sequence denoting the computed duration of each element in the left source sequence.
             * @param   {Function}                TRightDuration           The type of the elements in the duration sequence denoting the computed duration of each element in the right source sequence.
             * @param   {Function}                TResult                  The type of the elements in the result sequence, obtained by invoking the result selector function for source elements with overlapping duration.
             * @param   {System.IObservable$1}    left                     The left observable sequence to join elements for.
             * @param   {System.IObservable$1}    right                    The right observable sequence to join elements for.
             * @param   {System.Func}             leftDurationSelector     A function to select the duration of each element of the left observable sequence, used to determine overlap.
             * @param   {System.Func}             rightDurationSelector    A function to select the duration of each element of the right observable sequence, used to determine overlap.
             * @param   {System.Func}             resultSelector           A function invoked to compute a result element for any two overlapping elements of the left and right observable sequences.
             * @return  {System.IObservable$1}                             An observable sequence that contains result elements computed from source elements that have an overlapping duration.
             */
            join: function (TLeft, TRight, TLeftDuration, TRightDuration, TResult, left, right, leftDurationSelector, rightDurationSelector, resultSelector) {
                if (left == null) {
                    throw new System.ArgumentNullException("left");
                }
                if (right == null) {
                    throw new System.ArgumentNullException("right");
                }
                if (Bridge.staticEquals(leftDurationSelector, null)) {
                    throw new System.ArgumentNullException("leftDurationSelector");
                }
                if (Bridge.staticEquals(rightDurationSelector, null)) {
                    throw new System.ArgumentNullException("rightDurationSelector");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$join(TLeft, TRight, TLeftDuration, TRightDuration, TResult, left, right, leftDurationSelector, rightDurationSelector, resultSelector);
            },
            /**
             * Filters the elements of an observable sequence based on the specified type.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TResult    The type to filter the elements in the source sequence on.
             * @param   {System.IObservable$1}    source     The observable sequence that contains the elements to be filtered.
             * @return  {System.IObservable$1}               An observable sequence that contains elements from the input sequence of type TResult.
             */
            ofType: function (TResult, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$ofType(TResult, source);
            },
            /**
             * Projects each element of an observable sequence into a new form.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {Function}                TResult     The type of the elements in the result sequence, obtained by running the selector function for each element in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of elements to invoke a transform function on.
             * @param   {System.Func}             selector    A transform function to apply to each source element.
             * @return  {System.IObservable$1}                An observable sequence whose elements are the result of invoking the transform function on each element of source.
             */
            select: function (TSource, TResult, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$select(TSource, TResult, source, selector);
            },
            /**
             * Projects each element of an observable sequence into a new form by incorporating the element's index.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {Function}                TResult     The type of the elements in the result sequence, obtained by running the selector function for each element in the source sequence.
             * @param   {System.IObservable$1}    source      A sequence of elements to invoke a transform function on.
             * @param   {System.Func}             selector    A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
             * @return  {System.IObservable$1}                An observable sequence whose elements are the result of invoking the transform function on each element of source.
             */
            select$1: function (TSource, TResult, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$select$1(TSource, TResult, source, selector);
            },
            /**
             * Projects each element of the source observable sequence to the other observable sequence and merges the resulting observable sequences into one observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {Function}                TOther     The type of the elements in the other sequence and the elements in the result sequence.
             * @param   {System.IObservable$1}    source     An observable sequence of elements to project.
             * @param   {System.IObservable$1}    other      An observable sequence to project each element from the source sequence onto.
             * @return  {System.IObservable$1}               An observable sequence whose elements are the result of projecting each source element onto the other sequence and merging all the resulting sequences together.
             */
            selectMany$6: function (TSource, TOther, source, other) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (other == null) {
                    throw new System.ArgumentNullException("other");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$selectMany$6(TSource, TOther, source, other);
            },
            /**
             * Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {Function}                TResult     The type of the elements in the projected inner sequences and the elements in the merged result sequence.
             * @param   {System.IObservable$1}    source      An observable sequence of elements to project.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.
             */
            selectMany$1: function (TSource, TResult, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$selectMany$1(TSource, TResult, source, selector);
            },
            /**
             * Projects each element of an observable sequence to an observable sequence by incorporating the element's index and merges the resulting observable sequences into one observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {Function}                TResult     The type of the elements in the projected inner sequences and the elements in the merged result sequence.
             * @param   {System.IObservable$1}    source      An observable sequence of elements to project.
             * @param   {System.Func}             selector    A transform function to apply to each element; the second parameter of the function represents the index of the source element.
             * @return  {System.IObservable$1}                An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.
             */
            selectMany$4: function (TSource, TResult, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$selectMany$4(TSource, TResult, source, selector);
            },
            /**
             * Projects each element of an observable sequence to an observable sequence, invokes the result selector for the source element and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource               The type of the elements in the source sequence.
             * @param   {Function}                TCollection           The type of the elements in the projected intermediate sequences.
             * @param   {Function}                TResult               The type of the elements in the result sequence, obtained by using the selector to combine source sequence elements with their corresponding intermediate sequence elements.
             * @param   {System.IObservable$1}    source                An observable sequence of elements to project.
             * @param   {System.Func}             collectionSelector    A transform function to apply to each element.
             * @param   {System.Func}             resultSelector        A transform function to apply to each element of the intermediate sequence.
             * @return  {System.IObservable$1}                          An observable sequence whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of the input sequence and then mapping each of those sequence elements and their corresponding source element to a result element.
             */
            selectMany$8: function (TSource, TCollection, TResult, source, collectionSelector, resultSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(collectionSelector, null)) {
                    throw new System.ArgumentNullException("collectionSelector");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$selectMany$8(TSource, TCollection, TResult, source, collectionSelector, resultSelector);
            },
            /**
             * Projects each element of an observable sequence to an observable sequence by incorporating the element's index, invokes the result selector for the source element and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource               The type of the elements in the source sequence.
             * @param   {Function}                TCollection           The type of the elements in the projected intermediate sequences.
             * @param   {Function}                TResult               The type of the elements in the result sequence, obtained by using the selector to combine source sequence elements with their corresponding intermediate sequence elements.
             * @param   {System.IObservable$1}    source                An observable sequence of elements to project.
             * @param   {System.Func}             collectionSelector    A transform function to apply to each element; the second parameter of the function represents the index of the source element.
             * @param   {System.Func}             resultSelector        A transform function to apply to each element of the intermediate sequence; the second parameter of the function represents the index of the source element and the fourth parameter represents the index of the intermediate element.
             * @return  {System.IObservable$1}                          An observable sequence whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of the input sequence and then mapping each of those sequence elements and their corresponding source element to a result element.
             */
            selectMany$10: function (TSource, TCollection, TResult, source, collectionSelector, resultSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(collectionSelector, null)) {
                    throw new System.ArgumentNullException("collectionSelector");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$selectMany$10(TSource, TCollection, TResult, source, collectionSelector, resultSelector);
            },
            /**
             * Projects each notification of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource        The type of the elements in the source sequence.
             * @param   {Function}                TResult        The type of the elements in the projected inner sequences and the elements in the merged result sequence.
             * @param   {System.IObservable$1}    source         An observable sequence of notifications to project.
             * @param   {System.Func}             onNext         A transform function to apply to each element.
             * @param   {System.Func}             onError        A transform function to apply when an error occurs in the source sequence.
             * @param   {System.Func}             onCompleted    A transform function to apply when the end of the source sequence is reached.
             * @return  {System.IObservable$1}                   An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.
             */
            selectMany$2: function (TSource, TResult, source, onNext, onError, onCompleted) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(onNext, null)) {
                    throw new System.ArgumentNullException("onNext");
                }
                if (Bridge.staticEquals(onError, null)) {
                    throw new System.ArgumentNullException("onError");
                }
                if (Bridge.staticEquals(onCompleted, null)) {
                    throw new System.ArgumentNullException("onCompleted");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$selectMany$2(TSource, TResult, source, onNext, onError, onCompleted);
            },
            /**
             * Projects each notification of an observable sequence to an observable sequence by incorporating the element's index and merges the resulting observable sequences into one observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource        The type of the elements in the source sequence.
             * @param   {Function}                TResult        The type of the elements in the projected inner sequences and the elements in the merged result sequence.
             * @param   {System.IObservable$1}    source         An observable sequence of notifications to project.
             * @param   {System.Func}             onNext         A transform function to apply to each element; the second parameter of the function represents the index of the source element.
             * @param   {System.Func}             onError        A transform function to apply when an error occurs in the source sequence.
             * @param   {System.Func}             onCompleted    A transform function to apply when the end of the source sequence is reached.
             * @return  {System.IObservable$1}                   An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.
             */
            selectMany$5: function (TSource, TResult, source, onNext, onError, onCompleted) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(onNext, null)) {
                    throw new System.ArgumentNullException("onNext");
                }
                if (Bridge.staticEquals(onError, null)) {
                    throw new System.ArgumentNullException("onError");
                }
                if (Bridge.staticEquals(onCompleted, null)) {
                    throw new System.ArgumentNullException("onCompleted");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$selectMany$5(TSource, TResult, source, onNext, onError, onCompleted);
            },
            /**
             * Projects each element of an observable sequence to an enumerable sequence and concatenates the resulting enumerable sequences into one observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {Function}                TResult     The type of the elements in the projected inner enumerable sequences and the elements in the merged result sequence.
             * @param   {System.IObservable$1}    source      An observable sequence of elements to project.
             * @param   {System.Func}             selector    A transform function to apply to each element.
             * @return  {System.IObservable$1}                An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.
             */
            selectMany: function (TSource, TResult, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$selectMany(TSource, TResult, source, selector);
            },
            /**
             * Projects each element of an observable sequence to an enumerable sequence by incorporating the element's index and concatenates the resulting enumerable sequences into one observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {Function}                TResult     The type of the elements in the projected inner enumerable sequences and the elements in the merged result sequence.
             * @param   {System.IObservable$1}    source      An observable sequence of elements to project.
             * @param   {System.Func}             selector    A transform function to apply to each element; the second parameter of the function represents the index of the source element.
             * @return  {System.IObservable$1}                An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.
             */
            selectMany$3: function (TSource, TResult, source, selector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(selector, null)) {
                    throw new System.ArgumentNullException("selector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$selectMany$3(TSource, TResult, source, selector);
            },
            /**
             * Projects each element of an observable sequence to an enumerable sequence, invokes the result selector for the source element and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource               The type of the elements in the source sequence.
             * @param   {Function}                TCollection           The type of the elements in the projected intermediate enumerable sequences.
             * @param   {Function}                TResult               The type of the elements in the result sequence, obtained by using the selector to combine source sequence elements with their corresponding intermediate sequence elements.
             * @param   {System.IObservable$1}    source                An observable sequence of elements to project.
             * @param   {System.Func}             collectionSelector    A transform function to apply to each element.
             * @param   {System.Func}             resultSelector        A transform function to apply to each element of the intermediate sequence.
             * @return  {System.IObservable$1}                          An observable sequence whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of the input sequence and then mapping each of those sequence elements and their corresponding source element to a result element.
             */
            selectMany$7: function (TSource, TCollection, TResult, source, collectionSelector, resultSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(collectionSelector, null)) {
                    throw new System.ArgumentNullException("collectionSelector");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$selectMany$7(TSource, TCollection, TResult, source, collectionSelector, resultSelector);
            },
            /**
             * Projects each element of an observable sequence to an enumerable sequence by incorporating the element's index, invokes the result selector for the source element and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource               The type of the elements in the source sequence.
             * @param   {Function}                TCollection           The type of the elements in the projected intermediate enumerable sequences.
             * @param   {Function}                TResult               The type of the elements in the result sequence, obtained by using the selector to combine source sequence elements with their corresponding intermediate sequence elements.
             * @param   {System.IObservable$1}    source                An observable sequence of elements to project.
             * @param   {System.Func}             collectionSelector    A transform function to apply to each element; the second parameter of the function represents the index of the source element.
             * @param   {System.Func}             resultSelector        A transform function to apply to each element of the intermediate sequence; the second parameter of the function represents the index of the source element and the fourth parameter represents the index of the intermediate element.
             * @return  {System.IObservable$1}                          An observable sequence whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of the input sequence and then mapping each of those sequence elements and their corresponding source element to a result element.
             */
            selectMany$9: function (TSource, TCollection, TResult, source, collectionSelector, resultSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(collectionSelector, null)) {
                    throw new System.ArgumentNullException("collectionSelector");
                }
                if (Bridge.staticEquals(resultSelector, null)) {
                    throw new System.ArgumentNullException("resultSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$selectMany$9(TSource, TCollection, TResult, source, collectionSelector, resultSelector);
            },
            /**
             * Bypasses a specified number of elements in an observable sequence and then returns the remaining elements.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than zero.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     The sequence to take elements from.
             * @param   {number}                  count      The number of elements to skip before returning the remaining elements.
             * @return  {System.IObservable$1}               An observable sequence that contains the elements that occur after the specified index in the input sequence.
             */
            skip: function (TSource, source, count) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException("count");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$skip(TSource, source, count);
            },
            /**
             * Skips elements for the specified duration from the start of the observable source sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      Source sequence to skip elements for.
             * @param   {System.TimeSpan}         duration    Duration for skipping elements from the start of the sequence.
             * @return  {System.IObservable$1}                An observable sequence with the elements skipped during the specified duration from the start of the source sequence.
             */
            skip$1: function (TSource, source, duration) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(duration, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("duration");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$skip$1(TSource, source, duration);
            },
            /**
             * Skips elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to skip elements for.
             * @param   {System.TimeSpan}                           duration     Duration for skipping elements from the start of the sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the timer on.
             * @return  {System.IObservable$1}                                   An observable sequence with the elements skipped during the specified duration from the start of the source sequence.
             */
            skip$2: function (TSource, source, duration, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(duration, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("duration");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$skip$2(TSource, source, duration, scheduler);
            },
            /**
             * Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       An observable sequence to return elements from.
             * @param   {System.Func}             predicate    A function to test each element for a condition.
             * @return  {System.IObservable$1}                 An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.
             */
            skipWhile: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$skipWhile(TSource, source, predicate);
            },
            /**
             * Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.
             The element's index is used in the logic of the predicate function.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       An observable sequence to return elements from.
             * @param   {System.Func}             predicate    A function to test each element for a condition; the second parameter of the function represents the index of the source element.
             * @return  {System.IObservable$1}                 An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.
             */
            skipWhile$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$skipWhile$1(TSource, source, predicate);
            },
            /**
             * Returns a specified number of contiguous elements from the start of an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than zero.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     The sequence to take elements from.
             * @param   {number}                  count      The number of elements to return.
             * @return  {System.IObservable$1}               An observable sequence that contains the specified number of elements from the start of the input sequence.
             */
            take: function (TSource, source, count) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException("count");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$take(TSource, source, count);
            },
            /**
             * Returns a specified number of contiguous elements from the start of an observable sequence, using the specified scheduler for the edge case of Take(0).
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       The sequence to take elements from.
             * @param   {number}                                    count        The number of elements to return.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler used to produce an OnCompleted message in case <b>scheduler</b> is set to 0.
             * @return  {System.IObservable$1}                                   An observable sequence that contains the specified number of elements from the start of the input sequence.
             */
            take$1: function (TSource, source, count, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException("count");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$take$1(TSource, source, count, scheduler);
            },
            /**
             * Takes elements for the specified duration from the start of the observable source sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      Source sequence to take elements from.
             * @param   {System.TimeSpan}         duration    Duration for taking elements from the start of the sequence.
             * @return  {System.IObservable$1}                An observable sequence with the elements taken during the specified duration from the start of the source sequence.
             */
            take$2: function (TSource, source, duration) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(duration, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("duration");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$take$2(TSource, source, duration);
            },
            /**
             * Takes elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to take elements from.
             * @param   {System.TimeSpan}                           duration     Duration for taking elements from the start of the sequence.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the timer on.
             * @return  {System.IObservable$1}                                   An observable sequence with the elements taken during the specified duration from the start of the source sequence.
             */
            take$3: function (TSource, source, duration, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(duration, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("duration");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$take$3(TSource, source, duration, scheduler);
            },
            /**
             * Returns elements from an observable sequence as long as a specified condition is true.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       A sequence to return elements from.
             * @param   {System.Func}             predicate    A function to test each element for a condition.
             * @return  {System.IObservable$1}                 An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.
             */
            takeWhile: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$takeWhile(TSource, source, predicate);
            },
            /**
             * Returns elements from an observable sequence as long as a specified condition is true.
             The element's index is used in the logic of the predicate function.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       A sequence to return elements from.
             * @param   {System.Func}             predicate    A function to test each element for a condition; the second parameter of the function represents the index of the source element.
             * @return  {System.IObservable$1}                 An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.
             */
            takeWhile$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$takeWhile$1(TSource, source, predicate);
            },
            /**
             * Filters the elements of an observable sequence based on a predicate.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       An observable sequence whose elements to filter.
             * @param   {System.Func}             predicate    A function to test each source element for a condition.
             * @return  {System.IObservable$1}                 An observable sequence that contains elements from the input sequence that satisfy the condition.
             */
            where: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$where(TSource, source, predicate);
            },
            /**
             * Filters the elements of an observable sequence based on a predicate by incorporating the element's index.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source       An observable sequence whose elements to filter.
             * @param   {System.Func}             predicate    A function to test each source element for a conditio; the second parameter of the function represents the index of the source element.
             * @return  {System.IObservable$1}                 An observable sequence that contains elements from the input sequence that satisfy the condition.
             */
            where$1: function (TSource, source, predicate) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(predicate, null)) {
                    throw new System.ArgumentNullException("predicate");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$where$1(TSource, source, predicate);
            },
            /**
             * Time shifts the observable sequence by the specified relative time duration.
             The relative time intervals between the values are preserved.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence to delay values for.
             * @param   {System.TimeSpan}         dueTime    Relative time by which to shift the observable sequence. If this value is equal to TimeSpan.Zero, the scheduler will dispatch observer callbacks as soon as possible.
             * @return  {System.IObservable$1}               Time-shifted sequence.
             */
            delay$2: function (TSource, source, dueTime) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(dueTime, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("dueTime");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$delay$2(TSource, source, dueTime);
            },
            /**
             * Time shifts the observable sequence by the specified relative time duration, using the specified scheduler to run timers.
             The relative time intervals between the values are preserved.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to delay values for.
             * @param   {System.TimeSpan}                           dueTime      Relative time by which to shift the observable sequence. If this value is equal to TimeSpan.Zero, the scheduler will dispatch observer callbacks as soon as possible.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the delay timers on.
             * @return  {System.IObservable$1}                                   Time-shifted sequence.
             */
            delay$3: function (TSource, source, dueTime, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(dueTime, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("dueTime");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$delay$3(TSource, source, dueTime, scheduler);
            },
            /**
             * Time shifts the observable sequence to start propagating notifications at the specified absolute time.
             The relative time intervals between the values are preserved.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                 TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}     source     Source sequence to delay values for.
             * @param   {System.DateTimeOffset}    dueTime    Absolute time used to shift the observable sequence; the relative time shift gets computed upon subscription. If this value is less than or equal to DateTimeOffset.UtcNow, the scheduler will dispatch observer callbacks as soon as possible.
             * @return  {System.IObservable$1}                Time-shifted sequence.
             */
            delay: function (TSource, source, dueTime) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$delay(TSource, source, dueTime.$clone());
            },
            /**
             * Time shifts the observable sequence to start propagating notifications at the specified absolute time, using the specified scheduler to run timers.
             The relative time intervals between the values are preserved.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to delay values for.
             * @param   {System.DateTimeOffset}                     dueTime      Absolute time used to shift the observable sequence; the relative time shift gets computed upon subscription. If this value is less than or equal to DateTimeOffset.UtcNow, the scheduler will dispatch observer callbacks as soon as possible.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the delay timers on.
             * @return  {System.IObservable$1}                                   Time-shifted sequence.
             */
            delay$1: function (TSource, source, dueTime, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$delay$1(TSource, source, dueTime.$clone(), scheduler);
            },
            /**
             * Time shifts the observable sequence based on a delay selector function for each element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource                  The type of the elements in the source sequence.
             * @param   {Function}                TDelay                   The type of the elements in the delay sequences used to denote the delay duration of each element in the source sequence.
             * @param   {System.IObservable$1}    source                   Source sequence to delay values for.
             * @param   {System.Func}             delayDurationSelector    Selector function to retrieve a sequence indicating the delay for each given element.
             * @return  {System.IObservable$1}                             Time-shifted sequence.
             */
            delay$4: function (TSource, TDelay, source, delayDurationSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(delayDurationSelector, null)) {
                    throw new System.ArgumentNullException("delayDurationSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$delay$4(TSource, TDelay, source, delayDurationSelector);
            },
            /**
             * Time shifts the observable sequence based on a subscription delay and a delay selector function for each element.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource                  The type of the elements in the source sequence.
             * @param   {Function}                TDelay                   The type of the elements in the delay sequences used to denote the delay duration of each element in the source sequence.
             * @param   {System.IObservable$1}    source                   Source sequence to delay values for.
             * @param   {System.IObservable$1}    subscriptionDelay        Sequence indicating the delay for the subscription to the source.
             * @param   {System.Func}             delayDurationSelector    Selector function to retrieve a sequence indicating the delay for each given element.
             * @return  {System.IObservable$1}                             Time-shifted sequence.
             */
            delay$5: function (TSource, TDelay, source, subscriptionDelay, delayDurationSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (subscriptionDelay == null) {
                    throw new System.ArgumentNullException("subscriptionDelay");
                }
                if (Bridge.staticEquals(delayDurationSelector, null)) {
                    throw new System.ArgumentNullException("delayDurationSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$delay$5(TSource, TDelay, source, subscriptionDelay, delayDurationSelector);
            },
            /**
             * Time shifts the observable sequence by delaying the subscription with the specified relative time duration.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence to delay subscription for.
             * @param   {System.TimeSpan}         dueTime    Relative time shift of the subscription.
             * @return  {System.IObservable$1}               Time-shifted sequence.
             */
            delaySubscription$2: function (TSource, source, dueTime) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(dueTime, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("dueTime");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$delaySubscription$2(TSource, source, dueTime);
            },
            /**
             * Time shifts the observable sequence by delaying the subscription with the specified relative time duration, using the specified scheduler to run timers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to delay subscription for.
             * @param   {System.TimeSpan}                           dueTime      Relative time shift of the subscription.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the subscription delay timer on.
             * @return  {System.IObservable$1}                                   Time-shifted sequence.
             */
            delaySubscription$3: function (TSource, source, dueTime, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(dueTime, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("dueTime");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$delaySubscription$3(TSource, source, dueTime, scheduler);
            },
            /**
             * Time shifts the observable sequence by delaying the subscription to the specified absolute time.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                 TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}     source     Source sequence to delay subscription for.
             * @param   {System.DateTimeOffset}    dueTime    Absolute time to perform the subscription at.
             * @return  {System.IObservable$1}                Time-shifted sequence.
             */
            delaySubscription: function (TSource, source, dueTime) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$delaySubscription(TSource, source, dueTime.$clone());
            },
            /**
             * Time shifts the observable sequence by delaying the subscription to the specified absolute time, using the specified scheduler to run timers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to delay subscription for.
             * @param   {System.DateTimeOffset}                     dueTime      Absolute time to perform the subscription at.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the subscription delay timer on.
             * @return  {System.IObservable$1}                                   Time-shifted sequence.
             */
            delaySubscription$1: function (TSource, source, dueTime, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$delaySubscription$1(TSource, source, dueTime.$clone(), scheduler);
            },
            /**
             * Returns an observable sequence that produces a value after each period.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {System.TimeSpan}         period    Period for producing the values in the resulting sequence. If this value is equal to TimeSpan.Zero, the timer will recur as fast as possible.
             * @return  {System.IObservable$1}              An observable sequence that produces a value after each period.
             */
            interval: function (period) {
                if (System.TimeSpan.lt(period, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("period");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$interval(period);
            },
            /**
             * Returns an observable sequence that produces a value after each period, using the specified scheduler to run timers and to send out observer messages.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is less than TimeSpan.Zero.
             * @throws <b /> is null.
             * @param   {System.TimeSpan}                           period       Period for producing the values in the resulting sequence. If this value is equal to TimeSpan.Zero, the timer will recur as fast as possible.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the timer on.
             * @return  {System.IObservable$1}                                   An observable sequence that produces a value after each period.
             */
            interval$1: function (period, scheduler) {
                if (System.TimeSpan.lt(period, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("period");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$interval$1(period, scheduler);
            },
            /**
             * Samples the observable sequence at each interval.
             Upon each sampling tick, the latest element (if any) in the source sequence during the last sampling interval is sent to the resulting sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                TSource     The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source      Source sequence to sample.
             * @param   {System.TimeSpan}         interval    Interval at which to sample. If this value is equal to TimeSpan.Zero, the scheduler will continuously sample the stream.
             * @return  {System.IObservable$1}                Sampled observable sequence.
             */
            sample: function (TSource, source, interval) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(interval, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("interval");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sample(TSource, source, interval);
            },
            /**
             * Samples the observable sequence at each interval, using the specified scheduler to run sampling timers.
             Upon each sampling tick, the latest element (if any) in the source sequence during the last sampling interval is sent to the resulting sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to sample.
             * @param   {System.TimeSpan}                           interval     Interval at which to sample. If this value is equal to TimeSpan.Zero, the scheduler will continuously sample the stream.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the sampling timer on.
             * @return  {System.IObservable$1}                                   Sampled observable sequence.
             */
            sample$1: function (TSource, source, interval, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(interval, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("interval");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sample$1(TSource, source, interval, scheduler);
            },
            /**
             * Samples the source observable sequence using a sampler observable sequence producing sampling ticks.
             Upon each sampling tick, the latest element (if any) in the source sequence during the last sampling interval is sent to the resulting sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {Function}                TSample    The type of the elements in the sampling sequence.
             * @param   {System.IObservable$1}    source     Source sequence to sample.
             * @param   {System.IObservable$1}    sampler    Sampling tick sequence.
             * @return  {System.IObservable$1}               Sampled observable sequence.
             */
            sample$2: function (TSource, TSample, source, sampler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (sampler == null) {
                    throw new System.ArgumentNullException("sampler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$sample$2(TSource, TSample, source, sampler);
            },
            /**
             * Ignores elements from an observable sequence which are followed by another element within a specified relative time duration.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence to throttle.
             * @param   {System.TimeSpan}         dueTime    Throttling duration for each element.
             * @return  {System.IObservable$1}               The throttled sequence.
             */
            throttle: function (TSource, source, dueTime) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(dueTime, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("dueTime");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$throttle(TSource, source, dueTime);
            },
            /**
             * Ignores elements from an observable sequence which are followed by another element within a specified relative time duration, using the specified scheduler to run throttling timers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to throttle.
             * @param   {System.TimeSpan}                           dueTime      Throttling duration for each element.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the throttle timers on.
             * @return  {System.IObservable$1}                                   The throttled sequence.
             */
            throttle$1: function (TSource, source, dueTime, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(dueTime, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("dueTime");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$throttle$1(TSource, source, dueTime, scheduler);
            },
            /**
             * Ignores elements from an observable sequence which are followed by another value within a computed throttle duration.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource                     The type of the elements in the source sequence.
             * @param   {Function}                TThrottle                   The type of the elements in the throttle sequences selected for each element in the source sequence.
             * @param   {System.IObservable$1}    source                      Source sequence to throttle.
             * @param   {System.Func}             throttleDurationSelector    Selector function to retrieve a sequence indicating the throttle duration for each given element.
             * @return  {System.IObservable$1}                                The throttled sequence.
             */
            throttle$2: function (TSource, TThrottle, source, throttleDurationSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(throttleDurationSelector, null)) {
                    throw new System.ArgumentNullException("throttleDurationSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$throttle$2(TSource, TThrottle, source, throttleDurationSelector);
            },
            /**
             * Records the time interval between consecutive elements in an observable sequence.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence to record time intervals for.
             * @return  {System.IObservable$1}               An observable sequence with time interval information on elements.
             */
            timeInterval: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timeInterval(TSource, source);
            },
            /**
             * Records the time interval between consecutive elements in an observable sequence, using the specified scheduler to compute time intervals.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to record time intervals for.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler used to compute time intervals.
             * @return  {System.IObservable$1}                                   An observable sequence with time interval information on elements.
             */
            timeInterval$1: function (TSource, source, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timeInterval$1(TSource, source, scheduler);
            },
            /**
             * Applies a timeout policy for each element in the observable sequence.
             If the next element isn't received within the specified timeout duration starting from its predecessor, a TimeoutException is propagated to the observer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @throws (Asynchronous) If no element is produced within <b /> from the previous element.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence to perform a timeout for.
             * @param   {System.TimeSpan}         dueTime    Maximum duration between values before a timeout occurs.
             * @return  {System.IObservable$1}               The source sequence with a TimeoutException in case of a timeout.
             */
            timeout$4: function (TSource, source, dueTime) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(dueTime, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("dueTime");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timeout$4(TSource, source, dueTime);
            },
            /**
             * Applies a timeout policy for each element in the observable sequence, using the specified scheduler to run timeout timers.
             If the next element isn't received within the specified timeout duration starting from its predecessor, a TimeoutException is propagated to the observer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @throws (Asynchronous) If no element is produced within <b /> from the previous element.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to perform a timeout for.
             * @param   {System.TimeSpan}                           dueTime      Maximum duration between values before a timeout occurs.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the timeout timers on.
             * @return  {System.IObservable$1}                                   The source sequence with a TimeoutException in case of a timeout.
             */
            timeout$7: function (TSource, source, dueTime, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(dueTime, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("dueTime");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timeout$7(TSource, source, dueTime, scheduler);
            },
            /**
             * Applies a timeout policy for each element in the observable sequence.
             If the next element isn't received within the specified timeout duration starting from its predecessor, the other observable sequence is used to produce future messages from that point on.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                TSource    The type of the elements in the source sequence and the other sequence used upon a timeout.
             * @param   {System.IObservable$1}    source     Source sequence to perform a timeout for.
             * @param   {System.TimeSpan}         dueTime    Maximum duration between values before a timeout occurs.
             * @param   {System.IObservable$1}    other      Sequence to return in case of a timeout.
             * @return  {System.IObservable$1}               The source sequence switching to the other sequence in case of a timeout.
             */
            timeout$5: function (TSource, source, dueTime, other) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(dueTime, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("dueTime");
                }
                if (other == null) {
                    throw new System.ArgumentNullException("other");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timeout$5(TSource, source, dueTime, other);
            },
            /**
             * Applies a timeout policy for each element in the observable sequence, using the specified scheduler to run timeout timers.
             If the next element isn't received within the specified timeout duration starting from its predecessor, the other observable sequence is used to produce future messages from that point on.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence and the other sequence used upon a timeout.
             * @param   {System.IObservable$1}                      source       Source sequence to perform a timeout for.
             * @param   {System.TimeSpan}                           dueTime      Maximum duration between values before a timeout occurs.
             * @param   {System.IObservable$1}                      other        Sequence to return in case of a timeout.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the timeout timers on.
             * @return  {System.IObservable$1}                                   The source sequence switching to the other sequence in case of a timeout.
             */
            timeout$6: function (TSource, source, dueTime, other, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (System.TimeSpan.lt(dueTime, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("dueTime");
                }
                if (other == null) {
                    throw new System.ArgumentNullException("other");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timeout$6(TSource, source, dueTime, other, scheduler);
            },
            /**
             * Applies a timeout policy to the observable sequence based on an absolute time.
             If the sequence doesn't terminate before the specified absolute due time, a TimeoutException is propagated to the observer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @throws (Asynchronous) If the sequence hasn't terminated before <b />.
             * @param   {Function}                 TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}     source     Source sequence to perform a timeout for.
             * @param   {System.DateTimeOffset}    dueTime    Time when a timeout occurs. If this value is less than or equal to DateTimeOffset.UtcNow, the timeout occurs immediately.
             * @return  {System.IObservable$1}                The source sequence with a TimeoutException in case of a timeout.
             */
            timeout: function (TSource, source, dueTime) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timeout(TSource, source, dueTime.$clone());
            },
            /**
             * Applies a timeout policy to the observable sequence based on an absolute time, using the specified scheduler to run timeout timers.
             If the sequence doesn't terminate before the specified absolute due time, a TimeoutException is propagated to the observer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @throws (Asynchronous) If the sequence hasn't terminated before <b />.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to perform a timeout for.
             * @param   {System.DateTimeOffset}                     dueTime      Time when a timeout occurs. If this value is less than or equal to DateTimeOffset.UtcNow, the timeout occurs immediately.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the timeout timers on.
             * @return  {System.IObservable$1}                                   The source sequence with a TimeoutException in case of a timeout.
             */
            timeout$3: function (TSource, source, dueTime, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timeout$3(TSource, source, dueTime.$clone(), scheduler);
            },
            /**
             * Applies a timeout policy to the observable sequence based on an absolute time.
             If the sequence doesn't terminate before the specified absolute due time, the other observable sequence is used to produce future messages from that point on.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                 TSource    The type of the elements in the source sequence and the other sequence used upon a timeout.
             * @param   {System.IObservable$1}     source     Source sequence to perform a timeout for.
             * @param   {System.DateTimeOffset}    dueTime    Time when a timeout occurs. If this value is less than or equal to DateTimeOffset.UtcNow, the timeout occurs immediately.
             * @param   {System.IObservable$1}     other      Sequence to return in case of a timeout.
             * @return  {System.IObservable$1}                The source sequence switching to the other sequence in case of a timeout.
             */
            timeout$1: function (TSource, source, dueTime, other) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (other == null) {
                    throw new System.ArgumentNullException("other");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timeout$1(TSource, source, dueTime.$clone(), other);
            },
            /**
             * Applies a timeout policy to the observable sequence based on an absolute time, using the specified scheduler to run timeout timers.
             If the sequence doesn't terminate before the specified absolute due time, the other observable sequence is used to produce future messages from that point on.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence and the other sequence used upon a timeout.
             * @param   {System.IObservable$1}                      source       Source sequence to perform a timeout for.
             * @param   {System.DateTimeOffset}                     dueTime      Time when a timeout occurs. If this value is less than or equal to DateTimeOffset.UtcNow, the timeout occurs immediately.
             * @param   {System.IObservable$1}                      other        Sequence to return in case of a timeout.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the timeout timers on.
             * @return  {System.IObservable$1}                                   The source sequence switching to the other sequence in case of a timeout.
             */
            timeout$2: function (TSource, source, dueTime, other, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }
                if (other == null) {
                    throw new System.ArgumentNullException("other");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timeout$2(TSource, source, dueTime.$clone(), other, scheduler);
            },
            /**
             * Applies a timeout policy to the observable sequence based on a timeout duration computed for each element.
             If the next element isn't received within the computed duration starting from its predecessor, a TimeoutException is propagated to the observer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                TSource                    The type of the elements in the source sequence.
             * @param   {Function}                TTimeout                   The type of the elements in the timeout sequences used to indicate the timeout duration for each element in the source sequence.
             * @param   {System.IObservable$1}    source                     Source sequence to perform a timeout for.
             * @param   {System.Func}             timeoutDurationSelector    Selector to retrieve an observable sequence that represents the timeout between the current element and the next element.
             * @return  {System.IObservable$1}                               The source sequence with a TimeoutException in case of a timeout.
             */
            timeout$8: function (TSource, TTimeout, source, timeoutDurationSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(timeoutDurationSelector, null)) {
                    throw new System.ArgumentNullException("timeoutDurationSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timeout$8(TSource, TTimeout, source, timeoutDurationSelector);
            },
            /**
             * Applies a timeout policy to the observable sequence based on a timeout duration computed for each element.
             If the next element isn't received within the computed duration starting from its predecessor, the other observable sequence is used to produce future messages from that point on.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource                    The type of the elements in the source sequence and the other sequence used upon a timeout.
             * @param   {Function}                TTimeout                   The type of the elements in the timeout sequences used to indicate the timeout duration for each element in the source sequence.
             * @param   {System.IObservable$1}    source                     Source sequence to perform a timeout for.
             * @param   {System.Func}             timeoutDurationSelector    Selector to retrieve an observable sequence that represents the timeout between the current element and the next element.
             * @param   {System.IObservable$1}    other                      Sequence to return in case of a timeout.
             * @return  {System.IObservable$1}                               The source sequence switching to the other sequence in case of a timeout.
             */
            timeout$9: function (TSource, TTimeout, source, timeoutDurationSelector, other) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (Bridge.staticEquals(timeoutDurationSelector, null)) {
                    throw new System.ArgumentNullException("timeoutDurationSelector");
                }
                if (other == null) {
                    throw new System.ArgumentNullException("other");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timeout$9(TSource, TTimeout, source, timeoutDurationSelector, other);
            },
            /**
             * Applies a timeout policy to the observable sequence based on an initial timeout duration for the first element, and a timeout duration computed for each subsequent element.
             If the next element isn't received within the computed duration starting from its predecessor, a TimeoutException is propagated to the observer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource                    The type of the elements in the source sequence.
             * @param   {Function}                TTimeout                   The type of the elements in the timeout sequences used to indicate the timeout duration for each element in the source sequence.
             * @param   {System.IObservable$1}    source                     Source sequence to perform a timeout for.
             * @param   {System.IObservable$1}    firstTimeout               Observable sequence that represents the timeout for the first element.
             * @param   {System.Func}             timeoutDurationSelector    Selector to retrieve an observable sequence that represents the timeout between the current element and the next element.
             * @return  {System.IObservable$1}                               The source sequence with a TimeoutException in case of a timeout.
             */
            timeout$10: function (TSource, TTimeout, source, firstTimeout, timeoutDurationSelector) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (firstTimeout == null) {
                    throw new System.ArgumentNullException("firstTimeout");
                }
                if (Bridge.staticEquals(timeoutDurationSelector, null)) {
                    throw new System.ArgumentNullException("timeoutDurationSelector");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timeout$10(TSource, TTimeout, source, firstTimeout, timeoutDurationSelector);
            },
            /**
             * Applies a timeout policy to the observable sequence based on an initial timeout duration for the first element, and a timeout duration computed for each subsequent element.
             If the next element isn't received within the computed duration starting from its predecessor, the other observable sequence is used to produce future messages from that point on.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> or <b /> or <b /> is null.
             * @param   {Function}                TSource                    The type of the elements in the source sequence and the other sequence used upon a timeout.
             * @param   {Function}                TTimeout                   The type of the elements in the timeout sequences used to indicate the timeout duration for each element in the source sequence.
             * @param   {System.IObservable$1}    source                     Source sequence to perform a timeout for.
             * @param   {System.IObservable$1}    firstTimeout               Observable sequence that represents the timeout for the first element.
             * @param   {System.Func}             timeoutDurationSelector    Selector to retrieve an observable sequence that represents the timeout between the current element and the next element.
             * @param   {System.IObservable$1}    other                      Sequence to return in case of a timeout.
             * @return  {System.IObservable$1}                               The source sequence switching to the other sequence in case of a timeout.
             */
            timeout$11: function (TSource, TTimeout, source, firstTimeout, timeoutDurationSelector, other) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (firstTimeout == null) {
                    throw new System.ArgumentNullException("firstTimeout");
                }
                if (Bridge.staticEquals(timeoutDurationSelector, null)) {
                    throw new System.ArgumentNullException("timeoutDurationSelector");
                }
                if (other == null) {
                    throw new System.ArgumentNullException("other");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timeout$11(TSource, TTimeout, source, firstTimeout, timeoutDurationSelector, other);
            },
            /**
             * Returns an observable sequence that produces a single value after the specified relative due time has elapsed.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @param   {System.TimeSpan}         dueTime    Relative time at which to produce the value. If this value is less than or equal to TimeSpan.Zero, the timer will fire as soon as possible.
             * @return  {System.IObservable$1}               An observable sequence that produces a value after the due time has elapsed.
             */
            timer$4: function (dueTime) {
                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timer$4(dueTime);
            },
            /**
             * Returns an observable sequence that produces a single value at the specified absolute due time.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @param   {System.DateTimeOffset}    dueTime    Absolute time at which to produce the value. If this value is less than or equal to DateTimeOffset.UtcNow, the timer will fire as soon as possible.
             * @return  {System.IObservable$1}                An observable sequence that produces a value at due time.
             */
            timer: function (dueTime) {
                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timer(dueTime.$clone());
            },
            /**
             * Returns an observable sequence that periodically produces a value after the specified initial relative due time has elapsed.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {System.TimeSpan}         dueTime    Relative time at which to produce the first value. If this value is less than or equal to TimeSpan.Zero, the timer will fire as soon as possible.
             * @param   {System.TimeSpan}         period     Period to produce subsequent values. If this value is equal to TimeSpan.Zero, the timer will recur as fast as possible.
             * @return  {System.IObservable$1}               An observable sequence that produces a value after due time has elapsed and then after each period.
             */
            timer$6: function (dueTime, period) {
                if (System.TimeSpan.lt(period, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("period");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timer$6(dueTime, period);
            },
            /**
             * Returns an observable sequence that periodically produces a value starting at the specified initial absolute due time.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is less than TimeSpan.Zero.
             * @param   {System.DateTimeOffset}    dueTime    Absolute time at which to produce the first value. If this value is less than or equal to DateTimeOffset.UtcNow, the timer will fire as soon as possible.
             * @param   {System.TimeSpan}          period     Period to produce subsequent values. If this value is equal to TimeSpan.Zero, the timer will recur as fast as possible.
             * @return  {System.IObservable$1}                An observable sequence that produces a value at due time and then after each period.
             */
            timer$2: function (dueTime, period) {
                if (System.TimeSpan.lt(period, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("period");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timer$2(dueTime.$clone(), period);
            },
            /**
             * Returns an observable sequence that produces a single value after the specified relative due time has elapsed, using the specified scheduler to run the timer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.TimeSpan}                           dueTime      Relative time at which to produce the value. If this value is less than or equal to TimeSpan.Zero, the timer will fire as soon as possible.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the timer on.
             * @return  {System.IObservable$1}                                   An observable sequence that produces a value after the due time has elapsed.
             */
            timer$5: function (dueTime, scheduler) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timer$5(dueTime, scheduler);
            },
            /**
             * Returns an observable sequence that produces a single value at the specified absolute due time, using the specified scheduler to run the timer.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {System.DateTimeOffset}                     dueTime      Absolute time at which to produce the value. If this value is less than or equal to DateTimeOffset.UtcNow, the timer will fire as soon as possible.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run the timer on.
             * @return  {System.IObservable$1}                                   An observable sequence that produces a value at due time.
             */
            timer$1: function (dueTime, scheduler) {
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timer$1(dueTime.$clone(), scheduler);
            },
            /**
             * Returns an observable sequence that periodically produces a value after the specified initial relative due time has elapsed, using the specified scheduler to run timers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is less than TimeSpan.Zero.
             * @throws <b /> is null.
             * @param   {System.TimeSpan}                           dueTime      Relative time at which to produce the first value. If this value is less than or equal to TimeSpan.Zero, the timer will fire as soon as possible.
             * @param   {System.TimeSpan}                           period       Period to produce subsequent values. If this value is equal to TimeSpan.Zero, the timer will recur as fast as possible.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run timers on.
             * @return  {System.IObservable$1}                                   An observable sequence that produces a value after due time has elapsed and then each period.
             */
            timer$7: function (dueTime, period, scheduler) {
                if (System.TimeSpan.lt(period, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("period");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timer$7(dueTime, period, scheduler);
            },
            /**
             * Returns an observable sequence that periodically produces a value starting at the specified initial absolute due time, using the specified scheduler to run timers.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is less than TimeSpan.Zero.
             * @throws <b /> is null.
             * @param   {System.DateTimeOffset}                     dueTime      Absolute time at which to produce the first value. If this value is less than or equal to DateTimeOffset.UtcNow, the timer will fire as soon as possible.
             * @param   {System.TimeSpan}                           period       Period to produce subsequent values. If this value is equal to TimeSpan.Zero, the timer will recur as fast as possible.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to run timers on.
             * @return  {System.IObservable$1}                                   An observable sequence that produces a value at due time and then after each period.
             */
            timer$3: function (dueTime, period, scheduler) {
                if (System.TimeSpan.lt(period, System.TimeSpan.zero)) {
                    throw new System.ArgumentOutOfRangeException("period");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timer$3(dueTime.$clone(), period, scheduler);
            },
            /**
             * Timestamps each element in an observable sequence using the local system clock.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> is null.
             * @param   {Function}                TSource    The type of the elements in the source sequence.
             * @param   {System.IObservable$1}    source     Source sequence to timestamp elements for.
             * @return  {System.IObservable$1}               An observable sequence with timestamp information on elements.
             */
            timestamp: function (TSource, source) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timestamp(TSource, source);
            },
            /**
             * Timestamp each element in an observable sequence using the clock of the specified scheduler.
             *
             * @static
             * @public
             * @this System.Reactive.Linq.Observable
             * @memberof System.Reactive.Linq.Observable
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TSource      The type of the elements in the source sequence.
             * @param   {System.IObservable$1}                      source       Source sequence to timestamp elements for.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler used to compute timestamps.
             * @return  {System.IObservable$1}                                   An observable sequence with timestamp information on elements.
             */
            timestamp$1: function (TSource, source, scheduler) {
                if (source == null) {
                    throw new System.ArgumentNullException("source");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return System.Reactive.Linq.Observable.s_impl.System$Reactive$Linq$IQueryLanguage$timestamp$1(TSource, source, scheduler);
            }
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Amb$1._.AmbState", function (TSource) { return {
        $kind: "enum",
        statics: {
            Left: 0,
            Right: 1,
            Neither: 2
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Buffer$1.BufferImpl.State", function (TSource) { return {
        $kind: "struct",
        statics: {
            getDefaultValue: function () { return new (System.Reactive.Linq.ObservableImpl.Buffer$1.BufferImpl.State(TSource))(); }
        },
        isSpan: false,
        isShift: false,
        ctor: function () {
            this.$initialize();
        },
        getHashCode: function () {
            var h = Bridge.addHash([1952543928, this.isSpan, this.isShift]);
            return h;
        },
        equals: function (o) {
            if (!Bridge.is(o, System.Reactive.Linq.ObservableImpl.Buffer$1.BufferImpl.State(TSource))) {
                return false;
            }
            return Bridge.equals(this.isSpan, o.isSpan) && Bridge.equals(this.isShift, o.isShift);
        },
        $clone: function (to) {
            var s = to || new (System.Reactive.Linq.ObservableImpl.Buffer$1.BufferImpl.State(TSource))();
            s.isSpan = this.isSpan;
            s.isShift = this.isShift;
            return s;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.PushToPullAdapter$2", function (TSource, TResult) { return {
        inherits: [System.Collections.Generic.IEnumerable$1(TResult)],
        _source: null,
        config: {
            alias: [
            "getEnumerator", "System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(TResult) + "$getEnumerator"
            ]
        },
        ctor: function (source) {
            this.$initialize();
            this._source = source;
        },
        System$Collections$IEnumerable$getEnumerator: function () {
            return this.getEnumerator();
        },
        getEnumerator: function () {
            var d = new System.Reactive.Disposables.SingleAssignmentDisposable();
            var res = this.run(d);
            d.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._source, res));
            return res;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ICombineLatest", {
        $kind: "interface"
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.EventProducer$2.Session", function (TDelegate, TArgs) { return {
        _parent: null,
        _subject: null,
        _removeHandler: null,
        _count: 0,
        ctor: function (parent) {
            this.$initialize();
            this._parent = parent;
            this._subject = new (System.Reactive.Subjects.Subject$1(TArgs))();
        },
        connect: function (observer) {
            /* 
                 * CALLERS - Ensure this is called under the lock!
                 * 
                lock (_parent._gate) */
            {
                //
                // We connect the given observer to the subject first, before performing any kind
                // of initialization which will register an event handler. This is done to ensure
                // we don't have a time gap between adding the handler and connecting the user's
                // subject, e.g. when the ImmediateScheduler is used.
                //
                // [OK] Use of unsafe Subscribe: called on a known subject implementation.
                //
                var connection = this._subject.subscribe(observer);

                if (((this._count = (this._count + 1) | 0)) === 1) {
                    try {
                        this.initialize();
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        this._count = (this._count - 1) | 0;
                        connection.System$IDisposable$dispose();

                        observer["System$IObserver$1$" + Bridge.getTypeAlias(TArgs) + "$onError"](exception);
                        return System.Reactive.Disposables.Disposable.getEmpty();
                    }
                }

                return System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, function () {
                    connection.System$IDisposable$dispose();

                    this._parent._gate;
                    {
                        if (((this._count = (this._count - 1) | 0)) === 0) {
                            System.Reactive.Concurrency.Scheduler.schedule(this._parent._scheduler, Bridge.fn.bind(this._removeHandler, this._removeHandler.dispose));
                            this._parent._session = null;
                        }
                    }
                }));
            }
        },
        initialize: function () {
            /* 
                 * CALLERS - Ensure this is called under the lock!
                 * 
                lock (_parent._gate) */
            {
                //
                // When the ref count goes to zero, no-one should be able to perform operations on
                // the session object anymore, because it gets nulled out.
                //
                this._removeHandler = new System.Reactive.Disposables.SingleAssignmentDisposable();

                //
                // Conversion code is supposed to be a pure function and shouldn't be run on the
                // scheduler, but the add handler call should. Notice the scheduler can be the
                // ImmediateScheduler, causing synchronous invocation. This is the default when
                // no SynchronizationContext is found (see QueryLanguage.Events.cs and search for
                // the GetSchedulerForCurrentContext method).
                //
                var onNext = this._parent.getHandler(Bridge.fn.bind(this._subject, this._subject.onNext));
                this._parent._scheduler.System$Reactive$Concurrency$IScheduler$schedule(TDelegate, onNext, Bridge.fn.bind(this, this.addHandler));
            }
        },
        addHandler: function (self, onNext) {
            var removeHandler = null;
            try {
                removeHandler = this._parent.addHandler(onNext);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._subject.onError(exception);
                return System.Reactive.Disposables.Disposable.getEmpty();
            }

            //
            // We don't propagate the exception to the OnError channel upon Dispose. This is
            // not possible at this stage, because we've already auto-detached in the base
            // class Producer implementation. Even if we would switch the OnError and auto-
            // detach calls, it wouldn't work because the remove handler logic is scheduled
            // on the given scheduler, causing asynchrony. We can't block waiting for the
            // remove handler to run on the scheduler.
            //
            this._removeHandler.setDisposable(removeHandler);

            return System.Reactive.Disposables.Disposable.getEmpty();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ForEach$1", function (TSource) { return {

    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.FromEventPattern");

    Bridge.define("System.Reactive.Linq.ObservableImpl.IZip", {
        $kind: "interface"
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Map$2", function (TKey, TValue) { return {
        _map: null,
        ctor: function (capacity, comparer) {
            this.$initialize();
            if (System.Nullable.hasValue(capacity)) {
                this._map = new (System.Collections.Generic.Dictionary$2(TKey, TValue))(null, comparer);
            } else {
                this._map = new (System.Collections.Generic.Dictionary$2(TKey, TValue))(null, comparer);
            }
        },
        getValues: function () {
            this._map;
            {
                return System.Linq.Enumerable.from(this._map.getValues()).toArray();
            }
        },
        getOrAdd: function (key, valueFactory, added) {
            this._map;
            {
                added.v = false;

                var value = { v : Bridge.getDefaultValue(TValue) };
                if (!this._map.tryGetValue(key, value)) {
                    value.v = valueFactory();
                    this._map.add(key, value.v);
                    added.v = true;
                }

                return value.v;
            }
        },
        remove: function (key) {
            this._map;
            {
                return this._map.remove(key);
            }
        }
    }; });

    /**
     * Represents a value associated with time interval information.
     The time interval can represent the time it took to produce the value, the interval relative to a previous value, the value's delivery time relative to a base, etc.
     *
     * @public
     * @class System.Reactive.TimeInterval$1
     * @implements  System.IEquatable$1
     * @param   {Function}    [name]    The type of the value being annotated with time interval information.
     */
    Bridge.define("System.Reactive.TimeInterval$1", function (T) { return {
        inherits: function () { return [System.IEquatable$1(System.Reactive.TimeInterval$1(T))]; },
        $kind: "struct",
        statics: {
            /**
             * Determines whether the two specified TimeInterval&lt;T&gt; values have the same Value and Interval.
             *
             * @static
             * @public
             * @this System.Reactive.TimeInterval$1
             * @memberof System.Reactive.TimeInterval$1
             * @param   {System.Reactive.TimeInterval$1}    first     The first TimeInterval&lt;T&gt; value to compare.
             * @param   {System.Reactive.TimeInterval$1}    second    The second TimeInterval&lt;T&gt; value to compare.
             * @return  {boolean}                                     true if the first TimeInterval&lt;T&gt; value has the same Value and Interval as the second TimeInterval&lt;T&gt; value; otherwise, false.
             */
            op_Equality: function (first, second) {
                return first.equalsT(second);
            }/**
             * Determines whether the two specified TimeInterval&lt;T&gt; values don't have the same Value and Interval.
             *
             * @static
             * @public
             * @this System.Reactive.TimeInterval$1
             * @memberof System.Reactive.TimeInterval$1
             * @param   {System.Reactive.TimeInterval$1}    first     The first TimeInterval&lt;T&gt; value to compare.
             * @param   {System.Reactive.TimeInterval$1}    second    The second TimeInterval&lt;T&gt; value to compare.
             * @return  {boolean}                                     true if the first TimeInterval&lt;T&gt; value has a different Value or Interval as the second TimeInterval&lt;T&gt; value; otherwise, false.
             */
            ,
            op_Inequality: function (first, second) {
                return !first.equalsT(second);
            },
            getDefaultValue: function () { return new (System.Reactive.TimeInterval$1(T))(); }
        },
        _value: Bridge.getDefaultValue(T),
        config: {
            alias: [
            "equalsT", "System$IEquatable$1$System$Reactive$TimeInterval$1$" + Bridge.getTypeAlias(T) + "$equalsT"
            ],
            init: function () {
                this._interval = new System.TimeSpan();
            }
        },
        /**
         * Constructs a time interval value.
         *
         * @instance
         * @public
         * @this System.Reactive.TimeInterval$1
         * @memberof System.Reactive.TimeInterval$1
         * @param   {T}                  value       The value to be annotated with a time interval.
         * @param   {System.TimeSpan}    interval    Time interval associated with the value.
         * @return  {void}
         */
        $ctor1: function (value, interval) {
            this.$initialize();
            this._interval = interval;
            this._value = value;
        },
        ctor: function () {
            this.$initialize();
        },
        /**
         * Gets the value.
         *
         * @instance
         * @public
         * @this System.Reactive.TimeInterval$1
         * @memberof System.Reactive.TimeInterval$1
         * @function getValue
         * @return  {T}
         */
        /**
         * Gets the value.
         *
         * @instance
         * @function setValue
         */
        getValue: function () {
            return this._value;
        },
        /**
         * Gets the interval.
         *
         * @instance
         * @public
         * @this System.Reactive.TimeInterval$1
         * @memberof System.Reactive.TimeInterval$1
         * @function getInterval
         * @return  {System.TimeSpan}
         */
        /**
         * Gets the interval.
         *
         * @instance
         * @function setInterval
         */
        getInterval: function () {
            return this._interval;
        },
        /**
         * Determines whether the current TimeInterval&lt;T&gt; value has the same Value and Interval as a specified TimeInterval&lt;T&gt; value.
         *
         * @instance
         * @public
         * @this System.Reactive.TimeInterval$1
         * @memberof System.Reactive.TimeInterval$1
         * @param   {System.Reactive.TimeInterval$1}    other    An object to compare to the current TimeInterval&lt;T&gt; value.
         * @return  {boolean}                                    true if both TimeInterval&lt;T&gt; values have the same Value and Interval; otherwise, false.
         */
        equalsT: function (other) {
            return other.getInterval().equalsT(this.getInterval()) && System.Collections.Generic.EqualityComparer$1(T).def.equals2(this.getValue(), other.getValue());
        },
        /**
         * Determines whether the specified System.Object is equal to the current TimeInterval&lt;T&gt;.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.TimeInterval$1
         * @memberof System.Reactive.TimeInterval$1
         * @param   {Object}     obj    The System.Object to compare with the current TimeInterval&lt;T&gt;.
         * @return  {boolean}           true if the specified System.Object is equal to the current TimeInterval&lt;T&gt;; otherwise, false.
         */
        equals: function (obj) {
            if (!(Bridge.is(obj, System.Reactive.TimeInterval$1(T)))) {
                return false;
            }

            var other = System.Nullable.getValue(Bridge.cast(obj, System.Reactive.TimeInterval$1(T)));
            return this.equalsT(other);
        },
        /**
         * Returns the hash code for the current TimeInterval&lt;T&gt; value.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.TimeInterval$1
         * @memberof System.Reactive.TimeInterval$1
         * @return  {number}        A hash code for the current TimeInterval&lt;T&gt; value.
         */
        getHashCode: function () {
            var valueHashCode = this.getValue() == null ? 1963 : Bridge.getHashCode(this.getValue());

            return Bridge.getHashCode(this.getInterval()) ^ valueHashCode;
        },
        /**
         * Returns a string representation of the current TimeInterval&lt;T&gt; value.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.TimeInterval$1
         * @memberof System.Reactive.TimeInterval$1
         * @return  {string}        String representation of the current TimeInterval&lt;T&gt; value.
         */
        toString: function () {
            return System.String.formatProvider(System.Globalization.CultureInfo.getCurrentCulture(), "{0}@{1}", this.getValue(), this.getInterval());
        },
        $clone: function (to) {
            var s = to || new (System.Reactive.TimeInterval$1(T))();
            s._interval = this._interval;
            s._value = this._value;
            return s;
        }
    }; });

    /**
     * Represents value with a timestamp on it.
     The timestamp typically represents the time the value was received, using an IScheduler's clock to obtain the current time.
     *
     * @public
     * @class System.Reactive.Timestamped$1
     * @implements  System.IEquatable$1
     * @param   {Function}    [name]    The type of the value being timestamped.
     */
    Bridge.define("System.Reactive.Timestamped$1", function (T) { return {
        inherits: function () { return [System.IEquatable$1(System.Reactive.Timestamped$1(T))]; },
        $kind: "struct",
        statics: {
            /**
             * Determines whether the two specified Timestamped&lt;T&gt; values have the same Value and Timestamp.
             *
             * @static
             * @public
             * @this System.Reactive.Timestamped$1
             * @memberof System.Reactive.Timestamped$1
             * @param   {System.Reactive.Timestamped$1}    first     The first Timestamped&lt;T&gt; value to compare.
             * @param   {System.Reactive.Timestamped$1}    second    The second Timestamped&lt;T&gt; value to compare.
             * @return  {boolean}                                    true if the first Timestamped&lt;T&gt; value has the same Value and Timestamp as the second Timestamped&lt;T&gt; value; otherwise, false.
             */
            op_Equality: function (first, second) {
                return first.equalsT(second);
            }/**
             * Determines whether the two specified Timestamped&lt;T&gt; values don't have the same Value and Timestamp.
             *
             * @static
             * @public
             * @this System.Reactive.Timestamped$1
             * @memberof System.Reactive.Timestamped$1
             * @param   {System.Reactive.Timestamped$1}    first     The first Timestamped&lt;T&gt; value to compare.
             * @param   {System.Reactive.Timestamped$1}    second    The second Timestamped&lt;T&gt; value to compare.
             * @return  {boolean}                                    true if the first Timestamped&lt;T&gt; value has a different Value or Timestamp as the second Timestamped&lt;T&gt; value; otherwise, false.
             */
            ,
            op_Inequality: function (first, second) {
                return !first.equalsT(second);
            },
            getDefaultValue: function () { return new (System.Reactive.Timestamped$1(T))(); }
        },
        _value: Bridge.getDefaultValue(T),
        config: {
            alias: [
            "equalsT", "System$IEquatable$1$System$Reactive$Timestamped$1$" + Bridge.getTypeAlias(T) + "$equalsT"
            ],
            init: function () {
                this._timestamp = new System.DateTimeOffset();
            }
        },
        /**
         * Constructs a timestamped value.
         *
         * @instance
         * @public
         * @this System.Reactive.Timestamped$1
         * @memberof System.Reactive.Timestamped$1
         * @param   {T}                        value        The value to be annotated with a timestamp.
         * @param   {System.DateTimeOffset}    timestamp    Timestamp associated with the value.
         * @return  {void}
         */
        $ctor1: function (value, timestamp) {
            this.$initialize();
            this._timestamp = timestamp.$clone();
            this._value = value;
        },
        ctor: function () {
            this.$initialize();
        },
        /**
         * Gets the value.
         *
         * @instance
         * @public
         * @this System.Reactive.Timestamped$1
         * @memberof System.Reactive.Timestamped$1
         * @function getValue
         * @return  {T}
         */
        /**
         * Gets the value.
         *
         * @instance
         * @function setValue
         */
        getValue: function () {
            return this._value;
        },
        /**
         * Gets the timestamp.
         *
         * @instance
         * @public
         * @this System.Reactive.Timestamped$1
         * @memberof System.Reactive.Timestamped$1
         * @function getTimestamp
         * @return  {System.DateTimeOffset}
         */
        /**
         * Gets the timestamp.
         *
         * @instance
         * @function setTimestamp
         */
        getTimestamp: function () {
            return this._timestamp.$clone();
        },
        /**
         * Determines whether the current Timestamped&lt;T&gt; value has the same Value and Timestamp as a specified Timestamped&lt;T&gt; value.
         *
         * @instance
         * @public
         * @this System.Reactive.Timestamped$1
         * @memberof System.Reactive.Timestamped$1
         * @param   {System.Reactive.Timestamped$1}    other    An object to compare to the current Timestamped&lt;T&gt; value.
         * @return  {boolean}                                   true if both Timestamped&lt;T&gt; values have the same Value and Timestamp; otherwise, false.
         */
        equalsT: function (other) {
            return other.getTimestamp().equalsT(this.getTimestamp().$clone()) && System.Collections.Generic.EqualityComparer$1(T).def.equals2(this.getValue(), other.getValue());
        },
        /**
         * Determines whether the specified System.Object is equal to the current Timestamped&lt;T&gt;.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Timestamped$1
         * @memberof System.Reactive.Timestamped$1
         * @param   {Object}     obj    The System.Object to compare with the current Timestamped&lt;T&gt;.
         * @return  {boolean}           true if the specified System.Object is equal to the current Timestamped&lt;T&gt;; otherwise, false.
         */
        equals: function (obj) {
            if (!(Bridge.is(obj, System.Reactive.Timestamped$1(T)))) {
                return false;
            }

            var other = System.Nullable.getValue(Bridge.cast(obj, System.Reactive.Timestamped$1(T)));
            return this.equalsT(other);
        },
        /**
         * Returns the hash code for the current Timestamped&lt;T&gt; value.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Timestamped$1
         * @memberof System.Reactive.Timestamped$1
         * @return  {number}        A hash code for the current Timestamped&lt;T&gt; value.
         */
        getHashCode: function () {
            var valueHashCode = this.getValue() == null ? 1979 : Bridge.getHashCode(this.getValue());

            return this._timestamp.getHashCode() ^ valueHashCode;
        },
        /**
         * Returns a string representation of the current Timestamped&lt;T&gt; value.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Timestamped$1
         * @memberof System.Reactive.Timestamped$1
         * @return  {string}        String representation of the current Timestamped&lt;T&gt; value.
         */
        toString: function () {
            return System.String.formatProvider(System.Globalization.CultureInfo.getCurrentCulture(), "{0}@{1}", this.getValue(), this.getTimestamp().$clone());
        },
        $clone: function (to) {
            var s = to || new (System.Reactive.Timestamped$1(T))();
            s._timestamp = this._timestamp.$clone();
            s._value = this._value;
            return s;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ToObservable$1._.State", function (TSource) { return {
        flag: null,
        enumerator: null,
        ctor: function (flag, enumerator) {
            this.$initialize();
            this.flag = flag;
            this.enumerator = enumerator;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Window$1.WindowImpl.State", function (TSource) { return {
        $kind: "struct",
        statics: {
            getDefaultValue: function () { return new (System.Reactive.Linq.ObservableImpl.Window$1.WindowImpl.State(TSource))(); }
        },
        isSpan: false,
        isShift: false,
        ctor: function () {
            this.$initialize();
        },
        getHashCode: function () {
            var h = Bridge.addHash([1952543928, this.isSpan, this.isShift]);
            return h;
        },
        equals: function (o) {
            if (!Bridge.is(o, System.Reactive.Linq.ObservableImpl.Window$1.WindowImpl.State(TSource))) {
                return false;
            }
            return Bridge.equals(this.isSpan, o.isSpan) && Bridge.equals(this.isShift, o.isShift);
        },
        $clone: function (to) {
            var s = to || new (System.Reactive.Linq.ObservableImpl.Window$1.WindowImpl.State(TSource))();
            s.isSpan = this.isSpan;
            s.isShift = this.isShift;
            return s;
        }
    }; });

    Bridge.define("System.Reactive.Linq.QueryLanguage.WaitAndSetOnce", {
        inherits: [System.IDisposable],
        _evt: null,
        _hasSet: 0,
        config: {
            alias: [
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function () {
            this.$initialize();
            this._evt = new System.Threading.ManualResetEvent(false);
        },
        set: function () {
            if (System.Interlocked.exchange(System.Int32, Bridge.ref(this, "_hasSet"), 1) === 0) {
                this._evt.set();
            }
        },
        waitOne: function () {
            this._evt.waitOne();
        },
        dispose: function () {
            this._evt.dispose();
        }
    });

    Bridge.define("System.Reactive.Linq.QueryServices", {
        statics: {
            s_services: null,
            config: {
                init: function () {
                    this.s_services = System.Reactive.Linq.QueryServices.initialize();
                }
            },
            getQueryImpl: function (T, defaultInstance) {
                return System.Reactive.Linq.QueryServices.s_services.System$Reactive$Linq$IQueryServices$extend(T, defaultInstance);
            },
            initialize: function () { /// Type or member is obsolete


                return System.Reactive.PlatformServices.PlatformEnlightenmentProvider.getCurrent().System$Reactive$PlatformServices$IPlatformEnlightenmentProvider$getService(System.Reactive.Linq.IQueryServices) || new System.Reactive.Linq.DefaultQueryServices();
            }
        }
    });

    /**
     * The <b>System.Reactive</b> namespace contains interfaces and classes used throughout the Reactive Extensions library.
     *
     * @class System.Reactive.NamespaceDoc
     */
    Bridge.define("System.Reactive.NamespaceDoc");

    /**
     * Provides a set of static methods for constructing notifications.
     *
     * @static
     * @abstract
     * @public
     * @class System.Reactive.Notification
     */
    Bridge.define("System.Reactive.Notification", {
        statics: {
            /**
             * Creates an object that represents an OnNext notification to an observer.
             *
             * @static
             * @public
             * @this System.Reactive.Notification
             * @memberof System.Reactive.Notification
             * @param   {Function}                          T        The type of the elements received by the observer. Upon dematerialization of the notifications into an observable sequence, this type is used as the element type for the sequence.
             * @param   {T}                                 value    The value contained in the notification.
             * @return  {System.Reactive.Notification$1}             The OnNext notification containing the value.
             */
            createOnNext: function (T, value) {
                return new (System.Reactive.Notification$1.OnNextNotification(T))(value);
            },
            /**
             * Creates an object that represents an OnError notification to an observer.
             *
             * @static
             * @public
             * @this System.Reactive.Notification
             * @memberof System.Reactive.Notification
             * @throws <b /> is null.
             * @param   {Function}                          T        The type of the elements received by the observer. Upon dematerialization of the notifications into an observable sequence, this type is used as the element type for the sequence.
             * @param   {System.Exception}                  error    The exception contained in the notification.
             * @return  {System.Reactive.Notification$1}             The OnError notification containing the exception.
             */
            createOnError: function (T, error) {
                if (error == null) {
                    throw new System.ArgumentNullException("error");
                }

                return new (System.Reactive.Notification$1.OnErrorNotification(T))(error);
            },
            /**
             * Creates an object that represents an OnCompleted notification to an observer.
             *
             * @static
             * @public
             * @this System.Reactive.Notification
             * @memberof System.Reactive.Notification
             * @param   {Function}                          T    The type of the elements received by the observer. Upon dematerialization of the notifications into an observable sequence, this type is used as the element type for the sequence.
             * @return  {System.Reactive.Notification$1}         The OnCompleted notification.
             */
            createOnCompleted: function (T) {
                return new (System.Reactive.Notification$1.OnCompletedNotification(T))();
            }
        }
    });

    /**
     * Indicates the type of a notification.
     *
     * @public
     * @class System.Reactive.NotificationKind
     */
    Bridge.define("System.Reactive.NotificationKind", {
        $kind: "enum",
        statics: {
            /**
             * Represents an OnNext notification.
             *
             * @static
             * @public
             * @memberof System.Reactive.NotificationKind
             * @constant
             * @default 0
             * @type System.Reactive.NotificationKind
             */
            OnNext: 0,
            /**
             * Represents an OnError notification.
             *
             * @static
             * @public
             * @memberof System.Reactive.NotificationKind
             * @constant
             * @default 1
             * @type System.Reactive.NotificationKind
             */
            OnError: 1,
            /**
             * Represents an OnCompleted notification.
             *
             * @static
             * @public
             * @memberof System.Reactive.NotificationKind
             * @constant
             * @default 2
             * @type System.Reactive.NotificationKind
             */
            OnCompleted: 2
        }
    });

    /**
     * Provides a set of static methods for creating observers.
     *
     * @static
     * @abstract
     * @public
     * @class System.Reactive.Observer
     */
    Bridge.define("System.Reactive.Observer", {
        statics: {
            /**
             * Creates an observer from a notification callback.
             *
             * @static
             * @public
             * @this System.Reactive.Observer
             * @memberof System.Reactive.Observer
             * @throws <b /> is null.
             * @param   {Function}              T          The type of the elements received by the observer.
             * @param   {System.Action}         handler    Action that handles a notification.
             * @return  {System.IObserver$1}               The observer object that invokes the specified handler using a notification corresponding to each message it receives.
             */
            toObserver: function (T, handler) {
                if (Bridge.staticEquals(handler, null)) {
                    throw new System.ArgumentNullException("handler");
                }

                return new (System.Reactive.AnonymousObserver$1(T)).$ctor3(function (x) {
                    handler(System.Reactive.Notification.createOnNext(T, x));
                }, function (exception) {
                    handler(System.Reactive.Notification.createOnError(T, exception));
                }, function () {
                    handler(System.Reactive.Notification.createOnCompleted(T));
                });
            },
            /**
             * Creates a notification callback from an observer.
             *
             * @static
             * @public
             * @this System.Reactive.Observer
             * @memberof System.Reactive.Observer
             * @throws <b /> is null.
             * @param   {Function}              T           The type of the elements received by the observer.
             * @param   {System.IObserver$1}    observer    Observer object.
             * @return  {System.Action}                     The action that forwards its input notification to the underlying observer.
             */
            toNotifier: function (T, observer) {
                if (observer == null) {
                    throw new System.ArgumentNullException("observer");
                }

                return function (n) {
                    n.accept$3(observer);
                };
            },
            /**
             * Creates an observer from the specified OnNext action.
             *
             * @static
             * @public
             * @this System.Reactive.Observer
             * @memberof System.Reactive.Observer
             * @throws <b /> is null.
             * @param   {Function}              T         The type of the elements received by the observer.
             * @param   {System.Action}         onNext    Observer's OnNext action implementation.
             * @return  {System.IObserver$1}              The observer object implemented using the given actions.
             */
            create: function (T, onNext) {
                if (Bridge.staticEquals(onNext, null)) {
                    throw new System.ArgumentNullException("onNext");
                }

                return new (System.Reactive.AnonymousObserver$1(T)).ctor(onNext);
            },
            /**
             * Creates an observer from the specified OnNext and OnError actions.
             *
             * @static
             * @public
             * @this System.Reactive.Observer
             * @memberof System.Reactive.Observer
             * @throws <b /> or <b /> is null.
             * @param   {Function}              T          The type of the elements received by the observer.
             * @param   {System.Action}         onNext     Observer's OnNext action implementation.
             * @param   {System.Action}         onError    Observer's OnError action implementation.
             * @return  {System.IObserver$1}               The observer object implemented using the given actions.
             */
            create$2: function (T, onNext, onError) {
                if (Bridge.staticEquals(onNext, null)) {
                    throw new System.ArgumentNullException("onNext");
                }
                if (Bridge.staticEquals(onError, null)) {
                    throw new System.ArgumentNullException("onError");
                }

                return new (System.Reactive.AnonymousObserver$1(T)).$ctor2(onNext, onError);
            },
            /**
             * Creates an observer from the specified OnNext and OnCompleted actions.
             *
             * @static
             * @public
             * @this System.Reactive.Observer
             * @memberof System.Reactive.Observer
             * @throws <b /> or <b /> is null.
             * @param   {Function}              T              The type of the elements received by the observer.
             * @param   {System.Action}         onNext         Observer's OnNext action implementation.
             * @param   {System.Action}         onCompleted    Observer's OnCompleted action implementation.
             * @return  {System.IObserver$1}                   The observer object implemented using the given actions.
             */
            create$1: function (T, onNext, onCompleted) {
                if (Bridge.staticEquals(onNext, null)) {
                    throw new System.ArgumentNullException("onNext");
                }
                if (Bridge.staticEquals(onCompleted, null)) {
                    throw new System.ArgumentNullException("onCompleted");
                }

                return new (System.Reactive.AnonymousObserver$1(T)).$ctor1(onNext, onCompleted);
            },
            /**
             * Creates an observer from the specified OnNext, OnError, and OnCompleted actions.
             *
             * @static
             * @public
             * @this System.Reactive.Observer
             * @memberof System.Reactive.Observer
             * @throws <b /> or <b /> or <b /> is null.
             * @param   {Function}              T              The type of the elements received by the observer.
             * @param   {System.Action}         onNext         Observer's OnNext action implementation.
             * @param   {System.Action}         onError        Observer's OnError action implementation.
             * @param   {System.Action}         onCompleted    Observer's OnCompleted action implementation.
             * @return  {System.IObserver$1}                   The observer object implemented using the given actions.
             */
            create$3: function (T, onNext, onError, onCompleted) {
                if (Bridge.staticEquals(onNext, null)) {
                    throw new System.ArgumentNullException("onNext");
                }
                if (Bridge.staticEquals(onError, null)) {
                    throw new System.ArgumentNullException("onError");
                }
                if (Bridge.staticEquals(onCompleted, null)) {
                    throw new System.ArgumentNullException("onCompleted");
                }

                return new (System.Reactive.AnonymousObserver$1(T)).$ctor3(onNext, onError, onCompleted);
            },
            /**
             * Hides the identity of an observer.
             *
             * @static
             * @public
             * @this System.Reactive.Observer
             * @memberof System.Reactive.Observer
             * @throws <b /> is null.
             * @param   {Function}              T           The type of the elements received by the source observer.
             * @param   {System.IObserver$1}    observer    An observer whose identity to hide.
             * @return  {System.IObserver$1}                An observer that hides the identity of the specified observer.
             */
            asObserver: function (T, observer) {
                if (observer == null) {
                    throw new System.ArgumentNullException("observer");
                }

                return new (System.Reactive.AnonymousObserver$1(T)).$ctor3(Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"]), Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"]), Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]));
            },
            /**
             * Checks access to the observer for grammar violations. This includes checking for multiple OnError or OnCompleted calls, as well as reentrancy in any of the observer methods.
             If a violation is detected, an InvalidOperationException is thrown from the offending observer method call.
             *
             * @static
             * @public
             * @this System.Reactive.Observer
             * @memberof System.Reactive.Observer
             * @throws <b /> is null.
             * @param   {Function}              T           The type of the elements received by the source observer.
             * @param   {System.IObserver$1}    observer    The observer whose callback invocations should be checked for grammar violations.
             * @return  {System.IObserver$1}                An observer that checks callbacks invocations against the observer grammar and, if the checks pass, forwards those to the specified observer.
             */
            checked: function (T, observer) {
                if (observer == null) {
                    throw new System.ArgumentNullException("observer");
                }

                return new (System.Reactive.CheckedObserver$1(T))(observer);
            },
            /**
             * Synchronizes access to the observer such that its callback methods cannot be called concurrently from multiple threads. This overload is useful when coordinating access to an observer.
             Notice reentrant observer callbacks on the same thread are still possible.
             *
             * @static
             * @public
             * @this System.Reactive.Observer
             * @memberof System.Reactive.Observer
             * @throws <b /> is null.
             * @param   {Function}              T           The type of the elements received by the source observer.
             * @param   {System.IObserver$1}    observer    The observer whose callbacks should be synchronized.
             * @return  {System.IObserver$1}                An observer that delivers callbacks to the specified observer in a synchronized manner.
             */
            synchronize: function (T, observer) {
                if (observer == null) {
                    throw new System.ArgumentNullException("observer");
                }

                return new (System.Reactive.SynchronizedObserver$1(T))(observer, {  });
            },
            /**
             * Synchronizes access to the observer such that its callback methods cannot be called concurrently. This overload is useful when coordinating access to an observer.
             The <b /> parameter configures the type of lock used for synchronization.
             *
             * @static
             * @public
             * @this System.Reactive.Observer
             * @memberof System.Reactive.Observer
             * @throws <b /> is null.
             * @param   {Function}              T                    The type of the elements received by the source observer.
             * @param   {System.IObserver$1}    observer             The observer whose callbacks should be synchronized.
             * @param   {boolean}               preventReentrancy    If set to true, reentrant observer callbacks will be queued up and get delivered to the observer in a sequential manner.
             * @return  {System.IObserver$1}                         An observer that delivers callbacks to the specified observer in a synchronized manner.
             */
            synchronize$1: function (T, observer, preventReentrancy) {
                if (observer == null) {
                    throw new System.ArgumentNullException("observer");
                }

                if (preventReentrancy) {
                    return new (System.Reactive.AsyncLockObserver$1(T))(observer, new System.Reactive.Concurrency.AsyncLock());
                } else {
                    return new (System.Reactive.SynchronizedObserver$1(T))(observer, {  });
                }
            },
            /**
             * Synchronizes access to the observer such that its callback methods cannot be called concurrently by multiple threads, using the specified gate object for use by a {@link }-based lock.
             This overload is useful when coordinating multiple observers that access shared state by synchronizing on a common gate object.
             Notice reentrant observer callbacks on the same thread are still possible.
             *
             * @static
             * @public
             * @this System.Reactive.Observer
             * @memberof System.Reactive.Observer
             * @throws <b /> or <b /> is null.
             * @param   {Function}              T           The type of the elements received by the source observer.
             * @param   {System.IObserver$1}    observer    The observer whose callbacks should be synchronized.
             * @param   {Object}                gate        Gate object to synchronize each observer call on.
             * @return  {System.IObserver$1}                An observer that delivers callbacks to the specified observer in a synchronized manner.
             */
            synchronize$2: function (T, observer, gate) {
                if (observer == null) {
                    throw new System.ArgumentNullException("observer");
                }
                if (gate == null) {
                    throw new System.ArgumentNullException("gate");
                }

                return new (System.Reactive.SynchronizedObserver$1(T))(observer, gate);
            },
            /**
             * Synchronizes access to the observer such that its callback methods cannot be called concurrently, using the specified asynchronous lock to protect against concurrent and reentrant access.
             This overload is useful when coordinating multiple observers that access shared state by synchronizing on a common asynchronous lock.
             *
             * @static
             * @public
             * @this System.Reactive.Observer
             * @memberof System.Reactive.Observer
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                 T            The type of the elements received by the source observer.
             * @param   {System.IObserver$1}                       observer     The observer whose callbacks should be synchronized.
             * @param   {System.Reactive.Concurrency.AsyncLock}    asyncLock    Gate object to synchronize each observer call on.
             * @return  {System.IObserver$1}                                    An observer that delivers callbacks to the specified observer in a synchronized manner.
             */
            synchronize$3: function (T, observer, asyncLock) {
                if (observer == null) {
                    throw new System.ArgumentNullException("observer");
                }
                if (asyncLock == null) {
                    throw new System.ArgumentNullException("asyncLock");
                }

                return new (System.Reactive.AsyncLockObserver$1(T))(observer, asyncLock);
            },
            /**
             * Schedules the invocation of observer methods on the given scheduler.
             *
             * @static
             * @public
             * @this System.Reactive.Observer
             * @memberof System.Reactive.Observer
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  T            The type of the elements received by the source observer.
             * @param   {System.IObserver$1}                        observer     The observer to schedule messages for.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to schedule observer messages on.
             * @return  {System.IObserver$1}                                     Observer whose messages are scheduled on the given scheduler.
             */
            notifyOn: function (T, observer, scheduler) {
                if (observer == null) {
                    throw new System.ArgumentNullException("observer");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return new (System.Reactive.ObserveOnObserver$1(T))(scheduler, observer, null);
            }
        }
    });

    /** @namespace System.Reactive.PlatformServices */

    /**
     * (Infrastructure) Services to rethrow exceptions.
     *
     * @abstract
     * @public
     * @class System.Reactive.PlatformServices.IExceptionServices
     */
    Bridge.define("System.Reactive.PlatformServices.IExceptionServices", {
        $kind: "interface"
    });

    /**
     * (Infrastructure) Interface for enlightenment providers.
     *
     * @abstract
     * @public
     * @class System.Reactive.PlatformServices.IPlatformEnlightenmentProvider
     */
    Bridge.define("System.Reactive.PlatformServices.IPlatformEnlightenmentProvider", {
        $kind: "interface"
    });

    /**
     * (Infrastructure) Provides access to the local system clock.
     *
     * @abstract
     * @public
     * @class System.Reactive.PlatformServices.ISystemClock
     */
    Bridge.define("System.Reactive.PlatformServices.ISystemClock", {
        $kind: "interface"
    });

    /**
     * (Infrastructure) Provides a mechanism to notify local schedulers about system clock changes.
     *
     * @abstract
     * @public
     * @class System.Reactive.PlatformServices.INotifySystemClockChanged
     */
    Bridge.define("System.Reactive.PlatformServices.INotifySystemClockChanged", {
        $kind: "interface"
    });

    /**
     * @memberof System
     * @callback System.EventHandler
     * @param   {Object}                                                      sender    
     * @param   {System.Reactive.PlatformServices.HostSuspendingEventArgs}    e
     * @return  {void}
     */

    /**
     * (Infrastructure) Provides access to the host's lifecycle management services.
     *
     * @static
     * @abstract
     * @public
     * @class System.Reactive.PlatformServices.HostLifecycleService
     */
    Bridge.define("System.Reactive.PlatformServices.HostLifecycleService", {
        statics: {
            s_notifications: null,
            _refCount: 0,
            config: {
                events: {
                    /**
                     * Event that gets raised when the host suspends the application.
                     *
                     * @static
                     * @public
                     * @this System.Reactive.PlatformServices.HostLifecycleService
                     * @memberof System.Reactive.PlatformServices.HostLifecycleService
                     * @function addSuspending
                     * @param   {System.EventHandler}    value
                     * @return  {void}
                     */
                    /**
                     * Event that gets raised when the host suspends the application.
                     *
                     * @static
                     * @public
                     * @this System.Reactive.PlatformServices.HostLifecycleService
                     * @memberof System.Reactive.PlatformServices.HostLifecycleService
                     * @function removeSuspending
                     * @param   {System.EventHandler}    value
                     * @return  {void}
                     */
                    Suspending: null,
                    /**
                     * Event that gets raised when the host resumes the application.
                     *
                     * @static
                     * @public
                     * @this System.Reactive.PlatformServices.HostLifecycleService
                     * @memberof System.Reactive.PlatformServices.HostLifecycleService
                     * @function addResuming
                     * @param   {System.EventHandler}    value
                     * @return  {void}
                     */
                    /**
                     * Event that gets raised when the host resumes the application.
                     *
                     * @static
                     * @public
                     * @this System.Reactive.PlatformServices.HostLifecycleService
                     * @memberof System.Reactive.PlatformServices.HostLifecycleService
                     * @function removeResuming
                     * @param   {System.EventHandler}    value
                     * @return  {void}
                     */
                    Resuming: null
                },
                init: function () {
                    this.s_notifications = new (System.Lazy$1(System.Reactive.PlatformServices.IHostLifecycleNotifications)).ctor(System.Reactive.PlatformServices.HostLifecycleService.initializeNotifications);
                }
            },
            /**
             * Adds a reference to the host lifecycle manager, causing it to be sending notifications.
             *
             * @static
             * @public
             * @this System.Reactive.PlatformServices.HostLifecycleService
             * @memberof System.Reactive.PlatformServices.HostLifecycleService
             * @return  {void}
             */
            addRef: function () {
                if (System.Interlocked.increment(Bridge.ref(System.Reactive.PlatformServices.HostLifecycleService, "_refCount")) === 1) {
                    var notifications = System.Reactive.PlatformServices.HostLifecycleService.s_notifications.getValue();
                    if (notifications != null) {
                        notifications.System$Reactive$PlatformServices$IHostLifecycleNotifications$addSuspending(System.Reactive.PlatformServices.HostLifecycleService.onSuspending);
                        notifications.System$Reactive$PlatformServices$IHostLifecycleNotifications$addResuming(System.Reactive.PlatformServices.HostLifecycleService.onResuming);
                    }
                }
            },
            /**
             * Removes a reference to the host lifecycle manager, causing it to stop sending notifications
             if the removed reference was the last one.
             *
             * @static
             * @public
             * @this System.Reactive.PlatformServices.HostLifecycleService
             * @memberof System.Reactive.PlatformServices.HostLifecycleService
             * @return  {void}
             */
            release: function () {
                if (System.Interlocked.decrement(Bridge.ref(System.Reactive.PlatformServices.HostLifecycleService, "_refCount")) === 0) {
                    var notifications = System.Reactive.PlatformServices.HostLifecycleService.s_notifications.getValue();
                    if (notifications != null) {
                        notifications.System$Reactive$PlatformServices$IHostLifecycleNotifications$removeSuspending(System.Reactive.PlatformServices.HostLifecycleService.onSuspending);
                        notifications.System$Reactive$PlatformServices$IHostLifecycleNotifications$removeResuming(System.Reactive.PlatformServices.HostLifecycleService.onResuming);
                    }
                }
            },
            onSuspending: function (sender, e) {
                var suspending = System.Reactive.PlatformServices.HostLifecycleService.Suspending;
                if (!Bridge.staticEquals(suspending, null)) {
                    suspending(sender, e);
                }
            },
            onResuming: function (sender, e) {
                var resuming = System.Reactive.PlatformServices.HostLifecycleService.Resuming;
                if (!Bridge.staticEquals(resuming, null)) {
                    resuming(sender, e);
                }
            },
            initializeNotifications: function () { /// Type or member is obsolete


                return System.Reactive.PlatformServices.PlatformEnlightenmentProvider.getCurrent().System$Reactive$PlatformServices$IPlatformEnlightenmentProvider$getService(System.Reactive.PlatformServices.IHostLifecycleNotifications);
            }
        }
    });

    /**
     * (Infrastructure) Event arguments for host resumption events.
     *
     * @public
     * @class System.Reactive.PlatformServices.HostResumingEventArgs
     */
    Bridge.define("System.Reactive.PlatformServices.HostResumingEventArgs");

    /**
     * (Infrastructure) Event arguments for host suspension events.
     *
     * @public
     * @class System.Reactive.PlatformServices.HostSuspendingEventArgs
     */
    Bridge.define("System.Reactive.PlatformServices.HostSuspendingEventArgs");

    /**
     * (Infrastructure) Provides notifications about the host's lifecycle events.
     *
     * @abstract
     * @public
     * @class System.Reactive.PlatformServices.IHostLifecycleNotifications
     */
    Bridge.define("System.Reactive.PlatformServices.IHostLifecycleNotifications", {
        $kind: "interface"
    });

    /**
     * The <b>System.Reactive.PlatformServices</b> namespace contains interfaces and classes used by the runtime infrastructure of Reactive Extensions.
     Those are not intended to be used directly from user code and are subject to change in future releases of the product.
     *
     * @class System.Reactive.PlatformServices.NamespaceDoc
     */
    Bridge.define("System.Reactive.PlatformServices.NamespaceDoc");

    /**
     * (Infrastructure) Provider for platform-specific framework enlightenments.
     *
     * @static
     * @abstract
     * @public
     * @class System.Reactive.PlatformServices.PlatformEnlightenmentProvider
     */
    Bridge.define("System.Reactive.PlatformServices.PlatformEnlightenmentProvider", {
        statics: {
            s_current: null,
            config: {
                init: function () {
                    this.s_current = System.Reactive.PlatformServices.PlatformEnlightenmentProvider.createPlatformProvider();
                }
            },
            /**
             * (Infrastructure) Gets the current enlightenment provider. If none is loaded yet, accessing this property triggers provider resolution.
             *
             * @static
             * @public
             * @this System.Reactive.PlatformServices.PlatformEnlightenmentProvider
             * @memberof System.Reactive.PlatformServices.PlatformEnlightenmentProvider
             * @function getCurrent
             * @return  {System.Reactive.PlatformServices.IPlatformEnlightenmentProvider}
             */
            /**
             * (Infrastructure) Gets the current enlightenment provider. If none is loaded yet, accessing this property triggers provider resolution.
             *
             * @static
             * @public
             * @this System.Reactive.PlatformServices.PlatformEnlightenmentProvider
             * @memberof System.Reactive.PlatformServices.PlatformEnlightenmentProvider
             * @function setCurrent
             * @param   {System.Reactive.PlatformServices.IPlatformEnlightenmentProvider}    value
             * @return  {void}
             */
            getCurrent: function () {
                return System.Reactive.PlatformServices.PlatformEnlightenmentProvider.s_current;
            },
            /**
             * (Infrastructure) Gets the current enlightenment provider. If none is loaded yet, accessing this property triggers provider resolution.
             *
             * @static
             * @public
             * @this System.Reactive.PlatformServices.PlatformEnlightenmentProvider
             * @memberof System.Reactive.PlatformServices.PlatformEnlightenmentProvider
             * @function getCurrent
             * @return  {System.Reactive.PlatformServices.IPlatformEnlightenmentProvider}
             */
            /**
             * (Infrastructure) Gets the current enlightenment provider. If none is loaded yet, accessing this property triggers provider resolution.
             *
             * @static
             * @public
             * @this System.Reactive.PlatformServices.PlatformEnlightenmentProvider
             * @memberof System.Reactive.PlatformServices.PlatformEnlightenmentProvider
             * @function setCurrent
             * @param   {System.Reactive.PlatformServices.IPlatformEnlightenmentProvider}    value
             * @return  {void}
             */
            setCurrent: function (value) {
                if (value == null) {
                    throw new System.ArgumentNullException("value");
                }
                System.Reactive.PlatformServices.PlatformEnlightenmentProvider.s_current = value;
            },
            createPlatformProvider: function () {
                //
                // TODO: Investigate whether we can simplify this logic to just use "System.Reactive.PlatformServices.PlatformEnlightenmentProvider, System.Reactive.PlatformServices".
                //       It turns out this doesn't quite work on Silverlight. On the other hand, in .NET Compact Framework 3.5, we mysteriously have to use that path.
                //
                return new System.Reactive.PlatformServices.DefaultPlatformEnlightenmentProvider();
            }
        }
    });

    /**
     * (Infrastructure) Provides access to local system clock services.
     *
     * @static
     * @abstract
     * @public
     * @class System.Reactive.PlatformServices.SystemClock
     */
    Bridge.define("System.Reactive.PlatformServices.SystemClock", {
        statics: {
            s_serviceSystemClock: null,
            s_serviceSystemClockChanged: null,
            s_systemClockChanged: null,
            s_systemClockChangedHandlerCollector: null,
            _refCount: 0,
            config: {
                init: function () {
                    this.s_serviceSystemClock = new (System.Lazy$1(System.Reactive.PlatformServices.ISystemClock)).ctor(System.Reactive.PlatformServices.SystemClock.initializeSystemClock);
                    this.s_serviceSystemClockChanged = new (System.Lazy$1(System.Reactive.PlatformServices.INotifySystemClockChanged)).ctor(System.Reactive.PlatformServices.SystemClock.initializeSystemClockChanged);
                    this.s_systemClockChanged = new (System.Collections.Generic.HashSet$1(System.WeakReference$1(System.Reactive.Concurrency.LocalScheduler))).ctor();
                }
            },
            /**
             * Gets the local system clock time.
             *
             * @static
             * @public
             * @this System.Reactive.PlatformServices.SystemClock
             * @memberof System.Reactive.PlatformServices.SystemClock
             * @function getUtcNow
             * @return  {System.DateTimeOffset}
             */
            /**
             * Gets the local system clock time.
             *
             * @instance
             * @function setUtcNow
             */
            getUtcNow: function () {
                return System.Reactive.PlatformServices.SystemClock.s_serviceSystemClock.getValue().System$Reactive$PlatformServices$ISystemClock$getUtcNow().$clone();
            },
            /**
             * Adds a reference to the system clock monitor, causing it to be sending notifications.
             *
             * @static
             * @public
             * @this System.Reactive.PlatformServices.SystemClock
             * @memberof System.Reactive.PlatformServices.SystemClock
             * @throws Thrown when the system doesn't support sending clock change notifications.
             * @return  {void}
             */
            addRef: function () {
                if (System.Interlocked.increment(Bridge.ref(System.Reactive.PlatformServices.SystemClock, "_refCount")) === 1) {
                    System.Reactive.PlatformServices.SystemClock.s_serviceSystemClockChanged.getValue().System$Reactive$PlatformServices$INotifySystemClockChanged$addSystemClockChanged(System.Reactive.PlatformServices.SystemClock.onSystemClockChanged);
                }
            },
            /**
             * Removes a reference to the system clock monitor, causing it to stop sending notifications
             if the removed reference was the last one.
             *
             * @static
             * @public
             * @this System.Reactive.PlatformServices.SystemClock
             * @memberof System.Reactive.PlatformServices.SystemClock
             * @return  {void}
             */
            release: function () {
                if (System.Interlocked.decrement(Bridge.ref(System.Reactive.PlatformServices.SystemClock, "_refCount")) === 0) {
                    System.Reactive.PlatformServices.SystemClock.s_serviceSystemClockChanged.getValue().System$Reactive$PlatformServices$INotifySystemClockChanged$removeSystemClockChanged(System.Reactive.PlatformServices.SystemClock.onSystemClockChanged);
                }
            },
            onSystemClockChanged: function (sender, e) {
                var $t;
                System.Reactive.PlatformServices.SystemClock.s_systemClockChanged;
                {
                    $t = Bridge.getEnumerator(System.Reactive.PlatformServices.SystemClock.s_systemClockChanged);
                    while ($t.moveNext()) {
                        var entry = $t.getCurrent();
                        var scheduler = { v : null };
                        if (entry.tryGetTarget(scheduler)) {
                            scheduler.v.systemClockChanged(sender, e);
                        }
                    }
                }
            },
            initializeSystemClock: function () { /// Type or member is obsolete


                return System.Reactive.PlatformServices.PlatformEnlightenmentProvider.getCurrent().System$Reactive$PlatformServices$IPlatformEnlightenmentProvider$getService(System.Reactive.PlatformServices.ISystemClock) || new System.Reactive.PlatformServices.DefaultSystemClock(); /// Type or member is obsolete


            },
            initializeSystemClockChanged: function () { /// Type or member is obsolete


                return System.Reactive.PlatformServices.PlatformEnlightenmentProvider.getCurrent().System$Reactive$PlatformServices$IPlatformEnlightenmentProvider$getService(System.Reactive.PlatformServices.INotifySystemClockChanged) || new System.Reactive.PlatformServices.DefaultSystemClockMonitor();
            },
            register: function (scheduler) {
                //
                // LocalScheduler maintains per-instance work queues that need revisiting
                // upon system clock changes. We need to be careful to avoid keeping those
                // scheduler instances alive by the system clock monitor, so we use weak
                // references here. In particular, AsyncLockScheduler in ImmediateScheduler
                // can have a lot of instances, so we need to collect spurious handlers
                // at regular times.
                //
                System.Reactive.PlatformServices.SystemClock.s_systemClockChanged;
                {
                    System.Reactive.PlatformServices.SystemClock.s_systemClockChanged.add(new (System.WeakReference$1(System.Reactive.Concurrency.LocalScheduler))(scheduler));

                    if (System.Reactive.PlatformServices.SystemClock.s_systemClockChanged.getCount() === 1) {
                        System.Reactive.PlatformServices.SystemClock.s_systemClockChangedHandlerCollector = System.Reactive.Concurrency.ConcurrencyAbstractionLayer.getCurrent().System$Reactive$Concurrency$IConcurrencyAbstractionLayer$startPeriodicTimer(System.Reactive.PlatformServices.SystemClock.collectHandlers, System.TimeSpan.fromSeconds(30));
                    } else if (System.Reactive.PlatformServices.SystemClock.s_systemClockChanged.getCount() % 64 === 0) {
                        System.Reactive.PlatformServices.SystemClock.collectHandlers();
                    }
                }
            },
            collectHandlers: function () {
                var $t, $t1;
                //
                // The handler collector merely collects the WeakReference<T> instances
                // that are kept in the hash set. The underlying scheduler itself will
                // be collected due to the weak reference. Unfortunately, we can't use
                // the ConditionalWeakTable<TKey, TValue> type here because we need to
                // be able to enumerate the keys.
                //
                System.Reactive.PlatformServices.SystemClock.s_systemClockChanged;
                {
                    var remove = null;

                    $t = Bridge.getEnumerator(System.Reactive.PlatformServices.SystemClock.s_systemClockChanged);
                    while ($t.moveNext()) {
                        var handler = $t.getCurrent();
                        var scheduler = { v : null };
                        if (!handler.tryGetTarget(scheduler)) {
                            if (remove == null) {
                                remove = new (System.Collections.Generic.HashSet$1(System.WeakReference$1(System.Reactive.Concurrency.LocalScheduler))).ctor();
                            }

                            remove.add(handler);
                        }
                    }

                    if (remove != null) {
                        $t1 = Bridge.getEnumerator(remove);
                        while ($t1.moveNext()) {
                            var handler1 = $t1.getCurrent();
                            System.Reactive.PlatformServices.SystemClock.s_systemClockChanged.remove(handler1);
                        }
                    }

                    if (System.Reactive.PlatformServices.SystemClock.s_systemClockChanged.getCount() === 0) {
                        System.Reactive.PlatformServices.SystemClock.s_systemClockChangedHandlerCollector.System$IDisposable$dispose();
                        System.Reactive.PlatformServices.SystemClock.s_systemClockChangedHandlerCollector = null;
                    }
                }
            }
        }
    });

    /**
     * (Infrastructure) Event arguments for system clock change notifications.
     *
     * @public
     * @class System.Reactive.PlatformServices.SystemClockChangedEventArgs
     */
    Bridge.define("System.Reactive.PlatformServices.SystemClockChangedEventArgs", {
        config: {
            properties: {
                /**
                 * Gets the time before the system clock changed, or DateTimeOffset.MinValue if not known.
                 *
                 * @instance
                 * @public
                 * @this System.Reactive.PlatformServices.SystemClockChangedEventArgs
                 * @memberof System.Reactive.PlatformServices.SystemClockChangedEventArgs
                 * @function getOldTime
                 * @return  {System.DateTimeOffset}
                 */
                /**
                 * Gets the time before the system clock changed, or DateTimeOffset.MinValue if not known.
                 *
                 * @instance
                 * @private
                 * @this System.Reactive.PlatformServices.SystemClockChangedEventArgs
                 * @memberof System.Reactive.PlatformServices.SystemClockChangedEventArgs
                 * @function setOldTime
                 * @param   {System.DateTimeOffset}    value
                 * @return  {void}
                 */
                OldTime: null,
                /**
                 * Gets the time after the system clock changed, or DateTimeOffset.MaxValue if not known.
                 *
                 * @instance
                 * @public
                 * @this System.Reactive.PlatformServices.SystemClockChangedEventArgs
                 * @memberof System.Reactive.PlatformServices.SystemClockChangedEventArgs
                 * @function getNewTime
                 * @return  {System.DateTimeOffset}
                 */
                /**
                 * Gets the time after the system clock changed, or DateTimeOffset.MaxValue if not known.
                 *
                 * @instance
                 * @private
                 * @this System.Reactive.PlatformServices.SystemClockChangedEventArgs
                 * @memberof System.Reactive.PlatformServices.SystemClockChangedEventArgs
                 * @function setNewTime
                 * @param   {System.DateTimeOffset}    value
                 * @return  {void}
                 */
                NewTime: null
            },
            init: function () {
                this.OldTime = new System.DateTimeOffset();
                this.NewTime = new System.DateTimeOffset();
            }
        },
        /**
         * Creates a new system clock notification object with unknown old and new times.
         *
         * @instance
         * @public
         * @this System.Reactive.PlatformServices.SystemClockChangedEventArgs
         * @memberof System.Reactive.PlatformServices.SystemClockChangedEventArgs
         * @return  {void}
         */
        ctor: function () {
            System.Reactive.PlatformServices.SystemClockChangedEventArgs.$ctor1.call(this, System.DateTimeOffset.minValue.$clone(), System.DateTimeOffset.maxValue.$clone());
        },
        /**
         * Creates a new system clock notification object with the specified old and new times.
         *
         * @instance
         * @public
         * @this System.Reactive.PlatformServices.SystemClockChangedEventArgs
         * @memberof System.Reactive.PlatformServices.SystemClockChangedEventArgs
         * @param   {System.DateTimeOffset}    oldTime    Time before the system clock changed, or DateTimeOffset.MinValue if not known.
         * @param   {System.DateTimeOffset}    newTime    Time after the system clock changed, or DateTimeOffset.MaxValue if not known.
         * @return  {void}
         */
        $ctor1: function (oldTime, newTime) {
            this.$initialize();
            this.setOldTime(oldTime.$clone());
            this.setNewTime(newTime.$clone());
        }
    });

    Bridge.define("System.Reactive.PriorityQueue$1", function (T) { return {
        statics: {
            _count: System.Int64([0,-2147483648])
        },
        _items: null,
        _size: 0,
        ctor: function () {
            System.Reactive.PriorityQueue$1(T).$ctor1.call(this, 16);
        },
        $ctor1: function (capacity) {
            this.$initialize();
            this._items = System.Array.init(capacity, function (){
                return new (System.Reactive.PriorityQueue$1.IndexedItem(T))();
            });
            this._size = 0;
        },
        getCount: function () {
            return this._size;
        },
        isHigherPriority: function (left, right) {
            return this._items[left].compareTo(this._items[right].$clone()) < 0;
        },
        percolate: function (index) {
            if (index >= this._size || index < 0) {
                return;
            }
            var parent = (Bridge.Int.div((((index - 1) | 0)), 2)) | 0;
            if (parent < 0 || parent === index) {
                return;
            }

            if (this.isHigherPriority(index, parent)) {
                var temp = this._items[index].$clone();
                this._items[index] = this._items[parent].$clone();
                this._items[parent] = temp.$clone();
                this.percolate(parent);
            }
        },
        heapify: function () {
            this.heapify$1(0);
        },
        heapify$1: function (index) {
            if (index >= this._size || index < 0) {
                return;
            }

            var left = (((2 * index) | 0) + 1) | 0;
            var right = (((2 * index) | 0) + 2) | 0;
            var first = index;

            if (left < this._size && this.isHigherPriority(left, first)) {
                first = left;
            }
            if (right < this._size && this.isHigherPriority(right, first)) {
                first = right;
            }
            if (first !== index) {
                var temp = this._items[index].$clone();
                this._items[index] = this._items[first].$clone();
                this._items[first] = temp.$clone();
                this.heapify$1(first);
            }
        },
        peek: function () {
            if (this._size === 0) {
                throw new System.InvalidOperationException(System.Reactive.Strings_Core.HEAP_EMPTY);
            }

            return this._items[0].value;
        },
        removeAt: function (index) {
            this._items[index] = this._items[((this._size = (this._size - 1) | 0))].$clone();
            this._items[this._size] = Bridge.getDefaultValue(System.Reactive.PriorityQueue$1.IndexedItem(T));
            this.heapify();
            if (this._size < ((Bridge.Int.div(this._items.length, 4)) | 0)) {
                var temp = this._items;
                this._items = System.Array.init(((Bridge.Int.div(this._items.length, 2)) | 0), function (){
                    return new (System.Reactive.PriorityQueue$1.IndexedItem(T))();
                });
                System.Array.copy(temp, 0, this._items, 0, this._size);
            }
        },
        dequeue: function () {
            var result = this.peek();
            this.removeAt(0);
            return result;
        },
        enqueue: function (item) {
            if (this._size >= this._items.length) {
                var temp = this._items;
                this._items = System.Array.init(((this._items.length * 2) | 0), function (){
                    return new (System.Reactive.PriorityQueue$1.IndexedItem(T))();
                });
                System.Array.copy(temp, 0, this._items, 0, temp.length);
            }

            var index = Bridge.identity(this._size, (this._size = (this._size + 1) | 0));
            this._items[index] = Bridge.merge(new (System.Reactive.PriorityQueue$1.IndexedItem(T))(), {
                value: item,
                id: System.Interlocked.increment$1(Bridge.ref(System.Reactive.PriorityQueue$1(T), "_count"))
            } );
            this.percolate(index);
        },
        remove: function (item) {
            for (var i = 0; i < this._size; i = (i + 1) | 0) {
                if (System.Collections.Generic.EqualityComparer$1(T).def.equals2(this._items[i].value, item)) {
                    this.removeAt(i);
                    return true;
                }
            }

            return false;
        }
    }; });

    Bridge.define("System.Reactive.PriorityQueue$1.IndexedItem", function (T) { return {
        inherits: function () { return [System.IComparable$1(System.Reactive.PriorityQueue$1.IndexedItem(T))]; },
        $kind: "struct",
        statics: {
            getDefaultValue: function () { return new (System.Reactive.PriorityQueue$1.IndexedItem(T))(); }
        },
        value: Bridge.getDefaultValue(T),
        id: System.Int64(0),
        config: {
            alias: [
            "compareTo", "System$IComparable$1$System$Reactive$PriorityQueue$1$IndexedItem$" + Bridge.getTypeAlias(T) + "$compareTo"
            ]
        },
        ctor: function () {
            this.$initialize();
        },
        compareTo: function (other) {
            var c = Bridge.compare(this.value, other.value, false, T);
            if (c === 0) {
                c = this.id.compareTo(other.id);
            }
            return c;
        },
        getHashCode: function () {
            var h = Bridge.addHash([2939566389, this.value, this.id]);
            return h;
        },
        equals: function (o) {
            if (!Bridge.is(o, System.Reactive.PriorityQueue$1.IndexedItem(T))) {
                return false;
            }
            return Bridge.equals(this.value, o.value) && Bridge.equals(this.id, o.id);
        },
        $clone: function (to) {
            var s = to || new (System.Reactive.PriorityQueue$1.IndexedItem(T))();
            s.value = this.value;
            s.id = this.id;
            return s;
        }
    }; });

    Bridge.define("System.Reactive.Producer$1.State", function (TSource) { return {
        $kind: "struct",
        statics: {
            getDefaultValue: function () { return new (System.Reactive.Producer$1.State(TSource))(); }
        },
        sink: null,
        subscription: null,
        observer: null,
        ctor: function () {
            this.$initialize();
        },
        assign: function (s) {
            this.sink.setDisposable(s);
        },
        getHashCode: function () {
            var h = Bridge.addHash([1952543928, this.sink, this.subscription, this.observer]);
            return h;
        },
        equals: function (o) {
            if (!Bridge.is(o, System.Reactive.Producer$1.State(TSource))) {
                return false;
            }
            return Bridge.equals(this.sink, o.sink) && Bridge.equals(this.subscription, o.subscription) && Bridge.equals(this.observer, o.observer);
        },
        $clone: function (to) {
            var s = to || new (System.Reactive.Producer$1.State(TSource))();
            s.sink = this.sink;
            s.subscription = this.subscription;
            s.observer = this.observer;
            return s;
        }
    }; });

    Bridge.define("System.Reactive.ReflectionUtils", {
        statics: {
            createDelegate: function (TDelegate, o, method) {
                return Bridge.cast(Bridge.Reflection.midel(method, o), TDelegate);
            },
            createDelegate$1: function (delegateType, o, method) {
                return Bridge.Reflection.midel(method, o);
            },
            getEventMethods: function (TSender, TEventArgs, targetType, target, eventName, addMethod, removeMethod, delegateType, isWinRT) {
                var e = null;

                if (target == null) {
                    e = System.Reactive.ReflectionUtils.getEventEx(targetType, eventName, true);
                    if (e == null) {
                        throw new System.InvalidOperationException(System.String.formatProvider(System.Globalization.CultureInfo.getCurrentCulture(), System.Reactive.Strings_Linq.COULD_NOT_FIND_STATIC_EVENT, eventName, Bridge.Reflection.getTypeFullName(targetType)));
                    }
                } else {
                    e = System.Reactive.ReflectionUtils.getEventEx(targetType, eventName, false);
                    if (e == null) {
                        throw new System.InvalidOperationException(System.String.formatProvider(System.Globalization.CultureInfo.getCurrentCulture(), System.Reactive.Strings_Linq.COULD_NOT_FIND_INSTANCE_EVENT, eventName, Bridge.Reflection.getTypeFullName(targetType)));
                    }
                }

                addMethod.v = System.Reflection.EventInfoExtensions.getAddMethod(e);
                removeMethod.v = System.Reflection.EventInfoExtensions.getRemoveMethod(e);

                if (addMethod.v == null) {
                    throw new System.InvalidOperationException(System.Reactive.Strings_Linq.EVENT_MISSING_ADD_METHOD);
                }
                if (removeMethod.v == null) {
                    throw new System.InvalidOperationException(System.Reactive.Strings_Linq.EVENT_MISSING_REMOVE_METHOD);
                }

                var psa = (addMethod.v.pi || []);
                if (psa.length !== 1) {
                    throw new System.InvalidOperationException(System.Reactive.Strings_Linq.EVENT_ADD_METHOD_SHOULD_TAKE_ONE_PARAMETER);
                }

                var psr = (removeMethod.v.pi || []);
                if (psr.length !== 1) {
                    throw new System.InvalidOperationException(System.Reactive.Strings_Linq.EVENT_REMOVE_METHOD_SHOULD_TAKE_ONE_PARAMETER);
                }

                isWinRT.v = false;


                delegateType.v = psa[0].pt;

                var invokeMethod = Bridge.Reflection.getMembers(delegateType.v, 8, 284, "Invoke");

                var parameters = (invokeMethod.pi || []);

                if (parameters.length !== 2) {
                    throw new System.InvalidOperationException(System.Reactive.Strings_Linq.EVENT_PATTERN_REQUIRES_TWO_PARAMETERS);
                }

                if (!Bridge.Reflection.isAssignableFrom(TSender, parameters[0].pt)) {
                    throw new System.InvalidOperationException(System.String.formatProvider(System.Globalization.CultureInfo.getCurrentCulture(), System.Reactive.Strings_Linq.EVENT_SENDER_NOT_ASSIGNABLE, Bridge.Reflection.getTypeFullName(TSender)));
                }

                if (!Bridge.Reflection.isAssignableFrom(TEventArgs, parameters[1].pt)) {
                    throw new System.InvalidOperationException(System.String.formatProvider(System.Globalization.CultureInfo.getCurrentCulture(), System.Reactive.Strings_Linq.EVENT_ARGS_NOT_ASSIGNABLE, Bridge.Reflection.getTypeFullName(TEventArgs)));
                }

                if (!Bridge.referenceEquals(invokeMethod.rt, Object)) {
                    throw new System.InvalidOperationException(System.Reactive.Strings_Linq.EVENT_MUST_RETURN_VOID);
                }
            },
            getEventEx: function (type, name, isStatic) {
                return Bridge.Reflection.getMembers(type, 2, isStatic ? 24 : 20 | 256, name);
            }
        }
    });

    Bridge.define("System.Reactive.Strings_Core", {
        statics: {
            FAILED_CLOCK_MONITORING: "FAILED_CLOCK_MONITORING",
            CANT_OBTAIN_SCHEDULER: "CANT_OBTAIN_SCHEDULER",
            DISPOSABLES_CANT_CONTAIN_NULL: "DISPOSABLES_CANT_CONTAIN_NULL",
            DISPOSABLE_ALREADY_ASSIGNED: "DISPOSABLE_ALREADY_ASSIGNED",
            REENTRANCY_DETECTED: "REENTRANCY_DETECTED",
            OBSERVER_TERMINATED: "OBSERVER_TERMINATED",
            HEAP_EMPTY: "HEAP_EMPTY",
            COMPLETED_NO_VALUE: "COMPLETED_NO_VALUE"
        }
    });

    Bridge.define("System.Reactive.Strings_Linq", {
        statics: {
            NO_ELEMENTS: "NO_ELEMENTS",
            MORE_THAN_ONE_ELEMENT: "MORE_THAN_ONE_ELEMENT",
            CANT_ADVANCE_WHILE_RUNNING: "CANT_ADVANCE_WHILE_RUNNING",
            EVENT_MISSING_ADD_METHOD: "EVENT_MISSING_ADD_METHOD",
            EVENT_MISSING_REMOVE_METHOD: "EVENT_MISSING_REMOVE_METHOD",
            EVENT_ADD_METHOD_SHOULD_TAKE_ONE_PARAMETER: "EVENT_ADD_METHOD_SHOULD_TAKE_ONE_PARAMETER",
            EVENT_REMOVE_METHOD_SHOULD_TAKE_ONE_PARAMETER: "EVENT_REMOVE_METHOD_SHOULD_TAKE_ONE_PARAMETER",
            COULD_NOT_FIND_INSTANCE_EVENT: "COULD_NOT_FIND_INSTANCE_EVENT",
            COULD_NOT_FIND_STATIC_EVENT: "COULD_NOT_FIND_STATIC_EVENT",
            EVENT_PATTERN_REQUIRES_TWO_PARAMETERS: "EVENT_PATTERN_REQUIRES_TWO_PARAMETERS",
            EVENT_SENDER_NOT_ASSIGNABLE: "EVENT_SENDER_NOT_ASSIGNABLE",
            EVENT_ARGS_NOT_ASSIGNABLE: "EVENT_ARGS_NOT_ASSIGNABLE",
            EVENT_MUST_RETURN_VOID: "EVENT_MUST_RETURN_VOID",
            NO_MATCHING_ELEMENTS: "NO_MATCHING_ELEMENTS",
            MORE_THAN_ONE_MATCHING_ELEMENT: "MORE_THAN_ONE_MATCHING_ELEMENT"
        }
    });

    Bridge.define("System.Reactive.Stubs", {
        statics: {
            nop: null,
            throw: null,
            config: {
                init: function () {
                    this.nop = $asm.$.System.Reactive.Stubs.f1;
                    this.throw = $asm.$.System.Reactive.Stubs.f2;
                }
            }
        }
    });

    Bridge.ns("System.Reactive.Stubs", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Stubs, {
        f1: function () {
        },
        f2: function (ex) {
            System.Reactive.ExceptionHelpers.throw(ex);
        }
    });

    Bridge.define("System.Reactive.Stubs$1", function (T) { return {
        statics: {
            ignore: null,
            i: null,
            config: {
                init: function () {
                    this.ignore = $asm.$.System.Reactive.Stubs$1.f1;
                    this.i = $asm.$.System.Reactive.Stubs$1.f2;
                }
            }
        }
    }; });

    Bridge.ns("System.Reactive.Stubs$1", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Stubs$1, {
        f1: function (_) {
        },
        f2: function (_) {
            return _;
        }
    });

    Bridge.define("System.Reactive.Subjects.AsyncSubject$1.Subscription", function (T) { return {
        inherits: [System.IDisposable],
        _subject: null,
        _observer: null,
        config: {
            alias: [
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function (subject, observer) {
            this.$initialize();
            this._subject = subject;
            this._observer = observer;
        },
        dispose: function () {
            if (this._observer != null) {
                this._subject._gate;
                {
                    if (!this._subject._isDisposed && this._observer != null) {
                        this._subject._observers = this._subject._observers.remove(this._observer);
                        this._observer = null;
                    }
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Subjects.BehaviorSubject$1.Subscription", function (T) { return {
        inherits: [System.IDisposable],
        _subject: null,
        _observer: null,
        config: {
            alias: [
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function (subject, observer) {
            this.$initialize();
            this._subject = subject;
            this._observer = observer;
        },
        dispose: function () {
            if (this._observer != null) {
                this._subject._gate;
                {
                    if (!this._subject._isDisposed && this._observer != null) {
                        this._subject._observers = this._subject._observers.remove(this._observer);
                        this._observer = null;
                    }
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Subjects.ConnectableObservable$2.Connection", function (TSource, TResult) { return {
        inherits: [System.IDisposable],
        _parent: null,
        _subscription: null,
        config: {
            alias: [
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function (parent, subscription) {
            this.$initialize();
            this._parent = parent;
            this._subscription = subscription;
        },
        dispose: function () {
            this._parent._gate;
            {
                if (this._subscription != null) {
                    this._subscription.System$IDisposable$dispose();
                    this._subscription = null;

                    this._parent._connection = null;
                }
            }
        }
    }; });

    /** @namespace System.Reactive.Subjects */

    /**
     * The <b>System.Reactive.Subjects</b> namespace contains interfaces and classes to represent subjects, which are objects implementing both IObservable&lt;T&gt; and IObserver&lt;T&gt;.
     Subjects are often used as sources of events, allowing one party to raise events and allowing another party to write queries over the event stream. Because of their ability to
     have multiple registered observers, subjects are also used as a facility to provide multicast behavior for event streams in queries.
     *
     * @class System.Reactive.Subjects.NamespaceDoc
     */
    Bridge.define("System.Reactive.Subjects.NamespaceDoc");

    Bridge.define("System.Reactive.Subjects.ReplaySubject$1.ReplayBase.Subscription", function (T) { return {
        inherits: [System.IDisposable],
        _subject: null,
        _observer: null,
        config: {
            alias: [
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function (subject, observer) {
            this.$initialize();
            this._subject = subject;
            this._observer = observer;
        },
        dispose: function () {
            this._observer.System$IDisposable$dispose();
            this._subject.unsubscribe(this._observer);
        }
    }; });

    /**
     * Provides a set of static methods for creating subjects.
     *
     * @static
     * @abstract
     * @public
     * @class System.Reactive.Subjects.Subject
     */
    Bridge.define("System.Reactive.Subjects.Subject", {
        statics: {
            /**
             * Creates a subject from the specified observer and observable.
             *
             * @static
             * @public
             * @this System.Reactive.Subjects.Subject
             * @memberof System.Reactive.Subjects.Subject
             * @throws <b /> or <b /> is null.
             * @param   {Function}                               TSource       The type of the elements received by the observer.
             * @param   {Function}                               TResult       The type of the elements produced by the observable sequence.
             * @param   {System.IObserver$1}                     observer      The observer used to send messages to the subject.
             * @param   {System.IObservable$1}                   observable    The observable used to subscribe to messages sent from the subject.
             * @return  {System.Reactive.Subjects.ISubject$2}                  Subject implemented using the given observer and observable.
             */
            create$1: function (TSource, TResult, observer, observable) {
                if (observer == null) {
                    throw new System.ArgumentNullException("observer");
                }
                if (observable == null) {
                    throw new System.ArgumentNullException("observable");
                }

                return new (System.Reactive.Subjects.Subject.AnonymousSubject$2(TSource,TResult))(observer, observable);
            },
            /**
             * Creates a subject from the specified observer and observable.
             *
             * @static
             * @public
             * @this System.Reactive.Subjects.Subject
             * @memberof System.Reactive.Subjects.Subject
             * @throws <b /> or <b /> is null.
             * @param   {Function}                               T             The type of the elements received by the observer and produced by the observable sequence.
             * @param   {System.IObserver$1}                     observer      The observer used to send messages to the subject.
             * @param   {System.IObservable$1}                   observable    The observable used to subscribe to messages sent from the subject.
             * @return  {System.Reactive.Subjects.ISubject$1}                  Subject implemented using the given observer and observable.
             */
            create: function (T, observer, observable) {
                if (observer == null) {
                    throw new System.ArgumentNullException("observer");
                }
                if (observable == null) {
                    throw new System.ArgumentNullException("observable");
                }

                return new (System.Reactive.Subjects.Subject.AnonymousSubject$1(T))(observer, observable);
            },
            /**
             * Synchronizes the messages sent to the subject.
             *
             * @static
             * @public
             * @this System.Reactive.Subjects.Subject
             * @memberof System.Reactive.Subjects.Subject
             * @throws <b /> is null.
             * @param   {Function}                               TSource    The type of the elements received by the subject.
             * @param   {Function}                               TResult    The type of the elements produced by the subject.
             * @param   {System.Reactive.Subjects.ISubject$2}    subject    The subject to synchronize.
             * @return  {System.Reactive.Subjects.ISubject$2}               Subject whose messages are synchronized.
             */
            synchronize$2: function (TSource, TResult, subject) {
                if (subject == null) {
                    throw new System.ArgumentNullException("subject");
                }

                return new (System.Reactive.Subjects.Subject.AnonymousSubject$2(TSource,TResult))(System.Reactive.Observer.synchronize(TSource, subject), subject);
            },
            /**
             * Synchronizes the messages sent to the subject.
             *
             * @static
             * @public
             * @this System.Reactive.Subjects.Subject
             * @memberof System.Reactive.Subjects.Subject
             * @throws <b /> is null.
             * @param   {Function}                               TSource    The type of the elements received and produced by the subject.
             * @param   {System.Reactive.Subjects.ISubject$1}    subject    The subject to synchronize.
             * @return  {System.Reactive.Subjects.ISubject$1}               Subject whose messages are synchronized.
             */
            synchronize: function (TSource, subject) {
                if (subject == null) {
                    throw new System.ArgumentNullException("subject");
                }

                return new (System.Reactive.Subjects.Subject.AnonymousSubject$1(TSource))(System.Reactive.Observer.synchronize(TSource, subject), subject);
            },
            /**
             * Synchronizes the messages sent to the subject and notifies observers on the specified scheduler.
             *
             * @static
             * @public
             * @this System.Reactive.Subjects.Subject
             * @memberof System.Reactive.Subjects.Subject
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TSource      The type of the elements received by the subject.
             * @param   {Function}                                  TResult      The type of the elements produced by the subject.
             * @param   {System.Reactive.Subjects.ISubject$2}       subject      The subject to synchronize.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to notify observers on.
             * @return  {System.Reactive.Subjects.ISubject$2}                    Subject whose messages are synchronized and whose observers are notified on the given scheduler.
             */
            synchronize$3: function (TSource, TResult, subject, scheduler) {
                if (subject == null) {
                    throw new System.ArgumentNullException("subject");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return new (System.Reactive.Subjects.Subject.AnonymousSubject$2(TSource,TResult))(System.Reactive.Observer.synchronize(TSource, subject), System.Reactive.Linq.Observable.observeOn(TResult, subject, scheduler));
            },
            /**
             * Synchronizes the messages sent to the subject and notifies observers on the specified scheduler.
             *
             * @static
             * @public
             * @this System.Reactive.Subjects.Subject
             * @memberof System.Reactive.Subjects.Subject
             * @throws <b /> or <b /> is null.
             * @param   {Function}                                  TSource      The type of the elements received and produced by the subject.
             * @param   {System.Reactive.Subjects.ISubject$1}       subject      The subject to synchronize.
             * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler to notify observers on.
             * @return  {System.Reactive.Subjects.ISubject$1}                    Subject whose messages are synchronized and whose observers are notified on the given scheduler.
             */
            synchronize$1: function (TSource, subject, scheduler) {
                if (subject == null) {
                    throw new System.ArgumentNullException("subject");
                }
                if (scheduler == null) {
                    throw new System.ArgumentNullException("scheduler");
                }

                return new (System.Reactive.Subjects.Subject.AnonymousSubject$1(TSource))(System.Reactive.Observer.synchronize(TSource, subject), System.Reactive.Linq.Observable.observeOn(TSource, subject, scheduler));
            }
        }
    });

    Bridge.define("System.Reactive.Subjects.Subject$1.Subscription", function (T) { return {
        inherits: [System.IDisposable],
        _subject: null,
        _observer: null,
        config: {
            alias: [
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function (subject, observer) {
            this.$initialize();
            this._subject = subject;
            this._observer = observer;
        },
        dispose: function () {
            var observer = System.Interlocked.exchange(System.IObserver$1(T), Bridge.ref(this, "_observer"), null);
            if (observer == null) {
                return;
            }

            this._subject.unsubscribe(observer);
            this._subject = null;
        }
    }; });

    Bridge.define("System.Reactive.Threading.Semaphore", {
        inherits: [System.IDisposable],
        m_currentCount: 0,
        m_maximumCount: 0,
        m_lockObject: null,
        m_disposed: false,
        m_waiting: null,
        config: {
            alias: [
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function (initialCount, maximumCount) {
            this.$initialize();
            if (initialCount < 0) {
                throw new System.ArgumentOutOfRangeException("initialCount", "Non-negative number required.");
            }
            if (maximumCount < 1) {
                throw new System.ArgumentOutOfRangeException("maximumCount", "Positive number required.");
            }
            if (initialCount > maximumCount) {
                throw new System.ArgumentException("Initial count must be smaller than maximum");
            }
            this.m_waiting = new (System.Collections.Generic.List$1(System.Threading.ManualResetEvent))();
            this.m_currentCount = initialCount;
            this.m_maximumCount = maximumCount;
            this.m_lockObject = {  };
        },
        release: function () {
            return this.release$1(1);
        },
        release$1: function (releaseCount) {
            var $t;
            if (releaseCount < 1) {
                throw new System.ArgumentOutOfRangeException("releaseCount", "Positive number required.");
            }
            if (this.m_disposed) {
                throw new System.ObjectDisposedException("Semaphore");
            }

            var oldCount = Bridge.getDefaultValue(System.Int32);
            var toBeReleased = new (System.Collections.Generic.List$1(System.Threading.ManualResetEvent))();
            this.m_lockObject;
            {
                oldCount = this.m_currentCount;
                if (((releaseCount + this.m_currentCount) | 0) > this.m_maximumCount) {
                    throw new System.ArgumentOutOfRangeException("releaseCount", "Amount of releases would overflow maximum");
                }

                var waiting = this.m_waiting.toArray();
                var left = Math.max(0, ((releaseCount - waiting.length) | 0));
                for (var i = 0; i < releaseCount && i < this.m_waiting.getCount(); i = (i + 1) | 0) {
                    toBeReleased.add(waiting[i]);
                    this.m_waiting.removeAt(0);
                }
                this.m_currentCount = (this.m_currentCount + left) | 0;
            }
            $t = Bridge.getEnumerator(toBeReleased);
            while ($t.moveNext()) {
                var release = $t.getCurrent();
                release.set();
            }
            return oldCount;
        },
        waitOne: function () {
            return this.waitOne$1(-1);
        },
        waitOne$1: function (millisecondsTimeout) {
            if (this.m_disposed) {
                throw new System.ObjectDisposedException("Semaphore");
            }

            var manualResetEvent = null;

            this.m_lockObject;
            {
                if (this.m_currentCount === 0) {
                    manualResetEvent = new System.Threading.ManualResetEvent(false);
                    this.m_waiting.add(manualResetEvent);
                } else {
                    this.m_currentCount = (this.m_currentCount - 1) | 0;
                    return true;
                }
            }
            if (!manualResetEvent.waitOne(millisecondsTimeout)) {
                this.m_lockObject;
                {
                    this.m_waiting.remove(manualResetEvent);
                }
                return false;
            }
            return true;
        },
        waitOne$2: function (timeout) {
            return this.waitOne$1(Bridge.Int.clip32(timeout.getTotalMilliseconds()));
        },
        close: function () {
            this.dispose();
        },
        dispose: function () {
            //the .NET CLR semaphore does not release waits upon dispose
            //so we don't do that either.
            this.m_disposed = true;
        }
    });

    Bridge.define("System.Reactive.TimerStubs", {
        statics: {
            never: null,
            config: {
                init: function () {
                    this.never = new System.Threading.Timer.ctor($asm.$.System.Reactive.TimerStubs.f1);
                }
            }
        }
    });

    Bridge.ns("System.Reactive.TimerStubs", $asm.$);

    Bridge.apply($asm.$.System.Reactive.TimerStubs, {
        f1: function (_) {
        }
    });

    /**
     * A helper class with a factory method for creating Timestamped&lt;T&gt; instances.
     *
     * @static
     * @abstract
     * @public
     * @class System.Reactive.Timestamped
     */
    Bridge.define("System.Reactive.Timestamped", {
        statics: {
            /**
             * Creates an instance of a Timestamped&lt;T&gt;.  This is syntactic sugar that uses type inference
             to avoid specifying a type in a constructor call, which is very useful when using anonymous types.
             *
             * @static
             * @public
             * @this System.Reactive.Timestamped
             * @memberof System.Reactive.Timestamped
             * @param   {Function}                         T            
             * @param   {T}                                value        The value to be annotated with a timestamp.
             * @param   {System.DateTimeOffset}            timestamp    Timestamp associated with the value.
             * @return  {System.Reactive.Timestamped$1}                 Creates a new timestamped value.
             */
            create: function (T, value, timestamp) {
                return new (System.Reactive.Timestamped$1(T)).$ctor1(value, timestamp.$clone());
            }
        }
    });

    /**
     * Represents a type with a single value. This type is often used to denote the successful completion of a void-returning method (C#) or a Sub procedure (Visual Basic).
     *
     * @public
     * @class System.Reactive.Unit
     * @implements  System.IEquatable$1
     */
    Bridge.define("System.Reactive.Unit", {
        inherits: function () { return [System.IEquatable$1(System.Reactive.Unit)]; },
        $kind: "struct",
        statics: {
            config: {
                init: function () {
                    this._default = new System.Reactive.Unit();
                }
            },
            /**
             * Gets the single unit value.
             *
             * @static
             * @public
             * @this System.Reactive.Unit
             * @memberof System.Reactive.Unit
             * @function getDefault
             * @return  {System.Reactive.Unit}
             */
            /**
             * Gets the single unit value.
             *
             * @instance
             * @function setDefault
             */
            getDefault: function () {
                return System.Reactive.Unit._default;
            }/**
             * Determines whether the two specified Unit values are equal. Because Unit has a single value, this always returns true.
             *
             * @static
             * @public
             * @this System.Reactive.Unit
             * @memberof System.Reactive.Unit
             * @param   {System.Reactive.Unit}    first     The first Unit value to compare.
             * @param   {System.Reactive.Unit}    second    The second Unit value to compare.
             * @return  {boolean}                           Because Unit has a single value, this always returns true.
             */
            ,
            op_Equality: function (first, second) {
                return true;
            }/**
             * Determines whether the two specified Unit values are not equal. Because Unit has a single value, this always returns false.
             *
             * @static
             * @public
             * @this System.Reactive.Unit
             * @memberof System.Reactive.Unit
             * @param   {System.Reactive.Unit}    first     The first Unit value to compare.
             * @param   {System.Reactive.Unit}    second    The second Unit value to compare.
             * @return  {boolean}                           Because Unit has a single value, this always returns false.
             */
            ,
            op_Inequality: function (first, second) {
                return false;
            },
            getDefaultValue: function () { return new System.Reactive.Unit(); }
        },
        config: {
            alias: [
            "equalsT", "System$IEquatable$1$System$Reactive$Unit$equalsT"
            ]
        },
        ctor: function () {
            this.$initialize();
        },
        /**
         * Determines whether the specified Unit values is equal to the current Unit. Because Unit has a single value, this always returns true.
         *
         * @instance
         * @public
         * @this System.Reactive.Unit
         * @memberof System.Reactive.Unit
         * @param   {System.Reactive.Unit}    other    An object to compare to the current Unit value.
         * @return  {boolean}                          Because Unit has a single value, this always returns true.
         */
        equalsT: function (other) {
            return true;
        },
        /**
         * Determines whether the specified System.Object is equal to the current Unit.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Unit
         * @memberof System.Reactive.Unit
         * @param   {Object}     obj    The System.Object to compare with the current Unit.
         * @return  {boolean}           true if the specified System.Object is a Unit value; otherwise, false.
         */
        equals: function (obj) {
            return Bridge.is(obj, System.Reactive.Unit);
        },
        /**
         * Returns the hash code for the current Unit value.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Unit
         * @memberof System.Reactive.Unit
         * @return  {number}        A hash code for the current Unit value.
         */
        getHashCode: function () {
            return 0;
        },
        /**
         * Returns a string representation of the current Unit value.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Unit
         * @memberof System.Reactive.Unit
         * @return  {string}        String representation of the current Unit value.
         */
        toString: function () {
            return "()";
        },
        $clone: function (to) { return this; }
    });

    Bridge.define("System.Reflection.EventInfoExtensions", {
        statics: {
            getAddMethod: function (evt) {
                return null;
            },
            getRemoveMethod: function (evt) {
                return null;
            }
        }
    });

    Bridge.define("System.Runtime.CompilerServices.CompilerGeneratedAttribute", {
        inherits: [System.Attribute],
        ctor: function () {
            this.$initialize();
            System.Attribute.ctor.call(this);
        }
    });

    Bridge.define("System.TargetInvocationException", {
        inherits: [System.Exception],
        ctor: function (msg) {
            this.$initialize();
            System.Exception.ctor.call(this, msg);
        }
    });

    /** @namespace System.Threading */

    /**
     * This class is a hack to facilitate Bridge.net compatibility, use at your own risk
     *
     * @class System.Threading.ManualResetEvent
     * @implements  System.IDisposable
     */
    Bridge.define("System.Threading.ManualResetEvent", {
        inherits: [System.IDisposable],
        _state: false,
        config: {
            alias: [
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function (initial) {
            this.$initialize();
            this._state = initial;
        },
        set: function () {
            this._state = true;
        },
        waitOne: function (period) {
            if (period === void 0) { period = -1; }
            if (period < 0) {
                while (!this._state) {
                    Bridge.sleep(1);
                }
            } else {
                var abort = false;
                new System.Threading.Timer.$ctor1(function (x) {
                    abort = true;
                }, null, period, -1);
                while (!this._state && !abort) {
                    Bridge.sleep(1);
                }
            }
            return this._state;
        },
        dispose: function () {
            this.set();
        }
    });

    /**
     * Non-Volatile Volatile class for Bridge.net support
     *
     * @static
     * @abstract
     * @class System.Threading.Volatile
     */
    Bridge.define("System.Threading.Volatile", {
        statics: {
            read$1: function (location) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                var value = location.v;
                //Thread.MemoryBarrier();
                return value;
            },
            read$8: function (location) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                var value = location.v;
                //Thread.MemoryBarrier();
                return value;
            },
            read$2: function (location) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                var value = location.v;
                //Thread.MemoryBarrier();
                return value;
            },
            read$4: function (location) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                var value = location.v;
                //Thread.MemoryBarrier();
                return value;
            },
            read$10: function (location) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                var value = location.v;
                //Thread.MemoryBarrier();
                return value;
            },
            read$5: function (location) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                var value = location.v;
                //Thread.MemoryBarrier();
                return value;
            },
            read$11: function (location) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                var value = location.v;
                //Thread.MemoryBarrier();
                return value;
            },
            read$6: function (location) {
                //
                // On 32-bit machines, we use this implementation, since an ordinary volatile read
                // would not be atomic.
                //
                // On 64-bit machines, the VM will replace this with a more efficient implementation.
                //
                return System.Interlocked.compareExchange(System.Int64, location, System.Int64(0), System.Int64(0));
            },
            read$7: function (location) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                var value = location.v;
                //Thread.MemoryBarrier();
                return value;
            },
            read$12: function (location) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                var value = location.v;
                //Thread.MemoryBarrier();
                return value;
            },
            read$9: function (location) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                var value = location.v;
                //Thread.MemoryBarrier();
                return value;
            },
            read$3: function (location) {
                //
                // On 32-bit machines, we use this implementation, since an ordinary volatile read
                // would not be atomic.
                //
                // On 64-bit machines, the VM will replace this with a more efficient implementation.
                //
                return System.Interlocked.compareExchange(System.Double, location, 0, 0);
            },
            read: function (T, location) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                var value = location.v;
                //Thread.MemoryBarrier();
                return value;
            },
            write: function (location, value) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                //Thread.MemoryBarrier();
                location.v = value;
            },
            write$7: function (location, value) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                //Thread.MemoryBarrier();
                location.v = value;
            },
            write$1: function (location, value) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                //Thread.MemoryBarrier();
                location.v = value;
            },
            write$3: function (location, value) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                //Thread.MemoryBarrier();
                location.v = value;
            },
            write$9: function (location, value) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                //Thread.MemoryBarrier();
                location.v = value;
            },
            write$4: function (location, value) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                //Thread.MemoryBarrier();
                location.v = value;
            },
            write$10: function (location, value) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                //Thread.MemoryBarrier();
                location.v = value;
            },
            write$5: function (location, value) {
                //
                // On 32-bit machines, we use this implementation, since an ordinary volatile write 
                // would not be atomic.
                //
                // On 64-bit machines, the VM will replace this with a more efficient implementation.
                //
                System.Interlocked.exchange(System.Int64, location, value);
            },
            write$6: function (location, value) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                //Thread.MemoryBarrier();
                location.v = value;
            },
            write$11: function (location, value) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                //Thread.MemoryBarrier();
                location.v = value;
            },
            write$8: function (location, value) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                //Thread.MemoryBarrier();
                location.v = value;
            },
            write$2: function (location, value) {
                //
                // On 32-bit machines, we use this implementation, since an ordinary volatile write 
                // would not be atomic.
                //
                // On 64-bit machines, the VM will replace this with a more efficient implementation.
                //
                System.Interlocked.exchange(System.Double, location, value);
            },
            write$12: function (T, location, value) {
                // 
                // The VM will replace this with a more efficient implementation.
                //
                //Thread.MemoryBarrier();
                location.v = value;
            }
        }
    });

    Bridge.define("System.TimeZone", {
        statics: {
            currentTimeZone: null,
            config: {
                init: function () {
                    this.currentTimeZone = new System.TimeZone();
                }
            }
        },
        getUtcOffset: function (dt) {
            return new System.TimeSpan(dt.getTimezoneOffset(), 0, 0);
        }
    });

    Bridge.define("System.WeakReference$1", function (T) { return {
        _value: Bridge.getDefaultValue(T),
        ctor: function (value) {
            this.$initialize();
            this._value = value;
        },
        tryGetTarget: function (val) {
            val.v = this._value;
            return true;
        }
    }; });

    Bridge.define("System.Collections.Generic.SortedDictionary$2.TreeSet$1", function (TKey, TValue, T) { return {
        inherits: [System.Collections.Generic.SortedSet$1(T)],
        ctor: function (comparer) {
            this.$initialize();
            System.Collections.Generic.SortedSet$1(T).ctor.call(this, comparer);
        },
        addIfNotPresent: function (item) {
            var ret = System.Collections.Generic.SortedSet$1(T).prototype.addIfNotPresent.call(this, item);

            if (!ret) {
                throw new System.ArgumentException("Duplicate entry added.");
            }

            return ret;
        }
    }; });

    /**
     * Abstract base class for implementations of the IObservable&lt;T&gt; interface.
     *
     * @abstract
     * @public
     * @class System.Reactive.ObservableBase$1
     * @implements  System.IObservable$1
     * @param   {Function}    [name]    The type of the elements in the sequence.
     */
    Bridge.define("System.Reactive.ObservableBase$1", function (T) { return {
        inherits: [System.IObservable$1(T)],
        config: {
            alias: [
            "subscribe", "System$IObservable$1$" + Bridge.getTypeAlias(T) + "$subscribe"
            ]
        },
        /**
         * Subscribes the given observer to the observable sequence.
         *
         * @instance
         * @public
         * @this System.Reactive.ObservableBase$1
         * @memberof System.Reactive.ObservableBase$1
         * @throws <b /> is null.
         * @param   {System.IObserver$1}    observer    Observer that will receive notifications from the observable sequence.
         * @return  {System.IDisposable}                Disposable object representing an observer's subscription to the observable sequence.
         */
        subscribe: function (observer) {
            if (observer == null) {
                throw new System.ArgumentNullException("observer");
            }

            var autoDetachObserver = new (System.Reactive.AutoDetachObserver$1(T))(observer);

            if (System.Reactive.Concurrency.CurrentThreadScheduler.getIsScheduleRequired()) {
                //
                // Notice we don't protect this piece of code using an exception handler to
                // redirect errors to the OnError channel. This call to Schedule will run the
                // trampoline, so we'd be catching all exceptions, including those from user
                // callbacks that happen to run there. For example, consider:
                //
                //    Observable.Return(42, Scheduler.CurrentThread)
                //              .Subscribe(x => { throw new Exception(); });
                //
                // Here, the OnNext(42) call would be scheduled on the trampoline, so when we
                // return from the scheduled Subscribe call, the CurrentThreadScheduler moves
                // on to invoking this work item. Too much of protection here would cause the
                // exception thrown in OnNext to circle back to OnError, which looks like the
                // sequence can't make up its mind.
                //
                System.Reactive.Concurrency.CurrentThreadScheduler.getInstance().schedule(System.Reactive.AutoDetachObserver$1(T), autoDetachObserver, Bridge.fn.bind(this, this.scheduledSubscribe));
            } else {
                try {
                    autoDetachObserver.setDisposable(this.subscribeCore(autoDetachObserver));
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    //
                    // This can happen when there's a synchronous callback to OnError in the
                    // implementation of SubscribeCore, which also throws. So, we're seeing
                    // an exception being thrown from a handler.
                    //
                    // For compat with v1.x, we rethrow the exception in this case, keeping
                    // in mind this should be rare but if it happens, something's totally
                    // screwed up.
                    //
                    if (!autoDetachObserver.fail(exception)) {
                        throw exception;
                    }
                }
            }

            return autoDetachObserver;
        },
        scheduledSubscribe: function (_, autoDetachObserver) {
            try {
                autoDetachObserver.setDisposable(this.subscribeCore(autoDetachObserver));
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                //
                // This can happen when there's a synchronous callback to OnError in the
                // implementation of SubscribeCore, which also throws. So, we're seeing
                // an exception being thrown from a handler.
                //
                // For compat with v1.x, we rethrow the exception in this case, keeping
                // in mind this should be rare but if it happens, something's totally
                // screwed up.
                //
                if (!autoDetachObserver.fail(exception)) {
                    throw exception;
                }
            }

            return System.Reactive.Disposables.Disposable.getEmpty();
        }
    }; });

    /**
     * Abstract base class for implementations of the IObserver&lt;T&gt; interface.
     *
     * @abstract
     * @public
     * @class System.Reactive.ObserverBase$1
     * @implements  System.IObserver$1
     * @implements  System.IDisposable
     * @param   {Function}    [name]    The type of the elements in the sequence.
     */
    Bridge.define("System.Reactive.ObserverBase$1", function (T) { return {
        inherits: [System.IObserver$1(T),System.IDisposable],
        isStopped: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted",
            "dispose", "System$IDisposable$dispose"
            ]
        },
        /**
         * Creates a new observer in a non-stopped state.
         *
         * @instance
         * @protected
         * @this System.Reactive.ObserverBase$1
         * @memberof System.Reactive.ObserverBase$1
         * @return  {void}
         */
        ctor: function () {
            this.$initialize();
            this.isStopped = 0;
        },
        /**
         * Notifies the observer of a new element in the sequence.
         *
         * @instance
         * @public
         * @this System.Reactive.ObserverBase$1
         * @memberof System.Reactive.ObserverBase$1
         * @param   {T}       value    Next element in the sequence.
         * @return  {void}
         */
        onNext: function (value) {
            if (System.Threading.Volatile.read$5(Bridge.ref(this, "isStopped")) === 0) {
                this.onNextCore(value);
            }
        },
        /**
         * Notifies the observer that an exception has occurred.
         *
         * @instance
         * @public
         * @this System.Reactive.ObserverBase$1
         * @memberof System.Reactive.ObserverBase$1
         * @throws <b /> is null.
         * @param   {System.Exception}    error    The error that has occurred.
         * @return  {void}
         */
        onError: function (error) {
            if (error == null) {
                throw new System.ArgumentNullException("error");
            }

            if (System.Interlocked.exchange(System.Int32, Bridge.ref(this, "isStopped"), 1) === 0) {
                this.onErrorCore(error);
            }
        },
        /**
         * Notifies the observer of the end of the sequence.
         *
         * @instance
         * @public
         * @this System.Reactive.ObserverBase$1
         * @memberof System.Reactive.ObserverBase$1
         * @return  {void}
         */
        onCompleted: function () {
            if (System.Interlocked.exchange(System.Int32, Bridge.ref(this, "isStopped"), 1) === 0) {
                this.onCompletedCore();
            }
        },
        /**
         * Disposes the observer, causing it to transition to the stopped state.
         *
         * @instance
         * @public
         * @this System.Reactive.ObserverBase$1
         * @memberof System.Reactive.ObserverBase$1
         * @return  {void}
         */
        dispose: function () {
            this.dispose$1(true);
            System.GC.suppressFinalize(this);
        },
        /**
         * Core implementation of IDisposable.
         *
         * @instance
         * @protected
         * @this System.Reactive.ObserverBase$1
         * @memberof System.Reactive.ObserverBase$1
         * @param   {boolean}    disposing    true if the Dispose call was triggered by the IDisposable.Dispose method; false if it was triggered by the finalizer.
         * @return  {void}
         */
        dispose$1: function (disposing) {
            if (disposing) {
                System.Threading.Volatile.write$4(Bridge.ref(this, "isStopped"), 1);
            }
        },
        fail: function (error) {
            if (System.Interlocked.exchange(System.Int32, Bridge.ref(this, "isStopped"), 1) === 0) {
                this.onErrorCore(error);
                return true;
            }

            return false;
        }
    }; });

    /**
     * This class fuses logic from ObserverBase, AnonymousObserver, and SafeObserver into one class. When an observer
     needs to be safeguarded, an instance of this type can be created by SafeObserver.Create when it detects its
     input is an AnonymousObserver, which is commonly used by end users when using the Subscribe extension methods
     that accept delegates for the On* handlers. By doing the fusion, we make the call stack depth shorter which
     helps debugging and some performance.
     *
     * @class System.Reactive.AnonymousSafeObserver$1
     * @implements  System.IObserver$1
     */
    Bridge.define("System.Reactive.AnonymousSafeObserver$1", function (T) { return {
        inherits: [System.IObserver$1(T)],
        _onNext: null,
        _onError: null,
        _onCompleted: null,
        _disposable: null,
        isStopped: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"
            ]
        },
        ctor: function (onNext, onError, onCompleted, disposable) {
            this.$initialize();
            this._onNext = onNext;
            this._onError = onError;
            this._onCompleted = onCompleted;
            this._disposable = disposable;
        },
        onNext: function (value) {
            if (this.isStopped === 0) {
                var __noError = false;
                try {
                    this._onNext(value);
                    __noError = true;
                }
                finally {
                    if (!__noError) {
                        this._disposable.System$IDisposable$dispose();
                    }
                }
            }
        },
        onError: function (error) {
            if (System.Interlocked.exchange(System.Int32, Bridge.ref(this, "isStopped"), 1) === 0) {
                try {
                    this._onError(error);
                }
                finally {
                    this._disposable.System$IDisposable$dispose();
                }
            }
        },
        onCompleted: function () {
            if (System.Interlocked.exchange(System.Int32, Bridge.ref(this, "isStopped"), 1) === 0) {
                try {
                    this._onCompleted();
                }
                finally {
                    this._disposable.System$IDisposable$dispose();
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.CheckedObserver$1", function (T) { return {
        inherits: [System.IObserver$1(T)],
        statics: {
            IDLE: 0,
            BUSY: 1,
            DONE: 2
        },
        _observer: null,
        _state: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"
            ]
        },
        ctor: function (observer) {
            this.$initialize();
            this._observer = observer;
        },
        onNext: function (value) {
            this.checkAccess();

            try {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](value);
            }
            finally {
                System.Interlocked.exchange(System.Int32, Bridge.ref(this, "_state"), System.Reactive.CheckedObserver$1(T).IDLE);
            }
        },
        onError: function (error) {
            this.checkAccess();

            try {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](error);
            }
            finally {
                System.Interlocked.exchange(System.Int32, Bridge.ref(this, "_state"), System.Reactive.CheckedObserver$1(T).DONE);
            }
        },
        onCompleted: function () {
            this.checkAccess();

            try {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
            }
            finally {
                System.Interlocked.exchange(System.Int32, Bridge.ref(this, "_state"), System.Reactive.CheckedObserver$1(T).DONE);
            }
        },
        checkAccess: function () {
            switch (System.Interlocked.compareExchange(System.Int32, Bridge.ref(this, "_state"), System.Reactive.CheckedObserver$1(T).BUSY, System.Reactive.CheckedObserver$1(T).IDLE)) {
                case System.Reactive.CheckedObserver$1(T).BUSY: 
                    throw new System.InvalidOperationException(System.Reactive.Strings_Core.REENTRANCY_DETECTED);
                case System.Reactive.CheckedObserver$1(T).DONE: 
                    throw new System.InvalidOperationException(System.Reactive.Strings_Core.OBSERVER_TERMINATED);
            }
        }
    }; });

    Bridge.define("System.Reactive.TailRecursiveSink$1", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _isDisposed: false,
        _subscription: null,
        _gate: null,
        _stack: null,
        _length: null,
        _recurse: null,
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
        },
        run: function (sources) {
            this._isDisposed = false;
            this._subscription = new System.Reactive.Disposables.SerialDisposable();
            this._gate = new System.Reactive.Concurrency.AsyncLock();
            this._stack = new (System.Collections.Generic.Stack$1(System.Collections.Generic.IEnumerator$1(System.IObservable$1(TSource)))).ctor();
            this._length = new (System.Collections.Generic.Stack$1(System.Nullable$1(System.Int32))).ctor();

            var e = { v : null };
            if (!this.tryGetEnumerator(sources, e)) {
                return System.Reactive.Disposables.Disposable.getEmpty();
            }

            this._stack.push(e.v);
            this._length.push(System.Reactive.Helpers.getLength(System.IObservable$1(TSource), sources));

            var cancelable = System.Reactive.Concurrency.Scheduler.schedule$1(System.Reactive.Concurrency.SchedulerDefaults.getTailRecursion(), Bridge.fn.bind(this, $asm.$.System.Reactive.TailRecursiveSink$1.f1));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2([this._subscription, cancelable, System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, $asm.$.System.Reactive.TailRecursiveSink$1.f2))]);
        },
        moveNext: function () {
            var hasNext = false;
            var next = null;

            do {
                if (this._stack.getCount() === 0) {
                    break;
                }

                if (this._isDisposed) {
                    return;
                }

                var e = this._stack.peek();
                var l = this._length.peek();

                var current = null;
                try {
                    hasNext = e.System$Collections$IEnumerator$moveNext();
                    if (hasNext) {
                        current = e[Bridge.geti(e, "System$Collections$Generic$IEnumerator$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$getCurrent$1", "getCurrent$1")]();
                    }
                }
                catch (ex) {
                    ex = System.Exception.create(ex);
                    e.System$IDisposable$dispose();

                    //
                    // Failure to enumerate the sequence cannot be handled, even by
                    // operators like Catch, because it'd lead to another attempt at
                    // enumerating to find the next observable sequence. Therefore,
                    // we feed those errors directly to the observer.
                    //
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex);
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                    return;
                }

                if (!hasNext) {
                    e.System$IDisposable$dispose();

                    this._stack.pop();
                    this._length.pop();
                } else {
                    var r = Bridge.Int.clip32(System.Nullable.sub(l, 1));
                    this._length.pop();
                    this._length.push(r);

                    try {
                        next = System.Reactive.Helpers.unpack(TSource, current);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        //
                        // Errors from unpacking may produce side-effects that normally
                        // would occur during a SubscribeSafe operation. Those would feed
                        // back into the observer and be subject to the operator's error
                        // handling behavior. For example, Catch would allow to handle
                        // the error using a handler function.
                        //
                        if (!this.fail(exception)) {
                            e.System$IDisposable$dispose();
                        }

                        return;
                    }

                    //
                    // Tail recursive case; drop the current frame.
                    //
                    if (System.Nullable.eq(r, 0)) {
                        e.System$IDisposable$dispose();

                        this._stack.pop();
                        this._length.pop();
                    }

                    //
                    // Flattening of nested sequences. Prevents stack overflow in observers.
                    //
                    var nextSeq = this.extract(next);
                    if (nextSeq != null) {
                        var nextEnumerator = { v : null };
                        if (!this.tryGetEnumerator(nextSeq, nextEnumerator)) {
                            return;
                        }

                        this._stack.push(nextEnumerator.v);
                        this._length.push(System.Reactive.Helpers.getLength(System.IObservable$1(TSource), nextSeq));

                        hasNext = false;
                    }
                }
            } while (!hasNext);

            if (!hasNext) {
                this.done();
                return;
            }

            var d = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._subscription.setDisposable(d);
            d.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, next, this));
        },
        dispose$1: function () {
            while (this._stack.getCount() > 0) {
                var e = this._stack.pop();
                this._length.pop();

                e.System$IDisposable$dispose();
            }

            this._isDisposed = true;
        },
        tryGetEnumerator: function (sources, result) {
            try {
                result.v = Bridge.getEnumerator(sources, System.IObservable$1(TSource));
                return true;
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                //
                // Failure to enumerate the sequence cannot be handled, even by
                // operators like Catch, because it'd lead to another attempt at
                // enumerating to find the next observable sequence. Therefore,
                // we feed those errors directly to the observer.
                //
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](exception);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);

                result.v = null;
                return false;
            }
        },
        done: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        fail: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);

            return false;
        }
    }; });

    Bridge.ns("System.Reactive.TailRecursiveSink$1", $asm.$);

    Bridge.apply($asm.$.System.Reactive.TailRecursiveSink$1, {
        f1: function (self) {
            this._recurse = self;
            this._gate.wait(Bridge.fn.bind(this, this.moveNext));
        },
        f2: function () {
            this._gate.wait(Bridge.fn.bind(this, this.dispose$1));
        }
    });

    Bridge.define("System.Reactive.Concurrency.SchedulerWrapper", {
        inherits: [System.Reactive.Concurrency.IScheduler,System.Reactive.IServiceProvider],
        _scheduler: null,
        _gate: null,
        _recursiveOriginal: null,
        _recursiveWrapper: null,
        config: {
            alias: [
            "getNow", "System$Reactive$Concurrency$IScheduler$getNow",
            "schedule", "System$Reactive$Concurrency$IScheduler$schedule",
            "schedule$2", "System$Reactive$Concurrency$IScheduler$schedule$2",
            "schedule$1", "System$Reactive$Concurrency$IScheduler$schedule$1",
            "getService", "System$Reactive$IServiceProvider$getService"
            ],
            init: function () {
                this._gate = {  };
            }
        },
        ctor: function (scheduler) {
            this.$initialize();
            this._scheduler = scheduler;

        },
        getNow: function () {
            return this._scheduler.System$Reactive$Concurrency$IScheduler$getNow().$clone();
        },
        schedule: function (TState, state, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            return this._scheduler.System$Reactive$Concurrency$IScheduler$schedule(TState, state, this.wrap(TState, action));
        },
        schedule$2: function (TState, state, dueTime, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            return this._scheduler.System$Reactive$Concurrency$IScheduler$schedule$2(TState, state, dueTime, this.wrap(TState, action));
        },
        schedule$1: function (TState, state, dueTime, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            return this._scheduler.System$Reactive$Concurrency$IScheduler$schedule$1(TState, state, dueTime.$clone(), this.wrap(TState, action));
        },
        wrap: function (TState, action) {
            return Bridge.fn.bind(this, function (self, state) {
                return action(this.getRecursiveWrapper(self), state);
            });
        },
        getRecursiveWrapper: function (scheduler) {
            var recursiveWrapper = null;

            this._gate;
            {
                //
                // Chances are the recursive scheduler will remain the same. In practice, this
                // single-shot caching scheme works out quite well. Notice we propagate our
                // mini-cache to recursive raw scheduler wrappers too.
                //
                if (!Bridge.referenceEquals(scheduler, this._recursiveOriginal)) {
                    this._recursiveOriginal = scheduler;

                    var wrapper = this.clone(scheduler);
                    wrapper._recursiveOriginal = scheduler;
                    wrapper._recursiveWrapper = wrapper;

                    this._recursiveWrapper = wrapper;
                }

                recursiveWrapper = this._recursiveWrapper;
            }

            return recursiveWrapper;
        },
        getService: function (serviceType) {
            var serviceProvider = Bridge.as(this._scheduler, System.Reactive.IServiceProvider);
            if (serviceProvider == null) {
                return null;
            }

            var result = { v : null };
            if (this.tryGetService(serviceProvider, serviceType, result)) {
                return result.v;
            }

            return serviceProvider.System$Reactive$IServiceProvider$getService(serviceType);
        }
    });

    Bridge.define("System.Reactive.Concurrency.CatchScheduler$1.CatchSchedulerLongRunning", function (TException) { return {
        inherits: [System.Reactive.Concurrency.ISchedulerLongRunning],
        _scheduler: null,
        _handler: null,
        config: {
            alias: [
            "scheduleLongRunning", "System$Reactive$Concurrency$ISchedulerLongRunning$scheduleLongRunning"
            ]
        },
        ctor: function (scheduler, handler) {
            this.$initialize();
            this._scheduler = scheduler;
            this._handler = handler;
        },
        scheduleLongRunning: function (TState, state, action) {
            return this._scheduler.System$Reactive$Concurrency$ISchedulerLongRunning$scheduleLongRunning(TState, state, Bridge.fn.bind(this, function (state_, cancel) {
                try {
                    action(state_, cancel);
                }
                catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    var exception;
                    if (Bridge.is($e1, TException)) {
                        exception = $e1;
                        if (!this._handler(exception)) {
                            throw $e1;
                        }
                    } else {
                        throw $e1;
                    }
                }
            }));
        }
    }; });

    Bridge.define("System.Reactive.Concurrency.CatchScheduler$1.CatchSchedulerPeriodic", function (TException) { return {
        inherits: [System.Reactive.Concurrency.ISchedulerPeriodic],
        _scheduler: null,
        _handler: null,
        config: {
            alias: [
            "schedulePeriodic", "System$Reactive$Concurrency$ISchedulerPeriodic$schedulePeriodic"
            ]
        },
        ctor: function (scheduler, handler) {
            this.$initialize();
            this._scheduler = scheduler;
            this._handler = handler;
        },
        schedulePeriodic: function (TState, state, period, action) {
            var failed = false;

            var d = new System.Reactive.Disposables.SingleAssignmentDisposable();

            d.setDisposable(this._scheduler.System$Reactive$Concurrency$ISchedulerPeriodic$schedulePeriodic(TState, state, period, Bridge.fn.bind(this, function (state_) {
                //
                // Cancellation may not be granted immediately; prevent from running user
                // code in that case. Periodic schedulers are assumed to introduce some
                // degree of concurrency, so we should return from the SchedulePeriodic
                // call eventually, allowing the d.Dispose() call in the catch block to
                // take effect.
                //
                if (failed) {
                    return Bridge.getDefaultValue(TState);
                }

                try {
                    return action(state_);
                }
                catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    var exception;
                    if (Bridge.is($e1, TException)) {
                        exception = $e1;
                        failed = true;

                        if (!this._handler(exception)) {
                            throw $e1;
                        }

                        d.dispose();
                        return Bridge.getDefaultValue(TState);
                    } else {
                        throw $e1;
                    }
                }
            })));

            return d;
        }
    }; });

    /**
     * Abstract base class for machine-local schedulers, using the local system clock for time-based operations.
     *
     * @abstract
     * @public
     * @class System.Reactive.Concurrency.LocalScheduler
     * @implements  System.Reactive.Concurrency.IScheduler
     * @implements  System.Reactive.Concurrency.IStopwatchProvider
     * @implements  System.Reactive.IServiceProvider
     */
    Bridge.define("System.Reactive.Concurrency.LocalScheduler", {
        inherits: [System.Reactive.Concurrency.IScheduler,System.Reactive.Concurrency.IStopwatchProvider,System.Reactive.IServiceProvider],
        statics: {
            /**
             * Gate to protect local scheduler queues.
             *
             * @instance
             */
            _gate: null,
            /**
             * Gate to protect queues and to synchronize scheduling decisions and system clock
             change management.
             *
             * @instance
             */
            s_gate: null,
            /**
             * Long term work queue. Contains work that's due beyond SHORTTERM, computed at the
             time of enqueueing.
             *
             * @instance
             */
            s_longTerm: null,
            /**
             * Disposable resource for the long term timer that will reevaluate and dispatch the
             first item in the long term queue. A serial disposable is used to make "dispose
             current and assign new" logic easier. The disposable itself is never disposed.
             *
             * @instance
             */
            s_nextLongTermTimer: null,
            /**
             * Item at the head of the long term queue for which the current long term timer is
             running. Used to detect changes in the queue and decide whether we should replace
             or can continue using the current timer (because no earlier long term work was
             added to the queue).
             *
             * @instance
             */
            s_nextLongTermWorkItem: null,
            /**
             * Maximum error ratio for timer drift. We've seen machines with 10s drift on a
             daily basis, which is in the order 10E-4, so we allow for extra margin here.
             This value is used to calculate early arrival for the long term queue timer
             that will reevaluate work for the short term queue.
             Example:  -------------------------------...---------------------*-----$
                                                                              ^     ^
                                                                              |     |
                                                                            early  due
                                                                            0.999  1.0
             We also make the gap between early and due at least LONGTOSHORT so we have
             enough time to transition work to short term and as a courtesy to the
             destination scheduler to manage its queues etc.
             *
             * @instance
             */
            MAXERRORRATIO: 1000,
            config: {
                init: function () {
                    this._gate = {  };
                    this.s_gate = {  };
                    this.s_longTerm = new (System.Reactive.PriorityQueue$1(System.Reactive.Concurrency.LocalScheduler.WorkItem)).ctor();
                    this.s_nextLongTermTimer = new System.Reactive.Disposables.SerialDisposable();
                    this.SHORTTERM = System.TimeSpan.fromSeconds(10) || new System.TimeSpan();
                    this.LONGTOSHORT = System.TimeSpan.fromSeconds(5) || new System.TimeSpan();
                    this.RETRYSHORT = System.TimeSpan.fromMilliseconds(50) || new System.TimeSpan();
                    this.MAXSUPPORTEDTIMER = System.TimeSpan.fromMilliseconds(System.Int64([-2,0])) || new System.TimeSpan();
                }
            },
            /**
             * Schedule work that's due on the long term. This leads to the work being queued up for
             eventual transitioning to the short term work list.
             *
             * @static
             * @private
             * @this System.Reactive.Concurrency.LocalScheduler
             * @memberof System.Reactive.Concurrency.LocalScheduler
             * @param   {System.Reactive.Concurrency.LocalScheduler.WorkItem}    item    Work item to schedule on the long term. The caller is responsible to determine the work is indeed long term.
             * @return  {void}
             */
            scheduleLongTermWork: function (item) {
                System.Reactive.Concurrency.LocalScheduler.s_gate;
                {
                    System.Reactive.Concurrency.LocalScheduler.s_longTerm.enqueue(item);

                    //
                    // In case we're the first long-term item in the queue now, the timer will have
                    // to be updated.
                    //
                    System.Reactive.Concurrency.LocalScheduler.updateLongTermProcessingTimer();
                }
            },
            /**
             * Updates the long term timer which is responsible to transition work from the head of the
             long term queue to the short term work list.
             *
             * @static
             * @private
             * @this System.Reactive.Concurrency.LocalScheduler
             * @memberof System.Reactive.Concurrency.LocalScheduler
             * @return  {void}
             */
            updateLongTermProcessingTimer: function () {
                /* 
             * CALLERS - Ensure this is called under the lock!
             * 
            lock (s_gate) */
                {
                    if (System.Reactive.Concurrency.LocalScheduler.s_longTerm.getCount() === 0) {
                        return;
                    }

                    //
                    // To avoid setting the timer all over again for the first work item if it hasn't changed,
                    // we keep track of the next long term work item that will be processed by the timer.
                    //
                    var next = System.Reactive.Concurrency.LocalScheduler.s_longTerm.peek();
                    if (Bridge.referenceEquals(next, System.Reactive.Concurrency.LocalScheduler.s_nextLongTermWorkItem)) {
                        return;
                    }

                    //
                    // We need to arrive early in order to accommodate for potential drift. The relative amount
                    // of drift correction is kept in MAXERRORRATIO. At the very least, we want to be LONGTOSHORT
                    // early to make the final jump from long term to short term, giving the target scheduler
                    // enough time to process the item through its queue. LONGTOSHORT is chosen such that the
                    // error due to drift is negligible.
                    //
                    var due = System.Reactive.Concurrency.Scheduler.normalize(System.DateTimeOffset.op_Subtraction$1(next.getDueTime(), next.getScheduler().getNow()));
                    var remainder = System.TimeSpan.fromTicks(System.Int64.max(due.getTicks().div(System.Int64(System.Reactive.Concurrency.LocalScheduler.MAXERRORRATIO)), System.Reactive.Concurrency.LocalScheduler.LONGTOSHORT.getTicks()));
                    var dueEarly = System.TimeSpan.sub(due, remainder);

                    //
                    // Limit the interval to maximum supported by underlying Timer.
                    //
                    var dueCapped = System.TimeSpan.fromTicks(System.Int64.min(dueEarly.getTicks(), System.Reactive.Concurrency.LocalScheduler.MAXSUPPORTEDTIMER.getTicks()));

                    System.Reactive.Concurrency.LocalScheduler.s_nextLongTermWorkItem = next;
                    System.Reactive.Concurrency.LocalScheduler.s_nextLongTermTimer.setDisposable(System.Reactive.Concurrency.ConcurrencyAbstractionLayer.getCurrent().System$Reactive$Concurrency$IConcurrencyAbstractionLayer$startTimer(System.Reactive.Concurrency.LocalScheduler.evaluateLongTermQueue, null, dueCapped));
                }
            },
            /**
             * Evaluates the long term queue, transitioning short term work to the short term list,
             and adjusting the new long term processing timer accordingly.
             *
             * @static
             * @private
             * @this System.Reactive.Concurrency.LocalScheduler
             * @memberof System.Reactive.Concurrency.LocalScheduler
             * @param   {Object}    state    Ignored.
             * @return  {void}
             */
            evaluateLongTermQueue: function (state) {
                System.Reactive.Concurrency.LocalScheduler.s_gate;
                {
                    var next = null;

                    while (System.Reactive.Concurrency.LocalScheduler.s_longTerm.getCount() > 0) {
                        next = System.Reactive.Concurrency.LocalScheduler.s_longTerm.peek();

                        var due = System.Reactive.Concurrency.Scheduler.normalize(System.DateTimeOffset.op_Subtraction$1(next.getDueTime(), next.getScheduler().getNow()));
                        if (System.TimeSpan.gte(due, System.Reactive.Concurrency.LocalScheduler.SHORTTERM)) {
                            break;
                        }

                        var item = System.Reactive.Concurrency.LocalScheduler.s_longTerm.dequeue();
                        item.getScheduler().scheduleShortTermWork(item);
                    }

                    System.Reactive.Concurrency.LocalScheduler.s_nextLongTermWorkItem = null;
                    System.Reactive.Concurrency.LocalScheduler.updateLongTermProcessingTimer();
                }
            }
        },
        /**
         * Short term work queue. Contains work that's due soon, computed at the time of
         enqueueing or upon reevaluation of the long term queue causing migration of work
         items. This queue is kept in order to be able to relocate short term items back
         to the long term queue in case a system clock change occurs.
         *
         * @instance
         */
        _shortTerm: null,
        /**
         * Set of disposable handles to all of the current short term work Schedule calls,
         allowing those to be cancelled upon a system clock change.
         *
         * @instance
         */
        _shortTermWork: null,
        config: {
            alias: [
            "getNow", "System$Reactive$Concurrency$IScheduler$getNow",
            "schedule", "System$Reactive$Concurrency$IScheduler$schedule",
            "schedule$1", "System$Reactive$Concurrency$IScheduler$schedule$1",
            "startStopwatch", "System$Reactive$Concurrency$IStopwatchProvider$startStopwatch"
            ],
            init: function () {
                this._shortTerm = new (System.Reactive.PriorityQueue$1(System.Reactive.Concurrency.LocalScheduler.WorkItem)).ctor();
                this._shortTermWork = new (System.Collections.Generic.HashSet$1(System.IDisposable)).ctor();
            }
        },
        /**
         * Creates a new local scheduler.
         *
         * @instance
         * @protected
         * @this System.Reactive.Concurrency.LocalScheduler
         * @memberof System.Reactive.Concurrency.LocalScheduler
         * @return  {void}
         */
        ctor: function () {
            this.$initialize();
            //
            // Hook up for system clock change notifications. This doesn't do anything until the
            // AddRef method is called (which can throw).
            //
            System.Reactive.PlatformServices.SystemClock.register(this);
        },
        /**
         * Gets the scheduler's notion of current time.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.LocalScheduler
         * @memberof System.Reactive.Concurrency.LocalScheduler
         * @function getNow
         * @return  {System.DateTimeOffset}
         */
        /**
         * Gets the scheduler's notion of current time.
         *
         * @instance
         * @function setNow
         */
        getNow: function () {
            return System.Reactive.Concurrency.Scheduler.getNow().$clone();
        },
        /**
         * Schedules an action to be executed.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.LocalScheduler
         * @memberof System.Reactive.Concurrency.LocalScheduler
         * @throws <b /> is null.
         * @param   {Function}              TState    The type of the state passed to the scheduled action.
         * @param   {TState}                state     State passed to the action to be executed.
         * @param   {System.Func}           action    Action to be executed.
         * @return  {System.IDisposable}              The disposable object used to cancel the scheduled action (best effort).
         */
        schedule: function (TState, state, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            return this.schedule$2(TState, state, System.TimeSpan.zero, action);
        },
        /**
         * Schedules an action to be executed at dueTime.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.LocalScheduler
         * @memberof System.Reactive.Concurrency.LocalScheduler
         * @throws <b /> is null.
         * @param   {Function}                 TState     The type of the state passed to the scheduled action.
         * @param   {TState}                   state      State passed to the action to be executed.
         * @param   {System.DateTimeOffset}    dueTime    Absolute time at which to execute the action.
         * @param   {System.Func}              action     Action to be executed.
         * @return  {System.IDisposable}                  The disposable object used to cancel the scheduled action (best effort).
         */
        schedule$1: function (TState, state, dueTime, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            return this.enqueue(TState, state, dueTime.$clone(), action);
        },
        /**
         * Starts a new stopwatch object.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.LocalScheduler
         * @memberof System.Reactive.Concurrency.LocalScheduler
         * @return  {System.Reactive.Concurrency.IStopwatch}        New stopwatch object; started at the time of the request.
         */
        startStopwatch: function () {
            return System.Reactive.Concurrency.ConcurrencyAbstractionLayer.getCurrent().System$Reactive$Concurrency$IConcurrencyAbstractionLayer$startStopwatch();
        },
        System$Reactive$IServiceProvider$getService: function (serviceType) {
            return this.getService(serviceType);
        },
        /**
         * Discovers scheduler services by interface type. The base class implementation returns
         requested services for each scheduler interface implemented by the derived class. For
         more control over service discovery, derived types can override this method.
         *
         * @instance
         * @protected
         * @this System.Reactive.Concurrency.LocalScheduler
         * @memberof System.Reactive.Concurrency.LocalScheduler
         * @param   {Function}    serviceType    Scheduler service interface type to discover.
         * @return  {Object}                     Object implementing the requested service, if available; null otherwise.
         */
        getService: function (serviceType) {
            if (Bridge.referenceEquals(serviceType, System.Reactive.Concurrency.IStopwatchProvider)) {
                return Bridge.as(this, System.Reactive.Concurrency.IStopwatchProvider);
            } else {
                if (Bridge.referenceEquals(serviceType, System.Reactive.Concurrency.ISchedulerLongRunning)) {
                    return Bridge.as(this, System.Reactive.Concurrency.ISchedulerLongRunning);
                } else {
                    if (Bridge.referenceEquals(serviceType, System.Reactive.Concurrency.ISchedulerPeriodic)) {
                        return Bridge.as(this, System.Reactive.Concurrency.ISchedulerPeriodic);
                    }
                }
            }

            return null;
        },
        /**
         * Enqueues absolute time scheduled work in the timer queue or the short term work list.
         *
         * @instance
         * @private
         * @this System.Reactive.Concurrency.LocalScheduler
         * @memberof System.Reactive.Concurrency.LocalScheduler
         * @param   {Function}                 TState     
         * @param   {TState}                   state      State to pass to the action.
         * @param   {System.DateTimeOffset}    dueTime    Absolute time to run the work on. The timer queue is responsible to execute the work close to the specified time, also accounting for system clock changes.
         * @param   {System.Func}              action     Action to run, potentially recursing into the scheduler.
         * @return  {System.IDisposable}                  Disposable object to prevent the work from running.
         */
        enqueue: function (TState, state, dueTime, action) {
            //
            // Work that's due in the past is sent to the underlying scheduler through the Schedule
            // overload for execution at TimeSpan.Zero. We don't go to the overload for immediate
            // scheduling in order to:
            //
            // - Preserve the time-based nature of the call as surfaced to the underlying scheduler,
            //   as it may use different queuing strategies.
            //
            // - Optimize for the default behavior of LocalScheduler where a virtual call to Schedule
            //   for immediate execution calls into the abstract Schedule method with TimeSpan.Zero.
            //
            var due = System.Reactive.Concurrency.Scheduler.normalize(System.DateTimeOffset.op_Subtraction$1(dueTime, this.getNow()));
            if (System.TimeSpan.eq(due, System.TimeSpan.zero)) {
                return this.schedule$2(TState, state, System.TimeSpan.zero, action);
            }

            //
            // We're going down the path of queueing up work or scheduling it, so we need to make
            // sure we can get system clock change notifications. If not, the call below is expected
            // to throw NotSupportedException. WorkItem.Invoke decreases the ref count again to allow
            // the system clock monitor to stop if there's no work left. Notice work items always
            // reach an execution stage since we don't dequeue items but merely mark them as cancelled
            // through WorkItem.Dispose. Double execution is also prevented, so the ref count should
            // correctly balance out.
            //
            System.Reactive.PlatformServices.SystemClock.addRef();

            var workItem = new (System.Reactive.Concurrency.LocalScheduler.WorkItem$1(TState))(this, state, dueTime.$clone(), action);

            if (System.TimeSpan.lte(due, System.Reactive.Concurrency.LocalScheduler.SHORTTERM)) {
                this.scheduleShortTermWork(workItem);
            } else {
                System.Reactive.Concurrency.LocalScheduler.scheduleLongTermWork(workItem);
            }

            return workItem;
        },
        /**
         * Schedule work that's due in the short term. This leads to relative scheduling calls to the
         underlying scheduler for short TimeSpan values. If the system clock changes in the meantime,
         the short term work is attempted to be cancelled and reevaluated.
         *
         * @instance
         * @private
         * @this System.Reactive.Concurrency.LocalScheduler
         * @memberof System.Reactive.Concurrency.LocalScheduler
         * @param   {System.Reactive.Concurrency.LocalScheduler.WorkItem}    item    Work item to schedule in the short term. The caller is responsible to determine the work is indeed short term.
         * @return  {void}
         */
        scheduleShortTermWork: function (item) {
            System.Reactive.Concurrency.LocalScheduler._gate;
            {
                this._shortTerm.enqueue(item);

                //
                // We don't bother trying to dequeue the item or stop the timer upon cancellation,
                // but always let the timer fire to do the queue maintenance. When the item is
                // cancelled, it won't run (see WorkItem.Invoke). In the event of a system clock
                // change, all outstanding work in _shortTermWork is cancelled and the short
                // term queue is reevaluated, potentially prompting rescheduling of short term
                // work. Notice work is protected against double execution by the implementation
                // of WorkItem.Invoke.
                //
                var d = new System.Reactive.Disposables.SingleAssignmentDisposable();
                this._shortTermWork.add(d);

                //
                // We normalize the time delta again (possibly redundant), because we can't assume
                // the underlying scheduler implementations is valid and deals with negative values
                // (though it should).
                //
                var dueTime = System.Reactive.Concurrency.Scheduler.normalize(System.DateTimeOffset.op_Subtraction$1(item.getDueTime(), item.getScheduler().getNow()));
                d.setDisposable(item.getScheduler().schedule$2(System.Reactive.Disposables.SingleAssignmentDisposable, d, dueTime, Bridge.fn.bind(this, this.executeNextShortTermWorkItem)));
            }
        },
        /**
         * Callback to process the next short term work item.
         *
         * @instance
         * @private
         * @this System.Reactive.Concurrency.LocalScheduler
         * @memberof System.Reactive.Concurrency.LocalScheduler
         * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Recursive scheduler supplied by the underlying scheduler.
         * @param   {System.IDisposable}                        cancel       Disposable used to identify the work the timer was triggered for (see code for usage).
         * @return  {System.IDisposable}                                     Empty disposable. Recursive work cancellation is wired through the original WorkItem.
         */
        executeNextShortTermWorkItem: function (scheduler, cancel) {
            var next = null;

            System.Reactive.Concurrency.LocalScheduler._gate;
            {
                //
                // Notice that even though we try to cancel all work in the short term queue upon a
                // system clock change, cancellation may not be honored immediately and there's a
                // small chance this code runs for work that has been cancelled. Because the handler
                // doesn't execute the work that triggered the time-based Schedule call, but always
                // runs the work from the short term queue in order, we need to make sure we're not
                // stealing items in the queue. We can do so by remembering the object identity of
                // the disposable and check whether it still exists in the short term work list. If
                // not, a system clock change handler has gotten rid of it as part of reevaluating
                // the short term queue, but we still ended up here because the inherent race in the
                // call to Dispose versus the underlying timer. It's also possible the underlying
                // scheduler does a bad job at cancellation, so this measure helps for that too.
                //
                if (this._shortTermWork.remove(cancel) && this._shortTerm.getCount() > 0) {
                    next = this._shortTerm.dequeue();
                }
            }

            if (next != null) {
                //
                // If things don't make sense and we're way too early to run the work, this is our
                // final chance to prevent us from running before the due time. This situation can
                // arise when Windows applies system clock adjustment (see SetSystemTimeAdjustment)
                // and as a result the clock is ticking slower. If the clock is ticking faster due
                // to such an adjustment, too bad :-). We try to minimize the window for the final
                // relative time based scheduling such that 10%+ adjustments to the clock rate
                // have only "little" impact (range of 100s of ms). On an absolute time scale, we
                // don't provide stronger guarantees.
                //
                if (System.TimeSpan.gte(System.DateTimeOffset.op_Subtraction$1(next.getDueTime(), next.getScheduler().getNow()), System.Reactive.Concurrency.LocalScheduler.RETRYSHORT)) {
                    this.scheduleShortTermWork(next);
                } else {
                    //
                    // Invocation happens on the recursive scheduler supplied to the function. We
                    // are already running on the target scheduler, so we should stay on board.
                    // Not doing so would have unexpected behavior for e.g. NewThreadScheduler,
                    // causing a whole new thread to be allocated because of a top-level call to
                    // the Schedule method rather than a recursive one.
                    //
                    // Notice if work got cancelled, the call to Invoke will not propagate to user
                    // code because of the IsDisposed check inside.
                    //
                    next.invoke(scheduler);
                }
            }

            //
            // No need to return anything better here. We already handed out the original WorkItem
            // object upon the call to Enqueue (called itself by Schedule). The disposable inside
            // the work item allows a cancellation request to chase the underlying computation.
            //
            return System.Reactive.Disposables.Disposable.getEmpty();
        },
        /**
         * Callback invoked when a system clock change is observed in order to adjust and reevaluate
         the internal scheduling queues.
         *
         * @instance
         * @this System.Reactive.Concurrency.LocalScheduler
         * @memberof System.Reactive.Concurrency.LocalScheduler
         * @param   {Object}                                                          sender    Currently not used.
         * @param   {System.Reactive.PlatformServices.SystemClockChangedEventArgs}    args      Currently not used.
         * @return  {void}
         */
        systemClockChanged: function (sender, args) {
            var $t;
            System.Reactive.Concurrency.LocalScheduler._gate;
            {
                System.Reactive.Concurrency.LocalScheduler.s_gate;
                {
                    //
                    // Best-effort cancellation of short term work. A check for presence in the hash set
                    // is used to notice race conditions between cancellation and the timer firing (also
                    // guarded by the same gate object). See checks in ExecuteNextShortTermWorkItem.
                    //
                    $t = Bridge.getEnumerator(this._shortTermWork);
                    while ($t.moveNext()) {
                        var d = $t.getCurrent();
                        d.System$IDisposable$dispose();
                    }

                    this._shortTermWork.clear();

                    //
                    // Transition short term work to the long term queue for reevaluation by calling the
                    // EvaluateLongTermQueue method. We don't know which direction the clock was changed
                    // in, so we don't optimize for special cases, but always transition the whole queue.
                    // Notice the short term queue is bounded to SHORTTERM length.
                    //
                    while (this._shortTerm.getCount() > 0) {
                        var next = this._shortTerm.dequeue();
                        System.Reactive.Concurrency.LocalScheduler.s_longTerm.enqueue(next);
                    }

                    //
                    // Reevaluate the queue and don't forget to null out the current timer to force the
                    // method to create a new timer for the new first long term item.
                    //
                    System.Reactive.Concurrency.LocalScheduler.s_nextLongTermWorkItem = null;
                    System.Reactive.Concurrency.LocalScheduler.evaluateLongTermQueue(null);
                }
            }
        }
    });

    Bridge.define("System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer", {
        inherits: [System.Reactive.Concurrency.IConcurrencyAbstractionLayer],
        statics: {
            normalize: function (dueTime) {
                if (System.TimeSpan.lt(dueTime, System.TimeSpan.zero)) {
                    return System.TimeSpan.zero;
                }

                return dueTime;
            }
        },
        config: {
            alias: [
            "startTimer", "System$Reactive$Concurrency$IConcurrencyAbstractionLayer$startTimer",
            "startPeriodicTimer", "System$Reactive$Concurrency$IConcurrencyAbstractionLayer$startPeriodicTimer",
            "queueUserWorkItem", "System$Reactive$Concurrency$IConcurrencyAbstractionLayer$queueUserWorkItem",
            "sleep", "System$Reactive$Concurrency$IConcurrencyAbstractionLayer$sleep",
            "startStopwatch", "System$Reactive$Concurrency$IConcurrencyAbstractionLayer$startStopwatch",
            "getSupportsLongRunning", "System$Reactive$Concurrency$IConcurrencyAbstractionLayer$getSupportsLongRunning",
            "startThread", "System$Reactive$Concurrency$IConcurrencyAbstractionLayer$startThread"
            ]
        },
        getSupportsLongRunning: function () {
            return true;
        },
        startTimer: function (action, state, dueTime) {
            return new System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer.Timer(action, state, System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer.normalize(dueTime));
        },
        startPeriodicTimer: function (action, period) {
            if (System.TimeSpan.lt(period, System.TimeSpan.zero)) {
                throw new System.ArgumentOutOfRangeException("period");
            }

            //
            // The contract for periodic scheduling in Rx is that specifying TimeSpan.Zero as the period causes the scheduler to 
            // call back periodically as fast as possible, sequentially.
            //
            if (System.TimeSpan.eq(period, System.TimeSpan.zero)) {
                return new System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer.FastPeriodicTimer(action);
            } else {
                return new System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer.PeriodicTimer(action, period);
            }
        },
        queueUserWorkItem: function (action, state) {
            System.Threading.Tasks.Task.run(function () {
                action(state);
            });
            return System.Reactive.Disposables.Disposable.getEmpty();
        },
        sleep: function (timeout) {
            Bridge.sleep(null, System.Reactive.Concurrency.DefaultConcurrencyAbstractionLayer.normalize(timeout));
        },
        startStopwatch: function () {
            return new System.Reactive.Concurrency.DefaultStopwatch();
        },
        startThread: function (action, state) {
            System.Threading.Tasks.Task.run(function () {
                action(state);
            });
        }
    });

    Bridge.define("System.Reactive.Concurrency.DefaultScheduler.LongRunning", {
        inherits: [System.Reactive.Concurrency.ISchedulerLongRunning],
        statics: {
            instance: null,
            config: {
                init: function () {
                    this.instance = new System.Reactive.Concurrency.DefaultScheduler.LongRunning();
                }
            }
        },
        config: {
            alias: [
            "scheduleLongRunning", "System$Reactive$Concurrency$ISchedulerLongRunning$scheduleLongRunning"
            ]
        },
        scheduleLongRunning: function (TState, state, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            var cancel = new System.Reactive.Disposables.BooleanDisposable.ctor();

            System.Reactive.Concurrency.DefaultScheduler.s_cal.System$Reactive$Concurrency$IConcurrencyAbstractionLayer$startThread(function (arg) {
                var d = Bridge.cast(arg, System.Reactive.Disposables.ICancelable);

                //
                // Notice we don't check d.IsDisposed. The contract for ISchedulerLongRunning
                // requires us to ensure the scheduled work gets an opportunity to observe
                // the cancellation request.
                //
                action(state, d);
            }, cancel);

            return cancel;
        }
    });

    Bridge.define("System.Reactive.Concurrency.DefaultStopwatch", {
        inherits: [System.Reactive.Concurrency.IStopwatch],
        _sw: null,
        config: {
            alias: [
            "getElapsed", "System$Reactive$Concurrency$IStopwatch$getElapsed"
            ]
        },
        ctor: function () {
            this.$initialize();
            this._sw = System.Diagnostics.Stopwatch.startNew();
        },
        getElapsed: function () {
            return this._sw.timeSpan();
        }
    });

    /**
     * Base class for virtual time schedulers.
     *
     * @abstract
     * @public
     * @class System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
     * @implements  System.Reactive.Concurrency.IScheduler
     * @implements  System.Reactive.IServiceProvider
     * @implements  System.Reactive.Concurrency.IStopwatchProvider
     * @param   {Function}    [name]    Absolute time representation type.
     * @param   {Function}    [name]    Relative time representation type.
     */
    Bridge.define("System.Reactive.Concurrency.VirtualTimeSchedulerBase$2", function (TAbsolute, TRelative) { return {
        inherits: [System.Reactive.Concurrency.IScheduler,System.Reactive.IServiceProvider,System.Reactive.Concurrency.IStopwatchProvider],
        config: {
            properties: {
                /**
                 * Gets whether the scheduler is enabled to run work.
                 *
                 * @instance
                 * @public
                 * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
                 * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
                 * @function getIsEnabled
                 * @return  {boolean}
                 */
                /**
                 * Gets whether the scheduler is enabled to run work.
                 *
                 * @instance
                 * @private
                 * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
                 * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
                 * @function setIsEnabled
                 * @param   {boolean}    value
                 * @return  {void}
                 */
                IsEnabled: false,
                /**
                 * Gets the comparer used to compare absolute time values.
                 *
                 * @instance
                 * @protected
                 * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
                 * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
                 * @function getComparer
                 * @return  {System.Collections.Generic.IComparer$1}
                 */
                /**
                 * Gets the comparer used to compare absolute time values.
                 *
                 * @instance
                 * @private
                 * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
                 * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
                 * @function setComparer
                 * @param   {System.Collections.Generic.IComparer$1}    value
                 * @return  {void}
                 */
                Comparer: null,
                /**
                 * Gets the scheduler's absolute time clock value.
                 *
                 * @instance
                 * @public
                 * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
                 * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
                 * @function getClock
                 * @return  {TAbsolute}
                 */
                /**
                 * Gets the scheduler's absolute time clock value.
                 *
                 * @instance
                 * @protected
                 * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
                 * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
                 * @function setClock
                 * @param   {TAbsolute}    value
                 * @return  {void}
                 */
                Clock: Bridge.getDefaultValue(TAbsolute)
            },
            alias: [
            "schedule", "System$Reactive$Concurrency$IScheduler$schedule",
            "schedule$2", "System$Reactive$Concurrency$IScheduler$schedule$2",
            "schedule$1", "System$Reactive$Concurrency$IScheduler$schedule$1",
            "getNow", "System$Reactive$Concurrency$IScheduler$getNow",
            "startStopwatch", "System$Reactive$Concurrency$IStopwatchProvider$startStopwatch"
            ]
        },
        /**
         * Creates a new virtual time scheduler with the default value of TAbsolute as the initial clock value.
         *
         * @instance
         * @protected
         * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @return  {void}
         */
        ctor: function () {
            System.Reactive.Concurrency.VirtualTimeSchedulerBase$2(TAbsolute,TRelative).$ctor1.call(this, Bridge.getDefaultValue(TAbsolute), new (System.Collections.Generic.Comparer$1(TAbsolute))(System.Collections.Generic.Comparer$1.$default.fn));
        },
        /**
         * Creates a new virtual time scheduler with the specified initial clock value and absolute time comparer.
         *
         * @instance
         * @protected
         * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @throws <b /> is null.
         * @param   {TAbsolute}                                 initialClock    Initial value for the clock.
         * @param   {System.Collections.Generic.IComparer$1}    comparer        Comparer to determine causality of events based on absolute time.
         * @return  {void}
         */
        $ctor1: function (initialClock, comparer) {
            this.$initialize();
            if (comparer == null) {
                throw new System.ArgumentNullException("comparer");
            }

            this.setClock(initialClock);
            this.setComparer(comparer);
        },
        /**
         * Gets the scheduler's notion of current time.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @function getNow
         * @return  {System.DateTimeOffset}
         */
        /**
         * Gets the scheduler's notion of current time.
         *
         * @instance
         * @function setNow
         */
        getNow: function () {
            return this.toDateTimeOffset(this.getClock());
        },
        /**
         * Schedules an action to be executed at dueTime.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @param   {Function}              TState     The type of the state passed to the scheduled action.
         * @param   {TState}                state      State passed to the action to be executed.
         * @param   {TRelative}             dueTime    Relative time after which to execute the action.
         * @param   {System.Func}           action     Action to be executed.
         * @return  {System.IDisposable}               The disposable object used to cancel the scheduled action (best effort).
         */
        scheduleRelative: function (TState, state, dueTime, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            var runAt = this.add(this.getClock(), dueTime);

            return this.scheduleAbsolute(TState, state, runAt, action);
        },
        /**
         * Schedules an action to be executed.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @throws <b /> is null.
         * @param   {Function}              TState    The type of the state passed to the scheduled action.
         * @param   {TState}                state     State passed to the action to be executed.
         * @param   {System.Func}           action    Action to be executed.
         * @return  {System.IDisposable}              The disposable object used to cancel the scheduled action (best effort).
         */
        schedule: function (TState, state, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            return this.scheduleAbsolute(TState, state, this.getClock(), action);
        },
        /**
         * Schedules an action to be executed after dueTime.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @throws <b /> is null.
         * @param   {Function}              TState     The type of the state passed to the scheduled action.
         * @param   {TState}                state      State passed to the action to be executed.
         * @param   {System.TimeSpan}       dueTime    Relative time after which to execute the action.
         * @param   {System.Func}           action     Action to be executed.
         * @return  {System.IDisposable}               The disposable object used to cancel the scheduled action (best effort).
         */
        schedule$2: function (TState, state, dueTime, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            return this.scheduleRelative(TState, state, this.toRelative(dueTime), action);
        },
        /**
         * Schedules an action to be executed at dueTime.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @throws <b /> is null.
         * @param   {Function}                 TState     The type of the state passed to the scheduled action.
         * @param   {TState}                   state      State passed to the action to be executed.
         * @param   {System.DateTimeOffset}    dueTime    Absolute time at which to execute the action.
         * @param   {System.Func}              action     Action to be executed.
         * @return  {System.IDisposable}                  The disposable object used to cancel the scheduled action (best effort).
         */
        schedule$1: function (TState, state, dueTime, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            return this.scheduleRelative(TState, state, this.toRelative(System.DateTimeOffset.op_Subtraction$1(dueTime, this.getNow())), action);
        },
        /**
         * Starts the virtual time scheduler.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @return  {void}
         */
        start: function () {
            if (!this.getIsEnabled()) {
                this.setIsEnabled(true);
                do {
                    var next = this.getNext();
                    if (next != null) {
                        if (this.getComparer()["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TAbsolute) + "$compare"](next["System$Reactive$Concurrency$IScheduledItem$1$" + Bridge.getTypeAlias(TAbsolute) + "$getDueTime"](), this.getClock()) > 0) {
                            this.setClock(next["System$Reactive$Concurrency$IScheduledItem$1$" + Bridge.getTypeAlias(TAbsolute) + "$getDueTime"]());
                        }
                        next["System$Reactive$Concurrency$IScheduledItem$1$" + Bridge.getTypeAlias(TAbsolute) + "$invoke"]();
                    } else {
                        this.setIsEnabled(false);
                    }
                } while (this.getIsEnabled());
            }
        },
        /**
         * Stops the virtual time scheduler.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @return  {void}
         */
        stop: function () {
            this.setIsEnabled(false);
        },
        /**
         * Advances the scheduler's clock to the specified time, running all work till that point.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @throws <b /> is in the past.
         * @throws The scheduler is already running. VirtualTimeScheduler doesn't support running nested work dispatch loops. To simulate time slippage while running work on the scheduler, use {@link InvalidOperationException}.
         * @param   {TAbsolute}    time    Absolute time to advance the scheduler's clock to.
         * @return  {void}
         */
        advanceTo: function (time) {
            var dueToClock = this.getComparer()["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TAbsolute) + "$compare"](time, this.getClock());
            if (dueToClock < 0) {
                throw new System.ArgumentOutOfRangeException("time");
            }

            if (dueToClock === 0) {
                return;
            }

            if (!this.getIsEnabled()) {
                this.setIsEnabled(true);
                do {
                    var next = this.getNext();
                    if (next != null && this.getComparer()["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TAbsolute) + "$compare"](next["System$Reactive$Concurrency$IScheduledItem$1$" + Bridge.getTypeAlias(TAbsolute) + "$getDueTime"](), time) <= 0) {
                        if (this.getComparer()["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TAbsolute) + "$compare"](next["System$Reactive$Concurrency$IScheduledItem$1$" + Bridge.getTypeAlias(TAbsolute) + "$getDueTime"](), this.getClock()) > 0) {
                            this.setClock(next["System$Reactive$Concurrency$IScheduledItem$1$" + Bridge.getTypeAlias(TAbsolute) + "$getDueTime"]());
                        }
                        next["System$Reactive$Concurrency$IScheduledItem$1$" + Bridge.getTypeAlias(TAbsolute) + "$invoke"]();
                    } else {
                        this.setIsEnabled(false);
                    }
                } while (this.getIsEnabled());

                this.setClock(time);
            } else {
                throw new System.InvalidOperationException(System.String.formatProvider(System.Globalization.CultureInfo.getCurrentCulture(), System.Reactive.Strings_Linq.CANT_ADVANCE_WHILE_RUNNING, "AdvanceTo"));
            }
        },
        /**
         * Advances the scheduler's clock by the specified relative time, running all work scheduled for that timespan.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @throws <b /> is negative.
         * @throws The scheduler is already running. VirtualTimeScheduler doesn't support running nested work dispatch loops. To simulate time slippage while running work on the scheduler, use {@link InvalidOperationException}.
         * @param   {TRelative}    time    Relative time to advance the scheduler's clock by.
         * @return  {void}
         */
        advanceBy: function (time) {
            var dt = this.add(this.getClock(), time);

            var dueToClock = this.getComparer()["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TAbsolute) + "$compare"](dt, this.getClock());
            if (dueToClock < 0) {
                throw new System.ArgumentOutOfRangeException("time");
            }

            if (dueToClock === 0) {
                return;
            }

            if (!this.getIsEnabled()) {
                this.advanceTo(dt);
            } else {
                throw new System.InvalidOperationException(System.String.formatProvider(System.Globalization.CultureInfo.getCurrentCulture(), System.Reactive.Strings_Linq.CANT_ADVANCE_WHILE_RUNNING, "AdvanceBy"));
            }
        },
        /**
         * Advances the scheduler's clock by the specified relative time.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @throws <b /> is negative.
         * @param   {TRelative}    time    Relative time to advance the scheduler's clock by.
         * @return  {void}
         */
        sleep: function (time) {
            var dt = this.add(this.getClock(), time);

            var dueToClock = this.getComparer()["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TAbsolute) + "$compare"](dt, this.getClock());
            if (dueToClock < 0) {
                throw new System.ArgumentOutOfRangeException("time");
            }

            this.setClock(dt);
        },
        System$Reactive$IServiceProvider$getService: function (serviceType) {
            return this.getService(serviceType);
        },
        /**
         * Discovers scheduler services by interface type. The base class implementation supports
         only the IStopwatchProvider service. To influence service discovery - such as adding
         support for other scheduler services - derived types can override this method.
         *
         * @instance
         * @protected
         * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @param   {Function}    serviceType    Scheduler service interface type to discover.
         * @return  {Object}                     Object implementing the requested service, if available; null otherwise.
         */
        getService: function (serviceType) {
            if (Bridge.referenceEquals(serviceType, System.Reactive.Concurrency.IStopwatchProvider)) {
                return Bridge.as(this, System.Reactive.Concurrency.IStopwatchProvider);
            }

            return null;
        },
        /**
         * Starts a new stopwatch object.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @memberof System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
         * @return  {System.Reactive.Concurrency.IStopwatch}        New stopwatch object; started at the time of the request.
         */
        startStopwatch: function () {
            var start = this.toDateTimeOffset(this.getClock()).$clone();
            return new (System.Reactive.Concurrency.VirtualTimeSchedulerBase$2.VirtualTimeStopwatch(TAbsolute,TRelative))(Bridge.fn.bind(this, function () {
                return System.DateTimeOffset.op_Subtraction$1(this.toDateTimeOffset(this.getClock()), start);
            }));
        }
    }; });

    /**
     * Represents a work item that closes over scheduler invocation state. Subtyping is
     used to have a common type for the scheduler queues.
     *
     * @private
     * @class System.Reactive.Concurrency.LocalScheduler.WorkItem$1
     * @augments System.Reactive.Concurrency.LocalScheduler.WorkItem
     */
    Bridge.define("System.Reactive.Concurrency.LocalScheduler.WorkItem$1", function (TState) { return {
        inherits: [System.Reactive.Concurrency.LocalScheduler.WorkItem],
        _state: Bridge.getDefaultValue(TState),
        _action: null,
        ctor: function (scheduler, state, dueTime, action) {
            this.$initialize();
            System.Reactive.Concurrency.LocalScheduler.WorkItem.ctor.call(this, scheduler, dueTime);
            this._state = state;
            this._action = action;
        },
        invokeCore: function (scheduler) {
            return this._action(scheduler, this._state);
        }
    }; });

    /**
     * Interface with variance annotation; allows for better type checking when detecting capabilities in SubscribeSafe.
     *
     * @abstract
     * @class System.Reactive.IProducer$1
     * @implements  System.IObservable$1
     * @param   {Function}    [name]    Type of the resulting sequence's elements.
     */
    Bridge.definei("System.Reactive.IProducer$1", function (TSource) { return {
        inherits: [System.IObservable$1(TSource)],
        $kind: "interface",
        $variance: [1]
    }; });

    /**
     * Abstract base class for scheduled work items.
     *
     * @abstract
     * @public
     * @class System.Reactive.Concurrency.ScheduledItem$1
     * @implements  System.Reactive.Concurrency.IScheduledItem$1
     * @implements  System.IComparable$1
     * @param   {Function}    [name]    Absolute time representation type.
     */
    Bridge.define("System.Reactive.Concurrency.ScheduledItem$1", function (TAbsolute) { return {
        inherits: function () { return [System.Reactive.Concurrency.IScheduledItem$1(TAbsolute),System.IComparable$1(System.Reactive.Concurrency.ScheduledItem$1(TAbsolute))]; },
        statics: {
            /**
             * Determines whether one specified ScheduledItem&lt;TAbsolute&gt; object is due before a second specified ScheduledItem&lt;TAbsolute&gt; object.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.ScheduledItem$1
             * @memberof System.Reactive.Concurrency.ScheduledItem$1
             * @param   {System.Reactive.Concurrency.ScheduledItem$1}    left     The first object to compare.
             * @param   {System.Reactive.Concurrency.ScheduledItem$1}    right    The second object to compare.
             * @return  {boolean}                                                 true if the DueTime value of left is earlier than the DueTime value of right; otherwise, false.
             */
            op_LessThan: function (left, right) {
                return new (System.Collections.Generic.Comparer$1(System.Reactive.Concurrency.ScheduledItem$1(TAbsolute)))(System.Collections.Generic.Comparer$1.$default.fn).compare(left, right) < 0;
            }/**
             * Determines whether one specified ScheduledItem&lt;TAbsolute&gt; object is due before or at the same of a second specified ScheduledItem&lt;TAbsolute&gt; object.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.ScheduledItem$1
             * @memberof System.Reactive.Concurrency.ScheduledItem$1
             * @param   {System.Reactive.Concurrency.ScheduledItem$1}    left     The first object to compare.
             * @param   {System.Reactive.Concurrency.ScheduledItem$1}    right    The second object to compare.
             * @return  {boolean}                                                 true if the DueTime value of left is earlier than or simultaneous with the DueTime value of right; otherwise, false.
             */
            ,
            op_LessThanOrEqual: function (left, right) {
                return new (System.Collections.Generic.Comparer$1(System.Reactive.Concurrency.ScheduledItem$1(TAbsolute)))(System.Collections.Generic.Comparer$1.$default.fn).compare(left, right) <= 0;
            }/**
             * Determines whether one specified ScheduledItem&lt;TAbsolute&gt; object is due after a second specified ScheduledItem&lt;TAbsolute&gt; object.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.ScheduledItem$1
             * @memberof System.Reactive.Concurrency.ScheduledItem$1
             * @param   {System.Reactive.Concurrency.ScheduledItem$1}    left     The first object to compare.
             * @param   {System.Reactive.Concurrency.ScheduledItem$1}    right    The second object to compare.
             * @return  {boolean}                                                 true if the DueTime value of left is later than the DueTime value of right; otherwise, false.
             */
            ,
            op_GreaterThan: function (left, right) {
                return new (System.Collections.Generic.Comparer$1(System.Reactive.Concurrency.ScheduledItem$1(TAbsolute)))(System.Collections.Generic.Comparer$1.$default.fn).compare(left, right) > 0;
            }/**
             * Determines whether one specified ScheduledItem&lt;TAbsolute&gt; object is due after or at the same time of a second specified ScheduledItem&lt;TAbsolute&gt; object.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.ScheduledItem$1
             * @memberof System.Reactive.Concurrency.ScheduledItem$1
             * @param   {System.Reactive.Concurrency.ScheduledItem$1}    left     The first object to compare.
             * @param   {System.Reactive.Concurrency.ScheduledItem$1}    right    The second object to compare.
             * @return  {boolean}                                                 true if the DueTime value of left is later than or simultaneous with the DueTime value of right; otherwise, false.
             */
            ,
            op_GreaterThanOrEqual: function (left, right) {
                return new (System.Collections.Generic.Comparer$1(System.Reactive.Concurrency.ScheduledItem$1(TAbsolute)))(System.Collections.Generic.Comparer$1.$default.fn).compare(left, right) >= 0;
            }/**
             * Determines whether two specified ScheduledItem&lt;TAbsolute, TValue&gt; objects are equal.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.ScheduledItem$1
             * @memberof System.Reactive.Concurrency.ScheduledItem$1
             * @param   {System.Reactive.Concurrency.ScheduledItem$1}    left     The first object to compare.
             * @param   {System.Reactive.Concurrency.ScheduledItem$1}    right    The second object to compare.
             * @return  {boolean}                                                 true if both ScheduledItem&lt;TAbsolute, TValue&gt; are equal; otherwise, false.
             */
            ,
            op_Equality: function (left, right) {
                return Bridge.referenceEquals(left, right);
            }/**
             * Determines whether two specified ScheduledItem&lt;TAbsolute, TValue&gt; objects are inequal.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.ScheduledItem$1
             * @memberof System.Reactive.Concurrency.ScheduledItem$1
             * @param   {System.Reactive.Concurrency.ScheduledItem$1}    left     The first object to compare.
             * @param   {System.Reactive.Concurrency.ScheduledItem$1}    right    The second object to compare.
             * @return  {boolean}                                                 true if both ScheduledItem&lt;TAbsolute, TValue&gt; are inequal; otherwise, false.
             */
            ,
            op_Inequality: function (left, right) {
                return !(System.Reactive.Concurrency.ScheduledItem$1(TAbsolute).op_Equality(left, right));
            }
        },
        _disposable: null,
        _dueTime: Bridge.getDefaultValue(TAbsolute),
        _comparer: null,
        config: {
            alias: [
            "getDueTime", "System$Reactive$Concurrency$IScheduledItem$1$" + Bridge.getTypeAlias(TAbsolute) + "$getDueTime",
            "invoke", "System$Reactive$Concurrency$IScheduledItem$1$" + Bridge.getTypeAlias(TAbsolute) + "$invoke",
            "compareTo", "System$IComparable$1$System$Reactive$Concurrency$ScheduledItem$1$" + Bridge.getTypeAlias(TAbsolute) + "$compareTo"
            ],
            init: function () {
                this._disposable = new System.Reactive.Disposables.SingleAssignmentDisposable();
            }
        },
        /**
         * Creates a new scheduled work item to run at the specified time.
         *
         * @instance
         * @protected
         * @this System.Reactive.Concurrency.ScheduledItem$1
         * @memberof System.Reactive.Concurrency.ScheduledItem$1
         * @throws <b /> is null.
         * @param   {TAbsolute}                                 dueTime     Absolute time at which the work item has to be executed.
         * @param   {System.Collections.Generic.IComparer$1}    comparer    Comparer used to compare work items based on their scheduled time.
         * @return  {void}
         */
        ctor: function (dueTime, comparer) {
            this.$initialize();
            if (comparer == null) {
                throw new System.ArgumentNullException("comparer");
            }

            this._dueTime = dueTime;
            this._comparer = comparer;
        },
        /**
         * Gets the absolute time at which the item is due for invocation.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.ScheduledItem$1
         * @memberof System.Reactive.Concurrency.ScheduledItem$1
         * @function getDueTime
         * @return  {TAbsolute}
         */
        /**
         * Gets the absolute time at which the item is due for invocation.
         *
         * @instance
         * @function setDueTime
         */
        getDueTime: function () {
            return this._dueTime;
        },
        /**
         * Gets whether the work item has received a cancellation request.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.ScheduledItem$1
         * @memberof System.Reactive.Concurrency.ScheduledItem$1
         * @function getIsCanceled
         * @return  {boolean}
         */
        /**
         * Gets whether the work item has received a cancellation request.
         *
         * @instance
         * @function setIsCanceled
         */
        getIsCanceled: function () {
            return this._disposable.getIsDisposed();
        },
        /**
         * Invokes the work item.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.ScheduledItem$1
         * @memberof System.Reactive.Concurrency.ScheduledItem$1
         * @return  {void}
         */
        invoke: function () {
            if (!this._disposable.getIsDisposed()) {
                this._disposable.setDisposable(this.invokeCore());
            }
        },
        /**
         * Compares the work item with another work item based on absolute time values.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.ScheduledItem$1
         * @memberof System.Reactive.Concurrency.ScheduledItem$1
         * @param   {System.Reactive.Concurrency.ScheduledItem$1}    other    Work item to compare the current work item to.
         * @return  {number}                                                  Relative ordering between this and the specified work item.
         */
        compareTo: function (other) {
            // MSDN: By definition, any object compares greater than null, and two null references compare equal to each other. 
            if (Bridge.referenceEquals(other, null)) {
                return 1;
            }

            return this._comparer["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TAbsolute) + "$compare"](this.getDueTime(), other.getDueTime());
        },
        /**
         * Determines whether a ScheduledItem&lt;TAbsolute&gt; object is equal to the specified object.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Concurrency.ScheduledItem$1
         * @memberof System.Reactive.Concurrency.ScheduledItem$1
         * @param   {Object}     obj    The object to compare to the current ScheduledItem&lt;TAbsolute&gt; object.
         * @return  {boolean}           true if the obj parameter is a ScheduledItem&lt;TAbsolute&gt; object and is equal to the current ScheduledItem&lt;TAbsolute&gt; object; otherwise, false.
         */
        equals: function (obj) {
            return Bridge.referenceEquals(this, obj);
        },
        /**
         * Returns the hash code for the current ScheduledItem&lt;TAbsolute&gt; object.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Concurrency.ScheduledItem$1
         * @memberof System.Reactive.Concurrency.ScheduledItem$1
         * @return  {number}        A 32-bit signed integer hash code.
         */
        getHashCode: function () {
            return Bridge.getHashCode(this);
        },
        /**
         * Cancels the work item by disposing the resource returned by InvokeCore as soon as possible.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.ScheduledItem$1
         * @memberof System.Reactive.Concurrency.ScheduledItem$1
         * @return  {void}
         */
        cancel: function () {
            this._disposable.dispose();
        }
    }; });

    Bridge.define("System.Reactive.Concurrency.Scheduler.EmulatedStopwatch", {
        inherits: [System.Reactive.Concurrency.IStopwatch],
        _scheduler: null,
        config: {
            alias: [
            "getElapsed", "System$Reactive$Concurrency$IStopwatch$getElapsed"
            ],
            init: function () {
                this._start = new System.DateTimeOffset();
            }
        },
        ctor: function (scheduler) {
            this.$initialize();
            this._scheduler = scheduler;
            this._start = this._scheduler.System$Reactive$Concurrency$IScheduler$getNow().$clone();
        },
        getElapsed: function () {
            return System.Reactive.Concurrency.Scheduler.normalize(System.DateTimeOffset.op_Subtraction$1(this._scheduler.System$Reactive$Concurrency$IScheduler$getNow(), this._start.$clone()));
        }
    });

    Bridge.define("System.Reactive.Concurrency.Synchronize$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            var $t;
            this._parent = parent;
            this._gate = ($t = this._parent._gate, $t != null ? $t : {  });
    },
    onNext: function (value) {
        this._gate;
        {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        }
    },
    onError: function (error) {
        this._gate;
        {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    },
    onCompleted: function () {
        this._gate;
        {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }
    }; });

    Bridge.define("System.Reactive.Concurrency.VirtualTimeSchedulerBase$2.VirtualTimeStopwatch", function (TAbsolute, TRelative) { return {
        inherits: [System.Reactive.Concurrency.IStopwatch],
        _getElapsed: null,
        config: {
            alias: [
            "getElapsed", "System$Reactive$Concurrency$IStopwatch$getElapsed"
            ]
        },
        ctor: function (getElapsed) {
            this.$initialize();
            this._getElapsed = getElapsed;
        },
        getElapsed: function () {
            return this._getElapsed();
        }
    }; });

    /**
     * Represents an Action-based disposable.
     *
     * @class System.Reactive.Disposables.AnonymousDisposable
     * @implements  System.Reactive.Disposables.ICancelable
     */
    Bridge.define("System.Reactive.Disposables.AnonymousDisposable", {
        inherits: [System.Reactive.Disposables.ICancelable],
        _dispose: null,
        config: {
            alias: [
            "getIsDisposed", "System$Reactive$Disposables$ICancelable$getIsDisposed",
            "dispose", "System$IDisposable$dispose"
            ]
        },
        /**
         * Constructs a new disposable with the given action used for disposal.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.AnonymousDisposable
         * @memberof System.Reactive.Disposables.AnonymousDisposable
         * @param   {System.Action}    dispose    Disposal action which will be run upon calling Dispose.
         * @return  {void}
         */
        ctor: function (dispose) {
            this.$initialize();

            this._dispose = dispose;
        },
        /**
         * Gets a value that indicates whether the object is disposed.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.AnonymousDisposable
         * @memberof System.Reactive.Disposables.AnonymousDisposable
         * @function getIsDisposed
         * @return  {boolean}
         */
        /**
         * Gets a value that indicates whether the object is disposed.
         *
         * @instance
         * @function setIsDisposed
         */
        getIsDisposed: function () {
            return Bridge.staticEquals(this._dispose, null);
        },
        /**
         * Calls the disposal action if and only if the current instance hasn't been disposed yet.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.AnonymousDisposable
         * @memberof System.Reactive.Disposables.AnonymousDisposable
         * @return  {void}
         */
        dispose: function () {
            var dispose = System.Interlocked.exchange(Function, Bridge.ref(this, "_dispose"), null);
            if (!Bridge.staticEquals(dispose, null)) {
                dispose();
            }
        }
    });

    /**
     * Represents a disposable resource that can be checked for disposal status.
     *
     * @public
     * @class System.Reactive.Disposables.BooleanDisposable
     * @implements  System.Reactive.Disposables.ICancelable
     */
    Bridge.define("System.Reactive.Disposables.BooleanDisposable", {
        inherits: [System.Reactive.Disposables.ICancelable],
        statics: {
            true: null,
            config: {
                init: function () {
                    this.true = new System.Reactive.Disposables.BooleanDisposable.$ctor1(true);
                }
            }
        },
        _isDisposed: false,
        config: {
            alias: [
            "getIsDisposed", "System$Reactive$Disposables$ICancelable$getIsDisposed",
            "dispose", "System$IDisposable$dispose"
            ]
        },
        /**
         * Initializes a new instance of the {@link } class.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.BooleanDisposable
         * @memberof System.Reactive.Disposables.BooleanDisposable
         * @return  {void}
         */
        ctor: function () {
            this.$initialize();
        },
        $ctor1: function (isDisposed) {
            this.$initialize();
            this._isDisposed = isDisposed;
        },
        /**
         * Gets a value that indicates whether the object is disposed.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.BooleanDisposable
         * @memberof System.Reactive.Disposables.BooleanDisposable
         * @function getIsDisposed
         * @return  {boolean}
         */
        /**
         * Gets a value that indicates whether the object is disposed.
         *
         * @instance
         * @function setIsDisposed
         */
        getIsDisposed: function () {
            return this._isDisposed;
        },
        /**
         * Sets the status to disposed, which can be observer through the {@link } property.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.BooleanDisposable
         * @memberof System.Reactive.Disposables.BooleanDisposable
         * @return  {void}
         */
        dispose: function () {
            this._isDisposed = true;
        }
    });

    /**
     * Represents a group of disposable resources that are disposed together.
     *
     * @public
     * @class System.Reactive.Disposables.CompositeDisposable
     * @implements  System.Collections.Generic.ICollection$1
     * @implements  System.Reactive.Disposables.ICancelable
     */
    Bridge.define("System.Reactive.Disposables.CompositeDisposable", {
        inherits: [System.Collections.Generic.ICollection$1(System.IDisposable),System.Reactive.Disposables.ICancelable],
        statics: {
            SHRINK_THRESHOLD: 64
        },
        _gate: null,
        _disposed: false,
        _disposables: null,
        _count: 0,
        config: {
            alias: [
            "getCount", "System$Collections$Generic$ICollection$1$System$IDisposable$getCount",
            "add", "System$Collections$Generic$ICollection$1$System$IDisposable$add",
            "remove", "System$Collections$Generic$ICollection$1$System$IDisposable$remove",
            "dispose", "System$IDisposable$dispose",
            "clear", "System$Collections$Generic$ICollection$1$System$IDisposable$clear",
            "contains", "System$Collections$Generic$ICollection$1$System$IDisposable$contains",
            "copyTo", "System$Collections$Generic$ICollection$1$System$IDisposable$copyTo",
            "getIsReadOnly", "System$Collections$Generic$ICollection$1$System$IDisposable$getIsReadOnly",
            "getEnumerator", "System$Collections$Generic$IEnumerable$1$System$IDisposable$getEnumerator",
            "getIsDisposed", "System$Reactive$Disposables$ICancelable$getIsDisposed"
            ],
            init: function () {
                this._gate = {  };
            }
        },
        /**
         * Initializes a new instance of the {@link } class with no disposables contained by it initially.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.CompositeDisposable
         * @memberof System.Reactive.Disposables.CompositeDisposable
         * @return  {void}
         */
        ctor: function () {
            this.$initialize();
            this._disposables = new (System.Collections.Generic.List$1(System.IDisposable))();
        },
        /**
         * Initializes a new instance of the {@link } class with the specified number of disposables.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.CompositeDisposable
         * @memberof System.Reactive.Disposables.CompositeDisposable
         * @throws <b /> is less than zero.
         * @param   {number}    capacity    The number of disposables that the new CompositeDisposable can initially store.
         * @return  {void}
         */
        $ctor3: function (capacity) {
            this.$initialize();
            if (capacity < 0) {
                throw new System.ArgumentOutOfRangeException("capacity");
            }

            this._disposables = new (System.Collections.Generic.List$1(System.IDisposable))(capacity);
        },
        /**
         * Initializes a new instance of the {@link } class from a group of disposables.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.CompositeDisposable
         * @memberof System.Reactive.Disposables.CompositeDisposable
         * @throws <b /> is null.
         * @throws Any of the disposables in the <b /> collection is null.
         * @param   {Array.<System.IDisposable>}    disposables    Disposables that will be disposed together.
         * @return  {void}
         */
        $ctor2: function (disposables) {
            if (disposables === void 0) { disposables = []; }

            System.Reactive.Disposables.CompositeDisposable.$ctor1.call(this, Bridge.cast(disposables, System.Collections.Generic.IEnumerable$1(System.IDisposable)));
        },
        /**
         * Initializes a new instance of the {@link } class from a group of disposables.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.CompositeDisposable
         * @memberof System.Reactive.Disposables.CompositeDisposable
         * @throws <b /> is null.
         * @throws Any of the disposables in the <b /> collection is null.
         * @param   {System.Collections.Generic.IEnumerable$1}    disposables    Disposables that will be disposed together.
         * @return  {void}
         */
        $ctor1: function (disposables) {
            this.$initialize();
            if (disposables == null) {
                throw new System.ArgumentNullException("disposables");
            }

            this._disposables = new (System.Collections.Generic.List$1(System.IDisposable))(disposables);

            //
            // Doing this on the list to avoid duplicate enumeration of disposables.
            //
            if (this._disposables.contains(null)) {
                throw new System.ArgumentException(System.Reactive.Strings_Core.DISPOSABLES_CANT_CONTAIN_NULL, "disposables");
            }

            this._count = this._disposables.getCount();
        },
        /**
         * Gets the number of disposables contained in the CompositeDisposable.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.CompositeDisposable
         * @memberof System.Reactive.Disposables.CompositeDisposable
         * @function getCount
         * @return  {number}
         */
        /**
         * Gets the number of disposables contained in the CompositeDisposable.
         *
         * @instance
         * @function setCount
         */
        getCount: function () {
            return this._count;
        },
        /**
         * Always returns false.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.CompositeDisposable
         * @memberof System.Reactive.Disposables.CompositeDisposable
         * @function getIsReadOnly
         * @return  {boolean}
         */
        /**
         * Always returns false.
         *
         * @instance
         * @function setIsReadOnly
         */
        getIsReadOnly: function () {
            return false;
        },
        /**
         * Gets a value that indicates whether the object is disposed.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.CompositeDisposable
         * @memberof System.Reactive.Disposables.CompositeDisposable
         * @function getIsDisposed
         * @return  {boolean}
         */
        /**
         * Gets a value that indicates whether the object is disposed.
         *
         * @instance
         * @function setIsDisposed
         */
        getIsDisposed: function () {
            return this._disposed;
        },
        /**
         * Adds a disposable to the CompositeDisposable or disposes the disposable if the CompositeDisposable is disposed.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.CompositeDisposable
         * @memberof System.Reactive.Disposables.CompositeDisposable
         * @throws <b /> is null.
         * @param   {System.IDisposable}    item    Disposable to add.
         * @return  {void}
         */
        add: function (item) {
            if (item == null) {
                throw new System.ArgumentNullException("item");
            }

            var shouldDispose = false;
            this._gate;
            {
                shouldDispose = this._disposed;
                if (!this._disposed) {
                    this._disposables.add(item);
                    this._count = (this._count + 1) | 0;
                }
            }
            if (shouldDispose) {
                item.System$IDisposable$dispose();
            }
        },
        /**
         * Removes and disposes the first occurrence of a disposable from the CompositeDisposable.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.CompositeDisposable
         * @memberof System.Reactive.Disposables.CompositeDisposable
         * @throws <b /> is null.
         * @param   {System.IDisposable}    item    Disposable to remove.
         * @return  {boolean}                       true if found; false otherwise.
         */
        remove: function (item) {
            if (item == null) {
                throw new System.ArgumentNullException("item");
            }

            var shouldDispose = false;

            this._gate;
            {
                if (!this._disposed) {
                    //
                    // List<T> doesn't shrink the size of the underlying array but does collapse the array
                    // by copying the tail one position to the left of the removal index. We don't need
                    // index-based lookup but only ordering for sequential disposal. So, instead of spending
                    // cycles on the Array.Copy imposed by Remove, we use a null sentinel value. We also
                    // do manual Swiss cheese detection to shrink the list if there's a lot of holes in it.
                    //
                    var i = this._disposables.indexOf(item);
                    if (i >= 0) {
                        shouldDispose = true;
                        this._disposables.setItem(i, null);
                        this._count = (this._count - 1) | 0;

                    }

                }
            }

            if (shouldDispose) {
                item.System$IDisposable$dispose();
            }

            return shouldDispose;
        },
        /**
         * Disposes all disposables in the group and removes them from the group.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.CompositeDisposable
         * @memberof System.Reactive.Disposables.CompositeDisposable
         * @return  {void}
         */
        dispose: function () {
            var $t;
            var currentDisposables = null;
            this._gate;
            {
                if (!this._disposed) {
                    this._disposed = true;
                    currentDisposables = this._disposables.toArray();
                    this._disposables.clear();
                    this._count = 0;
                }
            }

            if (currentDisposables != null) {
                $t = Bridge.getEnumerator(currentDisposables);
                while ($t.moveNext()) {
                    var d = $t.getCurrent();
                    if (d != null) {
                        d.System$IDisposable$dispose();
                    }
                }
            }
        },
        /**
         * Removes and disposes all disposables from the CompositeDisposable, but does not dispose the CompositeDisposable.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.CompositeDisposable
         * @memberof System.Reactive.Disposables.CompositeDisposable
         * @return  {void}
         */
        clear: function () {
            var $t;
            var currentDisposables = null;
            this._gate;
            {
                currentDisposables = this._disposables.toArray();
                this._disposables.clear();
                this._count = 0;
            }

            $t = Bridge.getEnumerator(currentDisposables);
            while ($t.moveNext()) {
                var d = $t.getCurrent();
                if (d != null) {
                    d.System$IDisposable$dispose();
                }
            }
        },
        /**
         * Determines whether the CompositeDisposable contains a specific disposable.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.CompositeDisposable
         * @memberof System.Reactive.Disposables.CompositeDisposable
         * @throws <b /> is null.
         * @param   {System.IDisposable}    item    Disposable to search for.
         * @return  {boolean}                       true if the disposable was found; otherwise, false.
         */
        contains: function (item) {
            if (item == null) {
                throw new System.ArgumentNullException("item");
            }

            this._gate;
            {
                return this._disposables.contains(item);
            }
        },
        /**
         * Copies the disposables contained in the CompositeDisposable to an array, starting at a particular array index.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.CompositeDisposable
         * @memberof System.Reactive.Disposables.CompositeDisposable
         * @throws <b /> is null.
         * @throws <b /> is less than zero. -or - <b /> is larger than or equal to the array length.
         * @param   {Array.<System.IDisposable>}    array         Array to copy the contained disposables to.
         * @param   {number}                        arrayIndex    Target index at which to copy the first disposable of the group.
         * @return  {void}
         */
        copyTo: function (array, arrayIndex) {
            if (array == null) {
                throw new System.ArgumentNullException("array");
            }
            if (arrayIndex < 0 || arrayIndex >= array.length) {
                throw new System.ArgumentOutOfRangeException("arrayIndex");
            }

            this._gate;
            {
                System.Array.copy(System.Linq.Enumerable.from(this._disposables).where($asm.$.System.Reactive.Disposables.CompositeDisposable.f1).toArray(), 0, array, arrayIndex, ((array.length - arrayIndex) | 0));
            }
        },
        /**
         * Returns an enumerator that iterates through the CompositeDisposable.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.CompositeDisposable
         * @memberof System.Reactive.Disposables.CompositeDisposable
         * @return  {System.Collections.Generic.IEnumerator$1}        An enumerator to iterate over the disposables.
         */
        getEnumerator: function () {
            var res = null;

            this._gate;
            {
                res = System.Linq.Enumerable.from(this._disposables).where($asm.$.System.Reactive.Disposables.CompositeDisposable.f1).toList(System.IDisposable);
            }

            return Bridge.getEnumerator(res, System.IDisposable);
        },
        /**
         * Returns an enumerator that iterates through the CompositeDisposable.
         *
         * @instance
         * @this System.Reactive.Disposables.CompositeDisposable
         * @memberof System.Reactive.Disposables.CompositeDisposable
         * @return  {System.Collections.IEnumerator}        An enumerator to iterate over the disposables.
         */
        System$Collections$IEnumerable$getEnumerator: function () {
            return this.getEnumerator();
        }
    });

    Bridge.ns("System.Reactive.Disposables.CompositeDisposable", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Disposables.CompositeDisposable, {
        f1: function (d) {
            return d != null;
        }
    });

    /**
     * Represents a disposable resource whose underlying disposable resource can be swapped for another disposable resource.
     *
     * @public
     * @class System.Reactive.Disposables.MultipleAssignmentDisposable
     * @implements  System.Reactive.Disposables.ICancelable
     */
    Bridge.define("System.Reactive.Disposables.MultipleAssignmentDisposable", {
        inherits: [System.Reactive.Disposables.ICancelable],
        _current: null,
        config: {
            alias: [
            "getIsDisposed", "System$Reactive$Disposables$ICancelable$getIsDisposed",
            "dispose", "System$IDisposable$dispose"
            ]
        },
        /**
         * Initializes a new instance of the {@link } class with no current underlying disposable.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.MultipleAssignmentDisposable
         * @memberof System.Reactive.Disposables.MultipleAssignmentDisposable
         * @return  {void}
         */
        ctor: function () {
            this.$initialize();
        },
        /**
         * Gets a value that indicates whether the object is disposed.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.MultipleAssignmentDisposable
         * @memberof System.Reactive.Disposables.MultipleAssignmentDisposable
         * @function getIsDisposed
         * @return  {boolean}
         */
        /**
         * Gets a value that indicates whether the object is disposed.
         *
         * @instance
         * @function setIsDisposed
         */
        getIsDisposed: function () {
            // We use a sentinel value to indicate we've been disposed. This sentinel never leaks
            // to the outside world (see the Disposable property getter), so no-one can ever assign
            // this value to us manually.
            return Bridge.referenceEquals(System.Threading.Volatile.read(System.IDisposable, Bridge.ref(this, "_current")), System.Reactive.Disposables.BooleanDisposable.true);
        },
        /**
         * Gets or sets the underlying disposable. After disposal, the result of getting this property is undefined.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.MultipleAssignmentDisposable
         * @memberof System.Reactive.Disposables.MultipleAssignmentDisposable
         * @function getDisposable
         * @return  {System.IDisposable}
         */
        /**
         * Gets or sets the underlying disposable. After disposal, the result of getting this property is undefined.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.MultipleAssignmentDisposable
         * @memberof System.Reactive.Disposables.MultipleAssignmentDisposable
         * @function setDisposable
         * @param   {System.IDisposable}    value
         * @return  {void}
         */
        getDisposable: function () {
            var a = System.Threading.Volatile.read(System.IDisposable, Bridge.ref(this, "_current"));
            // Don't leak the DISPOSED sentinel
            if (Bridge.referenceEquals(a, System.Reactive.Disposables.BooleanDisposable.true)) {
                a = System.Reactive.Disposables.DefaultDisposable.instance;
            }
            return a;
        },
        /**
         * Gets or sets the underlying disposable. After disposal, the result of getting this property is undefined.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.MultipleAssignmentDisposable
         * @memberof System.Reactive.Disposables.MultipleAssignmentDisposable
         * @function getDisposable
         * @return  {System.IDisposable}
         */
        /**
         * Gets or sets the underlying disposable. After disposal, the result of getting this property is undefined.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.MultipleAssignmentDisposable
         * @memberof System.Reactive.Disposables.MultipleAssignmentDisposable
         * @function setDisposable
         * @param   {System.IDisposable}    value
         * @return  {void}
         */
        setDisposable: function (value) {
            var $t;
            // Let's read the current value atomically (also prevents reordering).
            var old = System.Threading.Volatile.read(System.IDisposable, Bridge.ref(this, "_current"));
            for (; ; ) {
                $t = (function () {
                    // If it is the disposed instance, dispose the value.
                    if (Bridge.referenceEquals(old, System.Reactive.Disposables.BooleanDisposable.true)) {
                        value != null ? value.System$IDisposable$dispose() : null;
                        return {jump: 3};
                    }
                    // Atomically swap in the new value and get back the old.
                    var b = System.Interlocked.compareExchange(System.IDisposable, Bridge.ref(this, "_current"), value, old);
                    // If the old and new are the same, the swap was successful and we can quit
                    if (Bridge.referenceEquals(old, b)) {
                        return {jump: 3};
                    }
                    // Otherwise, make the old reference the current and retry.
                    old = b;
                }).call(this) || {};
                if($t.jump == 3) return $t.v;
            }
        },
        /**
         * Disposes the underlying disposable as well as all future replacements.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.MultipleAssignmentDisposable
         * @memberof System.Reactive.Disposables.MultipleAssignmentDisposable
         * @return  {void}
         */
        dispose: function () {
            // Read the current atomically.
            var a = System.Threading.Volatile.read(System.IDisposable, Bridge.ref(this, "_current"));
            // If it is the disposed instance, don't bother further.
            if (!Bridge.referenceEquals(a, System.Reactive.Disposables.BooleanDisposable.true)) {
                // Atomically swap in the disposed instance.
                a = System.Interlocked.exchange(System.IDisposable, Bridge.ref(this, "_current"), System.Reactive.Disposables.BooleanDisposable.true);
                // It is possible there was a concurrent Dispose call so don't need to call Dispose()
                // on DISPOSED
                if (!Bridge.referenceEquals(a, System.Reactive.Disposables.BooleanDisposable.true)) {
                    a != null ? a.System$IDisposable$dispose() : null;
                }
            }
        }
    });

    /**
     * Represents a disposable resource that only disposes its underlying disposable resource when all {@link } have been disposed.
     *
     * @public
     * @class System.Reactive.Disposables.RefCountDisposable
     * @implements  System.Reactive.Disposables.ICancelable
     */
    Bridge.define("System.Reactive.Disposables.RefCountDisposable", {
        inherits: [System.Reactive.Disposables.ICancelable],
        _throwWhenDisposed: false,
        _gate: null,
        _disposable: null,
        _isPrimaryDisposed: false,
        _count: 0,
        config: {
            alias: [
            "getIsDisposed", "System$Reactive$Disposables$ICancelable$getIsDisposed",
            "dispose", "System$IDisposable$dispose"
            ],
            init: function () {
                this._gate = {  };
            }
        },
        /**
         * Initializes a new instance of the {@link } class with the specified disposable.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.RefCountDisposable
         * @memberof System.Reactive.Disposables.RefCountDisposable
         * @throws <b /> is null.
         * @param   {System.IDisposable}    disposable    Underlying disposable.
         * @return  {void}
         */
        ctor: function (disposable) {
            System.Reactive.Disposables.RefCountDisposable.$ctor1.call(this, disposable, false);

        },
        /**
         * Initializes a new instance of the {@link } class with the specified disposable.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.RefCountDisposable
         * @memberof System.Reactive.Disposables.RefCountDisposable
         * @throws <b /> is null.
         * @param   {System.IDisposable}    disposable           Underlying disposable.
         * @param   {boolean}               throwWhenDisposed    Indicates whether subsequent calls to {@link } should throw when this instance is disposed.
         * @return  {void}
         */
        $ctor1: function (disposable, throwWhenDisposed) {
            this.$initialize();
            if (disposable == null) {
                throw new System.ArgumentNullException("disposable");
            }

            this._disposable = disposable;
            this._isPrimaryDisposed = false;
            this._count = 0;
            this._throwWhenDisposed = throwWhenDisposed;
        },
        /**
         * Gets a value that indicates whether the object is disposed.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.RefCountDisposable
         * @memberof System.Reactive.Disposables.RefCountDisposable
         * @function getIsDisposed
         * @return  {boolean}
         */
        /**
         * Gets a value that indicates whether the object is disposed.
         *
         * @instance
         * @function setIsDisposed
         */
        getIsDisposed: function () {
            return this._disposable == null;
        },
        /**
         * Returns a dependent disposable that when disposed decreases the refcount on the underlying disposable.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.RefCountDisposable
         * @memberof System.Reactive.Disposables.RefCountDisposable
         * @throws This instance has been disposed and is configured to throw in this case by {@link ObjectDisposedException}.
         * @return  {System.IDisposable}        A dependent disposable contributing to the reference count that manages the underlying disposable's lifetime.
         */
        getDisposable: function () {
            this._gate;
            {
                if (this._disposable == null) {
                    if (this._throwWhenDisposed) {
                        throw new System.ObjectDisposedException("RefCountDisposable");
                    }

                    return System.Reactive.Disposables.Disposable.getEmpty();
                } else {
                    this._count = (this._count + 1) | 0;
                    return new System.Reactive.Disposables.RefCountDisposable.InnerDisposable(this);
                }
            }
        },
        /**
         * Disposes the underlying disposable only when all dependent disposables have been disposed.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.RefCountDisposable
         * @memberof System.Reactive.Disposables.RefCountDisposable
         * @return  {void}
         */
        dispose: function () {
            var disposable = null;
            this._gate;
            {
                if (this._disposable != null) {
                    if (!this._isPrimaryDisposed) {
                        this._isPrimaryDisposed = true;

                        if (this._count === 0) {
                            disposable = this._disposable;
                            this._disposable = null;
                        }
                    }
                }
            }

            if (disposable != null) {
                disposable.System$IDisposable$dispose();
            }
        },
        release: function () {
            var disposable = null;
            this._gate;
            {
                if (this._disposable != null) {
                    this._count = (this._count - 1) | 0;


                    if (this._isPrimaryDisposed) {
                        if (this._count === 0) {
                            disposable = this._disposable;
                            this._disposable = null;
                        }
                    }
                }
            }

            if (disposable != null) {
                disposable.System$IDisposable$dispose();
            }
        }
    });

    /**
     * Represents a disposable resource whose disposal invocation will be scheduled on the specified <seealso cref="T:System.Reactive.Concurrency.IScheduler" />.
     *
     * @public
     * @class System.Reactive.Disposables.ScheduledDisposable
     * @implements  System.Reactive.Disposables.ICancelable
     * @see {@link T:System.Reactive.Concurrency.IScheduler}
     */
    Bridge.define("System.Reactive.Disposables.ScheduledDisposable", {
        inherits: [System.Reactive.Disposables.ICancelable],
        _scheduler: null,
        _disposable: null,
        config: {
            alias: [
            "getIsDisposed", "System$Reactive$Disposables$ICancelable$getIsDisposed",
            "dispose", "System$IDisposable$dispose"
            ]
        },
        /**
         * Initializes a new instance of the {@link } class that uses an {@link } on which to dispose the disposable.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.ScheduledDisposable
         * @memberof System.Reactive.Disposables.ScheduledDisposable
         * @throws <b /> or <b /> is null.
         * @param   {System.Reactive.Concurrency.IScheduler}    scheduler     Scheduler where the disposable resource will be disposed on.
         * @param   {System.IDisposable}                        disposable    Disposable resource to dispose on the given scheduler.
         * @return  {void}
         */
        ctor: function (scheduler, disposable) {
            this.$initialize();
            if (scheduler == null) {
                throw new System.ArgumentNullException("scheduler");
            }
            if (disposable == null) {
                throw new System.ArgumentNullException("disposable");
            }

            this._scheduler = scheduler;
            this._disposable = disposable;
        },
        /**
         * Gets the scheduler where the disposable resource will be disposed on.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.ScheduledDisposable
         * @memberof System.Reactive.Disposables.ScheduledDisposable
         * @function getScheduler
         * @return  {System.Reactive.Concurrency.IScheduler}
         */
        /**
         * Gets the scheduler where the disposable resource will be disposed on.
         *
         * @instance
         * @function setScheduler
         */
        getScheduler: function () {
            return this._scheduler;
        },
        /**
         * Gets the underlying disposable. After disposal, the result is undefined.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.ScheduledDisposable
         * @memberof System.Reactive.Disposables.ScheduledDisposable
         * @function getDisposable
         * @return  {System.IDisposable}
         */
        /**
         * Gets the underlying disposable. After disposal, the result is undefined.
         *
         * @instance
         * @function setDisposable
         */
        getDisposable: function () {
            var current = this._disposable;

            if (Bridge.referenceEquals(current, System.Reactive.Disposables.BooleanDisposable.true)) {
                return System.Reactive.Disposables.DefaultDisposable.instance;
            } // Don't leak the sentinel value.

            return current;
        },
        /**
         * Gets a value that indicates whether the object is disposed.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.ScheduledDisposable
         * @memberof System.Reactive.Disposables.ScheduledDisposable
         * @function getIsDisposed
         * @return  {boolean}
         */
        /**
         * Gets a value that indicates whether the object is disposed.
         *
         * @instance
         * @function setIsDisposed
         */
        getIsDisposed: function () {
            return Bridge.referenceEquals(this._disposable, System.Reactive.Disposables.BooleanDisposable.true);
        },
        /**
         * Disposes the wrapped disposable on the provided scheduler.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.ScheduledDisposable
         * @memberof System.Reactive.Disposables.ScheduledDisposable
         * @return  {void}
         */
        dispose: function () {
            System.Reactive.Concurrency.Scheduler.schedule(this.getScheduler(), Bridge.fn.bind(this, this.disposeInner));
        },
        disposeInner: function () {
            var disposable = System.Interlocked.exchange(System.IDisposable, Bridge.ref(this, "_disposable"), System.Reactive.Disposables.BooleanDisposable.true);

            if (!Bridge.referenceEquals(disposable, System.Reactive.Disposables.BooleanDisposable.true)) {
                disposable.System$IDisposable$dispose();
            }
        }
    });

    /**
     * Represents a disposable resource whose underlying disposable resource can be replaced by another disposable resource, causing automatic disposal of the previous underlying disposable resource.
     *
     * @public
     * @class System.Reactive.Disposables.SerialDisposable
     * @implements  System.Reactive.Disposables.ICancelable
     */
    Bridge.define("System.Reactive.Disposables.SerialDisposable", {
        inherits: [System.Reactive.Disposables.ICancelable],
        _gate: null,
        _current: null,
        _disposed: false,
        config: {
            alias: [
            "getIsDisposed", "System$Reactive$Disposables$ICancelable$getIsDisposed",
            "dispose", "System$IDisposable$dispose"
            ],
            init: function () {
                this._gate = {  };
            }
        },
        /**
         * Initializes a new instance of the {@link } class.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.SerialDisposable
         * @memberof System.Reactive.Disposables.SerialDisposable
         * @return  {void}
         */
        ctor: function () {
            this.$initialize();
        },
        /**
         * Gets a value that indicates whether the object is disposed.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.SerialDisposable
         * @memberof System.Reactive.Disposables.SerialDisposable
         * @function getIsDisposed
         * @return  {boolean}
         */
        /**
         * Gets a value that indicates whether the object is disposed.
         *
         * @instance
         * @function setIsDisposed
         */
        getIsDisposed: function () {
            this._gate;
            {
                return this._disposed;
            }
        },
        /**
         * Gets or sets the underlying disposable.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.SerialDisposable
         * @memberof System.Reactive.Disposables.SerialDisposable
         * @function getDisposable
         * @return  {System.IDisposable}
         */
        /**
         * Gets or sets the underlying disposable.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.SerialDisposable
         * @memberof System.Reactive.Disposables.SerialDisposable
         * @function setDisposable
         * @param   {System.IDisposable}    value
         * @return  {void}
         */
        getDisposable: function () {
            return this._current;
        },
        /**
         * Gets or sets the underlying disposable.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.SerialDisposable
         * @memberof System.Reactive.Disposables.SerialDisposable
         * @function getDisposable
         * @return  {System.IDisposable}
         */
        /**
         * Gets or sets the underlying disposable.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.SerialDisposable
         * @memberof System.Reactive.Disposables.SerialDisposable
         * @function setDisposable
         * @param   {System.IDisposable}    value
         * @return  {void}
         */
        setDisposable: function (value) {
            var shouldDispose = false;
            var old = null;
            this._gate;
            {
                shouldDispose = this._disposed;
                if (!shouldDispose) {
                    old = this._current;
                    this._current = value;
                }
            }
            if (old != null) {
                old.System$IDisposable$dispose();
            }
            if (shouldDispose && value != null) {
                value.System$IDisposable$dispose();
            }
        },
        /**
         * Disposes the underlying disposable as well as all future replacements.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.SerialDisposable
         * @memberof System.Reactive.Disposables.SerialDisposable
         * @return  {void}
         */
        dispose: function () {
            var old = null;

            this._gate;
            {
                if (!this._disposed) {
                    this._disposed = true;
                    old = this._current;
                    this._current = null;
                }
            }

            if (old != null) {
                old.System$IDisposable$dispose();
            }
        }
    });

    /**
     * Represents a disposable resource which only allows a single assignment of its underlying disposable resource.
     If an underlying disposable resource has already been set, future attempts to set the underlying disposable resource will throw an {@link }.
     *
     * @public
     * @class System.Reactive.Disposables.SingleAssignmentDisposable
     * @implements  System.Reactive.Disposables.ICancelable
     */
    Bridge.define("System.Reactive.Disposables.SingleAssignmentDisposable", {
        inherits: [System.Reactive.Disposables.ICancelable],
        _current: null,
        config: {
            alias: [
            "getIsDisposed", "System$Reactive$Disposables$ICancelable$getIsDisposed",
            "dispose", "System$IDisposable$dispose"
            ]
        },
        /**
         * Initializes a new instance of the {@link } class.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.SingleAssignmentDisposable
         * @memberof System.Reactive.Disposables.SingleAssignmentDisposable
         * @return  {void}
         */
        ctor: function () {
            this.$initialize();
        },
        /**
         * Gets a value that indicates whether the object is disposed.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.SingleAssignmentDisposable
         * @memberof System.Reactive.Disposables.SingleAssignmentDisposable
         * @function getIsDisposed
         * @return  {boolean}
         */
        /**
         * Gets a value that indicates whether the object is disposed.
         *
         * @instance
         * @function setIsDisposed
         */
        getIsDisposed: function () {
            // We use a sentinel value to indicate we've been disposed. This sentinel never leaks
            // to the outside world (see the Disposable property getter), so no-one can ever assign
            // this value to us manually.
            return Bridge.referenceEquals(this._current, System.Reactive.Disposables.BooleanDisposable.true);
        },
        /**
         * Gets or sets the underlying disposable. After disposal, the result of getting this property is undefined.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.SingleAssignmentDisposable
         * @memberof System.Reactive.Disposables.SingleAssignmentDisposable
         * @function getDisposable
         * @throws Thrown if the SingleAssignmentDisposable has already been assigned to.
         * @return  {System.IDisposable}
         */
        /**
         * Gets or sets the underlying disposable. After disposal, the result of getting this property is undefined.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.SingleAssignmentDisposable
         * @memberof System.Reactive.Disposables.SingleAssignmentDisposable
         * @function setDisposable
         * @throws Thrown if the SingleAssignmentDisposable has already been assigned to.
         * @param   {System.IDisposable}    value
         * @return  {void}
         */
        getDisposable: function () {
            var current = this._current;

            if (Bridge.referenceEquals(current, System.Reactive.Disposables.BooleanDisposable.true)) {
                return System.Reactive.Disposables.DefaultDisposable.instance;
            } // Don't leak the sentinel value.

            return current;
        },
        /**
         * Gets or sets the underlying disposable. After disposal, the result of getting this property is undefined.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.SingleAssignmentDisposable
         * @memberof System.Reactive.Disposables.SingleAssignmentDisposable
         * @function getDisposable
         * @throws Thrown if the SingleAssignmentDisposable has already been assigned to.
         * @return  {System.IDisposable}
         */
        /**
         * Gets or sets the underlying disposable. After disposal, the result of getting this property is undefined.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.SingleAssignmentDisposable
         * @memberof System.Reactive.Disposables.SingleAssignmentDisposable
         * @function setDisposable
         * @throws Thrown if the SingleAssignmentDisposable has already been assigned to.
         * @param   {System.IDisposable}    value
         * @return  {void}
         */
        setDisposable: function (value) {
            var old = System.Interlocked.compareExchange(System.IDisposable, Bridge.ref(this, "_current"), value, null);
            if (old == null) {
                return;
            }

            if (!Bridge.referenceEquals(old, System.Reactive.Disposables.BooleanDisposable.true)) {
                throw new System.InvalidOperationException(System.Reactive.Strings_Core.DISPOSABLE_ALREADY_ASSIGNED);
            }

            if (value != null) {
                value.System$IDisposable$dispose();
            }
        },
        /**
         * Disposes the underlying disposable.
         *
         * @instance
         * @public
         * @this System.Reactive.Disposables.SingleAssignmentDisposable
         * @memberof System.Reactive.Disposables.SingleAssignmentDisposable
         * @return  {void}
         */
        dispose: function () {
            var old = System.Interlocked.exchange(System.IDisposable, Bridge.ref(this, "_current"), System.Reactive.Disposables.BooleanDisposable.true);
            if (old != null) {
                old.System$IDisposable$dispose();
            }
        }
    });

    /**
     * Represents a group of disposable resources that are disposed together.
     *
     * @abstract
     * @public
     * @class System.Reactive.Disposables.StableCompositeDisposable
     * @implements  System.Reactive.Disposables.ICancelable
     */
    Bridge.define("System.Reactive.Disposables.StableCompositeDisposable", {
        inherits: [System.Reactive.Disposables.ICancelable],
        statics: {
            /**
             * Creates a new group containing two disposable resources that are disposed together.
             *
             * @static
             * @public
             * @this System.Reactive.Disposables.StableCompositeDisposable
             * @memberof System.Reactive.Disposables.StableCompositeDisposable
             * @param   {System.IDisposable}                         disposable1    The first disposable resoruce to add to the group.
             * @param   {System.IDisposable}                         disposable2    The second disposable resoruce to add to the group.
             * @return  {System.Reactive.Disposables.ICancelable}                   Group of disposable resources that are disposed together.
             */
            create$1: function (disposable1, disposable2) {
                if (disposable1 == null) {
                    throw new System.ArgumentNullException("disposable1");
                }
                if (disposable2 == null) {
                    throw new System.ArgumentNullException("disposable2");
                }

                return new System.Reactive.Disposables.StableCompositeDisposable.Binary(disposable1, disposable2);
            },
            /**
             * Creates a new group of disposable resources that are disposed together.
             *
             * @static
             * @public
             * @this System.Reactive.Disposables.StableCompositeDisposable
             * @memberof System.Reactive.Disposables.StableCompositeDisposable
             * @param   {Array.<System.IDisposable>}                 disposables    Disposable resources to add to the group.
             * @return  {System.Reactive.Disposables.ICancelable}                   Group of disposable resources that are disposed together.
             */
            create$2: function (disposables) {
                if (disposables === void 0) { disposables = []; }
                if (disposables == null) {
                    throw new System.ArgumentNullException("disposables");
                }

                return new System.Reactive.Disposables.StableCompositeDisposable.NAry.$ctor1(disposables);
            },
            /**
             * Creates a new group of disposable resources that are disposed together.
             *
             * @static
             * @public
             * @this System.Reactive.Disposables.StableCompositeDisposable
             * @memberof System.Reactive.Disposables.StableCompositeDisposable
             * @param   {System.Collections.Generic.IEnumerable$1}    disposables    Disposable resources to add to the group.
             * @return  {System.Reactive.Disposables.ICancelable}                    Group of disposable resources that are disposed together.
             */
            create: function (disposables) {
                if (disposables == null) {
                    throw new System.ArgumentNullException("disposables");
                }

                return new System.Reactive.Disposables.StableCompositeDisposable.NAry.ctor(disposables);
            }
        }
    });

    Bridge.define("System.Reactive.DisposedObserver$1", function (T) { return {
        inherits: [System.IObserver$1(T)],
        statics: {
            instance: null,
            config: {
                init: function () {
                    this.instance = new (System.Reactive.DisposedObserver$1(T))();
                }
            }
        },
        config: {
            alias: [
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"
            ]
        },
        onCompleted: function () {
            throw new System.ObjectDisposedException("");
        },
        onError: function (error) {
            throw new System.ObjectDisposedException("");
        },
        onNext: function (value) {
            throw new System.ObjectDisposedException("");
        }
    }; });

    Bridge.define("System.Reactive.DoneObserver$1", function (T) { return {
        inherits: [System.IObserver$1(T)],
        statics: {
            completed: null,
            config: {
                init: function () {
                    this.completed = new (System.Reactive.DoneObserver$1(T))();
                }
            }
        },
        config: {
            properties: {
                Exception: null
            },
            alias: [
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"
            ]
        },
        onCompleted: function () {
        },
        onError: function (error) {
        },
        onNext: function (value) {
        }
    }; });

    Bridge.define("System.Reactive.Either$2.Left", function (TLeft, TRight) { return {
        inherits: function () { return [System.Reactive.Either$2(TLeft,TRight),System.IEquatable$1(System.Reactive.Either$2.Left(TLeft,TRight))]; },
        config: {
            properties: {
                Value: Bridge.getDefaultValue(TLeft)
            },
            alias: [
            "equalsT", "System$IEquatable$1$System$Reactive$Either$2$Left$" + Bridge.getTypeAlias(TLeft) + "$" + Bridge.getTypeAlias(TRight) + "$equalsT"
            ]
        },
        ctor: function (value) {
            this.$initialize();
            System.Reactive.Either$2(TLeft,TRight).ctor.call(this);
            this.setValue(value);
        },
        switch: function (TResult, caseLeft, caseRight) {
            return caseLeft(this.getValue());
        },
        switch$1: function (caseLeft, caseRight) {
            caseLeft(this.getValue());
        },
        equalsT: function (other) {
            if (Bridge.referenceEquals(other, this)) {
                return true;
            }
            if (other == null) {
                return false;
            }
            return System.Collections.Generic.EqualityComparer$1(TLeft).def.equals2(this.getValue(), other.getValue());
        },
        equals: function (obj) {
            return this.equalsT(Bridge.as(obj, System.Reactive.Either$2.Left(TLeft,TRight)));
        },
        getHashCode: function () {
            return System.Collections.Generic.EqualityComparer$1(TLeft).def.getHashCode2(this.getValue());
        },
        toString: function () {
            return System.String.formatProvider(System.Globalization.CultureInfo.getCurrentCulture(), "Left({0})", this.getValue());
        }
    }; });

    Bridge.define("System.Reactive.Either$2.Right", function (TLeft, TRight) { return {
        inherits: function () { return [System.Reactive.Either$2(TLeft,TRight),System.IEquatable$1(System.Reactive.Either$2.Right(TLeft,TRight))]; },
        config: {
            properties: {
                Value: Bridge.getDefaultValue(TRight)
            },
            alias: [
            "equalsT", "System$IEquatable$1$System$Reactive$Either$2$Right$" + Bridge.getTypeAlias(TLeft) + "$" + Bridge.getTypeAlias(TRight) + "$equalsT"
            ]
        },
        ctor: function (value) {
            this.$initialize();
            System.Reactive.Either$2(TLeft,TRight).ctor.call(this);
            this.setValue(value);
        },
        switch: function (TResult, caseLeft, caseRight) {
            return caseRight(this.getValue());
        },
        switch$1: function (caseLeft, caseRight) {
            caseRight(this.getValue());
        },
        equalsT: function (other) {
            if (Bridge.referenceEquals(other, this)) {
                return true;
            }
            if (other == null) {
                return false;
            }
            return System.Collections.Generic.EqualityComparer$1(TRight).def.equals2(this.getValue(), other.getValue());
        },
        equals: function (obj) {
            return this.equalsT(Bridge.as(obj, System.Reactive.Either$2.Right(TLeft,TRight)));
        },
        getHashCode: function () {
            return System.Collections.Generic.EqualityComparer$1(TRight).def.getHashCode2(this.getValue());
        },
        toString: function () {
            return System.String.formatProvider(System.Globalization.CultureInfo.getCurrentCulture(), "Right({0})", this.getValue());
        }
    }; });

    /**
     * Represents a .NET event invocation consisting of the strongly typed object that raised the event and the data that was generated by the event.
     *
     * @public
     * @class System.Reactive.EventPattern$2
     * @implements  System.IEquatable$1
     * @implements  System.Reactive.IEventPattern$2
     * @param   {Function}    [name]    The type of the sender that raised the event.
     * @param   {Function}    [name]    The type of the event data generated by the event.
     */
    Bridge.define("System.Reactive.EventPattern$2", function (TSender, TEventArgs) { return {
        inherits: function () { return [System.IEquatable$1(System.Reactive.EventPattern$2(TSender,TEventArgs)),System.Reactive.IEventPattern$2(TSender,TEventArgs)]; },
        statics: {
            /**
             * Determines whether two specified EventPattern&lt;TSender, TEventArgs&gt; objects represent the same event.
             *
             * @static
             * @public
             * @this System.Reactive.EventPattern$2
             * @memberof System.Reactive.EventPattern$2
             * @param   {System.Reactive.EventPattern$2}    first     The first EventPattern&lt;TSender, TEventArgs&gt; to compare, or null.
             * @param   {System.Reactive.EventPattern$2}    second    The second EventPattern&lt;TSender, TEventArgs&gt; to compare, or null.
             * @return  {boolean}                                     true if both EventPattern&lt;TSender, TEventArgs&gt; objects represent the same event; otherwise, false.
             */
            op_Equality: function (first, second) {
                return Bridge.equals(first, second);
            }/**
             * Determines whether two specified EventPattern&lt;TSender, TEventArgs&gt; objects represent a different event.
             *
             * @static
             * @public
             * @this System.Reactive.EventPattern$2
             * @memberof System.Reactive.EventPattern$2
             * @param   {System.Reactive.EventPattern$2}    first     The first EventPattern&lt;TSender, TEventArgs&gt; to compare, or null.
             * @param   {System.Reactive.EventPattern$2}    second    The second EventPattern&lt;TSender, TEventArgs&gt; to compare, or null.
             * @return  {boolean}                                     true if both EventPattern&lt;TSender, TEventArgs&gt; objects don't represent the same event; otherwise, false.
             */
            ,
            op_Inequality: function (first, second) {
                return !Bridge.equals(first, second);
            }
        },
        config: {
            properties: {
                /**
                 * Gets the sender object that raised the event.
                 *
                 * @instance
                 * @public
                 * @this System.Reactive.EventPattern$2
                 * @memberof System.Reactive.EventPattern$2
                 * @function getSender
                 * @return  {TSender}
                 */
                /**
                 * Gets the sender object that raised the event.
                 *
                 * @instance
                 * @private
                 * @this System.Reactive.EventPattern$2
                 * @memberof System.Reactive.EventPattern$2
                 * @function setSender
                 * @param   {TSender}    value
                 * @return  {void}
                 */
                Sender: Bridge.getDefaultValue(TSender),
                /**
                 * Gets the event data that was generated by the event.
                 *
                 * @instance
                 * @public
                 * @this System.Reactive.EventPattern$2
                 * @memberof System.Reactive.EventPattern$2
                 * @function getEventArgs
                 * @return  {TEventArgs}
                 */
                /**
                 * Gets the event data that was generated by the event.
                 *
                 * @instance
                 * @private
                 * @this System.Reactive.EventPattern$2
                 * @memberof System.Reactive.EventPattern$2
                 * @function setEventArgs
                 * @param   {TEventArgs}    value
                 * @return  {void}
                 */
                EventArgs: Bridge.getDefaultValue(TEventArgs)
            },
            alias: [
            "getSender", "System$Reactive$IEventPattern$2$" + Bridge.getTypeAlias(TSender) + "$" + Bridge.getTypeAlias(TEventArgs) + "$getSender",
            "setSender", "System$Reactive$IEventPattern$2$" + Bridge.getTypeAlias(TSender) + "$" + Bridge.getTypeAlias(TEventArgs) + "$setSender",
            "getEventArgs", "System$Reactive$IEventPattern$2$" + Bridge.getTypeAlias(TSender) + "$" + Bridge.getTypeAlias(TEventArgs) + "$getEventArgs",
            "setEventArgs", "System$Reactive$IEventPattern$2$" + Bridge.getTypeAlias(TSender) + "$" + Bridge.getTypeAlias(TEventArgs) + "$setEventArgs",
            "equalsT", "System$IEquatable$1$System$Reactive$EventPattern$2$" + Bridge.getTypeAlias(TSender) + "$" + Bridge.getTypeAlias(TEventArgs) + "$equalsT"
            ]
        },
        /**
         * Creates a new data representation instance of a .NET event invocation with the given sender and event data.
         *
         * @instance
         * @public
         * @this System.Reactive.EventPattern$2
         * @memberof System.Reactive.EventPattern$2
         * @param   {TSender}       sender    The sender object that raised the event.
         * @param   {TEventArgs}    e         The event data that was generated by the event.
         * @return  {void}
         */
        ctor: function (sender, e) {
            this.$initialize();
            this.setSender(sender);
            this.setEventArgs(e);
        },
        /**
         * Determines whether the current EventPattern&lt;TSender, TEventArgs&gt; object represents the same event as a specified EventPattern&lt;TSender, TEventArgs&gt; object.
         *
         * @instance
         * @public
         * @this System.Reactive.EventPattern$2
         * @memberof System.Reactive.EventPattern$2
         * @param   {System.Reactive.EventPattern$2}    other    An object to compare to the current EventPattern&lt;TSender, TEventArgs&gt; object.
         * @return  {boolean}                                    true if both EventPattern&lt;TSender, TEventArgs&gt; objects represent the same event; otherwise, false.
         */
        equalsT: function (other) {
            if (Bridge.referenceEquals(null, other)) {
                return false;
            }
            if (Bridge.referenceEquals(this, other)) {
                return true;
            }

            return System.Collections.Generic.EqualityComparer$1(TSender).def.equals2(this.getSender(), other.getSender()) && System.Collections.Generic.EqualityComparer$1(TEventArgs).def.equals2(this.getEventArgs(), other.getEventArgs());
        },
        /**
         * Determines whether the specified System.Object is equal to the current EventPattern&lt;TSender, TEventArgs&gt;.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.EventPattern$2
         * @memberof System.Reactive.EventPattern$2
         * @param   {Object}     obj    The System.Object to compare with the current EventPattern&lt;TSender, TEventArgs&gt;.
         * @return  {boolean}           true if the specified System.Object is equal to the current EventPattern&lt;TSender, TEventArgs&gt;; otherwise, false.
         */
        equals: function (obj) {
            return this.equalsT(Bridge.as(obj, System.Reactive.EventPattern$2(TSender,TEventArgs)));
        },
        /**
         * Returns the hash code for the current EventPattern&lt;TSender, TEventArgs&gt; instance.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.EventPattern$2
         * @memberof System.Reactive.EventPattern$2
         * @return  {number}        A hash code for the current EventPattern&lt;TSender, TEventArgs&gt; instance.
         */
        getHashCode: function () {
            var x = System.Collections.Generic.EqualityComparer$1(TSender).def.getHashCode2(this.getSender());
            var y = System.Collections.Generic.EqualityComparer$1(TEventArgs).def.getHashCode2(this.getEventArgs());
            return (((x << 5) + (x ^ y)) | 0);
        }
    }; });

    Bridge.define("System.Reactive.EventSource$1", function (T) { return {
        inherits: [System.Reactive.IEventSource$1(T)],
        _source: null,
        _subscriptions: null,
        _invokeHandler: null,
        config: {
            alias: [
            "addOnNext", "System$Reactive$IEventSource$1$" + Bridge.getTypeAlias(T) + "$addOnNext",
            "removeOnNext", "System$Reactive$IEventSource$1$" + Bridge.getTypeAlias(T) + "$removeOnNext"
            ]
        },
        ctor: function (source, invokeHandler) {
            this.$initialize();
            this._source = source;
            this._invokeHandler = invokeHandler;
            this._subscriptions = new (System.Collections.Generic.Dictionary$2(Function,System.Collections.Generic.Stack$1(System.IDisposable)))();
        },
        addOnNext: function (value) {
            var gate = {  };
            var isAdded = false;
            var isDone = false;

            var remove = Bridge.fn.bind(this, function () {
                gate;
                {
                    if (isAdded) {
                        this.remove(value);
                    } else {
                        isDone = true;
                    }
                }
            });

            //
            // [OK] Use of unsafe Subscribe: non-pretentious wrapper of an observable in an event; exceptions can occur during +=.
            //
            var d = System.ObservableExtensions.subscribe$4(T, this._source, Bridge.fn.bind(this, function (x) {
                this._invokeHandler(value, x);
            }), function (ex) {
                remove();
                System.Reactive.ExceptionHelpers.throw(ex);
            }, function () {
                remove();
            });

            gate;
            {
                if (!isDone) {
                    this.add(value, d);
                    isAdded = true;
                }
            }
        },
        removeOnNext: function (value) {
            this.remove(value);
        },
        add: function (handler, disposable) {
            this._subscriptions;
            {
                var l = { v : new (System.Collections.Generic.Stack$1(System.IDisposable)).ctor() };
                if (!this._subscriptions.tryGetValue(handler, l)) {
                    this._subscriptions.set(handler, (l.v = new (System.Collections.Generic.Stack$1(System.IDisposable)).ctor()));
                }

                l.v.push(disposable);
            }
        },
        remove: function (handler) {
            var d = null;

            this._subscriptions;
            {
                var l = { v : new (System.Collections.Generic.Stack$1(System.IDisposable)).ctor() };
                if (this._subscriptions.tryGetValue(handler, l)) {
                    d = l.v.pop();
                    if (l.v.getCount() === 0) {
                        this._subscriptions.remove(handler);
                    }
                }
            }

            if (d != null) {
                d.System$IDisposable$dispose();
            }
        }
    }; });

    Bridge.definei("System.Reactive.IScheduledObserver$1", function (T) { return {
        inherits: [System.IObserver$1(T),System.IDisposable],
        $kind: "interface"
    }; });

    Bridge.define("System.Reactive.Joins.ActivePlan$1", function (T1) { return {
        inherits: [System.Reactive.Joins.ActivePlan],
        onNext: null,
        onCompleted: null,
        first: null,
        ctor: function (first, onNext, onCompleted) {
            this.$initialize();
            System.Reactive.Joins.ActivePlan.ctor.call(this);
            this.onNext = onNext;
            this.onCompleted = onCompleted;
            this.first = first;
            this.addJoinObserver(first);
        },
        match: function () {
            if (this.first.getQueue().getCount() > 0) {
                var n1 = this.first.getQueue().peek();

                if (n1.getKind() === System.Reactive.NotificationKind.OnCompleted) {
                    this.onCompleted();
                } else {
                    this.dequeue();
                    this.onNext(n1.getValue());
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Joins.ActivePlan$10", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) { return {
        inherits: [System.Reactive.Joins.ActivePlan],
        onNext: null,
        onCompleted: null,
        first: null,
        second: null,
        third: null,
        fourth: null,
        fifth: null,
        sixth: null,
        seventh: null,
        eighth: null,
        ninth: null,
        tenth: null,
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, onNext, onCompleted) {
            this.$initialize();
            System.Reactive.Joins.ActivePlan.ctor.call(this);
            this.onNext = onNext;
            this.onCompleted = onCompleted;
            this.first = first;
            this.second = second;
            this.third = third;
            this.fourth = fourth;
            this.fifth = fifth;
            this.sixth = sixth;
            this.seventh = seventh;
            this.eighth = eighth;
            this.ninth = ninth;
            this.tenth = tenth;
            this.addJoinObserver(first);
            this.addJoinObserver(second);
            this.addJoinObserver(third);
            this.addJoinObserver(fourth);
            this.addJoinObserver(fifth);
            this.addJoinObserver(sixth);
            this.addJoinObserver(seventh);
            this.addJoinObserver(eighth);
            this.addJoinObserver(ninth);
            this.addJoinObserver(tenth);
        },
        match: function () {
            if (this.first.getQueue().getCount() > 0 && this.second.getQueue().getCount() > 0 && this.third.getQueue().getCount() > 0 && this.fourth.getQueue().getCount() > 0 && this.fifth.getQueue().getCount() > 0 && this.sixth.getQueue().getCount() > 0 && this.seventh.getQueue().getCount() > 0 && this.eighth.getQueue().getCount() > 0 && this.ninth.getQueue().getCount() > 0 && this.tenth.getQueue().getCount() > 0) {
                var n1 = this.first.getQueue().peek();
                var n2 = this.second.getQueue().peek();
                var n3 = this.third.getQueue().peek();
                var n4 = this.fourth.getQueue().peek();
                var n5 = this.fifth.getQueue().peek();
                var n6 = this.sixth.getQueue().peek();
                var n7 = this.seventh.getQueue().peek();
                var n8 = this.eighth.getQueue().peek();
                var n9 = this.ninth.getQueue().peek();
                var n10 = this.tenth.getQueue().peek();

                if (n1.getKind() === System.Reactive.NotificationKind.OnCompleted || n2.getKind() === System.Reactive.NotificationKind.OnCompleted || n3.getKind() === System.Reactive.NotificationKind.OnCompleted || n4.getKind() === System.Reactive.NotificationKind.OnCompleted || n5.getKind() === System.Reactive.NotificationKind.OnCompleted || n6.getKind() === System.Reactive.NotificationKind.OnCompleted || n7.getKind() === System.Reactive.NotificationKind.OnCompleted || n8.getKind() === System.Reactive.NotificationKind.OnCompleted || n9.getKind() === System.Reactive.NotificationKind.OnCompleted || n10.getKind() === System.Reactive.NotificationKind.OnCompleted) {
                    this.onCompleted();
                } else {
                    this.dequeue();
                    this.onNext(n1.getValue(), n2.getValue(), n3.getValue(), n4.getValue(), n5.getValue(), n6.getValue(), n7.getValue(), n8.getValue(), n9.getValue(), n10.getValue());
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Joins.ActivePlan$11", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) { return {
        inherits: [System.Reactive.Joins.ActivePlan],
        onNext: null,
        onCompleted: null,
        first: null,
        second: null,
        third: null,
        fourth: null,
        fifth: null,
        sixth: null,
        seventh: null,
        eighth: null,
        ninth: null,
        tenth: null,
        eleventh: null,
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, onNext, onCompleted) {
            this.$initialize();
            System.Reactive.Joins.ActivePlan.ctor.call(this);
            this.onNext = onNext;
            this.onCompleted = onCompleted;
            this.first = first;
            this.second = second;
            this.third = third;
            this.fourth = fourth;
            this.fifth = fifth;
            this.sixth = sixth;
            this.seventh = seventh;
            this.eighth = eighth;
            this.ninth = ninth;
            this.tenth = tenth;
            this.eleventh = eleventh;
            this.addJoinObserver(first);
            this.addJoinObserver(second);
            this.addJoinObserver(third);
            this.addJoinObserver(fourth);
            this.addJoinObserver(fifth);
            this.addJoinObserver(sixth);
            this.addJoinObserver(seventh);
            this.addJoinObserver(eighth);
            this.addJoinObserver(ninth);
            this.addJoinObserver(tenth);
            this.addJoinObserver(eleventh);
        },
        match: function () {
            if (this.first.getQueue().getCount() > 0 && this.second.getQueue().getCount() > 0 && this.third.getQueue().getCount() > 0 && this.fourth.getQueue().getCount() > 0 && this.fifth.getQueue().getCount() > 0 && this.sixth.getQueue().getCount() > 0 && this.seventh.getQueue().getCount() > 0 && this.eighth.getQueue().getCount() > 0 && this.ninth.getQueue().getCount() > 0 && this.tenth.getQueue().getCount() > 0 && this.eleventh.getQueue().getCount() > 0) {
                var n1 = this.first.getQueue().peek();
                var n2 = this.second.getQueue().peek();
                var n3 = this.third.getQueue().peek();
                var n4 = this.fourth.getQueue().peek();
                var n5 = this.fifth.getQueue().peek();
                var n6 = this.sixth.getQueue().peek();
                var n7 = this.seventh.getQueue().peek();
                var n8 = this.eighth.getQueue().peek();
                var n9 = this.ninth.getQueue().peek();
                var n10 = this.tenth.getQueue().peek();
                var n11 = this.eleventh.getQueue().peek();

                if (n1.getKind() === System.Reactive.NotificationKind.OnCompleted || n2.getKind() === System.Reactive.NotificationKind.OnCompleted || n3.getKind() === System.Reactive.NotificationKind.OnCompleted || n4.getKind() === System.Reactive.NotificationKind.OnCompleted || n5.getKind() === System.Reactive.NotificationKind.OnCompleted || n6.getKind() === System.Reactive.NotificationKind.OnCompleted || n7.getKind() === System.Reactive.NotificationKind.OnCompleted || n8.getKind() === System.Reactive.NotificationKind.OnCompleted || n9.getKind() === System.Reactive.NotificationKind.OnCompleted || n10.getKind() === System.Reactive.NotificationKind.OnCompleted || n11.getKind() === System.Reactive.NotificationKind.OnCompleted) {
                    this.onCompleted();
                } else {
                    this.dequeue();
                    this.onNext(n1.getValue(), n2.getValue(), n3.getValue(), n4.getValue(), n5.getValue(), n6.getValue(), n7.getValue(), n8.getValue(), n9.getValue(), n10.getValue(), n11.getValue());
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Joins.ActivePlan$12", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) { return {
        inherits: [System.Reactive.Joins.ActivePlan],
        onNext: null,
        onCompleted: null,
        first: null,
        second: null,
        third: null,
        fourth: null,
        fifth: null,
        sixth: null,
        seventh: null,
        eighth: null,
        ninth: null,
        tenth: null,
        eleventh: null,
        twelfth: null,
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, onNext, onCompleted) {
            this.$initialize();
            System.Reactive.Joins.ActivePlan.ctor.call(this);
            this.onNext = onNext;
            this.onCompleted = onCompleted;
            this.first = first;
            this.second = second;
            this.third = third;
            this.fourth = fourth;
            this.fifth = fifth;
            this.sixth = sixth;
            this.seventh = seventh;
            this.eighth = eighth;
            this.ninth = ninth;
            this.tenth = tenth;
            this.eleventh = eleventh;
            this.twelfth = twelfth;
            this.addJoinObserver(first);
            this.addJoinObserver(second);
            this.addJoinObserver(third);
            this.addJoinObserver(fourth);
            this.addJoinObserver(fifth);
            this.addJoinObserver(sixth);
            this.addJoinObserver(seventh);
            this.addJoinObserver(eighth);
            this.addJoinObserver(ninth);
            this.addJoinObserver(tenth);
            this.addJoinObserver(eleventh);
            this.addJoinObserver(twelfth);
        },
        match: function () {
            if (this.first.getQueue().getCount() > 0 && this.second.getQueue().getCount() > 0 && this.third.getQueue().getCount() > 0 && this.fourth.getQueue().getCount() > 0 && this.fifth.getQueue().getCount() > 0 && this.sixth.getQueue().getCount() > 0 && this.seventh.getQueue().getCount() > 0 && this.eighth.getQueue().getCount() > 0 && this.ninth.getQueue().getCount() > 0 && this.tenth.getQueue().getCount() > 0 && this.eleventh.getQueue().getCount() > 0 && this.twelfth.getQueue().getCount() > 0) {
                var n1 = this.first.getQueue().peek();
                var n2 = this.second.getQueue().peek();
                var n3 = this.third.getQueue().peek();
                var n4 = this.fourth.getQueue().peek();
                var n5 = this.fifth.getQueue().peek();
                var n6 = this.sixth.getQueue().peek();
                var n7 = this.seventh.getQueue().peek();
                var n8 = this.eighth.getQueue().peek();
                var n9 = this.ninth.getQueue().peek();
                var n10 = this.tenth.getQueue().peek();
                var n11 = this.eleventh.getQueue().peek();
                var n12 = this.twelfth.getQueue().peek();

                if (n1.getKind() === System.Reactive.NotificationKind.OnCompleted || n2.getKind() === System.Reactive.NotificationKind.OnCompleted || n3.getKind() === System.Reactive.NotificationKind.OnCompleted || n4.getKind() === System.Reactive.NotificationKind.OnCompleted || n5.getKind() === System.Reactive.NotificationKind.OnCompleted || n6.getKind() === System.Reactive.NotificationKind.OnCompleted || n7.getKind() === System.Reactive.NotificationKind.OnCompleted || n8.getKind() === System.Reactive.NotificationKind.OnCompleted || n9.getKind() === System.Reactive.NotificationKind.OnCompleted || n10.getKind() === System.Reactive.NotificationKind.OnCompleted || n11.getKind() === System.Reactive.NotificationKind.OnCompleted || n12.getKind() === System.Reactive.NotificationKind.OnCompleted) {
                    this.onCompleted();
                } else {
                    this.dequeue();
                    this.onNext(n1.getValue(), n2.getValue(), n3.getValue(), n4.getValue(), n5.getValue(), n6.getValue(), n7.getValue(), n8.getValue(), n9.getValue(), n10.getValue(), n11.getValue(), n12.getValue());
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Joins.ActivePlan$13", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) { return {
        inherits: [System.Reactive.Joins.ActivePlan],
        onNext: null,
        onCompleted: null,
        first: null,
        second: null,
        third: null,
        fourth: null,
        fifth: null,
        sixth: null,
        seventh: null,
        eighth: null,
        ninth: null,
        tenth: null,
        eleventh: null,
        twelfth: null,
        thirteenth: null,
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, onNext, onCompleted) {
            this.$initialize();
            System.Reactive.Joins.ActivePlan.ctor.call(this);
            this.onNext = onNext;
            this.onCompleted = onCompleted;
            this.first = first;
            this.second = second;
            this.third = third;
            this.fourth = fourth;
            this.fifth = fifth;
            this.sixth = sixth;
            this.seventh = seventh;
            this.eighth = eighth;
            this.ninth = ninth;
            this.tenth = tenth;
            this.eleventh = eleventh;
            this.twelfth = twelfth;
            this.thirteenth = thirteenth;
            this.addJoinObserver(first);
            this.addJoinObserver(second);
            this.addJoinObserver(third);
            this.addJoinObserver(fourth);
            this.addJoinObserver(fifth);
            this.addJoinObserver(sixth);
            this.addJoinObserver(seventh);
            this.addJoinObserver(eighth);
            this.addJoinObserver(ninth);
            this.addJoinObserver(tenth);
            this.addJoinObserver(eleventh);
            this.addJoinObserver(twelfth);
            this.addJoinObserver(thirteenth);
        },
        match: function () {
            if (this.first.getQueue().getCount() > 0 && this.second.getQueue().getCount() > 0 && this.third.getQueue().getCount() > 0 && this.fourth.getQueue().getCount() > 0 && this.fifth.getQueue().getCount() > 0 && this.sixth.getQueue().getCount() > 0 && this.seventh.getQueue().getCount() > 0 && this.eighth.getQueue().getCount() > 0 && this.ninth.getQueue().getCount() > 0 && this.tenth.getQueue().getCount() > 0 && this.eleventh.getQueue().getCount() > 0 && this.twelfth.getQueue().getCount() > 0 && this.thirteenth.getQueue().getCount() > 0) {
                var n1 = this.first.getQueue().peek();
                var n2 = this.second.getQueue().peek();
                var n3 = this.third.getQueue().peek();
                var n4 = this.fourth.getQueue().peek();
                var n5 = this.fifth.getQueue().peek();
                var n6 = this.sixth.getQueue().peek();
                var n7 = this.seventh.getQueue().peek();
                var n8 = this.eighth.getQueue().peek();
                var n9 = this.ninth.getQueue().peek();
                var n10 = this.tenth.getQueue().peek();
                var n11 = this.eleventh.getQueue().peek();
                var n12 = this.twelfth.getQueue().peek();
                var n13 = this.thirteenth.getQueue().peek();

                if (n1.getKind() === System.Reactive.NotificationKind.OnCompleted || n2.getKind() === System.Reactive.NotificationKind.OnCompleted || n3.getKind() === System.Reactive.NotificationKind.OnCompleted || n4.getKind() === System.Reactive.NotificationKind.OnCompleted || n5.getKind() === System.Reactive.NotificationKind.OnCompleted || n6.getKind() === System.Reactive.NotificationKind.OnCompleted || n7.getKind() === System.Reactive.NotificationKind.OnCompleted || n8.getKind() === System.Reactive.NotificationKind.OnCompleted || n9.getKind() === System.Reactive.NotificationKind.OnCompleted || n10.getKind() === System.Reactive.NotificationKind.OnCompleted || n11.getKind() === System.Reactive.NotificationKind.OnCompleted || n12.getKind() === System.Reactive.NotificationKind.OnCompleted || n13.getKind() === System.Reactive.NotificationKind.OnCompleted) {
                    this.onCompleted();
                } else {
                    this.dequeue();
                    this.onNext(n1.getValue(), n2.getValue(), n3.getValue(), n4.getValue(), n5.getValue(), n6.getValue(), n7.getValue(), n8.getValue(), n9.getValue(), n10.getValue(), n11.getValue(), n12.getValue(), n13.getValue());
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Joins.ActivePlan$14", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) { return {
        inherits: [System.Reactive.Joins.ActivePlan],
        onNext: null,
        onCompleted: null,
        first: null,
        second: null,
        third: null,
        fourth: null,
        fifth: null,
        sixth: null,
        seventh: null,
        eighth: null,
        ninth: null,
        tenth: null,
        eleventh: null,
        twelfth: null,
        thirteenth: null,
        fourteenth: null,
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, onNext, onCompleted) {
            this.$initialize();
            System.Reactive.Joins.ActivePlan.ctor.call(this);
            this.onNext = onNext;
            this.onCompleted = onCompleted;
            this.first = first;
            this.second = second;
            this.third = third;
            this.fourth = fourth;
            this.fifth = fifth;
            this.sixth = sixth;
            this.seventh = seventh;
            this.eighth = eighth;
            this.ninth = ninth;
            this.tenth = tenth;
            this.eleventh = eleventh;
            this.twelfth = twelfth;
            this.thirteenth = thirteenth;
            this.fourteenth = fourteenth;
            this.addJoinObserver(first);
            this.addJoinObserver(second);
            this.addJoinObserver(third);
            this.addJoinObserver(fourth);
            this.addJoinObserver(fifth);
            this.addJoinObserver(sixth);
            this.addJoinObserver(seventh);
            this.addJoinObserver(eighth);
            this.addJoinObserver(ninth);
            this.addJoinObserver(tenth);
            this.addJoinObserver(eleventh);
            this.addJoinObserver(twelfth);
            this.addJoinObserver(thirteenth);
            this.addJoinObserver(fourteenth);
        },
        match: function () {
            if (this.first.getQueue().getCount() > 0 && this.second.getQueue().getCount() > 0 && this.third.getQueue().getCount() > 0 && this.fourth.getQueue().getCount() > 0 && this.fifth.getQueue().getCount() > 0 && this.sixth.getQueue().getCount() > 0 && this.seventh.getQueue().getCount() > 0 && this.eighth.getQueue().getCount() > 0 && this.ninth.getQueue().getCount() > 0 && this.tenth.getQueue().getCount() > 0 && this.eleventh.getQueue().getCount() > 0 && this.twelfth.getQueue().getCount() > 0 && this.thirteenth.getQueue().getCount() > 0 && this.fourteenth.getQueue().getCount() > 0) {
                var n1 = this.first.getQueue().peek();
                var n2 = this.second.getQueue().peek();
                var n3 = this.third.getQueue().peek();
                var n4 = this.fourth.getQueue().peek();
                var n5 = this.fifth.getQueue().peek();
                var n6 = this.sixth.getQueue().peek();
                var n7 = this.seventh.getQueue().peek();
                var n8 = this.eighth.getQueue().peek();
                var n9 = this.ninth.getQueue().peek();
                var n10 = this.tenth.getQueue().peek();
                var n11 = this.eleventh.getQueue().peek();
                var n12 = this.twelfth.getQueue().peek();
                var n13 = this.thirteenth.getQueue().peek();
                var n14 = this.fourteenth.getQueue().peek();

                if (n1.getKind() === System.Reactive.NotificationKind.OnCompleted || n2.getKind() === System.Reactive.NotificationKind.OnCompleted || n3.getKind() === System.Reactive.NotificationKind.OnCompleted || n4.getKind() === System.Reactive.NotificationKind.OnCompleted || n5.getKind() === System.Reactive.NotificationKind.OnCompleted || n6.getKind() === System.Reactive.NotificationKind.OnCompleted || n7.getKind() === System.Reactive.NotificationKind.OnCompleted || n8.getKind() === System.Reactive.NotificationKind.OnCompleted || n9.getKind() === System.Reactive.NotificationKind.OnCompleted || n10.getKind() === System.Reactive.NotificationKind.OnCompleted || n11.getKind() === System.Reactive.NotificationKind.OnCompleted || n12.getKind() === System.Reactive.NotificationKind.OnCompleted || n13.getKind() === System.Reactive.NotificationKind.OnCompleted || n14.getKind() === System.Reactive.NotificationKind.OnCompleted) {
                    this.onCompleted();
                } else {
                    this.dequeue();
                    this.onNext(n1.getValue(), n2.getValue(), n3.getValue(), n4.getValue(), n5.getValue(), n6.getValue(), n7.getValue(), n8.getValue(), n9.getValue(), n10.getValue(), n11.getValue(), n12.getValue(), n13.getValue(), n14.getValue());
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Joins.ActivePlan$15", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) { return {
        inherits: [System.Reactive.Joins.ActivePlan],
        onNext: null,
        onCompleted: null,
        first: null,
        second: null,
        third: null,
        fourth: null,
        fifth: null,
        sixth: null,
        seventh: null,
        eighth: null,
        ninth: null,
        tenth: null,
        eleventh: null,
        twelfth: null,
        thirteenth: null,
        fourteenth: null,
        fifteenth: null,
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth, onNext, onCompleted) {
            this.$initialize();
            System.Reactive.Joins.ActivePlan.ctor.call(this);
            this.onNext = onNext;
            this.onCompleted = onCompleted;
            this.first = first;
            this.second = second;
            this.third = third;
            this.fourth = fourth;
            this.fifth = fifth;
            this.sixth = sixth;
            this.seventh = seventh;
            this.eighth = eighth;
            this.ninth = ninth;
            this.tenth = tenth;
            this.eleventh = eleventh;
            this.twelfth = twelfth;
            this.thirteenth = thirteenth;
            this.fourteenth = fourteenth;
            this.fifteenth = fifteenth;
            this.addJoinObserver(first);
            this.addJoinObserver(second);
            this.addJoinObserver(third);
            this.addJoinObserver(fourth);
            this.addJoinObserver(fifth);
            this.addJoinObserver(sixth);
            this.addJoinObserver(seventh);
            this.addJoinObserver(eighth);
            this.addJoinObserver(ninth);
            this.addJoinObserver(tenth);
            this.addJoinObserver(eleventh);
            this.addJoinObserver(twelfth);
            this.addJoinObserver(thirteenth);
            this.addJoinObserver(fourteenth);
            this.addJoinObserver(fifteenth);
        },
        match: function () {
            if (this.first.getQueue().getCount() > 0 && this.second.getQueue().getCount() > 0 && this.third.getQueue().getCount() > 0 && this.fourth.getQueue().getCount() > 0 && this.fifth.getQueue().getCount() > 0 && this.sixth.getQueue().getCount() > 0 && this.seventh.getQueue().getCount() > 0 && this.eighth.getQueue().getCount() > 0 && this.ninth.getQueue().getCount() > 0 && this.tenth.getQueue().getCount() > 0 && this.eleventh.getQueue().getCount() > 0 && this.twelfth.getQueue().getCount() > 0 && this.thirteenth.getQueue().getCount() > 0 && this.fourteenth.getQueue().getCount() > 0 && this.fifteenth.getQueue().getCount() > 0) {
                var n1 = this.first.getQueue().peek();
                var n2 = this.second.getQueue().peek();
                var n3 = this.third.getQueue().peek();
                var n4 = this.fourth.getQueue().peek();
                var n5 = this.fifth.getQueue().peek();
                var n6 = this.sixth.getQueue().peek();
                var n7 = this.seventh.getQueue().peek();
                var n8 = this.eighth.getQueue().peek();
                var n9 = this.ninth.getQueue().peek();
                var n10 = this.tenth.getQueue().peek();
                var n11 = this.eleventh.getQueue().peek();
                var n12 = this.twelfth.getQueue().peek();
                var n13 = this.thirteenth.getQueue().peek();
                var n14 = this.fourteenth.getQueue().peek();
                var n15 = this.fifteenth.getQueue().peek();

                if (n1.getKind() === System.Reactive.NotificationKind.OnCompleted || n2.getKind() === System.Reactive.NotificationKind.OnCompleted || n3.getKind() === System.Reactive.NotificationKind.OnCompleted || n4.getKind() === System.Reactive.NotificationKind.OnCompleted || n5.getKind() === System.Reactive.NotificationKind.OnCompleted || n6.getKind() === System.Reactive.NotificationKind.OnCompleted || n7.getKind() === System.Reactive.NotificationKind.OnCompleted || n8.getKind() === System.Reactive.NotificationKind.OnCompleted || n9.getKind() === System.Reactive.NotificationKind.OnCompleted || n10.getKind() === System.Reactive.NotificationKind.OnCompleted || n11.getKind() === System.Reactive.NotificationKind.OnCompleted || n12.getKind() === System.Reactive.NotificationKind.OnCompleted || n13.getKind() === System.Reactive.NotificationKind.OnCompleted || n14.getKind() === System.Reactive.NotificationKind.OnCompleted || n15.getKind() === System.Reactive.NotificationKind.OnCompleted) {
                    this.onCompleted();
                } else {
                    this.dequeue();
                    this.onNext(n1.getValue(), n2.getValue(), n3.getValue(), n4.getValue(), n5.getValue(), n6.getValue(), n7.getValue(), n8.getValue(), n9.getValue(), n10.getValue(), n11.getValue(), n12.getValue(), n13.getValue(), n14.getValue(), n15.getValue());
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Joins.ActivePlan$16", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) { return {
        inherits: [System.Reactive.Joins.ActivePlan],
        onNext: null,
        onCompleted: null,
        first: null,
        second: null,
        third: null,
        fourth: null,
        fifth: null,
        sixth: null,
        seventh: null,
        eighth: null,
        ninth: null,
        tenth: null,
        eleventh: null,
        twelfth: null,
        thirteenth: null,
        fourteenth: null,
        fifteenth: null,
        sixteenth: null,
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth, sixteenth, onNext, onCompleted) {
            this.$initialize();
            System.Reactive.Joins.ActivePlan.ctor.call(this);
            this.onNext = onNext;
            this.onCompleted = onCompleted;
            this.first = first;
            this.second = second;
            this.third = third;
            this.fourth = fourth;
            this.fifth = fifth;
            this.sixth = sixth;
            this.seventh = seventh;
            this.eighth = eighth;
            this.ninth = ninth;
            this.tenth = tenth;
            this.eleventh = eleventh;
            this.twelfth = twelfth;
            this.thirteenth = thirteenth;
            this.fourteenth = fourteenth;
            this.fifteenth = fifteenth;
            this.sixteenth = sixteenth;
            this.addJoinObserver(first);
            this.addJoinObserver(second);
            this.addJoinObserver(third);
            this.addJoinObserver(fourth);
            this.addJoinObserver(fifth);
            this.addJoinObserver(sixth);
            this.addJoinObserver(seventh);
            this.addJoinObserver(eighth);
            this.addJoinObserver(ninth);
            this.addJoinObserver(tenth);
            this.addJoinObserver(eleventh);
            this.addJoinObserver(twelfth);
            this.addJoinObserver(thirteenth);
            this.addJoinObserver(fourteenth);
            this.addJoinObserver(fifteenth);
            this.addJoinObserver(sixteenth);
        },
        match: function () {
            if (this.first.getQueue().getCount() > 0 && this.second.getQueue().getCount() > 0 && this.third.getQueue().getCount() > 0 && this.fourth.getQueue().getCount() > 0 && this.fifth.getQueue().getCount() > 0 && this.sixth.getQueue().getCount() > 0 && this.seventh.getQueue().getCount() > 0 && this.eighth.getQueue().getCount() > 0 && this.ninth.getQueue().getCount() > 0 && this.tenth.getQueue().getCount() > 0 && this.eleventh.getQueue().getCount() > 0 && this.twelfth.getQueue().getCount() > 0 && this.thirteenth.getQueue().getCount() > 0 && this.fourteenth.getQueue().getCount() > 0 && this.fifteenth.getQueue().getCount() > 0 && this.sixteenth.getQueue().getCount() > 0) {
                var n1 = this.first.getQueue().peek();
                var n2 = this.second.getQueue().peek();
                var n3 = this.third.getQueue().peek();
                var n4 = this.fourth.getQueue().peek();
                var n5 = this.fifth.getQueue().peek();
                var n6 = this.sixth.getQueue().peek();
                var n7 = this.seventh.getQueue().peek();
                var n8 = this.eighth.getQueue().peek();
                var n9 = this.ninth.getQueue().peek();
                var n10 = this.tenth.getQueue().peek();
                var n11 = this.eleventh.getQueue().peek();
                var n12 = this.twelfth.getQueue().peek();
                var n13 = this.thirteenth.getQueue().peek();
                var n14 = this.fourteenth.getQueue().peek();
                var n15 = this.fifteenth.getQueue().peek();
                var n16 = this.sixteenth.getQueue().peek();

                if (n1.getKind() === System.Reactive.NotificationKind.OnCompleted || n2.getKind() === System.Reactive.NotificationKind.OnCompleted || n3.getKind() === System.Reactive.NotificationKind.OnCompleted || n4.getKind() === System.Reactive.NotificationKind.OnCompleted || n5.getKind() === System.Reactive.NotificationKind.OnCompleted || n6.getKind() === System.Reactive.NotificationKind.OnCompleted || n7.getKind() === System.Reactive.NotificationKind.OnCompleted || n8.getKind() === System.Reactive.NotificationKind.OnCompleted || n9.getKind() === System.Reactive.NotificationKind.OnCompleted || n10.getKind() === System.Reactive.NotificationKind.OnCompleted || n11.getKind() === System.Reactive.NotificationKind.OnCompleted || n12.getKind() === System.Reactive.NotificationKind.OnCompleted || n13.getKind() === System.Reactive.NotificationKind.OnCompleted || n14.getKind() === System.Reactive.NotificationKind.OnCompleted || n15.getKind() === System.Reactive.NotificationKind.OnCompleted || n16.getKind() === System.Reactive.NotificationKind.OnCompleted) {
                    this.onCompleted();
                } else {
                    this.dequeue();
                    this.onNext(n1.getValue(), n2.getValue(), n3.getValue(), n4.getValue(), n5.getValue(), n6.getValue(), n7.getValue(), n8.getValue(), n9.getValue(), n10.getValue(), n11.getValue(), n12.getValue(), n13.getValue(), n14.getValue(), n15.getValue(), n16.getValue());
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Joins.ActivePlan$2", function (T1, T2) { return {
        inherits: [System.Reactive.Joins.ActivePlan],
        onNext: null,
        onCompleted: null,
        first: null,
        second: null,
        ctor: function (first, second, onNext, onCompleted) {
            this.$initialize();
            System.Reactive.Joins.ActivePlan.ctor.call(this);
            this.onNext = onNext;
            this.onCompleted = onCompleted;
            this.first = first;
            this.second = second;
            this.addJoinObserver(first);
            this.addJoinObserver(second);
        },
        match: function () {
            if (this.first.getQueue().getCount() > 0 && this.second.getQueue().getCount() > 0) {
                var n1 = this.first.getQueue().peek();
                var n2 = this.second.getQueue().peek();

                if (n1.getKind() === System.Reactive.NotificationKind.OnCompleted || n2.getKind() === System.Reactive.NotificationKind.OnCompleted) {
                    this.onCompleted();
                } else {
                    this.dequeue();
                    this.onNext(n1.getValue(), n2.getValue());
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Joins.ActivePlan$3", function (T1, T2, T3) { return {
        inherits: [System.Reactive.Joins.ActivePlan],
        onNext: null,
        onCompleted: null,
        first: null,
        second: null,
        third: null,
        ctor: function (first, second, third, onNext, onCompleted) {
            this.$initialize();
            System.Reactive.Joins.ActivePlan.ctor.call(this);
            this.onNext = onNext;
            this.onCompleted = onCompleted;
            this.first = first;
            this.second = second;
            this.third = third;
            this.addJoinObserver(first);
            this.addJoinObserver(second);
            this.addJoinObserver(third);
        },
        match: function () {
            if (this.first.getQueue().getCount() > 0 && this.second.getQueue().getCount() > 0 && this.third.getQueue().getCount() > 0) {
                var n1 = this.first.getQueue().peek();
                var n2 = this.second.getQueue().peek();
                var n3 = this.third.getQueue().peek();

                if (n1.getKind() === System.Reactive.NotificationKind.OnCompleted || n2.getKind() === System.Reactive.NotificationKind.OnCompleted || n3.getKind() === System.Reactive.NotificationKind.OnCompleted) {
                    this.onCompleted();
                } else {
                    this.dequeue();
                    this.onNext(n1.getValue(), n2.getValue(), n3.getValue());
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Joins.ActivePlan$4", function (T1, T2, T3, T4) { return {
        inherits: [System.Reactive.Joins.ActivePlan],
        onNext: null,
        onCompleted: null,
        first: null,
        second: null,
        third: null,
        fourth: null,
        ctor: function (first, second, third, fourth, onNext, onCompleted) {
            this.$initialize();
            System.Reactive.Joins.ActivePlan.ctor.call(this);
            this.onNext = onNext;
            this.onCompleted = onCompleted;
            this.first = first;
            this.second = second;
            this.third = third;
            this.fourth = fourth;
            this.addJoinObserver(first);
            this.addJoinObserver(second);
            this.addJoinObserver(third);
            this.addJoinObserver(fourth);
        },
        match: function () {
            if (this.first.getQueue().getCount() > 0 && this.second.getQueue().getCount() > 0 && this.third.getQueue().getCount() > 0 && this.fourth.getQueue().getCount() > 0) {
                var n1 = this.first.getQueue().peek();
                var n2 = this.second.getQueue().peek();
                var n3 = this.third.getQueue().peek();
                var n4 = this.fourth.getQueue().peek();

                if (n1.getKind() === System.Reactive.NotificationKind.OnCompleted || n2.getKind() === System.Reactive.NotificationKind.OnCompleted || n3.getKind() === System.Reactive.NotificationKind.OnCompleted || n4.getKind() === System.Reactive.NotificationKind.OnCompleted) {
                    this.onCompleted();
                } else {
                    this.dequeue();
                    this.onNext(n1.getValue(), n2.getValue(), n3.getValue(), n4.getValue());
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Joins.ActivePlan$5", function (T1, T2, T3, T4, T5) { return {
        inherits: [System.Reactive.Joins.ActivePlan],
        onNext: null,
        onCompleted: null,
        first: null,
        second: null,
        third: null,
        fourth: null,
        fifth: null,
        ctor: function (first, second, third, fourth, fifth, onNext, onCompleted) {
            this.$initialize();
            System.Reactive.Joins.ActivePlan.ctor.call(this);
            this.onNext = onNext;
            this.onCompleted = onCompleted;
            this.first = first;
            this.second = second;
            this.third = third;
            this.fourth = fourth;
            this.fifth = fifth;
            this.addJoinObserver(first);
            this.addJoinObserver(second);
            this.addJoinObserver(third);
            this.addJoinObserver(fourth);
            this.addJoinObserver(fifth);
        },
        match: function () {
            if (this.first.getQueue().getCount() > 0 && this.second.getQueue().getCount() > 0 && this.third.getQueue().getCount() > 0 && this.fourth.getQueue().getCount() > 0 && this.fifth.getQueue().getCount() > 0) {
                var n1 = this.first.getQueue().peek();
                var n2 = this.second.getQueue().peek();
                var n3 = this.third.getQueue().peek();
                var n4 = this.fourth.getQueue().peek();
                var n5 = this.fifth.getQueue().peek();

                if (n1.getKind() === System.Reactive.NotificationKind.OnCompleted || n2.getKind() === System.Reactive.NotificationKind.OnCompleted || n3.getKind() === System.Reactive.NotificationKind.OnCompleted || n4.getKind() === System.Reactive.NotificationKind.OnCompleted || n5.getKind() === System.Reactive.NotificationKind.OnCompleted) {
                    this.onCompleted();
                } else {
                    this.dequeue();
                    this.onNext(n1.getValue(), n2.getValue(), n3.getValue(), n4.getValue(), n5.getValue());
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Joins.ActivePlan$6", function (T1, T2, T3, T4, T5, T6) { return {
        inherits: [System.Reactive.Joins.ActivePlan],
        onNext: null,
        onCompleted: null,
        first: null,
        second: null,
        third: null,
        fourth: null,
        fifth: null,
        sixth: null,
        ctor: function (first, second, third, fourth, fifth, sixth, onNext, onCompleted) {
            this.$initialize();
            System.Reactive.Joins.ActivePlan.ctor.call(this);
            this.onNext = onNext;
            this.onCompleted = onCompleted;
            this.first = first;
            this.second = second;
            this.third = third;
            this.fourth = fourth;
            this.fifth = fifth;
            this.sixth = sixth;
            this.addJoinObserver(first);
            this.addJoinObserver(second);
            this.addJoinObserver(third);
            this.addJoinObserver(fourth);
            this.addJoinObserver(fifth);
            this.addJoinObserver(sixth);
        },
        match: function () {
            if (this.first.getQueue().getCount() > 0 && this.second.getQueue().getCount() > 0 && this.third.getQueue().getCount() > 0 && this.fourth.getQueue().getCount() > 0 && this.fifth.getQueue().getCount() > 0 && this.sixth.getQueue().getCount() > 0) {
                var n1 = this.first.getQueue().peek();
                var n2 = this.second.getQueue().peek();
                var n3 = this.third.getQueue().peek();
                var n4 = this.fourth.getQueue().peek();
                var n5 = this.fifth.getQueue().peek();
                var n6 = this.sixth.getQueue().peek();

                if (n1.getKind() === System.Reactive.NotificationKind.OnCompleted || n2.getKind() === System.Reactive.NotificationKind.OnCompleted || n3.getKind() === System.Reactive.NotificationKind.OnCompleted || n4.getKind() === System.Reactive.NotificationKind.OnCompleted || n5.getKind() === System.Reactive.NotificationKind.OnCompleted || n6.getKind() === System.Reactive.NotificationKind.OnCompleted) {
                    this.onCompleted();
                } else {
                    this.dequeue();
                    this.onNext(n1.getValue(), n2.getValue(), n3.getValue(), n4.getValue(), n5.getValue(), n6.getValue());
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Joins.ActivePlan$7", function (T1, T2, T3, T4, T5, T6, T7) { return {
        inherits: [System.Reactive.Joins.ActivePlan],
        onNext: null,
        onCompleted: null,
        first: null,
        second: null,
        third: null,
        fourth: null,
        fifth: null,
        sixth: null,
        seventh: null,
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, onNext, onCompleted) {
            this.$initialize();
            System.Reactive.Joins.ActivePlan.ctor.call(this);
            this.onNext = onNext;
            this.onCompleted = onCompleted;
            this.first = first;
            this.second = second;
            this.third = third;
            this.fourth = fourth;
            this.fifth = fifth;
            this.sixth = sixth;
            this.seventh = seventh;
            this.addJoinObserver(first);
            this.addJoinObserver(second);
            this.addJoinObserver(third);
            this.addJoinObserver(fourth);
            this.addJoinObserver(fifth);
            this.addJoinObserver(sixth);
            this.addJoinObserver(seventh);
        },
        match: function () {
            if (this.first.getQueue().getCount() > 0 && this.second.getQueue().getCount() > 0 && this.third.getQueue().getCount() > 0 && this.fourth.getQueue().getCount() > 0 && this.fifth.getQueue().getCount() > 0 && this.sixth.getQueue().getCount() > 0 && this.seventh.getQueue().getCount() > 0) {
                var n1 = this.first.getQueue().peek();
                var n2 = this.second.getQueue().peek();
                var n3 = this.third.getQueue().peek();
                var n4 = this.fourth.getQueue().peek();
                var n5 = this.fifth.getQueue().peek();
                var n6 = this.sixth.getQueue().peek();
                var n7 = this.seventh.getQueue().peek();

                if (n1.getKind() === System.Reactive.NotificationKind.OnCompleted || n2.getKind() === System.Reactive.NotificationKind.OnCompleted || n3.getKind() === System.Reactive.NotificationKind.OnCompleted || n4.getKind() === System.Reactive.NotificationKind.OnCompleted || n5.getKind() === System.Reactive.NotificationKind.OnCompleted || n6.getKind() === System.Reactive.NotificationKind.OnCompleted || n7.getKind() === System.Reactive.NotificationKind.OnCompleted) {
                    this.onCompleted();
                } else {
                    this.dequeue();
                    this.onNext(n1.getValue(), n2.getValue(), n3.getValue(), n4.getValue(), n5.getValue(), n6.getValue(), n7.getValue());
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Joins.ActivePlan$8", function (T1, T2, T3, T4, T5, T6, T7, T8) { return {
        inherits: [System.Reactive.Joins.ActivePlan],
        onNext: null,
        onCompleted: null,
        first: null,
        second: null,
        third: null,
        fourth: null,
        fifth: null,
        sixth: null,
        seventh: null,
        eighth: null,
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth, onNext, onCompleted) {
            this.$initialize();
            System.Reactive.Joins.ActivePlan.ctor.call(this);
            this.onNext = onNext;
            this.onCompleted = onCompleted;
            this.first = first;
            this.second = second;
            this.third = third;
            this.fourth = fourth;
            this.fifth = fifth;
            this.sixth = sixth;
            this.seventh = seventh;
            this.eighth = eighth;
            this.addJoinObserver(first);
            this.addJoinObserver(second);
            this.addJoinObserver(third);
            this.addJoinObserver(fourth);
            this.addJoinObserver(fifth);
            this.addJoinObserver(sixth);
            this.addJoinObserver(seventh);
            this.addJoinObserver(eighth);
        },
        match: function () {
            if (this.first.getQueue().getCount() > 0 && this.second.getQueue().getCount() > 0 && this.third.getQueue().getCount() > 0 && this.fourth.getQueue().getCount() > 0 && this.fifth.getQueue().getCount() > 0 && this.sixth.getQueue().getCount() > 0 && this.seventh.getQueue().getCount() > 0 && this.eighth.getQueue().getCount() > 0) {
                var n1 = this.first.getQueue().peek();
                var n2 = this.second.getQueue().peek();
                var n3 = this.third.getQueue().peek();
                var n4 = this.fourth.getQueue().peek();
                var n5 = this.fifth.getQueue().peek();
                var n6 = this.sixth.getQueue().peek();
                var n7 = this.seventh.getQueue().peek();
                var n8 = this.eighth.getQueue().peek();

                if (n1.getKind() === System.Reactive.NotificationKind.OnCompleted || n2.getKind() === System.Reactive.NotificationKind.OnCompleted || n3.getKind() === System.Reactive.NotificationKind.OnCompleted || n4.getKind() === System.Reactive.NotificationKind.OnCompleted || n5.getKind() === System.Reactive.NotificationKind.OnCompleted || n6.getKind() === System.Reactive.NotificationKind.OnCompleted || n7.getKind() === System.Reactive.NotificationKind.OnCompleted || n8.getKind() === System.Reactive.NotificationKind.OnCompleted) {
                    this.onCompleted();
                } else {
                    this.dequeue();
                    this.onNext(n1.getValue(), n2.getValue(), n3.getValue(), n4.getValue(), n5.getValue(), n6.getValue(), n7.getValue(), n8.getValue());
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Joins.ActivePlan$9", function (T1, T2, T3, T4, T5, T6, T7, T8, T9) { return {
        inherits: [System.Reactive.Joins.ActivePlan],
        onNext: null,
        onCompleted: null,
        first: null,
        second: null,
        third: null,
        fourth: null,
        fifth: null,
        sixth: null,
        seventh: null,
        eighth: null,
        ninth: null,
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, onNext, onCompleted) {
            this.$initialize();
            System.Reactive.Joins.ActivePlan.ctor.call(this);
            this.onNext = onNext;
            this.onCompleted = onCompleted;
            this.first = first;
            this.second = second;
            this.third = third;
            this.fourth = fourth;
            this.fifth = fifth;
            this.sixth = sixth;
            this.seventh = seventh;
            this.eighth = eighth;
            this.ninth = ninth;
            this.addJoinObserver(first);
            this.addJoinObserver(second);
            this.addJoinObserver(third);
            this.addJoinObserver(fourth);
            this.addJoinObserver(fifth);
            this.addJoinObserver(sixth);
            this.addJoinObserver(seventh);
            this.addJoinObserver(eighth);
            this.addJoinObserver(ninth);
        },
        match: function () {
            if (this.first.getQueue().getCount() > 0 && this.second.getQueue().getCount() > 0 && this.third.getQueue().getCount() > 0 && this.fourth.getQueue().getCount() > 0 && this.fifth.getQueue().getCount() > 0 && this.sixth.getQueue().getCount() > 0 && this.seventh.getQueue().getCount() > 0 && this.eighth.getQueue().getCount() > 0 && this.ninth.getQueue().getCount() > 0) {
                var n1 = this.first.getQueue().peek();
                var n2 = this.second.getQueue().peek();
                var n3 = this.third.getQueue().peek();
                var n4 = this.fourth.getQueue().peek();
                var n5 = this.fifth.getQueue().peek();
                var n6 = this.sixth.getQueue().peek();
                var n7 = this.seventh.getQueue().peek();
                var n8 = this.eighth.getQueue().peek();
                var n9 = this.ninth.getQueue().peek();

                if (n1.getKind() === System.Reactive.NotificationKind.OnCompleted || n2.getKind() === System.Reactive.NotificationKind.OnCompleted || n3.getKind() === System.Reactive.NotificationKind.OnCompleted || n4.getKind() === System.Reactive.NotificationKind.OnCompleted || n5.getKind() === System.Reactive.NotificationKind.OnCompleted || n6.getKind() === System.Reactive.NotificationKind.OnCompleted || n7.getKind() === System.Reactive.NotificationKind.OnCompleted || n8.getKind() === System.Reactive.NotificationKind.OnCompleted || n9.getKind() === System.Reactive.NotificationKind.OnCompleted) {
                    this.onCompleted();
                } else {
                    this.dequeue();
                    this.onNext(n1.getValue(), n2.getValue(), n3.getValue(), n4.getValue(), n5.getValue(), n6.getValue(), n7.getValue(), n8.getValue(), n9.getValue());
                }
            }
        }
    }; });

    /**
     * Represents a join pattern over one observable sequence.
     *
     * @public
     * @class System.Reactive.Joins.Pattern$1
     * @augments System.Reactive.Joins.Pattern
     * @param   {Function}    [name]    The type of the elements in the first source sequence.
     */
    Bridge.define("System.Reactive.Joins.Pattern$1", function (TSource1) { return {
        inherits: [System.Reactive.Joins.Pattern],
        config: {
            properties: {
                First: null
            }
        },
        ctor: function (first) {
            this.$initialize();
            System.Reactive.Joins.Pattern.ctor.call(this);
            this.setFirst(first);
        },
        /**
         * Matches when all observable sequences have an available element and projects the elements by invoking the selector function.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$1
         * @memberof System.Reactive.Joins.Pattern$1
         * @throws <b /> is null.
         * @param   {Function}                        TResult     The type of the elements in the result sequence, returned by the selector function.
         * @param   {System.Func}                     selector    Selector that will be invoked for elements in the source sequences.
         * @return  {System.Reactive.Joins.Plan$1}                Plan that produces the projected results, to be fed (with other plans) to the When operator.
         */
        then: function (TResult, selector) {
            if (Bridge.staticEquals(selector, null)) {
                throw new System.ArgumentNullException("selector");
            }

            return new (System.Reactive.Joins.Plan$2(TSource1,TResult))(this, selector);
        }
    }; });

    /**
     * Represents a join pattern over ten observable sequences.
     *
     * @public
     * @class System.Reactive.Joins.Pattern$10
     * @augments System.Reactive.Joins.Pattern
     * @param   {Function}    [name]    The type of the elements in the first source sequence.
     * @param   {Function}    [name]    The type of the elements in the second source sequence.
     * @param   {Function}    [name]    The type of the elements in the third source sequence.
     * @param   {Function}    [name]    The type of the elements in the fourth source sequence.
     * @param   {Function}    [name]    The type of the elements in the fifth source sequence.
     * @param   {Function}    [name]    The type of the elements in the sixth source sequence.
     * @param   {Function}    [name]    The type of the elements in the seventh source sequence.
     * @param   {Function}    [name]    The type of the elements in the eighth source sequence.
     * @param   {Function}    [name]    The type of the elements in the ninth source sequence.
     * @param   {Function}    [name]    The type of the elements in the tenth source sequence.
     */
    Bridge.define("System.Reactive.Joins.Pattern$10", function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10) { return {
        inherits: [System.Reactive.Joins.Pattern],
        config: {
            properties: {
                First: null,
                Second: null,
                Third: null,
                Fourth: null,
                Fifth: null,
                Sixth: null,
                Seventh: null,
                Eighth: null,
                Ninth: null,
                Tenth: null
            }
        },
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth) {
            this.$initialize();
            System.Reactive.Joins.Pattern.ctor.call(this);
            this.setFirst(first);
            this.setSecond(second);
            this.setThird(third);
            this.setFourth(fourth);
            this.setFifth(fifth);
            this.setSixth(sixth);
            this.setSeventh(seventh);
            this.setEighth(eighth);
            this.setNinth(ninth);
            this.setTenth(tenth);
        },
        /**
         * Creates a pattern that matches when all eleven observable sequences have an available element.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$10
         * @memberof System.Reactive.Joins.Pattern$10
         * @throws <b /> is null.
         * @param   {Function}                            TSource11    The type of the elements in the eleventh observable sequence.
         * @param   {System.IObservable$1}                other        Observable sequence to match with the ten previous sequences.
         * @return  {System.Reactive.Joins.Pattern$11}                 Pattern object that matches when all observable sequences have an available element.
         */
        and: function (TSource11, other) {
            if (other == null) {
                throw new System.ArgumentNullException("other");
            }

            return new (System.Reactive.Joins.Pattern$11(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11))(this.getFirst(), this.getSecond(), this.getThird(), this.getFourth(), this.getFifth(), this.getSixth(), this.getSeventh(), this.getEighth(), this.getNinth(), this.getTenth(), other);
        },
        /**
         * Matches when all observable sequences have an available element and projects the elements by invoking the selector function.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$10
         * @memberof System.Reactive.Joins.Pattern$10
         * @throws <b /> is null.
         * @param   {Function}                        TResult     The type of the elements in the result sequence, returned by the selector function.
         * @param   {System.Func}                     selector    Selector that will be invoked for elements in the source sequences.
         * @return  {System.Reactive.Joins.Plan$1}                Plan that produces the projected results, to be fed (with other plans) to the When operator.
         */
        then: function (TResult, selector) {
            if (Bridge.staticEquals(selector, null)) {
                throw new System.ArgumentNullException("selector");
            }

            return new (System.Reactive.Joins.Plan$11(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TResult))(this, selector);
        }
    }; });

    /**
     * Represents a join pattern over eleven observable sequences.
     *
     * @public
     * @class System.Reactive.Joins.Pattern$11
     * @augments System.Reactive.Joins.Pattern
     * @param   {Function}    [name]    The type of the elements in the first source sequence.
     * @param   {Function}    [name]    The type of the elements in the second source sequence.
     * @param   {Function}    [name]    The type of the elements in the third source sequence.
     * @param   {Function}    [name]    The type of the elements in the fourth source sequence.
     * @param   {Function}    [name]    The type of the elements in the fifth source sequence.
     * @param   {Function}    [name]    The type of the elements in the sixth source sequence.
     * @param   {Function}    [name]    The type of the elements in the seventh source sequence.
     * @param   {Function}    [name]    The type of the elements in the eighth source sequence.
     * @param   {Function}    [name]    The type of the elements in the ninth source sequence.
     * @param   {Function}    [name]    The type of the elements in the tenth source sequence.
     * @param   {Function}    [name]    The type of the elements in the eleventh source sequence.
     */
    Bridge.define("System.Reactive.Joins.Pattern$11", function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11) { return {
        inherits: [System.Reactive.Joins.Pattern],
        config: {
            properties: {
                First: null,
                Second: null,
                Third: null,
                Fourth: null,
                Fifth: null,
                Sixth: null,
                Seventh: null,
                Eighth: null,
                Ninth: null,
                Tenth: null,
                Eleventh: null
            }
        },
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh) {
            this.$initialize();
            System.Reactive.Joins.Pattern.ctor.call(this);
            this.setFirst(first);
            this.setSecond(second);
            this.setThird(third);
            this.setFourth(fourth);
            this.setFifth(fifth);
            this.setSixth(sixth);
            this.setSeventh(seventh);
            this.setEighth(eighth);
            this.setNinth(ninth);
            this.setTenth(tenth);
            this.setEleventh(eleventh);
        },
        /**
         * Creates a pattern that matches when all twelve observable sequences have an available element.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$11
         * @memberof System.Reactive.Joins.Pattern$11
         * @throws <b /> is null.
         * @param   {Function}                            TSource12    The type of the elements in the twelfth observable sequence.
         * @param   {System.IObservable$1}                other        Observable sequence to match with the eleven previous sequences.
         * @return  {System.Reactive.Joins.Pattern$12}                 Pattern object that matches when all observable sequences have an available element.
         */
        and: function (TSource12, other) {
            if (other == null) {
                throw new System.ArgumentNullException("other");
            }

            return new (System.Reactive.Joins.Pattern$12(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12))(this.getFirst(), this.getSecond(), this.getThird(), this.getFourth(), this.getFifth(), this.getSixth(), this.getSeventh(), this.getEighth(), this.getNinth(), this.getTenth(), this.getEleventh(), other);
        },
        /**
         * Matches when all observable sequences have an available element and projects the elements by invoking the selector function.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$11
         * @memberof System.Reactive.Joins.Pattern$11
         * @throws <b /> is null.
         * @param   {Function}                        TResult     The type of the elements in the result sequence, returned by the selector function.
         * @param   {System.Func}                     selector    Selector that will be invoked for elements in the source sequences.
         * @return  {System.Reactive.Joins.Plan$1}                Plan that produces the projected results, to be fed (with other plans) to the When operator.
         */
        then: function (TResult, selector) {
            if (Bridge.staticEquals(selector, null)) {
                throw new System.ArgumentNullException("selector");
            }

            return new (System.Reactive.Joins.Plan$12(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TResult))(this, selector);
        }
    }; });

    /**
     * Represents a join pattern over twelve observable sequences.
     *
     * @public
     * @class System.Reactive.Joins.Pattern$12
     * @augments System.Reactive.Joins.Pattern
     * @param   {Function}    [name]    The type of the elements in the first source sequence.
     * @param   {Function}    [name]    The type of the elements in the second source sequence.
     * @param   {Function}    [name]    The type of the elements in the third source sequence.
     * @param   {Function}    [name]    The type of the elements in the fourth source sequence.
     * @param   {Function}    [name]    The type of the elements in the fifth source sequence.
     * @param   {Function}    [name]    The type of the elements in the sixth source sequence.
     * @param   {Function}    [name]    The type of the elements in the seventh source sequence.
     * @param   {Function}    [name]    The type of the elements in the eighth source sequence.
     * @param   {Function}    [name]    The type of the elements in the ninth source sequence.
     * @param   {Function}    [name]    The type of the elements in the tenth source sequence.
     * @param   {Function}    [name]    The type of the elements in the eleventh source sequence.
     * @param   {Function}    [name]    The type of the elements in the twelfth source sequence.
     */
    Bridge.define("System.Reactive.Joins.Pattern$12", function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12) { return {
        inherits: [System.Reactive.Joins.Pattern],
        config: {
            properties: {
                First: null,
                Second: null,
                Third: null,
                Fourth: null,
                Fifth: null,
                Sixth: null,
                Seventh: null,
                Eighth: null,
                Ninth: null,
                Tenth: null,
                Eleventh: null,
                Twelfth: null
            }
        },
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth) {
            this.$initialize();
            System.Reactive.Joins.Pattern.ctor.call(this);
            this.setFirst(first);
            this.setSecond(second);
            this.setThird(third);
            this.setFourth(fourth);
            this.setFifth(fifth);
            this.setSixth(sixth);
            this.setSeventh(seventh);
            this.setEighth(eighth);
            this.setNinth(ninth);
            this.setTenth(tenth);
            this.setEleventh(eleventh);
            this.setTwelfth(twelfth);
        },
        /**
         * Creates a pattern that matches when all thirteen observable sequences have an available element.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$12
         * @memberof System.Reactive.Joins.Pattern$12
         * @throws <b /> is null.
         * @param   {Function}                            TSource13    The type of the elements in the thirteenth observable sequence.
         * @param   {System.IObservable$1}                other        Observable sequence to match with the twelve previous sequences.
         * @return  {System.Reactive.Joins.Pattern$13}                 Pattern object that matches when all observable sequences have an available element.
         */
        and: function (TSource13, other) {
            if (other == null) {
                throw new System.ArgumentNullException("other");
            }

            return new (System.Reactive.Joins.Pattern$13(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TSource13))(this.getFirst(), this.getSecond(), this.getThird(), this.getFourth(), this.getFifth(), this.getSixth(), this.getSeventh(), this.getEighth(), this.getNinth(), this.getTenth(), this.getEleventh(), this.getTwelfth(), other);
        },
        /**
         * Matches when all observable sequences have an available element and projects the elements by invoking the selector function.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$12
         * @memberof System.Reactive.Joins.Pattern$12
         * @throws <b /> is null.
         * @param   {Function}                        TResult     The type of the elements in the result sequence, returned by the selector function.
         * @param   {System.Func}                     selector    Selector that will be invoked for elements in the source sequences.
         * @return  {System.Reactive.Joins.Plan$1}                Plan that produces the projected results, to be fed (with other plans) to the When operator.
         */
        then: function (TResult, selector) {
            if (Bridge.staticEquals(selector, null)) {
                throw new System.ArgumentNullException("selector");
            }

            return new (System.Reactive.Joins.Plan$13(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TResult))(this, selector);
        }
    }; });

    /**
     * Represents a join pattern over thirteen observable sequences.
     *
     * @public
     * @class System.Reactive.Joins.Pattern$13
     * @augments System.Reactive.Joins.Pattern
     * @param   {Function}    [name]    The type of the elements in the first source sequence.
     * @param   {Function}    [name]    The type of the elements in the second source sequence.
     * @param   {Function}    [name]    The type of the elements in the third source sequence.
     * @param   {Function}    [name]    The type of the elements in the fourth source sequence.
     * @param   {Function}    [name]    The type of the elements in the fifth source sequence.
     * @param   {Function}    [name]    The type of the elements in the sixth source sequence.
     * @param   {Function}    [name]    The type of the elements in the seventh source sequence.
     * @param   {Function}    [name]    The type of the elements in the eighth source sequence.
     * @param   {Function}    [name]    The type of the elements in the ninth source sequence.
     * @param   {Function}    [name]    The type of the elements in the tenth source sequence.
     * @param   {Function}    [name]    The type of the elements in the eleventh source sequence.
     * @param   {Function}    [name]    The type of the elements in the twelfth source sequence.
     * @param   {Function}    [name]    The type of the elements in the thirteenth source sequence.
     */
    Bridge.define("System.Reactive.Joins.Pattern$13", function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13) { return {
        inherits: [System.Reactive.Joins.Pattern],
        config: {
            properties: {
                First: null,
                Second: null,
                Third: null,
                Fourth: null,
                Fifth: null,
                Sixth: null,
                Seventh: null,
                Eighth: null,
                Ninth: null,
                Tenth: null,
                Eleventh: null,
                Twelfth: null,
                Thirteenth: null
            }
        },
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth) {
            this.$initialize();
            System.Reactive.Joins.Pattern.ctor.call(this);
            this.setFirst(first);
            this.setSecond(second);
            this.setThird(third);
            this.setFourth(fourth);
            this.setFifth(fifth);
            this.setSixth(sixth);
            this.setSeventh(seventh);
            this.setEighth(eighth);
            this.setNinth(ninth);
            this.setTenth(tenth);
            this.setEleventh(eleventh);
            this.setTwelfth(twelfth);
            this.setThirteenth(thirteenth);
        },
        /**
         * Creates a pattern that matches when all fourteen observable sequences have an available element.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$13
         * @memberof System.Reactive.Joins.Pattern$13
         * @throws <b /> is null.
         * @param   {Function}                            TSource14    The type of the elements in the fourteenth observable sequence.
         * @param   {System.IObservable$1}                other        Observable sequence to match with the thirteen previous sequences.
         * @return  {System.Reactive.Joins.Pattern$14}                 Pattern object that matches when all observable sequences have an available element.
         */
        and: function (TSource14, other) {
            if (other == null) {
                throw new System.ArgumentNullException("other");
            }

            return new (System.Reactive.Joins.Pattern$14(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TSource13,TSource14))(this.getFirst(), this.getSecond(), this.getThird(), this.getFourth(), this.getFifth(), this.getSixth(), this.getSeventh(), this.getEighth(), this.getNinth(), this.getTenth(), this.getEleventh(), this.getTwelfth(), this.getThirteenth(), other);
        },
        /**
         * Matches when all observable sequences have an available element and projects the elements by invoking the selector function.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$13
         * @memberof System.Reactive.Joins.Pattern$13
         * @throws <b /> is null.
         * @param   {Function}                        TResult     The type of the elements in the result sequence, returned by the selector function.
         * @param   {System.Func}                     selector    Selector that will be invoked for elements in the source sequences.
         * @return  {System.Reactive.Joins.Plan$1}                Plan that produces the projected results, to be fed (with other plans) to the When operator.
         */
        then: function (TResult, selector) {
            if (Bridge.staticEquals(selector, null)) {
                throw new System.ArgumentNullException("selector");
            }

            return new (System.Reactive.Joins.Plan$14(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TSource13,TResult))(this, selector);
        }
    }; });

    /**
     * Represents a join pattern over fourteen observable sequences.
     *
     * @public
     * @class System.Reactive.Joins.Pattern$14
     * @augments System.Reactive.Joins.Pattern
     * @param   {Function}    [name]    The type of the elements in the first source sequence.
     * @param   {Function}    [name]    The type of the elements in the second source sequence.
     * @param   {Function}    [name]    The type of the elements in the third source sequence.
     * @param   {Function}    [name]    The type of the elements in the fourth source sequence.
     * @param   {Function}    [name]    The type of the elements in the fifth source sequence.
     * @param   {Function}    [name]    The type of the elements in the sixth source sequence.
     * @param   {Function}    [name]    The type of the elements in the seventh source sequence.
     * @param   {Function}    [name]    The type of the elements in the eighth source sequence.
     * @param   {Function}    [name]    The type of the elements in the ninth source sequence.
     * @param   {Function}    [name]    The type of the elements in the tenth source sequence.
     * @param   {Function}    [name]    The type of the elements in the eleventh source sequence.
     * @param   {Function}    [name]    The type of the elements in the twelfth source sequence.
     * @param   {Function}    [name]    The type of the elements in the thirteenth source sequence.
     * @param   {Function}    [name]    The type of the elements in the fourteenth source sequence.
     */
    Bridge.define("System.Reactive.Joins.Pattern$14", function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14) { return {
        inherits: [System.Reactive.Joins.Pattern],
        config: {
            properties: {
                First: null,
                Second: null,
                Third: null,
                Fourth: null,
                Fifth: null,
                Sixth: null,
                Seventh: null,
                Eighth: null,
                Ninth: null,
                Tenth: null,
                Eleventh: null,
                Twelfth: null,
                Thirteenth: null,
                Fourteenth: null
            }
        },
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth) {
            this.$initialize();
            System.Reactive.Joins.Pattern.ctor.call(this);
            this.setFirst(first);
            this.setSecond(second);
            this.setThird(third);
            this.setFourth(fourth);
            this.setFifth(fifth);
            this.setSixth(sixth);
            this.setSeventh(seventh);
            this.setEighth(eighth);
            this.setNinth(ninth);
            this.setTenth(tenth);
            this.setEleventh(eleventh);
            this.setTwelfth(twelfth);
            this.setThirteenth(thirteenth);
            this.setFourteenth(fourteenth);
        },
        /**
         * Creates a pattern that matches when all fifteen observable sequences have an available element.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$14
         * @memberof System.Reactive.Joins.Pattern$14
         * @throws <b /> is null.
         * @param   {Function}                            TSource15    The type of the elements in the fifteenth observable sequence.
         * @param   {System.IObservable$1}                other        Observable sequence to match with the fourteen previous sequences.
         * @return  {System.Reactive.Joins.Pattern$15}                 Pattern object that matches when all observable sequences have an available element.
         */
        and: function (TSource15, other) {
            if (other == null) {
                throw new System.ArgumentNullException("other");
            }

            return new (System.Reactive.Joins.Pattern$15(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TSource13,TSource14,TSource15))(this.getFirst(), this.getSecond(), this.getThird(), this.getFourth(), this.getFifth(), this.getSixth(), this.getSeventh(), this.getEighth(), this.getNinth(), this.getTenth(), this.getEleventh(), this.getTwelfth(), this.getThirteenth(), this.getFourteenth(), other);
        },
        /**
         * Matches when all observable sequences have an available element and projects the elements by invoking the selector function.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$14
         * @memberof System.Reactive.Joins.Pattern$14
         * @throws <b /> is null.
         * @param   {Function}                        TResult     The type of the elements in the result sequence, returned by the selector function.
         * @param   {System.Func}                     selector    Selector that will be invoked for elements in the source sequences.
         * @return  {System.Reactive.Joins.Plan$1}                Plan that produces the projected results, to be fed (with other plans) to the When operator.
         */
        then: function (TResult, selector) {
            if (Bridge.staticEquals(selector, null)) {
                throw new System.ArgumentNullException("selector");
            }

            return new (System.Reactive.Joins.Plan$15(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TSource13,TSource14,TResult))(this, selector);
        }
    }; });

    /**
     * Represents a join pattern over fifteen observable sequences.
     *
     * @public
     * @class System.Reactive.Joins.Pattern$15
     * @augments System.Reactive.Joins.Pattern
     * @param   {Function}    [name]    The type of the elements in the first source sequence.
     * @param   {Function}    [name]    The type of the elements in the second source sequence.
     * @param   {Function}    [name]    The type of the elements in the third source sequence.
     * @param   {Function}    [name]    The type of the elements in the fourth source sequence.
     * @param   {Function}    [name]    The type of the elements in the fifth source sequence.
     * @param   {Function}    [name]    The type of the elements in the sixth source sequence.
     * @param   {Function}    [name]    The type of the elements in the seventh source sequence.
     * @param   {Function}    [name]    The type of the elements in the eighth source sequence.
     * @param   {Function}    [name]    The type of the elements in the ninth source sequence.
     * @param   {Function}    [name]    The type of the elements in the tenth source sequence.
     * @param   {Function}    [name]    The type of the elements in the eleventh source sequence.
     * @param   {Function}    [name]    The type of the elements in the twelfth source sequence.
     * @param   {Function}    [name]    The type of the elements in the thirteenth source sequence.
     * @param   {Function}    [name]    The type of the elements in the fourteenth source sequence.
     * @param   {Function}    [name]    The type of the elements in the fifteenth source sequence.
     */
    Bridge.define("System.Reactive.Joins.Pattern$15", function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TSource15) { return {
        inherits: [System.Reactive.Joins.Pattern],
        config: {
            properties: {
                First: null,
                Second: null,
                Third: null,
                Fourth: null,
                Fifth: null,
                Sixth: null,
                Seventh: null,
                Eighth: null,
                Ninth: null,
                Tenth: null,
                Eleventh: null,
                Twelfth: null,
                Thirteenth: null,
                Fourteenth: null,
                Fifteenth: null
            }
        },
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth) {
            this.$initialize();
            System.Reactive.Joins.Pattern.ctor.call(this);
            this.setFirst(first);
            this.setSecond(second);
            this.setThird(third);
            this.setFourth(fourth);
            this.setFifth(fifth);
            this.setSixth(sixth);
            this.setSeventh(seventh);
            this.setEighth(eighth);
            this.setNinth(ninth);
            this.setTenth(tenth);
            this.setEleventh(eleventh);
            this.setTwelfth(twelfth);
            this.setThirteenth(thirteenth);
            this.setFourteenth(fourteenth);
            this.setFifteenth(fifteenth);
        },
        /**
         * Creates a pattern that matches when all sixteen observable sequences have an available element.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$15
         * @memberof System.Reactive.Joins.Pattern$15
         * @throws <b /> is null.
         * @param   {Function}                            TSource16    The type of the elements in the sixteenth observable sequence.
         * @param   {System.IObservable$1}                other        Observable sequence to match with the fifteen previous sequences.
         * @return  {System.Reactive.Joins.Pattern$16}                 Pattern object that matches when all observable sequences have an available element.
         */
        and: function (TSource16, other) {
            if (other == null) {
                throw new System.ArgumentNullException("other");
            }

            return new (System.Reactive.Joins.Pattern$16(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TSource13,TSource14,TSource15,TSource16))(this.getFirst(), this.getSecond(), this.getThird(), this.getFourth(), this.getFifth(), this.getSixth(), this.getSeventh(), this.getEighth(), this.getNinth(), this.getTenth(), this.getEleventh(), this.getTwelfth(), this.getThirteenth(), this.getFourteenth(), this.getFifteenth(), other);
        },
        /**
         * Matches when all observable sequences have an available element and projects the elements by invoking the selector function.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$15
         * @memberof System.Reactive.Joins.Pattern$15
         * @throws <b /> is null.
         * @param   {Function}                        TResult     The type of the elements in the result sequence, returned by the selector function.
         * @param   {System.Func}                     selector    Selector that will be invoked for elements in the source sequences.
         * @return  {System.Reactive.Joins.Plan$1}                Plan that produces the projected results, to be fed (with other plans) to the When operator.
         */
        then: function (TResult, selector) {
            if (Bridge.staticEquals(selector, null)) {
                throw new System.ArgumentNullException("selector");
            }

            return new (System.Reactive.Joins.Plan$16(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TSource13,TSource14,TSource15,TResult))(this, selector);
        }
    }; });

    /**
     * Represents a join pattern over sixteen observable sequences.
     *
     * @public
     * @class System.Reactive.Joins.Pattern$16
     * @augments System.Reactive.Joins.Pattern
     * @param   {Function}    [name]    The type of the elements in the first source sequence.
     * @param   {Function}    [name]    The type of the elements in the second source sequence.
     * @param   {Function}    [name]    The type of the elements in the third source sequence.
     * @param   {Function}    [name]    The type of the elements in the fourth source sequence.
     * @param   {Function}    [name]    The type of the elements in the fifth source sequence.
     * @param   {Function}    [name]    The type of the elements in the sixth source sequence.
     * @param   {Function}    [name]    The type of the elements in the seventh source sequence.
     * @param   {Function}    [name]    The type of the elements in the eighth source sequence.
     * @param   {Function}    [name]    The type of the elements in the ninth source sequence.
     * @param   {Function}    [name]    The type of the elements in the tenth source sequence.
     * @param   {Function}    [name]    The type of the elements in the eleventh source sequence.
     * @param   {Function}    [name]    The type of the elements in the twelfth source sequence.
     * @param   {Function}    [name]    The type of the elements in the thirteenth source sequence.
     * @param   {Function}    [name]    The type of the elements in the fourteenth source sequence.
     * @param   {Function}    [name]    The type of the elements in the fifteenth source sequence.
     * @param   {Function}    [name]    The type of the elements in the sixteenth source sequence.
     */
    Bridge.define("System.Reactive.Joins.Pattern$16", function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TSource15, TSource16) { return {
        inherits: [System.Reactive.Joins.Pattern],
        config: {
            properties: {
                First: null,
                Second: null,
                Third: null,
                Fourth: null,
                Fifth: null,
                Sixth: null,
                Seventh: null,
                Eighth: null,
                Ninth: null,
                Tenth: null,
                Eleventh: null,
                Twelfth: null,
                Thirteenth: null,
                Fourteenth: null,
                Fifteenth: null,
                Sixteenth: null
            }
        },
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth, sixteenth) {
            this.$initialize();
            System.Reactive.Joins.Pattern.ctor.call(this);
            this.setFirst(first);
            this.setSecond(second);
            this.setThird(third);
            this.setFourth(fourth);
            this.setFifth(fifth);
            this.setSixth(sixth);
            this.setSeventh(seventh);
            this.setEighth(eighth);
            this.setNinth(ninth);
            this.setTenth(tenth);
            this.setEleventh(eleventh);
            this.setTwelfth(twelfth);
            this.setThirteenth(thirteenth);
            this.setFourteenth(fourteenth);
            this.setFifteenth(fifteenth);
            this.setSixteenth(sixteenth);
        },
        /**
         * Matches when all observable sequences have an available element and projects the elements by invoking the selector function.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$16
         * @memberof System.Reactive.Joins.Pattern$16
         * @throws <b /> is null.
         * @param   {Function}                        TResult     The type of the elements in the result sequence, returned by the selector function.
         * @param   {System.Func}                     selector    Selector that will be invoked for elements in the source sequences.
         * @return  {System.Reactive.Joins.Plan$1}                Plan that produces the projected results, to be fed (with other plans) to the When operator.
         */
        then: function (TResult, selector) {
            if (Bridge.staticEquals(selector, null)) {
                throw new System.ArgumentNullException("selector");
            }

            return new (System.Reactive.Joins.Plan$17(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TSource13,TSource14,TSource15,TSource16,TResult))(this, selector);
        }
    }; });

    /**
     * Represents a join pattern over two observable sequences.
     *
     * @public
     * @class System.Reactive.Joins.Pattern$2
     * @augments System.Reactive.Joins.Pattern
     * @param   {Function}    [name]    The type of the elements in the first source sequence.
     * @param   {Function}    [name]    The type of the elements in the second source sequence.
     */
    Bridge.define("System.Reactive.Joins.Pattern$2", function (TSource1, TSource2) { return {
        inherits: [System.Reactive.Joins.Pattern],
        config: {
            properties: {
                First: null,
                Second: null
            }
        },
        ctor: function (first, second) {
            this.$initialize();
            System.Reactive.Joins.Pattern.ctor.call(this);
            this.setFirst(first);
            this.setSecond(second);
        },
        /**
         * Creates a pattern that matches when all three observable sequences have an available element.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$2
         * @memberof System.Reactive.Joins.Pattern$2
         * @throws <b /> is null.
         * @param   {Function}                           TSource3    The type of the elements in the third observable sequence.
         * @param   {System.IObservable$1}               other       Observable sequence to match with the two previous sequences.
         * @return  {System.Reactive.Joins.Pattern$3}                Pattern object that matches when all observable sequences have an available element.
         */
        and: function (TSource3, other) {
            if (other == null) {
                throw new System.ArgumentNullException("other");
            }

            return new (System.Reactive.Joins.Pattern$3(TSource1,TSource2,TSource3))(this.getFirst(), this.getSecond(), other);
        },
        /**
         * Matches when all observable sequences have an available element and projects the elements by invoking the selector function.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$2
         * @memberof System.Reactive.Joins.Pattern$2
         * @throws <b /> is null.
         * @param   {Function}                        TResult     The type of the elements in the result sequence, returned by the selector function.
         * @param   {System.Func}                     selector    Selector that will be invoked for elements in the source sequences.
         * @return  {System.Reactive.Joins.Plan$1}                Plan that produces the projected results, to be fed (with other plans) to the When operator.
         */
        then: function (TResult, selector) {
            if (Bridge.staticEquals(selector, null)) {
                throw new System.ArgumentNullException("selector");
            }

            return new (System.Reactive.Joins.Plan$3(TSource1,TSource2,TResult))(this, selector);
        }
    }; });

    /**
     * Represents a join pattern over three observable sequences.
     *
     * @public
     * @class System.Reactive.Joins.Pattern$3
     * @augments System.Reactive.Joins.Pattern
     * @param   {Function}    [name]    The type of the elements in the first source sequence.
     * @param   {Function}    [name]    The type of the elements in the second source sequence.
     * @param   {Function}    [name]    The type of the elements in the third source sequence.
     */
    Bridge.define("System.Reactive.Joins.Pattern$3", function (TSource1, TSource2, TSource3) { return {
        inherits: [System.Reactive.Joins.Pattern],
        config: {
            properties: {
                First: null,
                Second: null,
                Third: null
            }
        },
        ctor: function (first, second, third) {
            this.$initialize();
            System.Reactive.Joins.Pattern.ctor.call(this);
            this.setFirst(first);
            this.setSecond(second);
            this.setThird(third);
        },
        /**
         * Creates a pattern that matches when all four observable sequences have an available element.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$3
         * @memberof System.Reactive.Joins.Pattern$3
         * @throws <b /> is null.
         * @param   {Function}                           TSource4    The type of the elements in the fourth observable sequence.
         * @param   {System.IObservable$1}               other       Observable sequence to match with the three previous sequences.
         * @return  {System.Reactive.Joins.Pattern$4}                Pattern object that matches when all observable sequences have an available element.
         */
        and: function (TSource4, other) {
            if (other == null) {
                throw new System.ArgumentNullException("other");
            }

            return new (System.Reactive.Joins.Pattern$4(TSource1,TSource2,TSource3,TSource4))(this.getFirst(), this.getSecond(), this.getThird(), other);
        },
        /**
         * Matches when all observable sequences have an available element and projects the elements by invoking the selector function.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$3
         * @memberof System.Reactive.Joins.Pattern$3
         * @throws <b /> is null.
         * @param   {Function}                        TResult     The type of the elements in the result sequence, returned by the selector function.
         * @param   {System.Func}                     selector    Selector that will be invoked for elements in the source sequences.
         * @return  {System.Reactive.Joins.Plan$1}                Plan that produces the projected results, to be fed (with other plans) to the When operator.
         */
        then: function (TResult, selector) {
            if (Bridge.staticEquals(selector, null)) {
                throw new System.ArgumentNullException("selector");
            }

            return new (System.Reactive.Joins.Plan$4(TSource1,TSource2,TSource3,TResult))(this, selector);
        }
    }; });

    /**
     * Represents a join pattern over four observable sequences.
     *
     * @public
     * @class System.Reactive.Joins.Pattern$4
     * @augments System.Reactive.Joins.Pattern
     * @param   {Function}    [name]    The type of the elements in the first source sequence.
     * @param   {Function}    [name]    The type of the elements in the second source sequence.
     * @param   {Function}    [name]    The type of the elements in the third source sequence.
     * @param   {Function}    [name]    The type of the elements in the fourth source sequence.
     */
    Bridge.define("System.Reactive.Joins.Pattern$4", function (TSource1, TSource2, TSource3, TSource4) { return {
        inherits: [System.Reactive.Joins.Pattern],
        config: {
            properties: {
                First: null,
                Second: null,
                Third: null,
                Fourth: null
            }
        },
        ctor: function (first, second, third, fourth) {
            this.$initialize();
            System.Reactive.Joins.Pattern.ctor.call(this);
            this.setFirst(first);
            this.setSecond(second);
            this.setThird(third);
            this.setFourth(fourth);
        },
        /**
         * Creates a pattern that matches when all five observable sequences have an available element.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$4
         * @memberof System.Reactive.Joins.Pattern$4
         * @throws <b /> is null.
         * @param   {Function}                           TSource5    The type of the elements in the fifth observable sequence.
         * @param   {System.IObservable$1}               other       Observable sequence to match with the four previous sequences.
         * @return  {System.Reactive.Joins.Pattern$5}                Pattern object that matches when all observable sequences have an available element.
         */
        and: function (TSource5, other) {
            if (other == null) {
                throw new System.ArgumentNullException("other");
            }

            return new (System.Reactive.Joins.Pattern$5(TSource1,TSource2,TSource3,TSource4,TSource5))(this.getFirst(), this.getSecond(), this.getThird(), this.getFourth(), other);
        },
        /**
         * Matches when all observable sequences have an available element and projects the elements by invoking the selector function.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$4
         * @memberof System.Reactive.Joins.Pattern$4
         * @throws <b /> is null.
         * @param   {Function}                        TResult     The type of the elements in the result sequence, returned by the selector function.
         * @param   {System.Func}                     selector    Selector that will be invoked for elements in the source sequences.
         * @return  {System.Reactive.Joins.Plan$1}                Plan that produces the projected results, to be fed (with other plans) to the When operator.
         */
        then: function (TResult, selector) {
            if (Bridge.staticEquals(selector, null)) {
                throw new System.ArgumentNullException("selector");
            }

            return new (System.Reactive.Joins.Plan$5(TSource1,TSource2,TSource3,TSource4,TResult))(this, selector);
        }
    }; });

    /**
     * Represents a join pattern over five observable sequences.
     *
     * @public
     * @class System.Reactive.Joins.Pattern$5
     * @augments System.Reactive.Joins.Pattern
     * @param   {Function}    [name]    The type of the elements in the first source sequence.
     * @param   {Function}    [name]    The type of the elements in the second source sequence.
     * @param   {Function}    [name]    The type of the elements in the third source sequence.
     * @param   {Function}    [name]    The type of the elements in the fourth source sequence.
     * @param   {Function}    [name]    The type of the elements in the fifth source sequence.
     */
    Bridge.define("System.Reactive.Joins.Pattern$5", function (TSource1, TSource2, TSource3, TSource4, TSource5) { return {
        inherits: [System.Reactive.Joins.Pattern],
        config: {
            properties: {
                First: null,
                Second: null,
                Third: null,
                Fourth: null,
                Fifth: null
            }
        },
        ctor: function (first, second, third, fourth, fifth) {
            this.$initialize();
            System.Reactive.Joins.Pattern.ctor.call(this);
            this.setFirst(first);
            this.setSecond(second);
            this.setThird(third);
            this.setFourth(fourth);
            this.setFifth(fifth);
        },
        /**
         * Creates a pattern that matches when all six observable sequences have an available element.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$5
         * @memberof System.Reactive.Joins.Pattern$5
         * @throws <b /> is null.
         * @param   {Function}                           TSource6    The type of the elements in the sixth observable sequence.
         * @param   {System.IObservable$1}               other       Observable sequence to match with the five previous sequences.
         * @return  {System.Reactive.Joins.Pattern$6}                Pattern object that matches when all observable sequences have an available element.
         */
        and: function (TSource6, other) {
            if (other == null) {
                throw new System.ArgumentNullException("other");
            }

            return new (System.Reactive.Joins.Pattern$6(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6))(this.getFirst(), this.getSecond(), this.getThird(), this.getFourth(), this.getFifth(), other);
        },
        /**
         * Matches when all observable sequences have an available element and projects the elements by invoking the selector function.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$5
         * @memberof System.Reactive.Joins.Pattern$5
         * @throws <b /> is null.
         * @param   {Function}                        TResult     The type of the elements in the result sequence, returned by the selector function.
         * @param   {System.Func}                     selector    Selector that will be invoked for elements in the source sequences.
         * @return  {System.Reactive.Joins.Plan$1}                Plan that produces the projected results, to be fed (with other plans) to the When operator.
         */
        then: function (TResult, selector) {
            if (Bridge.staticEquals(selector, null)) {
                throw new System.ArgumentNullException("selector");
            }

            return new (System.Reactive.Joins.Plan$6(TSource1,TSource2,TSource3,TSource4,TSource5,TResult))(this, selector);
        }
    }; });

    /**
     * Represents a join pattern over six observable sequences.
     *
     * @public
     * @class System.Reactive.Joins.Pattern$6
     * @augments System.Reactive.Joins.Pattern
     * @param   {Function}    [name]    The type of the elements in the first source sequence.
     * @param   {Function}    [name]    The type of the elements in the second source sequence.
     * @param   {Function}    [name]    The type of the elements in the third source sequence.
     * @param   {Function}    [name]    The type of the elements in the fourth source sequence.
     * @param   {Function}    [name]    The type of the elements in the fifth source sequence.
     * @param   {Function}    [name]    The type of the elements in the sixth source sequence.
     */
    Bridge.define("System.Reactive.Joins.Pattern$6", function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6) { return {
        inherits: [System.Reactive.Joins.Pattern],
        config: {
            properties: {
                First: null,
                Second: null,
                Third: null,
                Fourth: null,
                Fifth: null,
                Sixth: null
            }
        },
        ctor: function (first, second, third, fourth, fifth, sixth) {
            this.$initialize();
            System.Reactive.Joins.Pattern.ctor.call(this);
            this.setFirst(first);
            this.setSecond(second);
            this.setThird(third);
            this.setFourth(fourth);
            this.setFifth(fifth);
            this.setSixth(sixth);
        },
        /**
         * Creates a pattern that matches when all seven observable sequences have an available element.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$6
         * @memberof System.Reactive.Joins.Pattern$6
         * @throws <b /> is null.
         * @param   {Function}                           TSource7    The type of the elements in the seventh observable sequence.
         * @param   {System.IObservable$1}               other       Observable sequence to match with the six previous sequences.
         * @return  {System.Reactive.Joins.Pattern$7}                Pattern object that matches when all observable sequences have an available element.
         */
        and: function (TSource7, other) {
            if (other == null) {
                throw new System.ArgumentNullException("other");
            }

            return new (System.Reactive.Joins.Pattern$7(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7))(this.getFirst(), this.getSecond(), this.getThird(), this.getFourth(), this.getFifth(), this.getSixth(), other);
        },
        /**
         * Matches when all observable sequences have an available element and projects the elements by invoking the selector function.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$6
         * @memberof System.Reactive.Joins.Pattern$6
         * @throws <b /> is null.
         * @param   {Function}                        TResult     The type of the elements in the result sequence, returned by the selector function.
         * @param   {System.Func}                     selector    Selector that will be invoked for elements in the source sequences.
         * @return  {System.Reactive.Joins.Plan$1}                Plan that produces the projected results, to be fed (with other plans) to the When operator.
         */
        then: function (TResult, selector) {
            if (Bridge.staticEquals(selector, null)) {
                throw new System.ArgumentNullException("selector");
            }

            return new (System.Reactive.Joins.Plan$7(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TResult))(this, selector);
        }
    }; });

    /**
     * Represents a join pattern over seven observable sequences.
     *
     * @public
     * @class System.Reactive.Joins.Pattern$7
     * @augments System.Reactive.Joins.Pattern
     * @param   {Function}    [name]    The type of the elements in the first source sequence.
     * @param   {Function}    [name]    The type of the elements in the second source sequence.
     * @param   {Function}    [name]    The type of the elements in the third source sequence.
     * @param   {Function}    [name]    The type of the elements in the fourth source sequence.
     * @param   {Function}    [name]    The type of the elements in the fifth source sequence.
     * @param   {Function}    [name]    The type of the elements in the sixth source sequence.
     * @param   {Function}    [name]    The type of the elements in the seventh source sequence.
     */
    Bridge.define("System.Reactive.Joins.Pattern$7", function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7) { return {
        inherits: [System.Reactive.Joins.Pattern],
        config: {
            properties: {
                First: null,
                Second: null,
                Third: null,
                Fourth: null,
                Fifth: null,
                Sixth: null,
                Seventh: null
            }
        },
        ctor: function (first, second, third, fourth, fifth, sixth, seventh) {
            this.$initialize();
            System.Reactive.Joins.Pattern.ctor.call(this);
            this.setFirst(first);
            this.setSecond(second);
            this.setThird(third);
            this.setFourth(fourth);
            this.setFifth(fifth);
            this.setSixth(sixth);
            this.setSeventh(seventh);
        },
        /**
         * Creates a pattern that matches when all eight observable sequences have an available element.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$7
         * @memberof System.Reactive.Joins.Pattern$7
         * @throws <b /> is null.
         * @param   {Function}                           TSource8    The type of the elements in the eighth observable sequence.
         * @param   {System.IObservable$1}               other       Observable sequence to match with the seven previous sequences.
         * @return  {System.Reactive.Joins.Pattern$8}                Pattern object that matches when all observable sequences have an available element.
         */
        and: function (TSource8, other) {
            if (other == null) {
                throw new System.ArgumentNullException("other");
            }

            return new (System.Reactive.Joins.Pattern$8(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8))(this.getFirst(), this.getSecond(), this.getThird(), this.getFourth(), this.getFifth(), this.getSixth(), this.getSeventh(), other);
        },
        /**
         * Matches when all observable sequences have an available element and projects the elements by invoking the selector function.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$7
         * @memberof System.Reactive.Joins.Pattern$7
         * @throws <b /> is null.
         * @param   {Function}                        TResult     The type of the elements in the result sequence, returned by the selector function.
         * @param   {System.Func}                     selector    Selector that will be invoked for elements in the source sequences.
         * @return  {System.Reactive.Joins.Plan$1}                Plan that produces the projected results, to be fed (with other plans) to the When operator.
         */
        then: function (TResult, selector) {
            if (Bridge.staticEquals(selector, null)) {
                throw new System.ArgumentNullException("selector");
            }

            return new (System.Reactive.Joins.Plan$8(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TResult))(this, selector);
        }
    }; });

    /**
     * Represents a join pattern over eight observable sequences.
     *
     * @public
     * @class System.Reactive.Joins.Pattern$8
     * @augments System.Reactive.Joins.Pattern
     * @param   {Function}    [name]    The type of the elements in the first source sequence.
     * @param   {Function}    [name]    The type of the elements in the second source sequence.
     * @param   {Function}    [name]    The type of the elements in the third source sequence.
     * @param   {Function}    [name]    The type of the elements in the fourth source sequence.
     * @param   {Function}    [name]    The type of the elements in the fifth source sequence.
     * @param   {Function}    [name]    The type of the elements in the sixth source sequence.
     * @param   {Function}    [name]    The type of the elements in the seventh source sequence.
     * @param   {Function}    [name]    The type of the elements in the eighth source sequence.
     */
    Bridge.define("System.Reactive.Joins.Pattern$8", function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8) { return {
        inherits: [System.Reactive.Joins.Pattern],
        config: {
            properties: {
                First: null,
                Second: null,
                Third: null,
                Fourth: null,
                Fifth: null,
                Sixth: null,
                Seventh: null,
                Eighth: null
            }
        },
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth) {
            this.$initialize();
            System.Reactive.Joins.Pattern.ctor.call(this);
            this.setFirst(first);
            this.setSecond(second);
            this.setThird(third);
            this.setFourth(fourth);
            this.setFifth(fifth);
            this.setSixth(sixth);
            this.setSeventh(seventh);
            this.setEighth(eighth);
        },
        /**
         * Creates a pattern that matches when all nine observable sequences have an available element.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$8
         * @memberof System.Reactive.Joins.Pattern$8
         * @throws <b /> is null.
         * @param   {Function}                           TSource9    The type of the elements in the ninth observable sequence.
         * @param   {System.IObservable$1}               other       Observable sequence to match with the eight previous sequences.
         * @return  {System.Reactive.Joins.Pattern$9}                Pattern object that matches when all observable sequences have an available element.
         */
        and: function (TSource9, other) {
            if (other == null) {
                throw new System.ArgumentNullException("other");
            }

            return new (System.Reactive.Joins.Pattern$9(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9))(this.getFirst(), this.getSecond(), this.getThird(), this.getFourth(), this.getFifth(), this.getSixth(), this.getSeventh(), this.getEighth(), other);
        },
        /**
         * Matches when all observable sequences have an available element and projects the elements by invoking the selector function.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$8
         * @memberof System.Reactive.Joins.Pattern$8
         * @throws <b /> is null.
         * @param   {Function}                        TResult     The type of the elements in the result sequence, returned by the selector function.
         * @param   {System.Func}                     selector    Selector that will be invoked for elements in the source sequences.
         * @return  {System.Reactive.Joins.Plan$1}                Plan that produces the projected results, to be fed (with other plans) to the When operator.
         */
        then: function (TResult, selector) {
            if (Bridge.staticEquals(selector, null)) {
                throw new System.ArgumentNullException("selector");
            }

            return new (System.Reactive.Joins.Plan$9(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TResult))(this, selector);
        }
    }; });

    /**
     * Represents a join pattern over nine observable sequences.
     *
     * @public
     * @class System.Reactive.Joins.Pattern$9
     * @augments System.Reactive.Joins.Pattern
     * @param   {Function}    [name]    The type of the elements in the first source sequence.
     * @param   {Function}    [name]    The type of the elements in the second source sequence.
     * @param   {Function}    [name]    The type of the elements in the third source sequence.
     * @param   {Function}    [name]    The type of the elements in the fourth source sequence.
     * @param   {Function}    [name]    The type of the elements in the fifth source sequence.
     * @param   {Function}    [name]    The type of the elements in the sixth source sequence.
     * @param   {Function}    [name]    The type of the elements in the seventh source sequence.
     * @param   {Function}    [name]    The type of the elements in the eighth source sequence.
     * @param   {Function}    [name]    The type of the elements in the ninth source sequence.
     */
    Bridge.define("System.Reactive.Joins.Pattern$9", function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9) { return {
        inherits: [System.Reactive.Joins.Pattern],
        config: {
            properties: {
                First: null,
                Second: null,
                Third: null,
                Fourth: null,
                Fifth: null,
                Sixth: null,
                Seventh: null,
                Eighth: null,
                Ninth: null
            }
        },
        ctor: function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth) {
            this.$initialize();
            System.Reactive.Joins.Pattern.ctor.call(this);
            this.setFirst(first);
            this.setSecond(second);
            this.setThird(third);
            this.setFourth(fourth);
            this.setFifth(fifth);
            this.setSixth(sixth);
            this.setSeventh(seventh);
            this.setEighth(eighth);
            this.setNinth(ninth);
        },
        /**
         * Creates a pattern that matches when all ten observable sequences have an available element.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$9
         * @memberof System.Reactive.Joins.Pattern$9
         * @throws <b /> is null.
         * @param   {Function}                            TSource10    The type of the elements in the tenth observable sequence.
         * @param   {System.IObservable$1}                other        Observable sequence to match with the nine previous sequences.
         * @return  {System.Reactive.Joins.Pattern$10}                 Pattern object that matches when all observable sequences have an available element.
         */
        and: function (TSource10, other) {
            if (other == null) {
                throw new System.ArgumentNullException("other");
            }

            return new (System.Reactive.Joins.Pattern$10(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10))(this.getFirst(), this.getSecond(), this.getThird(), this.getFourth(), this.getFifth(), this.getSixth(), this.getSeventh(), this.getEighth(), this.getNinth(), other);
        },
        /**
         * Matches when all observable sequences have an available element and projects the elements by invoking the selector function.
         *
         * @instance
         * @public
         * @this System.Reactive.Joins.Pattern$9
         * @memberof System.Reactive.Joins.Pattern$9
         * @throws <b /> is null.
         * @param   {Function}                        TResult     The type of the elements in the result sequence, returned by the selector function.
         * @param   {System.Func}                     selector    Selector that will be invoked for elements in the source sequences.
         * @return  {System.Reactive.Joins.Plan$1}                Plan that produces the projected results, to be fed (with other plans) to the When operator.
         */
        then: function (TResult, selector) {
            if (Bridge.staticEquals(selector, null)) {
                throw new System.ArgumentNullException("selector");
            }

            return new (System.Reactive.Joins.Plan$10(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TResult))(this, selector);
        }
    }; });

    Bridge.define("System.Reactive.Joins.Plan$10", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult) { return {
        inherits: [System.Reactive.Joins.Plan$1(TResult)],
        config: {
            properties: {
                Expression: null,
                Selector: null
            }
        },
        ctor: function (expression, selector) {
            this.$initialize();
            System.Reactive.Joins.Plan$1(TResult).ctor.call(this);
            this.setExpression(expression);
            this.setSelector(selector);
        },
        activate: function (externalSubscriptions, observer, deactivate) {
            var onError = Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"]);
            var firstJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T1, externalSubscriptions, this.getExpression().getFirst(), onError);
            var secondJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T2, externalSubscriptions, this.getExpression().getSecond(), onError);
            var thirdJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T3, externalSubscriptions, this.getExpression().getThird(), onError);
            var fourthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T4, externalSubscriptions, this.getExpression().getFourth(), onError);
            var fifthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T5, externalSubscriptions, this.getExpression().getFifth(), onError);
            var sixthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T6, externalSubscriptions, this.getExpression().getSixth(), onError);
            var seventhJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T7, externalSubscriptions, this.getExpression().getSeventh(), onError);
            var eighthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T8, externalSubscriptions, this.getExpression().getEighth(), onError);
            var ninthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T9, externalSubscriptions, this.getExpression().getNinth(), onError);
            var activePlan = null;

            activePlan = new (System.Reactive.Joins.ActivePlan$9(T1,T2,T3,T4,T5,T6,T7,T8,T9))(firstJoinObserver, secondJoinObserver, thirdJoinObserver, fourthJoinObserver, fifthJoinObserver, sixthJoinObserver, seventhJoinObserver, eighthJoinObserver, ninthJoinObserver, Bridge.fn.bind(this, function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth) {
                var result = Bridge.getDefaultValue(TResult);
                try {
                    result = this.getSelector()(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                    return;
                }
                observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            }), function () {
                firstJoinObserver.removeActivePlan(activePlan);
                secondJoinObserver.removeActivePlan(activePlan);
                thirdJoinObserver.removeActivePlan(activePlan);
                fourthJoinObserver.removeActivePlan(activePlan);
                fifthJoinObserver.removeActivePlan(activePlan);
                sixthJoinObserver.removeActivePlan(activePlan);
                seventhJoinObserver.removeActivePlan(activePlan);
                eighthJoinObserver.removeActivePlan(activePlan);
                ninthJoinObserver.removeActivePlan(activePlan);
                deactivate(activePlan);
            });

            firstJoinObserver.addActivePlan(activePlan);
            secondJoinObserver.addActivePlan(activePlan);
            thirdJoinObserver.addActivePlan(activePlan);
            fourthJoinObserver.addActivePlan(activePlan);
            fifthJoinObserver.addActivePlan(activePlan);
            sixthJoinObserver.addActivePlan(activePlan);
            seventhJoinObserver.addActivePlan(activePlan);
            eighthJoinObserver.addActivePlan(activePlan);
            ninthJoinObserver.addActivePlan(activePlan);
            return activePlan;
        }
    }; });

    Bridge.define("System.Reactive.Joins.Plan$11", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult) { return {
        inherits: [System.Reactive.Joins.Plan$1(TResult)],
        config: {
            properties: {
                Expression: null,
                Selector: null
            }
        },
        ctor: function (expression, selector) {
            this.$initialize();
            System.Reactive.Joins.Plan$1(TResult).ctor.call(this);
            this.setExpression(expression);
            this.setSelector(selector);
        },
        activate: function (externalSubscriptions, observer, deactivate) {
            var onError = Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"]);
            var firstJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T1, externalSubscriptions, this.getExpression().getFirst(), onError);
            var secondJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T2, externalSubscriptions, this.getExpression().getSecond(), onError);
            var thirdJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T3, externalSubscriptions, this.getExpression().getThird(), onError);
            var fourthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T4, externalSubscriptions, this.getExpression().getFourth(), onError);
            var fifthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T5, externalSubscriptions, this.getExpression().getFifth(), onError);
            var sixthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T6, externalSubscriptions, this.getExpression().getSixth(), onError);
            var seventhJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T7, externalSubscriptions, this.getExpression().getSeventh(), onError);
            var eighthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T8, externalSubscriptions, this.getExpression().getEighth(), onError);
            var ninthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T9, externalSubscriptions, this.getExpression().getNinth(), onError);
            var tenthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T10, externalSubscriptions, this.getExpression().getTenth(), onError);
            var activePlan = null;

            activePlan = new (System.Reactive.Joins.ActivePlan$10(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10))(firstJoinObserver, secondJoinObserver, thirdJoinObserver, fourthJoinObserver, fifthJoinObserver, sixthJoinObserver, seventhJoinObserver, eighthJoinObserver, ninthJoinObserver, tenthJoinObserver, Bridge.fn.bind(this, function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth) {
                var result = Bridge.getDefaultValue(TResult);
                try {
                    result = this.getSelector()(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                    return;
                }
                observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            }), function () {
                firstJoinObserver.removeActivePlan(activePlan);
                secondJoinObserver.removeActivePlan(activePlan);
                thirdJoinObserver.removeActivePlan(activePlan);
                fourthJoinObserver.removeActivePlan(activePlan);
                fifthJoinObserver.removeActivePlan(activePlan);
                sixthJoinObserver.removeActivePlan(activePlan);
                seventhJoinObserver.removeActivePlan(activePlan);
                eighthJoinObserver.removeActivePlan(activePlan);
                ninthJoinObserver.removeActivePlan(activePlan);
                tenthJoinObserver.removeActivePlan(activePlan);
                deactivate(activePlan);
            });

            firstJoinObserver.addActivePlan(activePlan);
            secondJoinObserver.addActivePlan(activePlan);
            thirdJoinObserver.addActivePlan(activePlan);
            fourthJoinObserver.addActivePlan(activePlan);
            fifthJoinObserver.addActivePlan(activePlan);
            sixthJoinObserver.addActivePlan(activePlan);
            seventhJoinObserver.addActivePlan(activePlan);
            eighthJoinObserver.addActivePlan(activePlan);
            ninthJoinObserver.addActivePlan(activePlan);
            tenthJoinObserver.addActivePlan(activePlan);
            return activePlan;
        }
    }; });

    Bridge.define("System.Reactive.Joins.Plan$12", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult) { return {
        inherits: [System.Reactive.Joins.Plan$1(TResult)],
        config: {
            properties: {
                Expression: null,
                Selector: null
            }
        },
        ctor: function (expression, selector) {
            this.$initialize();
            System.Reactive.Joins.Plan$1(TResult).ctor.call(this);
            this.setExpression(expression);
            this.setSelector(selector);
        },
        activate: function (externalSubscriptions, observer, deactivate) {
            var onError = Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"]);
            var firstJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T1, externalSubscriptions, this.getExpression().getFirst(), onError);
            var secondJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T2, externalSubscriptions, this.getExpression().getSecond(), onError);
            var thirdJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T3, externalSubscriptions, this.getExpression().getThird(), onError);
            var fourthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T4, externalSubscriptions, this.getExpression().getFourth(), onError);
            var fifthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T5, externalSubscriptions, this.getExpression().getFifth(), onError);
            var sixthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T6, externalSubscriptions, this.getExpression().getSixth(), onError);
            var seventhJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T7, externalSubscriptions, this.getExpression().getSeventh(), onError);
            var eighthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T8, externalSubscriptions, this.getExpression().getEighth(), onError);
            var ninthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T9, externalSubscriptions, this.getExpression().getNinth(), onError);
            var tenthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T10, externalSubscriptions, this.getExpression().getTenth(), onError);
            var eleventhJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T11, externalSubscriptions, this.getExpression().getEleventh(), onError);

            var activePlan = null;

            activePlan = new (System.Reactive.Joins.ActivePlan$11(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11))(firstJoinObserver, secondJoinObserver, thirdJoinObserver, fourthJoinObserver, fifthJoinObserver, sixthJoinObserver, seventhJoinObserver, eighthJoinObserver, ninthJoinObserver, tenthJoinObserver, eleventhJoinObserver, Bridge.fn.bind(this, function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh) {
                var result = Bridge.getDefaultValue(TResult);
                try {
                    result = this.getSelector()(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                    return;
                }
                observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            }), function () {
                firstJoinObserver.removeActivePlan(activePlan);
                secondJoinObserver.removeActivePlan(activePlan);
                thirdJoinObserver.removeActivePlan(activePlan);
                fourthJoinObserver.removeActivePlan(activePlan);
                fifthJoinObserver.removeActivePlan(activePlan);
                sixthJoinObserver.removeActivePlan(activePlan);
                seventhJoinObserver.removeActivePlan(activePlan);
                eighthJoinObserver.removeActivePlan(activePlan);
                ninthJoinObserver.removeActivePlan(activePlan);
                tenthJoinObserver.removeActivePlan(activePlan);
                eleventhJoinObserver.removeActivePlan(activePlan);
                deactivate(activePlan);
            });

            firstJoinObserver.addActivePlan(activePlan);
            secondJoinObserver.addActivePlan(activePlan);
            thirdJoinObserver.addActivePlan(activePlan);
            fourthJoinObserver.addActivePlan(activePlan);
            fifthJoinObserver.addActivePlan(activePlan);
            sixthJoinObserver.addActivePlan(activePlan);
            seventhJoinObserver.addActivePlan(activePlan);
            eighthJoinObserver.addActivePlan(activePlan);
            ninthJoinObserver.addActivePlan(activePlan);
            tenthJoinObserver.addActivePlan(activePlan);
            eleventhJoinObserver.addActivePlan(activePlan);
            return activePlan;
        }
    }; });

    Bridge.define("System.Reactive.Joins.Plan$13", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult) { return {
        inherits: [System.Reactive.Joins.Plan$1(TResult)],
        config: {
            properties: {
                Expression: null,
                Selector: null
            }
        },
        ctor: function (expression, selector) {
            this.$initialize();
            System.Reactive.Joins.Plan$1(TResult).ctor.call(this);
            this.setExpression(expression);
            this.setSelector(selector);
        },
        activate: function (externalSubscriptions, observer, deactivate) {
            var onError = Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"]);
            var firstJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T1, externalSubscriptions, this.getExpression().getFirst(), onError);
            var secondJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T2, externalSubscriptions, this.getExpression().getSecond(), onError);
            var thirdJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T3, externalSubscriptions, this.getExpression().getThird(), onError);
            var fourthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T4, externalSubscriptions, this.getExpression().getFourth(), onError);
            var fifthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T5, externalSubscriptions, this.getExpression().getFifth(), onError);
            var sixthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T6, externalSubscriptions, this.getExpression().getSixth(), onError);
            var seventhJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T7, externalSubscriptions, this.getExpression().getSeventh(), onError);
            var eighthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T8, externalSubscriptions, this.getExpression().getEighth(), onError);
            var ninthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T9, externalSubscriptions, this.getExpression().getNinth(), onError);
            var tenthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T10, externalSubscriptions, this.getExpression().getTenth(), onError);
            var eleventhJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T11, externalSubscriptions, this.getExpression().getEleventh(), onError);
            var twelfthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T12, externalSubscriptions, this.getExpression().getTwelfth(), onError);

            var activePlan = null;

            activePlan = new (System.Reactive.Joins.ActivePlan$12(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12))(firstJoinObserver, secondJoinObserver, thirdJoinObserver, fourthJoinObserver, fifthJoinObserver, sixthJoinObserver, seventhJoinObserver, eighthJoinObserver, ninthJoinObserver, tenthJoinObserver, eleventhJoinObserver, twelfthJoinObserver, Bridge.fn.bind(this, function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth) {
                var result = Bridge.getDefaultValue(TResult);
                try {
                    result = this.getSelector()(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                    return;
                }
                observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            }), function () {
                firstJoinObserver.removeActivePlan(activePlan);
                secondJoinObserver.removeActivePlan(activePlan);
                thirdJoinObserver.removeActivePlan(activePlan);
                fourthJoinObserver.removeActivePlan(activePlan);
                fifthJoinObserver.removeActivePlan(activePlan);
                sixthJoinObserver.removeActivePlan(activePlan);
                seventhJoinObserver.removeActivePlan(activePlan);
                eighthJoinObserver.removeActivePlan(activePlan);
                ninthJoinObserver.removeActivePlan(activePlan);
                tenthJoinObserver.removeActivePlan(activePlan);
                eleventhJoinObserver.removeActivePlan(activePlan);
                twelfthJoinObserver.removeActivePlan(activePlan);
                deactivate(activePlan);
            });

            firstJoinObserver.addActivePlan(activePlan);
            secondJoinObserver.addActivePlan(activePlan);
            thirdJoinObserver.addActivePlan(activePlan);
            fourthJoinObserver.addActivePlan(activePlan);
            fifthJoinObserver.addActivePlan(activePlan);
            sixthJoinObserver.addActivePlan(activePlan);
            seventhJoinObserver.addActivePlan(activePlan);
            eighthJoinObserver.addActivePlan(activePlan);
            ninthJoinObserver.addActivePlan(activePlan);
            tenthJoinObserver.addActivePlan(activePlan);
            eleventhJoinObserver.addActivePlan(activePlan);
            twelfthJoinObserver.addActivePlan(activePlan);
            return activePlan;
        }
    }; });

    Bridge.define("System.Reactive.Joins.Plan$14", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult) { return {
        inherits: [System.Reactive.Joins.Plan$1(TResult)],
        config: {
            properties: {
                Expression: null,
                Selector: null
            }
        },
        ctor: function (expression, selector) {
            this.$initialize();
            System.Reactive.Joins.Plan$1(TResult).ctor.call(this);
            this.setExpression(expression);
            this.setSelector(selector);
        },
        activate: function (externalSubscriptions, observer, deactivate) {
            var onError = Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"]);
            var firstJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T1, externalSubscriptions, this.getExpression().getFirst(), onError);
            var secondJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T2, externalSubscriptions, this.getExpression().getSecond(), onError);
            var thirdJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T3, externalSubscriptions, this.getExpression().getThird(), onError);
            var fourthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T4, externalSubscriptions, this.getExpression().getFourth(), onError);
            var fifthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T5, externalSubscriptions, this.getExpression().getFifth(), onError);
            var sixthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T6, externalSubscriptions, this.getExpression().getSixth(), onError);
            var seventhJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T7, externalSubscriptions, this.getExpression().getSeventh(), onError);
            var eighthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T8, externalSubscriptions, this.getExpression().getEighth(), onError);
            var ninthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T9, externalSubscriptions, this.getExpression().getNinth(), onError);
            var tenthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T10, externalSubscriptions, this.getExpression().getTenth(), onError);
            var eleventhJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T11, externalSubscriptions, this.getExpression().getEleventh(), onError);
            var twelfthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T12, externalSubscriptions, this.getExpression().getTwelfth(), onError);
            var thirteenthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T13, externalSubscriptions, this.getExpression().getThirteenth(), onError);

            var activePlan = null;

            activePlan = new (System.Reactive.Joins.ActivePlan$13(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13))(firstJoinObserver, secondJoinObserver, thirdJoinObserver, fourthJoinObserver, fifthJoinObserver, sixthJoinObserver, seventhJoinObserver, eighthJoinObserver, ninthJoinObserver, tenthJoinObserver, eleventhJoinObserver, twelfthJoinObserver, thirteenthJoinObserver, Bridge.fn.bind(this, function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth) {
                var result = Bridge.getDefaultValue(TResult);
                try {
                    result = this.getSelector()(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                    return;
                }
                observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            }), function () {
                firstJoinObserver.removeActivePlan(activePlan);
                secondJoinObserver.removeActivePlan(activePlan);
                thirdJoinObserver.removeActivePlan(activePlan);
                fourthJoinObserver.removeActivePlan(activePlan);
                fifthJoinObserver.removeActivePlan(activePlan);
                sixthJoinObserver.removeActivePlan(activePlan);
                seventhJoinObserver.removeActivePlan(activePlan);
                eighthJoinObserver.removeActivePlan(activePlan);
                ninthJoinObserver.removeActivePlan(activePlan);
                tenthJoinObserver.removeActivePlan(activePlan);
                eleventhJoinObserver.removeActivePlan(activePlan);
                twelfthJoinObserver.removeActivePlan(activePlan);
                thirteenthJoinObserver.removeActivePlan(activePlan);
                deactivate(activePlan);
            });

            firstJoinObserver.addActivePlan(activePlan);
            secondJoinObserver.addActivePlan(activePlan);
            thirdJoinObserver.addActivePlan(activePlan);
            fourthJoinObserver.addActivePlan(activePlan);
            fifthJoinObserver.addActivePlan(activePlan);
            sixthJoinObserver.addActivePlan(activePlan);
            seventhJoinObserver.addActivePlan(activePlan);
            eighthJoinObserver.addActivePlan(activePlan);
            ninthJoinObserver.addActivePlan(activePlan);
            tenthJoinObserver.addActivePlan(activePlan);
            eleventhJoinObserver.addActivePlan(activePlan);
            twelfthJoinObserver.addActivePlan(activePlan);
            thirteenthJoinObserver.addActivePlan(activePlan);
            return activePlan;
        }
    }; });

    Bridge.define("System.Reactive.Joins.Plan$15", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult) { return {
        inherits: [System.Reactive.Joins.Plan$1(TResult)],
        config: {
            properties: {
                Expression: null,
                Selector: null
            }
        },
        ctor: function (expression, selector) {
            this.$initialize();
            System.Reactive.Joins.Plan$1(TResult).ctor.call(this);
            this.setExpression(expression);
            this.setSelector(selector);
        },
        activate: function (externalSubscriptions, observer, deactivate) {
            var onError = Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"]);
            var firstJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T1, externalSubscriptions, this.getExpression().getFirst(), onError);
            var secondJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T2, externalSubscriptions, this.getExpression().getSecond(), onError);
            var thirdJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T3, externalSubscriptions, this.getExpression().getThird(), onError);
            var fourthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T4, externalSubscriptions, this.getExpression().getFourth(), onError);
            var fifthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T5, externalSubscriptions, this.getExpression().getFifth(), onError);
            var sixthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T6, externalSubscriptions, this.getExpression().getSixth(), onError);
            var seventhJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T7, externalSubscriptions, this.getExpression().getSeventh(), onError);
            var eighthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T8, externalSubscriptions, this.getExpression().getEighth(), onError);
            var ninthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T9, externalSubscriptions, this.getExpression().getNinth(), onError);
            var tenthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T10, externalSubscriptions, this.getExpression().getTenth(), onError);
            var eleventhJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T11, externalSubscriptions, this.getExpression().getEleventh(), onError);
            var twelfthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T12, externalSubscriptions, this.getExpression().getTwelfth(), onError);
            var thirteenthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T13, externalSubscriptions, this.getExpression().getThirteenth(), onError);
            var fourteenthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T14, externalSubscriptions, this.getExpression().getFourteenth(), onError);

            var activePlan = null;

            activePlan = new (System.Reactive.Joins.ActivePlan$14(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14))(firstJoinObserver, secondJoinObserver, thirdJoinObserver, fourthJoinObserver, fifthJoinObserver, sixthJoinObserver, seventhJoinObserver, eighthJoinObserver, ninthJoinObserver, tenthJoinObserver, eleventhJoinObserver, twelfthJoinObserver, thirteenthJoinObserver, fourteenthJoinObserver, Bridge.fn.bind(this, function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth) {
                var result = Bridge.getDefaultValue(TResult);
                try {
                    result = this.getSelector()(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                    return;
                }
                observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            }), function () {
                firstJoinObserver.removeActivePlan(activePlan);
                secondJoinObserver.removeActivePlan(activePlan);
                thirdJoinObserver.removeActivePlan(activePlan);
                fourthJoinObserver.removeActivePlan(activePlan);
                fifthJoinObserver.removeActivePlan(activePlan);
                sixthJoinObserver.removeActivePlan(activePlan);
                seventhJoinObserver.removeActivePlan(activePlan);
                eighthJoinObserver.removeActivePlan(activePlan);
                ninthJoinObserver.removeActivePlan(activePlan);
                tenthJoinObserver.removeActivePlan(activePlan);
                eleventhJoinObserver.removeActivePlan(activePlan);
                twelfthJoinObserver.removeActivePlan(activePlan);
                thirteenthJoinObserver.removeActivePlan(activePlan);
                fourteenthJoinObserver.removeActivePlan(activePlan);
                deactivate(activePlan);
            });

            firstJoinObserver.addActivePlan(activePlan);
            secondJoinObserver.addActivePlan(activePlan);
            thirdJoinObserver.addActivePlan(activePlan);
            fourthJoinObserver.addActivePlan(activePlan);
            fifthJoinObserver.addActivePlan(activePlan);
            sixthJoinObserver.addActivePlan(activePlan);
            seventhJoinObserver.addActivePlan(activePlan);
            eighthJoinObserver.addActivePlan(activePlan);
            ninthJoinObserver.addActivePlan(activePlan);
            tenthJoinObserver.addActivePlan(activePlan);
            eleventhJoinObserver.addActivePlan(activePlan);
            twelfthJoinObserver.addActivePlan(activePlan);
            thirteenthJoinObserver.addActivePlan(activePlan);
            fourteenthJoinObserver.addActivePlan(activePlan);
            return activePlan;
        }
    }; });

    Bridge.define("System.Reactive.Joins.Plan$16", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult) { return {
        inherits: [System.Reactive.Joins.Plan$1(TResult)],
        config: {
            properties: {
                Expression: null,
                Selector: null
            }
        },
        ctor: function (expression, selector) {
            this.$initialize();
            System.Reactive.Joins.Plan$1(TResult).ctor.call(this);
            this.setExpression(expression);
            this.setSelector(selector);
        },
        activate: function (externalSubscriptions, observer, deactivate) {
            var onError = Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"]);
            var firstJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T1, externalSubscriptions, this.getExpression().getFirst(), onError);
            var secondJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T2, externalSubscriptions, this.getExpression().getSecond(), onError);
            var thirdJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T3, externalSubscriptions, this.getExpression().getThird(), onError);
            var fourthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T4, externalSubscriptions, this.getExpression().getFourth(), onError);
            var fifthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T5, externalSubscriptions, this.getExpression().getFifth(), onError);
            var sixthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T6, externalSubscriptions, this.getExpression().getSixth(), onError);
            var seventhJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T7, externalSubscriptions, this.getExpression().getSeventh(), onError);
            var eighthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T8, externalSubscriptions, this.getExpression().getEighth(), onError);
            var ninthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T9, externalSubscriptions, this.getExpression().getNinth(), onError);
            var tenthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T10, externalSubscriptions, this.getExpression().getTenth(), onError);
            var eleventhJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T11, externalSubscriptions, this.getExpression().getEleventh(), onError);
            var twelfthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T12, externalSubscriptions, this.getExpression().getTwelfth(), onError);
            var thirteenthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T13, externalSubscriptions, this.getExpression().getThirteenth(), onError);
            var fourteenthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T14, externalSubscriptions, this.getExpression().getFourteenth(), onError);
            var fifteenthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T15, externalSubscriptions, this.getExpression().getFifteenth(), onError);

            var activePlan = null;

            activePlan = new (System.Reactive.Joins.ActivePlan$15(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15))(firstJoinObserver, secondJoinObserver, thirdJoinObserver, fourthJoinObserver, fifthJoinObserver, sixthJoinObserver, seventhJoinObserver, eighthJoinObserver, ninthJoinObserver, tenthJoinObserver, eleventhJoinObserver, twelfthJoinObserver, thirteenthJoinObserver, fourteenthJoinObserver, fifteenthJoinObserver, Bridge.fn.bind(this, function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth) {
                var result = Bridge.getDefaultValue(TResult);
                try {
                    result = this.getSelector()(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                    return;
                }
                observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            }), function () {
                firstJoinObserver.removeActivePlan(activePlan);
                secondJoinObserver.removeActivePlan(activePlan);
                thirdJoinObserver.removeActivePlan(activePlan);
                fourthJoinObserver.removeActivePlan(activePlan);
                fifthJoinObserver.removeActivePlan(activePlan);
                sixthJoinObserver.removeActivePlan(activePlan);
                seventhJoinObserver.removeActivePlan(activePlan);
                eighthJoinObserver.removeActivePlan(activePlan);
                ninthJoinObserver.removeActivePlan(activePlan);
                tenthJoinObserver.removeActivePlan(activePlan);
                eleventhJoinObserver.removeActivePlan(activePlan);
                twelfthJoinObserver.removeActivePlan(activePlan);
                thirteenthJoinObserver.removeActivePlan(activePlan);
                fourteenthJoinObserver.removeActivePlan(activePlan);
                fifteenthJoinObserver.removeActivePlan(activePlan);
                deactivate(activePlan);
            });

            firstJoinObserver.addActivePlan(activePlan);
            secondJoinObserver.addActivePlan(activePlan);
            thirdJoinObserver.addActivePlan(activePlan);
            fourthJoinObserver.addActivePlan(activePlan);
            fifthJoinObserver.addActivePlan(activePlan);
            sixthJoinObserver.addActivePlan(activePlan);
            seventhJoinObserver.addActivePlan(activePlan);
            eighthJoinObserver.addActivePlan(activePlan);
            ninthJoinObserver.addActivePlan(activePlan);
            tenthJoinObserver.addActivePlan(activePlan);
            eleventhJoinObserver.addActivePlan(activePlan);
            twelfthJoinObserver.addActivePlan(activePlan);
            thirteenthJoinObserver.addActivePlan(activePlan);
            fourteenthJoinObserver.addActivePlan(activePlan);
            fifteenthJoinObserver.addActivePlan(activePlan);
            return activePlan;
        }
    }; });

    Bridge.define("System.Reactive.Joins.Plan$17", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult) { return {
        inherits: [System.Reactive.Joins.Plan$1(TResult)],
        config: {
            properties: {
                Expression: null,
                Selector: null
            }
        },
        ctor: function (expression, selector) {
            this.$initialize();
            System.Reactive.Joins.Plan$1(TResult).ctor.call(this);
            this.setExpression(expression);
            this.setSelector(selector);
        },
        activate: function (externalSubscriptions, observer, deactivate) {
            var onError = Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"]);
            var firstJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T1, externalSubscriptions, this.getExpression().getFirst(), onError);
            var secondJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T2, externalSubscriptions, this.getExpression().getSecond(), onError);
            var thirdJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T3, externalSubscriptions, this.getExpression().getThird(), onError);
            var fourthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T4, externalSubscriptions, this.getExpression().getFourth(), onError);
            var fifthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T5, externalSubscriptions, this.getExpression().getFifth(), onError);
            var sixthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T6, externalSubscriptions, this.getExpression().getSixth(), onError);
            var seventhJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T7, externalSubscriptions, this.getExpression().getSeventh(), onError);
            var eighthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T8, externalSubscriptions, this.getExpression().getEighth(), onError);
            var ninthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T9, externalSubscriptions, this.getExpression().getNinth(), onError);
            var tenthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T10, externalSubscriptions, this.getExpression().getTenth(), onError);
            var eleventhJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T11, externalSubscriptions, this.getExpression().getEleventh(), onError);
            var twelfthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T12, externalSubscriptions, this.getExpression().getTwelfth(), onError);
            var thirteenthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T13, externalSubscriptions, this.getExpression().getThirteenth(), onError);
            var fourteenthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T14, externalSubscriptions, this.getExpression().getFourteenth(), onError);
            var fifteenthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T15, externalSubscriptions, this.getExpression().getFifteenth(), onError);
            var sixteenthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T16, externalSubscriptions, this.getExpression().getSixteenth(), onError);

            var activePlan = null;

            activePlan = new (System.Reactive.Joins.ActivePlan$16(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16))(firstJoinObserver, secondJoinObserver, thirdJoinObserver, fourthJoinObserver, fifthJoinObserver, sixthJoinObserver, seventhJoinObserver, eighthJoinObserver, ninthJoinObserver, tenthJoinObserver, eleventhJoinObserver, twelfthJoinObserver, thirteenthJoinObserver, fourteenthJoinObserver, fifteenthJoinObserver, sixteenthJoinObserver, Bridge.fn.bind(this, function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth, sixteenth) {
                var result = Bridge.getDefaultValue(TResult);
                try {
                    result = this.getSelector()(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth, sixteenth);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                    return;
                }
                observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            }), function () {
                firstJoinObserver.removeActivePlan(activePlan);
                secondJoinObserver.removeActivePlan(activePlan);
                thirdJoinObserver.removeActivePlan(activePlan);
                fourthJoinObserver.removeActivePlan(activePlan);
                fifthJoinObserver.removeActivePlan(activePlan);
                sixthJoinObserver.removeActivePlan(activePlan);
                seventhJoinObserver.removeActivePlan(activePlan);
                eighthJoinObserver.removeActivePlan(activePlan);
                ninthJoinObserver.removeActivePlan(activePlan);
                tenthJoinObserver.removeActivePlan(activePlan);
                eleventhJoinObserver.removeActivePlan(activePlan);
                twelfthJoinObserver.removeActivePlan(activePlan);
                thirteenthJoinObserver.removeActivePlan(activePlan);
                fourteenthJoinObserver.removeActivePlan(activePlan);
                fifteenthJoinObserver.removeActivePlan(activePlan);
                sixteenthJoinObserver.removeActivePlan(activePlan);
                deactivate(activePlan);
            });

            firstJoinObserver.addActivePlan(activePlan);
            secondJoinObserver.addActivePlan(activePlan);
            thirdJoinObserver.addActivePlan(activePlan);
            fourthJoinObserver.addActivePlan(activePlan);
            fifthJoinObserver.addActivePlan(activePlan);
            sixthJoinObserver.addActivePlan(activePlan);
            seventhJoinObserver.addActivePlan(activePlan);
            eighthJoinObserver.addActivePlan(activePlan);
            ninthJoinObserver.addActivePlan(activePlan);
            tenthJoinObserver.addActivePlan(activePlan);
            eleventhJoinObserver.addActivePlan(activePlan);
            twelfthJoinObserver.addActivePlan(activePlan);
            thirteenthJoinObserver.addActivePlan(activePlan);
            fourteenthJoinObserver.addActivePlan(activePlan);
            fifteenthJoinObserver.addActivePlan(activePlan);
            sixteenthJoinObserver.addActivePlan(activePlan);
            return activePlan;
        }
    }; });

    Bridge.define("System.Reactive.Joins.Plan$2", function (T1, TResult) { return {
        inherits: [System.Reactive.Joins.Plan$1(TResult)],
        config: {
            properties: {
                Expression: null,
                Selector: null
            }
        },
        ctor: function (expression, selector) {
            this.$initialize();
            System.Reactive.Joins.Plan$1(TResult).ctor.call(this);
            this.setExpression(expression);
            this.setSelector(selector);
        },
        activate: function (externalSubscriptions, observer, deactivate) {
            var onError = Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"]);
            var firstJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T1, externalSubscriptions, this.getExpression().getFirst(), onError);
            var activePlan = null;

            activePlan = new (System.Reactive.Joins.ActivePlan$1(T1))(firstJoinObserver, Bridge.fn.bind(this, function (first) {
                var result = Bridge.getDefaultValue(TResult);
                try {
                    result = this.getSelector()(first);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                    return;
                }
                observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            }), function () {
                firstJoinObserver.removeActivePlan(activePlan);
                deactivate(activePlan);
            });

            firstJoinObserver.addActivePlan(activePlan);
            return activePlan;
        }
    }; });

    Bridge.define("System.Reactive.Joins.Plan$3", function (T1, T2, TResult) { return {
        inherits: [System.Reactive.Joins.Plan$1(TResult)],
        config: {
            properties: {
                Expression: null,
                Selector: null
            }
        },
        ctor: function (expression, selector) {
            this.$initialize();
            System.Reactive.Joins.Plan$1(TResult).ctor.call(this);
            this.setExpression(expression);
            this.setSelector(selector);
        },
        activate: function (externalSubscriptions, observer, deactivate) {
            var onError = Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"]);
            var firstJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T1, externalSubscriptions, this.getExpression().getFirst(), onError);
            var secondJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T2, externalSubscriptions, this.getExpression().getSecond(), onError);
            var activePlan = null;

            activePlan = new (System.Reactive.Joins.ActivePlan$2(T1,T2))(firstJoinObserver, secondJoinObserver, Bridge.fn.bind(this, function (first, second) {
                var result = Bridge.getDefaultValue(TResult);
                try {
                    result = this.getSelector()(first, second);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                    return;
                }
                observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            }), function () {
                firstJoinObserver.removeActivePlan(activePlan);
                secondJoinObserver.removeActivePlan(activePlan);
                deactivate(activePlan);
            });

            firstJoinObserver.addActivePlan(activePlan);
            secondJoinObserver.addActivePlan(activePlan);
            return activePlan;
        }
    }; });

    Bridge.define("System.Reactive.Joins.Plan$4", function (T1, T2, T3, TResult) { return {
        inherits: [System.Reactive.Joins.Plan$1(TResult)],
        config: {
            properties: {
                Expression: null,
                Selector: null
            }
        },
        ctor: function (expression, selector) {
            this.$initialize();
            System.Reactive.Joins.Plan$1(TResult).ctor.call(this);
            this.setExpression(expression);
            this.setSelector(selector);
        },
        activate: function (externalSubscriptions, observer, deactivate) {
            var onError = Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"]);
            var firstJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T1, externalSubscriptions, this.getExpression().getFirst(), onError);
            var secondJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T2, externalSubscriptions, this.getExpression().getSecond(), onError);
            var thirdJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T3, externalSubscriptions, this.getExpression().getThird(), onError);
            var activePlan = null;

            activePlan = new (System.Reactive.Joins.ActivePlan$3(T1,T2,T3))(firstJoinObserver, secondJoinObserver, thirdJoinObserver, Bridge.fn.bind(this, function (first, second, third) {
                var result = Bridge.getDefaultValue(TResult);
                try {
                    result = this.getSelector()(first, second, third);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                    return;
                }
                observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            }), function () {
                firstJoinObserver.removeActivePlan(activePlan);
                secondJoinObserver.removeActivePlan(activePlan);
                thirdJoinObserver.removeActivePlan(activePlan);
                deactivate(activePlan);
            });

            firstJoinObserver.addActivePlan(activePlan);
            secondJoinObserver.addActivePlan(activePlan);
            thirdJoinObserver.addActivePlan(activePlan);
            return activePlan;
        }
    }; });

    Bridge.define("System.Reactive.Joins.Plan$5", function (T1, T2, T3, T4, TResult) { return {
        inherits: [System.Reactive.Joins.Plan$1(TResult)],
        config: {
            properties: {
                Expression: null,
                Selector: null
            }
        },
        ctor: function (expression, selector) {
            this.$initialize();
            System.Reactive.Joins.Plan$1(TResult).ctor.call(this);
            this.setExpression(expression);
            this.setSelector(selector);
        },
        activate: function (externalSubscriptions, observer, deactivate) {
            var onError = Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"]);
            var firstJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T1, externalSubscriptions, this.getExpression().getFirst(), onError);
            var secondJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T2, externalSubscriptions, this.getExpression().getSecond(), onError);
            var thirdJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T3, externalSubscriptions, this.getExpression().getThird(), onError);
            var fourthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T4, externalSubscriptions, this.getExpression().getFourth(), onError);
            var activePlan = null;

            activePlan = new (System.Reactive.Joins.ActivePlan$4(T1,T2,T3,T4))(firstJoinObserver, secondJoinObserver, thirdJoinObserver, fourthJoinObserver, Bridge.fn.bind(this, function (first, second, third, fourth) {
                var result = Bridge.getDefaultValue(TResult);
                try {
                    result = this.getSelector()(first, second, third, fourth);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                    return;
                }
                observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            }), function () {
                firstJoinObserver.removeActivePlan(activePlan);
                secondJoinObserver.removeActivePlan(activePlan);
                thirdJoinObserver.removeActivePlan(activePlan);
                fourthJoinObserver.removeActivePlan(activePlan);
                deactivate(activePlan);
            });

            firstJoinObserver.addActivePlan(activePlan);
            secondJoinObserver.addActivePlan(activePlan);
            thirdJoinObserver.addActivePlan(activePlan);
            fourthJoinObserver.addActivePlan(activePlan);
            return activePlan;
        }
    }; });

    Bridge.define("System.Reactive.Joins.Plan$6", function (T1, T2, T3, T4, T5, TResult) { return {
        inherits: [System.Reactive.Joins.Plan$1(TResult)],
        config: {
            properties: {
                Expression: null,
                Selector: null
            }
        },
        ctor: function (expression, selector) {
            this.$initialize();
            System.Reactive.Joins.Plan$1(TResult).ctor.call(this);
            this.setExpression(expression);
            this.setSelector(selector);
        },
        activate: function (externalSubscriptions, observer, deactivate) {
            var onError = Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"]);
            var firstJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T1, externalSubscriptions, this.getExpression().getFirst(), onError);
            var secondJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T2, externalSubscriptions, this.getExpression().getSecond(), onError);
            var thirdJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T3, externalSubscriptions, this.getExpression().getThird(), onError);
            var fourthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T4, externalSubscriptions, this.getExpression().getFourth(), onError);
            var fifthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T5, externalSubscriptions, this.getExpression().getFifth(), onError);
            var activePlan = null;

            activePlan = new (System.Reactive.Joins.ActivePlan$5(T1,T2,T3,T4,T5))(firstJoinObserver, secondJoinObserver, thirdJoinObserver, fourthJoinObserver, fifthJoinObserver, Bridge.fn.bind(this, function (first, second, third, fourth, fifth) {
                var result = Bridge.getDefaultValue(TResult);
                try {
                    result = this.getSelector()(first, second, third, fourth, fifth);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                    return;
                }
                observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            }), function () {
                firstJoinObserver.removeActivePlan(activePlan);
                secondJoinObserver.removeActivePlan(activePlan);
                thirdJoinObserver.removeActivePlan(activePlan);
                fourthJoinObserver.removeActivePlan(activePlan);
                fifthJoinObserver.removeActivePlan(activePlan);
                deactivate(activePlan);
            });

            firstJoinObserver.addActivePlan(activePlan);
            secondJoinObserver.addActivePlan(activePlan);
            thirdJoinObserver.addActivePlan(activePlan);
            fourthJoinObserver.addActivePlan(activePlan);
            fifthJoinObserver.addActivePlan(activePlan);
            return activePlan;
        }
    }; });

    Bridge.define("System.Reactive.Joins.Plan$7", function (T1, T2, T3, T4, T5, T6, TResult) { return {
        inherits: [System.Reactive.Joins.Plan$1(TResult)],
        config: {
            properties: {
                Expression: null,
                Selector: null
            }
        },
        ctor: function (expression, selector) {
            this.$initialize();
            System.Reactive.Joins.Plan$1(TResult).ctor.call(this);
            this.setExpression(expression);
            this.setSelector(selector);
        },
        activate: function (externalSubscriptions, observer, deactivate) {
            var onError = Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"]);
            var firstJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T1, externalSubscriptions, this.getExpression().getFirst(), onError);
            var secondJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T2, externalSubscriptions, this.getExpression().getSecond(), onError);
            var thirdJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T3, externalSubscriptions, this.getExpression().getThird(), onError);
            var fourthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T4, externalSubscriptions, this.getExpression().getFourth(), onError);
            var fifthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T5, externalSubscriptions, this.getExpression().getFifth(), onError);
            var sixthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T6, externalSubscriptions, this.getExpression().getSixth(), onError);
            var activePlan = null;

            activePlan = new (System.Reactive.Joins.ActivePlan$6(T1,T2,T3,T4,T5,T6))(firstJoinObserver, secondJoinObserver, thirdJoinObserver, fourthJoinObserver, fifthJoinObserver, sixthJoinObserver, Bridge.fn.bind(this, function (first, second, third, fourth, fifth, sixth) {
                var result = Bridge.getDefaultValue(TResult);
                try {
                    result = this.getSelector()(first, second, third, fourth, fifth, sixth);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                    return;
                }
                observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            }), function () {
                firstJoinObserver.removeActivePlan(activePlan);
                secondJoinObserver.removeActivePlan(activePlan);
                thirdJoinObserver.removeActivePlan(activePlan);
                fourthJoinObserver.removeActivePlan(activePlan);
                fifthJoinObserver.removeActivePlan(activePlan);
                sixthJoinObserver.removeActivePlan(activePlan);
                deactivate(activePlan);
            });

            firstJoinObserver.addActivePlan(activePlan);
            secondJoinObserver.addActivePlan(activePlan);
            thirdJoinObserver.addActivePlan(activePlan);
            fourthJoinObserver.addActivePlan(activePlan);
            fifthJoinObserver.addActivePlan(activePlan);
            sixthJoinObserver.addActivePlan(activePlan);
            return activePlan;
        }
    }; });

    Bridge.define("System.Reactive.Joins.Plan$8", function (T1, T2, T3, T4, T5, T6, T7, TResult) { return {
        inherits: [System.Reactive.Joins.Plan$1(TResult)],
        config: {
            properties: {
                Expression: null,
                Selector: null
            }
        },
        ctor: function (expression, selector) {
            this.$initialize();
            System.Reactive.Joins.Plan$1(TResult).ctor.call(this);
            this.setExpression(expression);
            this.setSelector(selector);
        },
        activate: function (externalSubscriptions, observer, deactivate) {
            var onError = Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"]);
            var firstJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T1, externalSubscriptions, this.getExpression().getFirst(), onError);
            var secondJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T2, externalSubscriptions, this.getExpression().getSecond(), onError);
            var thirdJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T3, externalSubscriptions, this.getExpression().getThird(), onError);
            var fourthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T4, externalSubscriptions, this.getExpression().getFourth(), onError);
            var fifthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T5, externalSubscriptions, this.getExpression().getFifth(), onError);
            var sixthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T6, externalSubscriptions, this.getExpression().getSixth(), onError);
            var seventhJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T7, externalSubscriptions, this.getExpression().getSeventh(), onError);
            var activePlan = null;

            activePlan = new (System.Reactive.Joins.ActivePlan$7(T1,T2,T3,T4,T5,T6,T7))(firstJoinObserver, secondJoinObserver, thirdJoinObserver, fourthJoinObserver, fifthJoinObserver, sixthJoinObserver, seventhJoinObserver, Bridge.fn.bind(this, function (first, second, third, fourth, fifth, sixth, seventh) {
                var result = Bridge.getDefaultValue(TResult);
                try {
                    result = this.getSelector()(first, second, third, fourth, fifth, sixth, seventh);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                    return;
                }
                observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            }), function () {
                firstJoinObserver.removeActivePlan(activePlan);
                secondJoinObserver.removeActivePlan(activePlan);
                thirdJoinObserver.removeActivePlan(activePlan);
                fourthJoinObserver.removeActivePlan(activePlan);
                fifthJoinObserver.removeActivePlan(activePlan);
                sixthJoinObserver.removeActivePlan(activePlan);
                seventhJoinObserver.removeActivePlan(activePlan);
                deactivate(activePlan);
            });

            firstJoinObserver.addActivePlan(activePlan);
            secondJoinObserver.addActivePlan(activePlan);
            thirdJoinObserver.addActivePlan(activePlan);
            fourthJoinObserver.addActivePlan(activePlan);
            fifthJoinObserver.addActivePlan(activePlan);
            sixthJoinObserver.addActivePlan(activePlan);
            seventhJoinObserver.addActivePlan(activePlan);
            return activePlan;
        }
    }; });

    Bridge.define("System.Reactive.Joins.Plan$9", function (T1, T2, T3, T4, T5, T6, T7, T8, TResult) { return {
        inherits: [System.Reactive.Joins.Plan$1(TResult)],
        config: {
            properties: {
                Expression: null,
                Selector: null
            }
        },
        ctor: function (expression, selector) {
            this.$initialize();
            System.Reactive.Joins.Plan$1(TResult).ctor.call(this);
            this.setExpression(expression);
            this.setSelector(selector);
        },
        activate: function (externalSubscriptions, observer, deactivate) {
            var onError = Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"]);
            var firstJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T1, externalSubscriptions, this.getExpression().getFirst(), onError);
            var secondJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T2, externalSubscriptions, this.getExpression().getSecond(), onError);
            var thirdJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T3, externalSubscriptions, this.getExpression().getThird(), onError);
            var fourthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T4, externalSubscriptions, this.getExpression().getFourth(), onError);
            var fifthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T5, externalSubscriptions, this.getExpression().getFifth(), onError);
            var sixthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T6, externalSubscriptions, this.getExpression().getSixth(), onError);
            var seventhJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T7, externalSubscriptions, this.getExpression().getSeventh(), onError);
            var eighthJoinObserver = System.Reactive.Joins.Plan$1(TResult).createObserver(T8, externalSubscriptions, this.getExpression().getEighth(), onError);
            var activePlan = null;

            activePlan = new (System.Reactive.Joins.ActivePlan$8(T1,T2,T3,T4,T5,T6,T7,T8))(firstJoinObserver, secondJoinObserver, thirdJoinObserver, fourthJoinObserver, fifthJoinObserver, sixthJoinObserver, seventhJoinObserver, eighthJoinObserver, Bridge.fn.bind(this, function (first, second, third, fourth, fifth, sixth, seventh, eighth) {
                var result = Bridge.getDefaultValue(TResult);
                try {
                    result = this.getSelector()(first, second, third, fourth, fifth, sixth, seventh, eighth);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                    return;
                }
                observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            }), function () {
                firstJoinObserver.removeActivePlan(activePlan);
                secondJoinObserver.removeActivePlan(activePlan);
                thirdJoinObserver.removeActivePlan(activePlan);
                fourthJoinObserver.removeActivePlan(activePlan);
                fifthJoinObserver.removeActivePlan(activePlan);
                sixthJoinObserver.removeActivePlan(activePlan);
                seventhJoinObserver.removeActivePlan(activePlan);
                eighthJoinObserver.removeActivePlan(activePlan);
                deactivate(activePlan);
            });

            firstJoinObserver.addActivePlan(activePlan);
            secondJoinObserver.addActivePlan(activePlan);
            thirdJoinObserver.addActivePlan(activePlan);
            fourthJoinObserver.addActivePlan(activePlan);
            fifthJoinObserver.addActivePlan(activePlan);
            sixthJoinObserver.addActivePlan(activePlan);
            seventhJoinObserver.addActivePlan(activePlan);
            eighthJoinObserver.addActivePlan(activePlan);
            return activePlan;
        }
    }; });

    Bridge.define("System.Reactive.Linq.DefaultQueryServices", {
        inherits: [System.Reactive.Linq.IQueryServices],
        config: {
            alias: [
            "extend", "System$Reactive$Linq$IQueryServices$extend"
            ]
        },
        extend: function (T, baseImpl) {
            return baseImpl;
        }
    });

    /**
     * Represents an observable sequence of elements that have a common key.
     *
     * @abstract
     * @public
     * @class System.Reactive.Linq.IGroupedObservable$2
     * @implements  System.IObservable$1
     * @param   {Function}    [name]    The type of the key shared by all elements in the group.
     This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see Covariance and Contravariance in Generics.
     * @param   {Function}    [name]    The type of the elements in the group.
     This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see Covariance and Contravariance in Generics.
     */
    Bridge.definei("System.Reactive.Linq.IGroupedObservable$2", function (TKey, TElement) { return {
        inherits: [System.IObservable$1(TElement)],
        $kind: "interface",
        $variance: [1,1]
    }; });

    /**
     * Provides functionality to evaluate queries against a specific data source wherein the type of the data is known.
     *
     * @abstract
     * @public
     * @class System.Reactive.Linq.IQbservable$1
     * @implements  System.Reactive.Linq.IQbservable
     * @implements  System.IObservable$1
     * @param   {Function}    [name]    The type of the data in the data source.
     This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see Covariance and Contravariance in Generics.
     */
    Bridge.definei("System.Reactive.Linq.IQbservable$1", function (T) { return {
        inherits: [System.Reactive.Linq.IQbservable,System.IObservable$1(T)],
        $kind: "interface",
        $variance: [1]
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AddRef$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Aggregate$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _accumulation: Bridge.getDefaultValue(TSource),
        _hasAccumulation: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._accumulation = Bridge.getDefaultValue(TSource);
            this._hasAccumulation = false;
        },
        onNext: function (value) {
            if (!this._hasAccumulation) {
                this._accumulation = value;
                this._hasAccumulation = true;
            } else {
                try {
                    this._accumulation = this._parent._accumulator(this._accumulation, value);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](exception);
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                }
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._hasAccumulation) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            } else {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._accumulation);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Aggregate$3._", function (TSource, TAccumulate, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.IObserver$1(TSource)],
        _parent: null,
        _accumulation: Bridge.getDefaultValue(TAccumulate),
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._accumulation = this._parent._seed;
        },
        onNext: function (value) {
            try {
                this._accumulation = this._parent._accumulator(this._accumulation, value);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        },
        onCompleted: function () {
            var result = Bridge.getDefaultValue(TResult);
            try {
                result = this._parent._resultSelector(this._accumulation);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return;
            }

            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.All$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(Boolean),System.IObserver$1(TSource)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(Boolean).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        onNext: function (value) {
            var res = false;
            try {
                res = this._parent._predicate(value);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer.System$IObserver$1$Boolean$onError(ex);
                System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
                return;
            }

            if (!res) {
                this._observer.System$IObserver$1$Boolean$onNext(false);
                this._observer.System$IObserver$1$Boolean$onCompleted();
                System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$Boolean$onError(error);
            System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$Boolean$onNext(true);
            this._observer.System$IObserver$1$Boolean$onCompleted();
            System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Amb$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource)],
        _parent: null,
        _choice: 0,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var ls = new System.Reactive.Disposables.SingleAssignmentDisposable();
            var rs = new System.Reactive.Disposables.SingleAssignmentDisposable();
            var d = System.Reactive.Disposables.StableCompositeDisposable.create$1(ls, rs);

            var gate = {  };

            var lo = new (System.Reactive.Linq.ObservableImpl.Amb$1._.AmbObserver(TSource))();
            lo._disposable = d;
            lo._target = new (System.Reactive.Linq.ObservableImpl.Amb$1._.DecisionObserver(TSource))(this, gate, System.Reactive.Linq.ObservableImpl.Amb$1._.AmbState(TSource).Left, ls, rs, lo);

            var ro = new (System.Reactive.Linq.ObservableImpl.Amb$1._.AmbObserver(TSource))();
            ro._disposable = d;
            ro._target = new (System.Reactive.Linq.ObservableImpl.Amb$1._.DecisionObserver(TSource))(this, gate, System.Reactive.Linq.ObservableImpl.Amb$1._.AmbState(TSource).Right, rs, ls, ro);

            this._choice = System.Reactive.Linq.ObservableImpl.Amb$1._.AmbState(TSource).Neither;

            ls.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._left, lo));
            rs.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._right, ro));

            return d;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Amb$1._.AmbObserver", function (TSource) { return {
        inherits: [System.IObserver$1(TSource)],
        _target: null,
        _disposable: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        onNext: function (value) {
            this._target["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._target["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            this._disposable.System$IDisposable$dispose();
        },
        onCompleted: function () {
            this._target["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            this._disposable.System$IDisposable$dispose();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Amb$1._.DecisionObserver", function (TSource) { return {
        inherits: [System.IObserver$1(TSource)],
        _parent: null,
        _me: 0,
        _subscription: null,
        _otherSubscription: null,
        _gate: null,
        _observer: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, gate, me, subscription, otherSubscription, observer) {
            this.$initialize();
            this._parent = parent;
            this._gate = gate;
            this._me = me;
            this._subscription = subscription;
            this._otherSubscription = otherSubscription;
            this._observer = observer;
        },
        onNext: function (value) {
            this._gate;
            {
                if (this._parent._choice === System.Reactive.Linq.ObservableImpl.Amb$1._.AmbState(TSource).Neither) {
                    this._parent._choice = this._me;
                    this._otherSubscription.System$IDisposable$dispose();
                    this._observer._disposable = this._subscription;
                    this._observer._target = this._parent._observer;
                }

                if (this._parent._choice === this._me) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
                }
            }
        },
        onError: function (error) {
            this._gate;
            {
                if (this._parent._choice === System.Reactive.Linq.ObservableImpl.Amb$1._.AmbState(TSource).Neither) {
                    this._parent._choice = this._me;
                    this._otherSubscription.System$IDisposable$dispose();
                    this._observer._disposable = this._subscription;
                    this._observer._target = this._parent._observer;
                }

                if (this._parent._choice === this._me) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                    this._parent.dispose();
                }
            }
        },
        onCompleted: function () {
            this._gate;
            {
                if (this._parent._choice === System.Reactive.Linq.ObservableImpl.Amb$1._.AmbState(TSource).Neither) {
                    this._parent._choice = this._me;
                    this._otherSubscription.System$IDisposable$dispose();
                    this._observer._disposable = this._subscription;
                    this._observer._target = this._parent._observer;
                }

                if (this._parent._choice === this._me) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    this._parent.dispose();
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Any$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(Boolean),System.IObserver$1(TSource)],
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(Boolean).ctor.call(this, observer, cancel);
        },
        onNext: function (value) {
            this._observer.System$IObserver$1$Boolean$onNext(true);
            this._observer.System$IObserver$1$Boolean$onCompleted();
            System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
        },
        onError: function (error) {
            this._observer.System$IObserver$1$Boolean$onError(error);
            System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$Boolean$onNext(false);
            this._observer.System$IObserver$1$Boolean$onCompleted();
            System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Any$1.AnyImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(Boolean),System.IObserver$1(TSource)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(Boolean).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        onNext: function (value) {
            var res = false;
            try {
                res = this._parent._predicate(value);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer.System$IObserver$1$Boolean$onError(ex);
                System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
                return;
            }

            if (res) {
                this._observer.System$IObserver$1$Boolean$onNext(true);
                this._observer.System$IObserver$1$Boolean$onCompleted();
                System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$Boolean$onError(error);
            System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$Boolean$onNext(false);
            this._observer.System$IObserver$1$Boolean$onCompleted();
            System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AsObservable$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageDecimal._", {
        inherits: [System.Reactive.Sink$1(System.Decimal),System.IObserver$1(System.Decimal)],
        _sum: System.Decimal(0.0),
        _count: System.Int64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Decimal$onNext",
            "onError", "System$IObserver$1$System$Decimal$onError",
            "onCompleted", "System$IObserver$1$System$Decimal$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Decimal).ctor.call(this, observer, cancel);
            this._sum = System.Decimal(0.0);
            this._count = System.Int64(0);
        },
        onNext: function (value) {
            try {
                this._sum = this._sum.add(value);
                this._count = this._count.inc(1);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer.System$IObserver$1$System$Decimal$onError(ex);
                System.Reactive.Sink$1(System.Decimal).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Decimal$onError(error);
            System.Reactive.Sink$1(System.Decimal).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (this._count.gt(System.Int64(0))) {
                this._observer.System$IObserver$1$System$Decimal$onNext(this._sum.div(System.Decimal(this._count)));
                this._observer.System$IObserver$1$System$Decimal$onCompleted();
            } else {
                this._observer.System$IObserver$1$System$Decimal$onError(new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            }

            System.Reactive.Sink$1(System.Decimal).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageDecimalNullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Decimal)),System.IObserver$1(System.Nullable$1(System.Decimal))],
        _sum: System.Decimal(0.0),
        _count: System.Int64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Decimal$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Decimal$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Decimal$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Decimal)).ctor.call(this, observer, cancel);
            this._sum = System.Decimal(0.0);
            this._count = System.Int64(0);
        },
        onNext: function (value) {
            try {
                if (System.Nullable.liftne("ne", value, System.Decimal.lift(null))) {
                    this._sum = this._sum.add(System.Nullable.getValue(value));
                    this._count = this._count.inc(1);
                }
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer.System$IObserver$1$System$Nullable$1$System$Decimal$onError(ex);
                System.Reactive.Sink$1(System.Nullable$1(System.Decimal)).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Decimal$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Decimal)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (this._count.gt(System.Int64(0))) {
                this._observer.System$IObserver$1$System$Nullable$1$System$Decimal$onNext(this._sum.div(System.Decimal(this._count)));
            } else {
                this._observer.System$IObserver$1$System$Nullable$1$System$Decimal$onNext(System.Decimal.lift(null));
            }

            this._observer.System$IObserver$1$System$Nullable$1$System$Decimal$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Decimal)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageDouble._", {
        inherits: [System.Reactive.Sink$1(System.Double),System.IObserver$1(System.Double)],
        _sum: 0,
        _count: System.Int64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Double$onNext",
            "onError", "System$IObserver$1$System$Double$onError",
            "onCompleted", "System$IObserver$1$System$Double$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Double).ctor.call(this, observer, cancel);
            this._sum = 0.0;
            this._count = System.Int64(0);
        },
        onNext: function (value) {
            try {
                this._sum += value;
                this._count = this._count.inc(1);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer.System$IObserver$1$System$Double$onError(ex);
                System.Reactive.Sink$1(System.Double).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Double$onError(error);
            System.Reactive.Sink$1(System.Double).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (this._count.gt(System.Int64(0))) {
                this._observer.System$IObserver$1$System$Double$onNext(this._sum / System.Int64.toNumber(this._count));
                this._observer.System$IObserver$1$System$Double$onCompleted();
            } else {
                this._observer.System$IObserver$1$System$Double$onError(new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            }

            System.Reactive.Sink$1(System.Double).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageDoubleNullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Double)),System.IObserver$1(System.Nullable$1(System.Double))],
        _sum: 0,
        _count: System.Int64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Double$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Double$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Double$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).ctor.call(this, observer, cancel);
            this._sum = 0.0;
            this._count = System.Int64(0);
        },
        onNext: function (value) {
            try {
                if (value != null) {
                    this._sum += System.Nullable.getValue(value);
                    this._count = this._count.inc(1);
                }
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer.System$IObserver$1$System$Nullable$1$System$Double$onError(ex);
                System.Reactive.Sink$1(System.Nullable$1(System.Double)).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Double$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (this._count.gt(System.Int64(0))) {
                this._observer.System$IObserver$1$System$Nullable$1$System$Double$onNext(this._sum / System.Int64.toNumber(this._count));
            } else {
                this._observer.System$IObserver$1$System$Nullable$1$System$Double$onNext(null);
            }

            this._observer.System$IObserver$1$System$Nullable$1$System$Double$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageInt32._", {
        inherits: [System.Reactive.Sink$1(System.Double),System.IObserver$1(System.Int32)],
        _sum: System.Int64(0),
        _count: System.Int64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Int32$onNext",
            "onError", "System$IObserver$1$System$Int32$onError",
            "onCompleted", "System$IObserver$1$System$Int32$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Double).ctor.call(this, observer, cancel);
            this._sum = System.Int64(0);
            this._count = System.Int64(0);
        },
        onNext: function (value) {
            try {
                this._sum = this._sum.add(System.Int64(value), 1);
                this._count = this._count.inc(1);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer.System$IObserver$1$System$Double$onError(ex);
                System.Reactive.Sink$1(System.Double).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Double$onError(error);
            System.Reactive.Sink$1(System.Double).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (this._count.gt(System.Int64(0))) {
                this._observer.System$IObserver$1$System$Double$onNext(this._sum / System.Int64.toNumber(this._count));
                this._observer.System$IObserver$1$System$Double$onCompleted();
            } else {
                this._observer.System$IObserver$1$System$Double$onError(new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            }

            System.Reactive.Sink$1(System.Double).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageInt32Nullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Double)),System.IObserver$1(System.Nullable$1(System.Int32))],
        _sum: System.Int64(0),
        _count: System.Int64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Int32$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Int32$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Int32$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).ctor.call(this, observer, cancel);
            this._sum = System.Int64(0);
            this._count = System.Int64(0);
        },
        onNext: function (value) {
            try {
                if (value != null) {
                    this._sum = this._sum.add(System.Int64(System.Nullable.getValue(value)), 1);
                    this._count = this._count.inc(1);
                }
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer.System$IObserver$1$System$Nullable$1$System$Double$onError(ex);
                System.Reactive.Sink$1(System.Nullable$1(System.Double)).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Double$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (this._count.gt(System.Int64(0))) {
                this._observer.System$IObserver$1$System$Nullable$1$System$Double$onNext(this._sum / System.Int64.toNumber(this._count));
            } else {
                this._observer.System$IObserver$1$System$Nullable$1$System$Double$onNext(null);
            }

            this._observer.System$IObserver$1$System$Nullable$1$System$Double$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageInt64._", {
        inherits: [System.Reactive.Sink$1(System.Double),System.IObserver$1(System.Int64)],
        _sum: System.Int64(0),
        _count: System.Int64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Int64$onNext",
            "onError", "System$IObserver$1$System$Int64$onError",
            "onCompleted", "System$IObserver$1$System$Int64$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Double).ctor.call(this, observer, cancel);
            this._sum = System.Int64(0);
            this._count = System.Int64(0);
        },
        onNext: function (value) {
            try {
                this._sum = this._sum.add(value, 1);
                this._count = this._count.inc(1);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer.System$IObserver$1$System$Double$onError(ex);
                System.Reactive.Sink$1(System.Double).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Double$onError(error);
            System.Reactive.Sink$1(System.Double).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (this._count.gt(System.Int64(0))) {
                this._observer.System$IObserver$1$System$Double$onNext(this._sum / System.Int64.toNumber(this._count));
                this._observer.System$IObserver$1$System$Double$onCompleted();
            } else {
                this._observer.System$IObserver$1$System$Double$onError(new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            }

            System.Reactive.Sink$1(System.Double).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageInt64Nullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Double)),System.IObserver$1(System.Nullable$1(System.Int64))],
        _sum: System.Int64(0),
        _count: System.Int64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Int64$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Int64$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Int64$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).ctor.call(this, observer, cancel);
            this._sum = System.Int64(0);
            this._count = System.Int64(0);
        },
        onNext: function (value) {
            try {
                if (System.Nullable.liftne("ne", value, System.Int64.lift(null))) {
                    this._sum = this._sum.add(System.Nullable.getValue(value), 1);
                    this._count = this._count.inc(1);
                }
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer.System$IObserver$1$System$Nullable$1$System$Double$onError(ex);
                System.Reactive.Sink$1(System.Nullable$1(System.Double)).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Double$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (this._count.gt(System.Int64(0))) {
                this._observer.System$IObserver$1$System$Nullable$1$System$Double$onNext(this._sum / System.Int64.toNumber(this._count));
            } else {
                this._observer.System$IObserver$1$System$Nullable$1$System$Double$onNext(null);
            }

            this._observer.System$IObserver$1$System$Nullable$1$System$Double$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageSingle._", {
        inherits: [System.Reactive.Sink$1(System.Single),System.IObserver$1(System.Single)],
        _sum: 0,
        _count: System.Int64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Single$onNext",
            "onError", "System$IObserver$1$System$Single$onError",
            "onCompleted", "System$IObserver$1$System$Single$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Single).ctor.call(this, observer, cancel);
            this._sum = 0.0;
            this._count = System.Int64(0);
        },
        onNext: function (value) {
            try {
                this._sum += value;
                this._count = this._count.inc(1);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer.System$IObserver$1$System$Single$onError(ex);
                System.Reactive.Sink$1(System.Single).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Single$onError(error);
            System.Reactive.Sink$1(System.Single).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (this._count.gt(System.Int64(0))) {
                this._observer.System$IObserver$1$System$Single$onNext((this._sum / System.Int64.toNumber(this._count)));
                this._observer.System$IObserver$1$System$Single$onCompleted();
            } else {
                this._observer.System$IObserver$1$System$Single$onError(new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            }

            System.Reactive.Sink$1(System.Single).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageSingleNullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Single)),System.IObserver$1(System.Nullable$1(System.Single))],
        _sum: 0,
        _count: System.Int64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Single$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Single$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Single$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Single)).ctor.call(this, observer, cancel);
            this._sum = 0.0;
            this._count = System.Int64(0);
        },
        onNext: function (value) {
            try {
                if (value != null) {
                    this._sum += System.Nullable.getValue(value);
                    this._count = this._count.inc(1);
                }
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer.System$IObserver$1$System$Nullable$1$System$Single$onError(ex);
                System.Reactive.Sink$1(System.Nullable$1(System.Single)).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Single$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Single)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (this._count.gt(System.Int64(0))) {
                this._observer.System$IObserver$1$System$Nullable$1$System$Single$onNext((this._sum / System.Int64.toNumber(this._count)));
            } else {
                this._observer.System$IObserver$1$System$Nullable$1$System$Single$onNext(null);
            }

            this._observer.System$IObserver$1$System$Nullable$1$System$Single$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Single)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Buffer$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        _queue: null,
        _n: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._queue = new (System.Collections.Generic.Queue$1(System.Collections.Generic.IList$1(TSource))).ctor();
            this._n = 0;

            this.createWindow();
            return System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this);
        },
        createWindow: function () {
            var s = new (System.Collections.Generic.List$1(TSource))();
            this._queue.enqueue(s);
        },
        onNext: function (value) {
            var $t;
            $t = Bridge.getEnumerator(this._queue);
            while ($t.moveNext()) {
                var s = $t.getCurrent();
                System.Array.add(s, value, TSource);
            }

            var c = (((this._n - this._parent._count) | 0) + 1) | 0;
            if (c >= 0 && c % this._parent._skip === 0) {
                var s1 = this._queue.dequeue();
                if (System.Array.getCount(s1, TSource) > 0) {
                    this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](s1);
                }
            }

            this._n = (this._n + 1) | 0;
            if (this._n % this._parent._skip === 0) {
                this.createWindow();
            }
        },
        onError: function (error) {
            while (this._queue.getCount() > 0) {
                System.Array.clear(this._queue.dequeue(), TSource);
            }

            this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            while (this._queue.getCount() > 0) {
                var s = this._queue.dequeue();
                if (System.Array.getCount(s, TSource) > 0) {
                    this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](s);
                }
            }

            this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Buffer$1.BufferImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        _q: null,
        _timerD: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ],
            init: function () {
                this._totalTime = new System.TimeSpan();
                this._nextShift = new System.TimeSpan();
                this._nextSpan = new System.TimeSpan();
            }
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._totalTime = System.TimeSpan.zero;
            this._nextShift = this._parent._timeShift;
            this._nextSpan = this._parent._timeSpan;

            this._gate = {  };
            this._q = new (System.Collections.Generic.Queue$1(System.Collections.Generic.List$1(TSource))).ctor();

            this._timerD = new System.Reactive.Disposables.SerialDisposable();

            this.createWindow();
            this.createTimer();

            var subscription = System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this);

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(this._timerD, subscription);
        },
        createWindow: function () {
            var s = new (System.Collections.Generic.List$1(TSource))();
            this._q.enqueue(s);
        },
        createTimer: function () {
            var m = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._timerD.setDisposable(m);

            var isSpan = false;
            var isShift = false;
            if (System.TimeSpan.eq(this._nextSpan, this._nextShift)) {
                isSpan = true;
                isShift = true;
            } else if (System.TimeSpan.lt(this._nextSpan, this._nextShift)) {
                isSpan = true;
            } else {
                isShift = true;
            }

            var newTotalTime = isSpan ? this._nextSpan : this._nextShift;
            var ts = System.TimeSpan.sub(newTotalTime, this._totalTime);
            this._totalTime = newTotalTime;

            if (isSpan) {
                this._nextSpan = System.TimeSpan.add(this._nextSpan, this._parent._timeShift);
            }
            if (isShift) {
                this._nextShift = System.TimeSpan.add(this._nextShift, this._parent._timeShift);
            }

            m.setDisposable(this._parent._scheduler.System$Reactive$Concurrency$IScheduler$schedule$2(System.Reactive.Linq.ObservableImpl.Buffer$1.BufferImpl.State(TSource), Bridge.merge(new (System.Reactive.Linq.ObservableImpl.Buffer$1.BufferImpl.State(TSource))(), {
                isSpan: isSpan,
                isShift: isShift
            } ), ts, Bridge.fn.bind(this, this.tick)));
        },
        tick: function (self, state) {
            this._gate;
            {
                //
                // Before v2, the two operations below were reversed. This doesn't have an observable
                // difference for Buffer, but is done to keep code consistent with Window, where we
                // took a breaking change in v2 to ensure consistency across overloads. For more info,
                // see the comment in Tick for Window.
                //
                if (state.isSpan) {
                    var s = this._q.dequeue();
                    this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](s);
                }

                if (state.isShift) {
                    this.createWindow();
                }
            }

            this.createTimer();

            return System.Reactive.Disposables.Disposable.getEmpty();
        },
        onNext: function (value) {
            var $t;
            this._gate;
            {
                $t = Bridge.getEnumerator(this._q);
                while ($t.moveNext()) {
                    var s = $t.getCurrent();
                    s.add(value);
                }
            }
        },
        onError: function (error) {
            this._gate;
            {
                while (this._q.getCount() > 0) {
                    this._q.dequeue().clear();
                }

                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._gate;
            {
                while (this._q.getCount() > 0) {
                    this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._q.dequeue());
                }

                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Buffer$1.BufferTimeShift", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        _list: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };
            this._list = new (System.Collections.Generic.List$1(TSource))();

            var d = System.Reactive.Concurrency.Scheduler.schedulePeriodic(this._parent._scheduler, this._parent._timeSpan, Bridge.fn.bind(this, this.tick));
            var s = System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this);

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(d, s);
        },
        tick: function () {
            this._gate;
            {
                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._list);
                this._list = new (System.Collections.Generic.List$1(TSource))();
            }
        },
        onNext: function (value) {
            this._gate;
            {
                this._list.add(value);
            }
        },
        onError: function (error) {
            this._gate;
            {
                this._list.clear();

                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._gate;
            {
                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._list);
                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Buffer$1.Impl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        _s: null,
        _n: 0,
        _windowId: 0,
        _timerD: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };
            this._s = null;
            this._n = 0;
            this._windowId = 0;

            this._timerD = new System.Reactive.Disposables.SerialDisposable();

            this._s = new (System.Collections.Generic.List$1(TSource))();
            this.createTimer(0);

            var subscription = System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this);

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(this._timerD, subscription);
        },
        createTimer: function (id) {
            var m = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._timerD.setDisposable(m);

            m.setDisposable(this._parent._scheduler.System$Reactive$Concurrency$IScheduler$schedule$2(System.Int32, id, this._parent._timeSpan, Bridge.fn.bind(this, this.tick)));
        },
        tick: function (self, id) {
            var d = System.Reactive.Disposables.Disposable.getEmpty();

            var newId = 0;
            this._gate;
            {
                if (id !== this._windowId) {
                    return d;
                }

                this._n = 0;
                newId = ((this._windowId = (this._windowId + 1) | 0));

                var res = this._s;
                this._s = new (System.Collections.Generic.List$1(TSource))();
                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](res);

                this.createTimer(newId);
            }

            return d;
        },
        onNext: function (value) {
            var newWindow = false;
            var newId = 0;

            this._gate;
            {
                System.Array.add(this._s, value, TSource);

                this._n = (this._n + 1) | 0;
                if (this._n === this._parent._count) {
                    newWindow = true;
                    this._n = 0;
                    newId = ((this._windowId = (this._windowId + 1) | 0));

                    var res = this._s;
                    this._s = new (System.Collections.Generic.List$1(TSource))();
                    this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](res);
                }

                if (newWindow) {
                    this.createTimer(newId);
                }
            }
        },
        onError: function (error) {
            this._gate;
            {
                System.Array.clear(this._s, TSource);
                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._gate;
            {
                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._s);
                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Buffer$2._", function (TSource, TBufferClosing) { return {
        inherits: [System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        _buffer: null,
        _gate: null,
        _bufferGate: null,
        _m: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._buffer = new (System.Collections.Generic.List$1(TSource))();
            this._gate = {  };
            this._bufferGate = new System.Reactive.Concurrency.AsyncLock();

            this._m = new System.Reactive.Disposables.SerialDisposable();
            var groupDisposable = Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Buffer$2._.f1)(new System.Reactive.Disposables.CompositeDisposable.$ctor3(2));

            groupDisposable.add(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            this._bufferGate.wait(Bridge.fn.bind(this, this.createBufferClose));

            return groupDisposable;
        },
        createBufferClose: function () {
            var bufferClose = null;
            try {
                bufferClose = this._parent._bufferClosingSelector();
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._gate;
                {
                    this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onError"](exception);
                    System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
                }
                return;
            }

            var closingSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._m.setDisposable(closingSubscription);
            closingSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TBufferClosing, bufferClose, new (System.Reactive.Linq.ObservableImpl.Buffer$2._.Omega(TSource,TBufferClosing))(this, closingSubscription)));
        },
        closeBuffer: function (closingSubscription) {
            closingSubscription.System$IDisposable$dispose();

            this._gate;
            {
                var res = this._buffer;
                this._buffer = new (System.Collections.Generic.List$1(TSource))();
                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](res);
            }

            this._bufferGate.wait(Bridge.fn.bind(this, this.createBufferClose));
        },
        onNext: function (value) {
            this._gate;
            {
                System.Array.add(this._buffer, value, TSource);
            }
        },
        onError: function (error) {
            this._gate;
            {
                System.Array.clear(this._buffer, TSource);
                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._gate;
            {
                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._buffer);
                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
            }
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Buffer$2._", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Buffer$2._, {
        f1: function (_o1) {
            _o1.add(this._m);
            return _o1;
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Buffer$2._.Omega", function (TSource, TBufferClosing) { return {
        inherits: [System.IObserver$1(TBufferClosing)],
        _parent: null,
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TBufferClosing) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TBufferClosing) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TBufferClosing) + "$onCompleted"
            ]
        },
        ctor: function (parent, self) {
            this.$initialize();
            this._parent = parent;
            this._self = self;
        },
        onNext: function (value) {
            this._parent.closeBuffer(this._self);
        },
        onError: function (error) {
            this._parent.onError(error);
        },
        onCompleted: function () {
            this._parent.closeBuffer(this._self);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Buffer$2.Beta", function (TSource, TBufferClosing) { return {
        inherits: [System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        _buffer: null,
        _gate: null,
        _refCountDisposable: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._buffer = new (System.Collections.Generic.List$1(TSource))();
            this._gate = {  };

            var d = new System.Reactive.Disposables.CompositeDisposable.$ctor3(2);
            this._refCountDisposable = new System.Reactive.Disposables.RefCountDisposable.ctor(d);

            d.add(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));
            d.add(System.ObservableExtensions.subscribeSafe(TBufferClosing, this._parent._bufferBoundaries, new (System.Reactive.Linq.ObservableImpl.Buffer$2.Beta.Omega(TSource,TBufferClosing))(this)));

            return this._refCountDisposable;
        },
        onNext: function (value) {
            this._gate;
            {
                System.Array.add(this._buffer, value, TSource);
            }
        },
        onError: function (error) {
            this._gate;
            {
                System.Array.clear(this._buffer, TSource);
                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._gate;
            {
                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._buffer);
                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Buffer$2.Beta.Omega", function (TSource, TBufferClosing) { return {
        inherits: [System.IObserver$1(TBufferClosing)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TBufferClosing) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TBufferClosing) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TBufferClosing) + "$onCompleted"
            ]
        },
        ctor: function (parent) {
            this.$initialize();
            this._parent = parent;
        },
        onNext: function (value) {
            this._parent._gate;
            {
                var res = this._parent._buffer;
                this._parent._buffer = new (System.Collections.Generic.List$1(TSource))();
                this._parent._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](res);
            }
        },
        onError: function (error) {
            this._parent.onError(error);
        },
        onCompleted: function () {
            this._parent.onCompleted();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Case$2._", function (TValue, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.IObserver$1(TResult)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var result = null;
            try {
                result = this._parent.eval();
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return System.Reactive.Disposables.Disposable.getEmpty();
            }

            return System.ObservableExtensions.subscribeSafe(TResult, result, this);
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](value);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Cast$2._", function (TSource, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.IObserver$1(TSource)],
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
        },
        onNext: function (value) {
            var result = Bridge.getDefaultValue(TResult);
            try {
                result = Bridge.cast(value, TResult);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return;
            }

            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Catch$2._", function (TSource, TException) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _subscription: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._subscription = new System.Reactive.Disposables.SerialDisposable();

            var d1 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._subscription.setDisposable(d1);
            d1.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            return this._subscription;
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            var e = Bridge.as(error, TException);
            if (e != null) {
                var result = null;
                try {
                    result = this._parent._handler(e);
                }
                catch (ex) {
                    ex = System.Exception.create(ex);
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex);
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                    return;
                }

                var d = new System.Reactive.Disposables.SingleAssignmentDisposable();
                this._subscription.setDisposable(d);
                d.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, result, new (System.Reactive.Linq.ObservableImpl.Catch$2._.Impl(TSource,TException))(this)));
            } else {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Catch$2._.Impl", function (TSource, TException) { return {
        inherits: [System.IObserver$1(TSource)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent) {
            this.$initialize();
            this._parent = parent;
        },
        onNext: function (value) {
            this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            this._parent.dispose();
        },
        onCompleted: function () {
            this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            this._parent.dispose();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Collect$2", function (TSource, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.PushToPullAdapter$2(TSource,TResult)],
        _getInitialCollector: null,
        _merge: null,
        _getNewCollector: null,
        ctor: function (source, getInitialCollector, merge, getNewCollector) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.PushToPullAdapter$2(TSource,TResult).ctor.call(this, source);
            this._getInitialCollector = getInitialCollector;
            this._merge = merge;
            this._getNewCollector = getNewCollector;
        },
        run: function (subscription) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Collect$2._(TSource,TResult))(this, subscription);
            sink.initialize();
            return sink;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.PushToPullSink$2", function (TSource, TResult) { return {
        inherits: [System.IObserver$1(TSource),System.Collections.Generic.IEnumerator$1(TResult),System.IDisposable],
        _subscription: null,
        _done: false,
        config: {
            properties: {
                Current: Bridge.getDefaultValue(TResult)
            },
            alias: [
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "getCurrent", "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(TResult) + "$getCurrent$1",
            "setCurrent", "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(TResult) + "$setCurrent$1",
            "reset", "System$Collections$IEnumerator$reset",
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function (subscription) {
            this.$initialize();
            this._subscription = subscription;
        },
        System$Collections$IEnumerator$getCurrent: function () {
            return this.getCurrent();
        },
        moveNext: function () {
            if (!this._done) {
                var current = { v : Bridge.getDefaultValue(TResult) };
                if (this.tryMoveNext(current)) {
                    this.setCurrent(current.v);
                    return true;
                } else {
                    this._done = true;
                    this._subscription.System$IDisposable$dispose();
                }
            }

            return false;
        },
        reset: function () {
            throw new System.NotSupportedException();
        },
        dispose: function () {
            this._subscription.System$IDisposable$dispose();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatestSink$1", function (TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.Reactive.Linq.ObservableImpl.ICombineLatest],
        _gate: null,
        _hasValueAll: false,
        _hasValue: null,
        _isDone: null,
        config: {
            alias: [
            "next", "System$Reactive$Linq$ObservableImpl$ICombineLatest$next",
            "fail", "System$Reactive$Linq$ObservableImpl$ICombineLatest$fail",
            "done", "System$Reactive$Linq$ObservableImpl$ICombineLatest$done"
            ]
        },
        ctor: function (arity, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._gate = {  };

            this._hasValue = System.Array.init(arity, false);
            this._isDone = System.Array.init(arity, false);
        },
        next: function (index) {
            var $t;
            if (!this._hasValueAll) {
                this._hasValue[index] = true;

                var hasValueAll = true;
                $t = Bridge.getEnumerator(this._hasValue);
                while ($t.moveNext()) {
                    var hasValue = $t.getCurrent();
                    if (!hasValue) {
                        hasValueAll = false;
                        break;
                    }
                }

                this._hasValueAll = hasValueAll;
            }

            if (this._hasValueAll) {
                var res = Bridge.getDefaultValue(TResult);
                try {
                    res = this.getResult();
                }
                catch (ex) {
                    ex = System.Exception.create(ex);
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                    return;
                }

                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](res);
            } else {
                var allOthersDone = true;
                for (var i = 0; i < this._isDone.length; i = (i + 1) | 0) {
                    if (i !== index && !this._isDone[i]) {
                        allOthersDone = false;
                        break;
                    }
                }

                if (allOthersDone) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                }
            }
        },
        fail: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        },
        done: function (index) {
            var $t;
            this._isDone[index] = true;

            var allDone = true;
            $t = Bridge.getEnumerator(this._isDone);
            while ($t.moveNext()) {
                var isDone = $t.getCurrent();
                if (!isDone) {
                    allDone = false;
                    break;
                }
            }

            if (allDone) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return;
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$2._", function (TSource, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult)],
        _parent: null,
        _gate: null,
        _hasValue: null,
        _hasValueAll: false,
        _values: null,
        _isDone: null,
        _subscriptions: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var srcs = System.Linq.Enumerable.from(this._parent._sources).toArray();

            var N = srcs.length;

            this._hasValue = System.Array.init(N, false);
            this._hasValueAll = false;

            this._values = new (System.Collections.Generic.List$1(TSource))(N);
            for (var i = 0; i < N; i = (i + 1) | 0) {
                this._values.add(Bridge.getDefaultValue(TSource));
            }

            this._isDone = System.Array.init(N, false);

            this._subscriptions = System.Array.init(N, null);

            this._gate = {  };

            for (var i1 = 0; i1 < N; i1 = (i1 + 1) | 0) {
                var j = i1;

                var d = new System.Reactive.Disposables.SingleAssignmentDisposable();
                this._subscriptions[j] = d;

                var o = new (System.Reactive.Linq.ObservableImpl.CombineLatest$2._.O(TSource,TResult))(this, j);
                d.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, srcs[j], o));
            }

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(this._subscriptions);
        },
        onNext: function (index, value) {
            this._gate;
            {
                this._values.setItem(index, value);

                this._hasValue[index] = true;

                if (this._hasValueAll || ((this._hasValueAll = System.Linq.Enumerable.from(this._hasValue).all(System.Reactive.Stubs$1(Boolean).i)))) {
                    var res = Bridge.getDefaultValue(TResult);
                    try {
                        res = this._parent._resultSelector(new (System.Collections.ObjectModel.ReadOnlyCollection$1(TSource))(this._values));
                    }
                    catch (ex) {
                        ex = System.Exception.create(ex);
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                        System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                        return;
                    }

                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](res);
                } else if (System.Linq.Enumerable.from(this._isDone).where(function (x, i) {
                        return i !== index;
                    }).all(System.Reactive.Stubs$1(Boolean).i)) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                    return;
                }
            }
        },
        onError: function (error) {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
            }
        },
        onCompleted: function (index) {
            this._gate;
            {
                this._isDone[index] = true;

                if (System.Linq.Enumerable.from(this._isDone).all(System.Reactive.Stubs$1(Boolean).i)) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                    return;
                } else {
                    this._subscriptions[index].System$IDisposable$dispose();
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$2._.O", function (TSource, TResult) { return {
        inherits: [System.IObserver$1(TSource)],
        _parent: null,
        _index: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, index) {
            this.$initialize();
            this._parent = parent;
            this._index = index;
        },
        onNext: function (value) {
            this._parent.onNext(this._index, value);
        },
        onError: function (error) {
            this._parent.onError(error);
        },
        onCompleted: function () {
            this._parent.onCompleted(this._index);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$3._", function (TFirst, TSecond, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult)],
        _parent: null,
        _gate: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };

            var fstSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            var sndSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();

            var fstO = new (System.Reactive.Linq.ObservableImpl.CombineLatest$3._.F(TFirst,TSecond,TResult))(this, fstSubscription);
            var sndO = new (System.Reactive.Linq.ObservableImpl.CombineLatest$3._.S(TFirst,TSecond,TResult))(this, sndSubscription);

            fstO.setOther(sndO);
            sndO.setOther(fstO);

            fstSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TFirst, this._parent._first, fstO));
            sndSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSecond, this._parent._second, sndO));

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(fstSubscription, sndSubscription);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$3._.F", function (TFirst, TSecond, TResult) { return {
        inherits: [System.IObserver$1(TFirst)],
        _parent: null,
        _self: null,
        _other: null,
        config: {
            properties: {
                HasValue: false,
                Value: Bridge.getDefaultValue(TFirst),
                Done: false
            },
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TFirst) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TFirst) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TFirst) + "$onCompleted"
            ]
        },
        ctor: function (parent, self) {
            this.$initialize();
            this._parent = parent;
            this._self = self;
        },
        setOther: function (value) {
            this._other = value;
        },
        onNext: function (value) {
            this._parent._gate;
            {
                this.setHasValue(true);
                this.setValue(value);

                if (this._other.getHasValue()) {
                    var res = Bridge.getDefaultValue(TResult);
                    try {
                        res = this._parent._parent._resultSelector(value, this._other.getValue());
                    }
                    catch (ex) {
                        ex = System.Exception.create(ex);
                        this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                        this._parent.dispose();
                        return;
                    }

                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](res);
                } else if (this._other.getDone()) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    this._parent.dispose();
                    return;
                }
            }
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._gate;
            {
                this.setDone(true);

                if (this._other.getDone()) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    this._parent.dispose();
                    return;
                } else {
                    this._self.System$IDisposable$dispose();
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$3._.S", function (TFirst, TSecond, TResult) { return {
        inherits: [System.IObserver$1(TSecond)],
        _parent: null,
        _self: null,
        _other: null,
        config: {
            properties: {
                HasValue: false,
                Value: Bridge.getDefaultValue(TSecond),
                Done: false
            },
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSecond) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSecond) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSecond) + "$onCompleted"
            ]
        },
        ctor: function (parent, self) {
            this.$initialize();
            this._parent = parent;
            this._self = self;
        },
        setOther: function (value) {
            this._other = value;
        },
        onNext: function (value) {
            this._parent._gate;
            {
                this.setHasValue(true);
                this.setValue(value);

                if (this._other.getHasValue()) {
                    var res = Bridge.getDefaultValue(TResult);
                    try {
                        res = this._parent._parent._resultSelector(this._other.getValue(), value);
                    }
                    catch (ex) {
                        ex = System.Exception.create(ex);
                        this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                        this._parent.dispose();
                        return;
                    }

                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](res);
                } else if (this._other.getDone()) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    this._parent.dispose();
                    return;
                }
            }
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._gate;
            {
                this.setDone(true);

                if (this._other.getDone()) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    this._parent.dispose();
                    return;
                } else {
                    this._self.System$IDisposable$dispose();
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1", function (T) { return {
        inherits: [System.IObserver$1(T)],
        _gate: null,
        _parent: null,
        _index: 0,
        _self: null,
        _value: Bridge.getDefaultValue(T),
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"
            ]
        },
        ctor: function (gate, parent, index, self) {
            this.$initialize();
            this._gate = gate;
            this._parent = parent;
            this._index = index;
            this._self = self;
        },
        getValue: function () {
            return this._value;
        },
        onNext: function (value) {
            this._gate;
            {
                this._value = value;
                this._parent.System$Reactive$Linq$ObservableImpl$ICombineLatest$next(this._index);
            }
        },
        onError: function (error) {
            this._self.System$IDisposable$dispose();

            this._gate;
            {
                this._parent.System$Reactive$Linq$ObservableImpl$ICombineLatest$fail(error);
            }
        },
        onCompleted: function () {
            this._self.System$IDisposable$dispose();

            this._gate;
            {
                this._parent.System$Reactive$Linq$ObservableImpl$ICombineLatest$done(this._index);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Contains$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(Boolean),System.IObserver$1(TSource)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(Boolean).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        onNext: function (value) {
            var res = false;
            try {
                res = this._parent._comparer["System$Collections$Generic$IEqualityComparer$1$" + Bridge.getTypeAlias(TSource) + "$equals2"](value, this._parent._value);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer.System$IObserver$1$Boolean$onError(ex);
                System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
                return;
            }

            if (res) {
                this._observer.System$IObserver$1$Boolean$onNext(true);
                this._observer.System$IObserver$1$Boolean$onCompleted();
                System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$Boolean$onError(error);
            System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$Boolean$onNext(false);
            this._observer.System$IObserver$1$Boolean$onCompleted();
            System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Count$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.Int32),System.IObserver$1(TSource)],
        _count: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Int32).ctor.call(this, observer, cancel);
            this._count = 0;
        },
        onNext: function (value) {
            try {
                this._count = Bridge.Int.check(this._count + 1, System.Int32);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer.System$IObserver$1$System$Int32$onError(ex);
                System.Reactive.Sink$1(System.Int32).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Int32$onError(error);
            System.Reactive.Sink$1(System.Int32).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Int32$onNext(this._count);
            this._observer.System$IObserver$1$System$Int32$onCompleted();
            System.Reactive.Sink$1(System.Int32).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Count$1.CountImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.Int32),System.IObserver$1(TSource)],
        _parent: null,
        _count: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Int32).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._count = 0;
        },
        onNext: function (value) {
            try {
                if (this._parent._predicate(value)) {
                    this._count = Bridge.Int.check(this._count + 1, System.Int32);
                }
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer.System$IObserver$1$System$Int32$onError(ex);
                System.Reactive.Sink$1(System.Int32).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Int32$onError(error);
            System.Reactive.Sink$1(System.Int32).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Int32$onNext(this._count);
            this._observer.System$IObserver$1$System$Int32$onCompleted();
            System.Reactive.Sink$1(System.Int32).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.DefaultIfEmpty$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _found: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._found = false;
        },
        onNext: function (value) {
            this._found = true;
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._found) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._parent._defaultValue);
            }
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Defer$1._", function (TValue) { return {
        inherits: [System.Reactive.Sink$1(TValue),System.IObserver$1(TValue)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TValue) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TValue) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TValue) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TValue).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var result = null;
            try {
                result = this._parent.eval();
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TValue) + "$onError"](exception);
                System.Reactive.Sink$1(TValue).prototype.dispose.call(this);
                return System.Reactive.Disposables.Disposable.getEmpty();
            }

            return System.ObservableExtensions.subscribeSafe(TValue, result, this);
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TValue) + "$onNext"](value);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TValue) + "$onError"](error);
            System.Reactive.Sink$1(TValue).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TValue) + "$onCompleted"]();
            System.Reactive.Sink$1(TValue).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Delay$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _scheduler: null,
        _sourceSubscription: null,
        _cancelable: null,
        _watch: null,
        _gate: null,
        _ready: false,
        _active: false,
        _running: false,
        _queue: null,
        _hasCompleted: false,
        _hasFailed: false,
        _exception: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ],
            init: function () {
                this._delay = new System.TimeSpan();
                this._completeAt = new System.TimeSpan();
            }
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._scheduler = this._parent._scheduler;

            this._cancelable = new System.Reactive.Disposables.SerialDisposable();

            this._gate = {  };
            this._active = false;
            this._running = false;
            this._queue = new (System.Collections.Generic.Queue$1(System.Reactive.TimeInterval$1(TSource))).ctor();
            this._hasCompleted = false;
            this._completeAt = Bridge.getDefaultValue(System.TimeSpan);
            this._hasFailed = false;
            this._exception = null;

            this._watch = System.Reactive.Concurrency.Scheduler.startStopwatch(this._scheduler);

            if (System.Nullable.hasValue(this._parent._dueTimeA)) {
                this._ready = false;

                var dueTimeA = System.Nullable.getValue(this._parent._dueTimeA);
                this._cancelable.setDisposable(System.Reactive.Concurrency.Scheduler.schedule$2(this._scheduler, dueTimeA.$clone(), Bridge.fn.bind(this, this.start)));
            } else {
                this._ready = true;

                var dueTimeR = System.Nullable.getValue(this._parent._dueTimeR);
                this._delay = System.Reactive.Concurrency.Scheduler.normalize(dueTimeR);
            }

            var sourceSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._sourceSubscription = sourceSubscription;
            sourceSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(this._sourceSubscription, this._cancelable);
        },
        start: function () {
            var next = Bridge.getDefaultValue(System.TimeSpan);
            var shouldRun = false;

            this._gate;
            {
                this._delay = this._watch.System$Reactive$Concurrency$IStopwatch$getElapsed();

                var oldQueue = this._queue;
                this._queue = new (System.Collections.Generic.Queue$1(System.Reactive.TimeInterval$1(TSource))).ctor();

                if (oldQueue.getCount() > 0) {
                    next = oldQueue.peek().getInterval();

                    while (oldQueue.getCount() > 0) {
                        var item = oldQueue.dequeue();
                        this._queue.enqueue(new (System.Reactive.TimeInterval$1(TSource)).$ctor1(item.getValue(), item.getInterval().add(this._delay)));
                    }

                    shouldRun = true;
                    this._active = true;
                }

                this._ready = true;
            }

            if (shouldRun) {
                this._cancelable.setDisposable(System.Reactive.Concurrency.Scheduler.schedule$5(this._scheduler, next, Bridge.fn.bind(this, this.drainQueue)));
            }
        },
        onNext: function (value) {
            var next = this._watch.System$Reactive$Concurrency$IStopwatch$getElapsed().add(this._delay);
            var shouldRun = false;

            this._gate;
            {
                this._queue.enqueue(new (System.Reactive.TimeInterval$1(TSource)).$ctor1(value, next));

                shouldRun = this._ready && !this._active;
                this._active = true;
            }

            if (shouldRun) {
                this._cancelable.setDisposable(System.Reactive.Concurrency.Scheduler.schedule$5(this._scheduler, this._delay, Bridge.fn.bind(this, this.drainQueue)));
            }
        },
        onError: function (error) {
            this._sourceSubscription.System$IDisposable$dispose();

            var shouldRun = false;

            this._gate;
            {
                this._queue.clear();

                this._exception = error;
                this._hasFailed = true;

                shouldRun = !this._running;
            }

            if (shouldRun) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._sourceSubscription.System$IDisposable$dispose();

            var next = this._watch.System$Reactive$Concurrency$IStopwatch$getElapsed().add(this._delay);
            var shouldRun = false;

            this._gate;
            {
                this._completeAt = next;
                this._hasCompleted = true;

                shouldRun = this._ready && !this._active;
                this._active = true;
            }

            if (shouldRun) {
                this._cancelable.setDisposable(System.Reactive.Concurrency.Scheduler.schedule$5(this._scheduler, this._delay, Bridge.fn.bind(this, this.drainQueue)));
            }
        },
        drainQueue: function (recurse) {
            this._gate;
            {
                if (this._hasFailed) {
                    return;
                }
                this._running = true;
            }

            //
            // The shouldYield flag was added to address TFS 487881: "Delay can be unfair". In the old
            // implementation, the loop below kept running while there was work for immediate dispatch,
            // potentially causing a long running work item on the target scheduler. With the addition
            // of long-running scheduling in Rx v2.0, we can check whether the scheduler supports this
            // interface and perform different processing (see LongRunningImpl). To reduce the code 
            // churn in the old loop code here, we set the shouldYield flag to true after the first 
            // dispatch iteration, in order to break from the loop and enter the recursive scheduling path.
            //
            var shouldYield = false;

            while (true) {
                var hasFailed = false;
                var error = null;

                var hasValue = false;
                var value = Bridge.getDefaultValue(TSource);
                var hasCompleted = false;

                var shouldRecurse = false;
                var recurseDueTime = Bridge.getDefaultValue(System.TimeSpan);

                this._gate;
                {
                    if (this._hasFailed) {
                        error = this._exception;
                        hasFailed = true;
                        this._running = false;
                    } else {
                        var now = this._watch.System$Reactive$Concurrency$IStopwatch$getElapsed();

                        if (this._queue.getCount() > 0) {
                            var nextDue = this._queue.peek().getInterval();

                            if (nextDue.compareTo(now) <= 0 && !shouldYield) {
                                value = this._queue.dequeue().getValue();
                                hasValue = true;
                            } else {
                                shouldRecurse = true;
                                recurseDueTime = System.Reactive.Concurrency.Scheduler.normalize(nextDue.subtract(now));
                                this._running = false;
                            }
                        } else if (this._hasCompleted) {
                            if (this._completeAt.compareTo(now) <= 0 && !shouldYield) {
                                hasCompleted = true;
                            } else {
                                shouldRecurse = true;
                                recurseDueTime = System.Reactive.Concurrency.Scheduler.normalize(this._completeAt.subtract(now));
                                this._running = false;
                            }
                        } else {
                            this._running = false;
                            this._active = false;
                        }
                    }
                } /*  lock (_gate) */

                if (hasValue) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
                    shouldYield = true;
                } else {
                    if (hasCompleted) {
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                        System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                    } else if (hasFailed) {
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                        System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                    } else if (shouldRecurse) {
                        recurse(recurseDueTime);
                    }

                    return;
                }
            } /*  while (true) */
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Delay$1.LongRunningImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _sourceSubscription: null,
        _cancelable: null,
        _watch: null,
        _gate: null,
        _evt: null,
        _stopped: false,
        _stop: null,
        _queue: null,
        _hasCompleted: false,
        _hasFailed: false,
        _exception: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ],
            init: function () {
                this._delay = new System.TimeSpan();
                this._completeAt = new System.TimeSpan();
            }
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._cancelable = new System.Reactive.Disposables.SerialDisposable();

            this._gate = {  };
            this._evt = new System.Reactive.Threading.Semaphore(0, 2147483647);
            this._queue = new (System.Collections.Generic.Queue$1(System.Reactive.TimeInterval$1(TSource))).ctor();
            this._hasCompleted = false;
            this._completeAt = Bridge.getDefaultValue(System.TimeSpan);
            this._hasFailed = false;
            this._exception = null;

            this._watch = System.Reactive.Concurrency.Scheduler.startStopwatch(this._parent._scheduler);

            if (System.Nullable.hasValue(this._parent._dueTimeA)) {
                var dueTimeA = System.Nullable.getValue(this._parent._dueTimeA);
                this._cancelable.setDisposable(System.Reactive.Concurrency.Scheduler.schedule$2(this._parent._scheduler, dueTimeA.$clone(), Bridge.fn.bind(this, this.start)));
            } else {
                var dueTimeR = System.Nullable.getValue(this._parent._dueTimeR);
                this._delay = System.Reactive.Concurrency.Scheduler.normalize(dueTimeR);
                this.scheduleDrain();
            }

            var sourceSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._sourceSubscription = sourceSubscription;
            sourceSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(this._sourceSubscription, this._cancelable);
        },
        start: function () {
            this._gate;
            {
                this._delay = this._watch.System$Reactive$Concurrency$IStopwatch$getElapsed();

                var oldQueue = this._queue;
                this._queue = new (System.Collections.Generic.Queue$1(System.Reactive.TimeInterval$1(TSource))).ctor();

                while (oldQueue.getCount() > 0) {
                    var item = oldQueue.dequeue();
                    this._queue.enqueue(new (System.Reactive.TimeInterval$1(TSource)).$ctor1(item.getValue(), item.getInterval().add(this._delay)));
                }
            }

            this.scheduleDrain();
        },
        scheduleDrain: function () {
            this._stop = new System.Threading.ManualResetEvent(false);
            this._cancelable.setDisposable(System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Delay$1.LongRunningImpl.f1)));

            System.Reactive.Concurrency.Scheduler.scheduleLongRunning(System.Reactive.Concurrency.Scheduler.asLongRunning(this._parent._scheduler), Bridge.fn.bind(this, this.drainQueue));
        },
        onNext: function (value) {
            var next = this._watch.System$Reactive$Concurrency$IStopwatch$getElapsed().add(this._delay);

            this._gate;
            {
                this._queue.enqueue(new (System.Reactive.TimeInterval$1(TSource)).$ctor1(value, next));

                this._evt.release();
            }
        },
        onError: function (error) {
            this._sourceSubscription.System$IDisposable$dispose();

            this._gate;
            {
                this._queue.clear();

                this._exception = error;
                this._hasFailed = true;

                this._evt.release();
            }
        },
        onCompleted: function () {
            this._sourceSubscription.System$IDisposable$dispose();

            var next = this._watch.System$Reactive$Concurrency$IStopwatch$getElapsed().add(this._delay);

            this._gate;
            {
                this._completeAt = next;
                this._hasCompleted = true;

                this._evt.release();
            }
        },
        drainQueue: function (cancel) {
            var $t;
            while (true) {
                $t = (function () {
                    this._evt.waitOne();
                    if (this._stopped) {
                        return {jump: 3};
                    }

                    var hasFailed = false;
                    var error = null;

                    var hasValue = false;
                    var value = Bridge.getDefaultValue(TSource);
                    var hasCompleted = false;

                    var shouldWait = false;
                    var waitTime = Bridge.getDefaultValue(System.TimeSpan);

                    this._gate;
                    {
                        if (this._hasFailed) {
                            error = this._exception;
                            hasFailed = true;
                        } else {
                            var now = this._watch.System$Reactive$Concurrency$IStopwatch$getElapsed();

                            if (this._queue.getCount() > 0) {
                                var next = this._queue.dequeue();

                                hasValue = true;
                                value = next.getValue();

                                var nextDue = next.getInterval();
                                if (nextDue.compareTo(now) > 0) {
                                    shouldWait = true;
                                    waitTime = System.Reactive.Concurrency.Scheduler.normalize(nextDue.subtract(now));
                                }
                            } else if (this._hasCompleted) {
                                hasCompleted = true;

                                if (this._completeAt.compareTo(now) > 0) {
                                    shouldWait = true;
                                    waitTime = System.Reactive.Concurrency.Scheduler.normalize(this._completeAt.subtract(now));
                                }
                            }
                        }
                    } /*  lock (_gate) */

                    if (shouldWait) {
                        var timer = new System.Threading.ManualResetEvent(false);
                        System.Reactive.Concurrency.Scheduler.schedule$4(this._parent._scheduler, waitTime, function () {
                            timer.set();
                        });
                        timer.waitOne();
                    }

                    if (hasValue) {
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
                    } else {
                        if (hasCompleted) {
                            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                        } else if (hasFailed) {
                            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                        }

                        return {jump: 3};
                    }
                }).call(this) || {};
                if($t.jump == 3) return $t.v;
            }
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Delay$1.LongRunningImpl", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Delay$1.LongRunningImpl, {
        f1: function () {
            this._stopped = true;
            this._stop.set();
            this._evt.release();
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Delay$2._", function (TSource, TDelay) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _delays: null,
        _gate: null,
        _atEnd: false,
        _subscription: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._delays = new System.Reactive.Disposables.CompositeDisposable.ctor();
            this._gate = {  };
            this._atEnd = false;
            this._subscription = new System.Reactive.Disposables.SerialDisposable();

            if (this._parent._subscriptionDelay == null) {
                this.start();
            } else {
                this._subscription.setDisposable(System.ObservableExtensions.subscribeSafe(TDelay, this._parent._subscriptionDelay, new (System.Reactive.Linq.ObservableImpl.Delay$2._.SubscriptionDelay(TSource,TDelay))(this)));
            }

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(this._subscription, this._delays);
        },
        start: function () {
            this._subscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));
        },
        onNext: function (value) {
            var delay = null;
            try {
                delay = this._parent._delaySelector(value);
            }
            catch (error) {
                error = System.Exception.create(error);
                this._gate;
                {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                }

                return;
            }

            var d = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._delays.add(d);
            d.setDisposable(System.ObservableExtensions.subscribeSafe(TDelay, delay, new (System.Reactive.Linq.ObservableImpl.Delay$2._.Delta(TSource,TDelay))(this, value, d)));
        },
        onError: function (error) {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._gate;
            {
                this._atEnd = true;
                this._subscription.dispose();

                this.checkDone();
            }
        },
        checkDone: function () {
            if (this._atEnd && this._delays.getCount() === 0) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Delay$2._.Delta", function (TSource, TDelay) { return {
        inherits: [System.IObserver$1(TDelay)],
        _parent: null,
        _value: Bridge.getDefaultValue(TSource),
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TDelay) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TDelay) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TDelay) + "$onCompleted"
            ]
        },
        ctor: function (parent, value, self) {
            this.$initialize();
            this._parent = parent;
            this._value = value;
            this._self = self;
        },
        onNext: function (value) {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._value);

                this._parent._delays.remove(this._self);
                this._parent.checkDone();
            }
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._value);

                this._parent._delays.remove(this._self);
                this._parent.checkDone();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Delay$2._.SubscriptionDelay", function (TSource, TDelay) { return {
        inherits: [System.IObserver$1(TDelay)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TDelay) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TDelay) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TDelay) + "$onCompleted"
            ]
        },
        ctor: function (parent) {
            this.$initialize();
            this._parent = parent;
        },
        onNext: function (value) {
            this._parent.start();
        },
        onError: function (error) {
            this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            this._parent.dispose();
        },
        onCompleted: function () {
            this._parent.start();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.DelaySubscription$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Dematerialize$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(System.Reactive.Notification$1(TSource))],
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Reactive$Notification$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$System$Reactive$Notification$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$System$Reactive$Notification$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
        },
        onNext: function (value) {
            switch (value.getKind()) {
                case System.Reactive.NotificationKind.OnNext: 
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value.getValue());
                    break;
                case System.Reactive.NotificationKind.OnError: 
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](value.getException());
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                    break;
                case System.Reactive.NotificationKind.OnCompleted: 
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                    break;
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Distinct$2._", function (TSource, TKey) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _hashSet: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._hashSet = new (System.Collections.Generic.HashSet$1(TKey)).$ctor3(this._parent._comparer);
        },
        onNext: function (value) {
            var key = Bridge.getDefaultValue(TKey);
            var hasAdded = false;
            try {
                key = this._parent._keySelector(value);
                hasAdded = this._hashSet.add(key);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](exception);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                return;
            }

            if (hasAdded) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.DistinctUntilChanged$2._", function (TSource, TKey) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _currentKey: Bridge.getDefaultValue(TKey),
        _hasCurrentKey: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._currentKey = Bridge.getDefaultValue(TKey);
            this._hasCurrentKey = false;
        },
        onNext: function (value) {
            var key = Bridge.getDefaultValue(TKey);
            try {
                key = this._parent._keySelector(value);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](exception);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                return;
            }

            var comparerEquals = false;
            if (this._hasCurrentKey) {
                try {
                    comparerEquals = this._parent._comparer["System$Collections$Generic$IEqualityComparer$1$" + Bridge.getTypeAlias(TKey) + "$equals2"](this._currentKey, key);
                }
                catch (exception1) {
                    exception1 = System.Exception.create(exception1);
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](exception1);
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                    return;
                }
            }

            if (!this._hasCurrentKey || !comparerEquals) {
                this._hasCurrentKey = true;
                this._currentKey = key;
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Do$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        onNext: function (value) {
            try {
                this._parent._onNext(value);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                return;
            }

            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            try {
                this._parent._onError(error);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                return;
            }

            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            try {
                this._parent._onCompleted();
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                return;
            }

            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ElementAt$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _i: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._i = this._parent._index;
        },
        onNext: function (value) {
            if (this._i === 0) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }

            this._i = (this._i - 1) | 0;
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (this._parent._throwOnEmpty) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](new System.ArgumentOutOfRangeException("index"));
            } else {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](Bridge.getDefaultValue(TSource));
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            }

            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Empty$1._", function (TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult)],
        _parent: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            return System.Reactive.Concurrency.Scheduler.schedule(this._parent._scheduler, Bridge.fn.bind(this, this.invoke));
        },
        invoke: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Finally$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var subscription = System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this);

            return System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, function () {
                try {
                    subscription.System$IDisposable$dispose();
                }
                finally {
                    this._parent._finallyAction();
                }
            }));
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.FirstAsync$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (this._parent._throwOnEmpty) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            } else {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](Bridge.getDefaultValue(TSource));
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            }

            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.FirstAsync$1.FirstAsyncImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        onNext: function (value) {
            var b = false;

            try {
                b = this._parent._predicate(value);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                return;
            }

            if (b) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (this._parent._throwOnEmpty) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_MATCHING_ELEMENTS));
            } else {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](Bridge.getDefaultValue(TSource));
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            }

            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ForEach$1._", function (TSource) { return {
        inherits: [System.IObserver$1(TSource)],
        _onNext: null,
        _done: null,
        _exception: null,
        _stopped: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (onNext, done) {
            this.$initialize();
            this._onNext = onNext;
            this._done = done;

            this._stopped = 0;
        },
        getError: function () {
            return this._exception;
        },
        onNext: function (value) {
            if (this._stopped === 0) {
                try {
                    this._onNext(value);
                }
                catch (ex) {
                    ex = System.Exception.create(ex);
                    this.onError(ex);
                }
            }
        },
        onError: function (error) {
            if (System.Interlocked.exchange(System.Int32, Bridge.ref(this, "_stopped"), 1) === 0) {
                this._exception = error;
                this._done();
            }
        },
        onCompleted: function () {
            if (System.Interlocked.exchange(System.Int32, Bridge.ref(this, "_stopped"), 1) === 0) {
                this._done();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ForEach$1.ForEachImpl", function (TSource) { return {
        inherits: [System.IObserver$1(TSource)],
        _onNext: null,
        _done: null,
        _index: 0,
        _exception: null,
        _stopped: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (onNext, done) {
            this.$initialize();
            this._onNext = onNext;
            this._done = done;

            this._index = 0;
            this._stopped = 0;
        },
        getError: function () {
            return this._exception;
        },
        onNext: function (value) {
            if (this._stopped === 0) {
                try {
                    this._onNext(value, Bridge.identity(this._index, (this._index = Bridge.Int.check(this._index + 1, System.Int32))));
                }
                catch (ex) {
                    ex = System.Exception.create(ex);
                    this.onError(ex);
                }
            }
        },
        onError: function (error) {
            if (System.Interlocked.exchange(System.Int32, Bridge.ref(this, "_stopped"), 1) === 0) {
                this._exception = error;
                this._done();
            }
        },
        onCompleted: function () {
            if (System.Interlocked.exchange(System.Int32, Bridge.ref(this, "_stopped"), 1) === 0) {
                this._done();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Generate$2._", function (TState, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult)],
        _parent: null,
        _state: Bridge.getDefaultValue(TState),
        _first: false,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._state = this._parent._initialState;
            this._first = true;

            var longRunning = System.Reactive.Concurrency.Scheduler.asLongRunning(this._parent._scheduler);
            if (longRunning != null) {
                return System.Reactive.Concurrency.Scheduler.scheduleLongRunning(longRunning, Bridge.fn.bind(this, this.loop));
            } else {
                return System.Reactive.Concurrency.Scheduler.schedule$1(this._parent._scheduler, Bridge.fn.bind(this, this.loopRec));
            }
        },
        loop: function (cancel) {
            while (!cancel.System$Reactive$Disposables$ICancelable$getIsDisposed()) {
                var hasResult = false;
                var result = Bridge.getDefaultValue(TResult);
                try {
                    if (this._first) {
                        this._first = false;
                    } else {
                        this._state = this._parent._iterate(this._state);
                    }
                    hasResult = this._parent._condition(this._state);
                    if (hasResult) {
                        result = this._parent._resultSelector(this._state);
                    }
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                    return;
                }

                if (hasResult) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
                } else {
                    break;
                }
            }

            if (!cancel.System$Reactive$Disposables$ICancelable$getIsDisposed()) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
            }

            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        },
        loopRec: function (recurse) {
            var hasResult = false;
            var result = Bridge.getDefaultValue(TResult);
            try {
                if (this._first) {
                    this._first = false;
                } else {
                    this._state = this._parent._iterate(this._state);
                }
                hasResult = this._parent._condition(this._state);
                if (hasResult) {
                    result = this._parent._resultSelector(this._state);
                }
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return;
            }

            if (hasResult) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
                recurse();
            } else {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Generate$2.Delta", function (TState, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult)],
        _parent: null,
        _first: false,
        _hasResult: false,
        _result: Bridge.getDefaultValue(TResult),
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._first = true;
            this._hasResult = false;
            this._result = Bridge.getDefaultValue(TResult);

            return this._parent._scheduler.System$Reactive$Concurrency$IScheduler$schedule(TState, this._parent._initialState, Bridge.fn.bind(this, this.invokeRec));
        },
        invokeRec: function (self, state) {
            var time = Bridge.getDefaultValue(System.TimeSpan);

            if (this._hasResult) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](this._result);
            }
            try {
                if (this._first) {
                    this._first = false;
                } else {
                    state = this._parent._iterate(state);
                }
                this._hasResult = this._parent._condition(state);
                if (this._hasResult) {
                    this._result = this._parent._resultSelector(state);
                    time = this._parent._timeSelectorR(state);
                }
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return System.Reactive.Disposables.Disposable.getEmpty();
            }

            if (!this._hasResult) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return System.Reactive.Disposables.Disposable.getEmpty();
            }

            return self.System$Reactive$Concurrency$IScheduler$schedule$2(TState, state, time, Bridge.fn.bind(this, this.invokeRec));
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Generate$2.SelectorA", function (TState, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult)],
        _parent: null,
        _first: false,
        _hasResult: false,
        _result: Bridge.getDefaultValue(TResult),
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._first = true;
            this._hasResult = false;
            this._result = Bridge.getDefaultValue(TResult);

            return this._parent._scheduler.System$Reactive$Concurrency$IScheduler$schedule(TState, this._parent._initialState, Bridge.fn.bind(this, this.invokeRec));
        },
        invokeRec: function (self, state) {
            var time = Bridge.getDefaultValue(System.DateTimeOffset);

            if (this._hasResult) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](this._result);
            }
            try {
                if (this._first) {
                    this._first = false;
                } else {
                    state = this._parent._iterate(state);
                }
                this._hasResult = this._parent._condition(state);
                if (this._hasResult) {
                    this._result = this._parent._resultSelector(state);
                    time = this._parent._timeSelectorA(state).$clone();
                }
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return System.Reactive.Disposables.Disposable.getEmpty();
            }

            if (!this._hasResult) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return System.Reactive.Disposables.Disposable.getEmpty();
            }

            return self.System$Reactive$Concurrency$IScheduler$schedule$1(TState, state, time.$clone(), Bridge.fn.bind(this, this.invokeRec));
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.GroupByUntil$4._.Delta", function (TSource, TKey, TElement, TDuration) { return {
        inherits: [System.IObserver$1(TDuration)],
        _parent: null,
        _key: Bridge.getDefaultValue(TKey),
        _writer: null,
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TDuration) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TDuration) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TDuration) + "$onCompleted"
            ]
        },
        ctor: function (parent, key, writer, self) {
            this.$initialize();
            this._parent = parent;
            this._key = key;
            this._writer = writer;
            this._self = self;
        },
        onNext: function (value) {
            this.onCompleted();
        },
        onError: function (error) {
            this._parent.error(error);
            this._self.System$IDisposable$dispose();
        },
        onCompleted: function () {
            if (this._key == null) {
                var $null = null;
                this._parent._nullGate;
                {
                    $null = this._parent._null;
                    this._parent._null = null;
                }

                $null["System$IObserver$1$" + Bridge.getTypeAlias(TElement) + "$onCompleted"]();
            } else {
                if (this._parent._map.remove(this._key)) {
                    this._writer["System$IObserver$1$" + Bridge.getTypeAlias(TElement) + "$onCompleted"]();
                }
            }

            this._parent._parent._groupDisposable.remove(this._self);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.GroupJoin$5._", function (TLeft, TRight, TLeftDuration, TRightDuration, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult)],
        _parent: null,
        _gate: null,
        _group: null,
        _refCount: null,
        _leftID: 0,
        _leftMap: null,
        _rightID: 0,
        _rightMap: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };
            this._group = new System.Reactive.Disposables.CompositeDisposable.ctor();
            this._refCount = new System.Reactive.Disposables.RefCountDisposable.ctor(this._group);

            var leftSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._group.add(leftSubscription);
            this._leftID = 0;
            this._leftMap = new (System.Collections.Generic.SortedDictionary$2(System.Int32,System.IObserver$1(TRight)))();

            var rightSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._group.add(rightSubscription);
            this._rightID = 0;
            this._rightMap = new (System.Collections.Generic.SortedDictionary$2(System.Int32,TRight))();

            leftSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TLeft, this._parent._left, new (System.Reactive.Linq.ObservableImpl.GroupJoin$5._.LeftObserver(TLeft,TRight,TLeftDuration,TRightDuration,TResult))(this, leftSubscription)));
            rightSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TRight, this._parent._right, new (System.Reactive.Linq.ObservableImpl.GroupJoin$5._.RightObserver(TLeft,TRight,TLeftDuration,TRightDuration,TResult))(this, rightSubscription)));

            return this._refCount;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.GroupJoin$5._.LeftObserver", function (TLeft, TRight, TLeftDuration, TRightDuration, TResult) { return {
        inherits: [System.IObserver$1(TLeft)],
        _parent: null,
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TLeft) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TLeft) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TLeft) + "$onCompleted"
            ]
        },
        ctor: function (parent, self) {
            this.$initialize();
            this._parent = parent;
            this._self = self;
        },
        expire: function (id, group, resource) {
            this._parent._gate;
            {
                if (this._parent._leftMap.remove(id)) {
                    group["System$IObserver$1$" + Bridge.getTypeAlias(TRight) + "$onCompleted"]();
                }
            }

            this._parent._group.remove(resource);
        },
        onNext: function (value) {
            var $t, $t1;
            var s = new (System.Reactive.Subjects.Subject$1(TRight))();
            var id = 0;
            var rightID = 0;
            this._parent._gate;
            {
                id = Bridge.identity(this._parent._leftID, ($t = (this._parent._leftID + 1) | 0, this._parent._leftID = $t, $t));
                rightID = this._parent._rightID;
                this._parent._leftMap.add(id, s);
            }

            var $window = new (System.Reactive.Linq.ObservableImpl.WindowObservable$1(TRight))(s, this._parent._refCount);

            // BREAKING CHANGE v2 > v1.x - Order of evaluation or the _leftDurationSelector and _resultSelector now consistent with Join.
            var md = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._parent._group.add(md);

            var duration = null;
            try {
                duration = this._parent._parent._leftDurationSelector(value);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this.onError(exception);
                return;
            }

            // BREAKING CHANGE v2 > v1.x - The duration sequence is subscribed to before the result sequence is evaluated.
            md.setDisposable(System.ObservableExtensions.subscribeSafe(TLeftDuration, duration, new (System.Reactive.Linq.ObservableImpl.GroupJoin$5._.LeftObserver.Delta(TLeft,TRight,TLeftDuration,TRightDuration,TResult))(this, id, s, md)));

            var result = Bridge.getDefaultValue(TResult);
            try {
                result = this._parent._parent._resultSelector(value, $window);
            }
            catch (exception1) {
                exception1 = System.Exception.create(exception1);
                this.onError(exception1);
                return;
            }

            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);

                $t1 = Bridge.getEnumerator(this._parent._rightMap);
                while ($t1.moveNext()) {
                    var rightValue = $t1.getCurrent();
                    if (rightValue.key < rightID) {
                        s.onNext(rightValue.value);
                    }
                }
            }
        },
        onError: function (error) {
            var $t;
            this._parent._gate;
            {
                $t = Bridge.getEnumerator(this._parent._leftMap);
                while ($t.moveNext()) {
                    var o = $t.getCurrent();
                    o.value["System$IObserver$1$" + Bridge.getTypeAlias(TRight) + "$onError"](error);
                }

                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                this._parent.dispose();
            }

            this._self.System$IDisposable$dispose();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.GroupJoin$5._.LeftObserver.Delta", function (TLeft, TRight, TLeftDuration, TRightDuration, TResult) { return {
        inherits: [System.IObserver$1(TLeftDuration)],
        _parent: null,
        _id: 0,
        _group: null,
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TLeftDuration) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TLeftDuration) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TLeftDuration) + "$onCompleted"
            ]
        },
        ctor: function (parent, id, group, self) {
            this.$initialize();
            this._parent = parent;
            this._id = id;
            this._group = group;
            this._self = self;
        },
        onNext: function (value) {
            this._parent.expire(this._id, this._group, this._self);
        },
        onError: function (error) {
            this._parent.onError(error);
        },
        onCompleted: function () {
            this._parent.expire(this._id, this._group, this._self);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.GroupJoin$5._.RightObserver", function (TLeft, TRight, TLeftDuration, TRightDuration, TResult) { return {
        inherits: [System.IObserver$1(TRight)],
        _parent: null,
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TRight) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TRight) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TRight) + "$onCompleted"
            ]
        },
        ctor: function (parent, self) {
            this.$initialize();
            this._parent = parent;
            this._self = self;
        },
        expire: function (id, resource) {
            this._parent._gate;
            {
                this._parent._rightMap.remove(id);
            }

            this._parent._group.remove(resource);
        },
        onNext: function (value) {
            var $t, $t1;
            var id = 0;
            var leftID = 0;
            this._parent._gate;
            {
                id = Bridge.identity(this._parent._rightID, ($t = (this._parent._rightID + 1) | 0, this._parent._rightID = $t, $t));
                leftID = this._parent._leftID;
                this._parent._rightMap.add(id, value);
            }

            var md = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._parent._group.add(md);

            var duration = null;
            try {
                duration = this._parent._parent._rightDurationSelector(value);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this.onError(exception);
                return;
            }

            md.setDisposable(System.ObservableExtensions.subscribeSafe(TRightDuration, duration, new (System.Reactive.Linq.ObservableImpl.GroupJoin$5._.RightObserver.Delta(TLeft,TRight,TLeftDuration,TRightDuration,TResult))(this, id, md)));

            this._parent._gate;
            {
                $t1 = Bridge.getEnumerator(this._parent._leftMap);
                while ($t1.moveNext()) {
                    var o = $t1.getCurrent();
                    if (o.key < leftID) {
                        o.value["System$IObserver$1$" + Bridge.getTypeAlias(TRight) + "$onNext"](value);
                    }
                }
            }
        },
        onError: function (error) {
            var $t;
            this._parent._gate;
            {
                $t = Bridge.getEnumerator(this._parent._leftMap);
                while ($t.moveNext()) {
                    var o = $t.getCurrent();
                    o.value["System$IObserver$1$" + Bridge.getTypeAlias(TRight) + "$onError"](error);
                }

                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._self.System$IDisposable$dispose();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.GroupJoin$5._.RightObserver.Delta", function (TLeft, TRight, TLeftDuration, TRightDuration, TResult) { return {
        inherits: [System.IObserver$1(TRightDuration)],
        _parent: null,
        _id: 0,
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TRightDuration) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TRightDuration) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TRightDuration) + "$onCompleted"
            ]
        },
        ctor: function (parent, id, self) {
            this.$initialize();
            this._parent = parent;
            this._id = id;
            this._self = self;
        },
        onNext: function (value) {
            this._parent.expire(this._id, this._self);
        },
        onError: function (error) {
            this._parent.onError(error);
        },
        onCompleted: function () {
            this._parent.expire(this._id, this._self);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.If$1._", function (TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.IObserver$1(TResult)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var result = null;
            try {
                result = this._parent.eval();
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return System.Reactive.Disposables.Disposable.getEmpty();
            }

            return System.ObservableExtensions.subscribeSafe(TResult, result, this);
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](value);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.IgnoreElements$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
        },
        onNext: function (value) {
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.IsEmpty$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(Boolean),System.IObserver$1(TSource)],
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(Boolean).ctor.call(this, observer, cancel);
        },
        onNext: function (value) {
            this._observer.System$IObserver$1$Boolean$onNext(false);
            this._observer.System$IObserver$1$Boolean$onCompleted();
            System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
        },
        onError: function (error) {
            this._observer.System$IObserver$1$Boolean$onError(error);
            System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$Boolean$onNext(true);
            this._observer.System$IObserver$1$Boolean$onCompleted();
            System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Join$5._", function (TLeft, TRight, TLeftDuration, TRightDuration, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult)],
        _parent: null,
        _gate: null,
        _group: null,
        _leftDone: false,
        _leftID: 0,
        _leftMap: null,
        _rightDone: false,
        _rightID: 0,
        _rightMap: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };
            this._group = new System.Reactive.Disposables.CompositeDisposable.ctor();

            var leftSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._group.add(leftSubscription);
            this._leftDone = false;
            this._leftID = 0;
            this._leftMap = new (System.Collections.Generic.SortedDictionary$2(System.Int32,TLeft))();

            var rightSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._group.add(rightSubscription);
            this._rightDone = false;
            this._rightID = 0;
            this._rightMap = new (System.Collections.Generic.SortedDictionary$2(System.Int32,TRight))();

            leftSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TLeft, this._parent._left, new (System.Reactive.Linq.ObservableImpl.Join$5._.LeftObserver(TLeft,TRight,TLeftDuration,TRightDuration,TResult))(this, leftSubscription)));
            rightSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TRight, this._parent._right, new (System.Reactive.Linq.ObservableImpl.Join$5._.RightObserver(TLeft,TRight,TLeftDuration,TRightDuration,TResult))(this, rightSubscription)));

            return this._group;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Join$5._.LeftObserver", function (TLeft, TRight, TLeftDuration, TRightDuration, TResult) { return {
        inherits: [System.IObserver$1(TLeft)],
        _parent: null,
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TLeft) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TLeft) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TLeft) + "$onCompleted"
            ]
        },
        ctor: function (parent, self) {
            this.$initialize();
            this._parent = parent;
            this._self = self;
        },
        expire: function (id, resource) {
            this._parent._gate;
            {
                if (this._parent._leftMap.remove(id) && this._parent._leftMap.getCount() === 0 && this._parent._leftDone) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    this._parent.dispose();
                }
            }

            this._parent._group.remove(resource);
        },
        onNext: function (value) {
            var $t, $t1;
            var id = 0;
            var rightID = 0;
            this._parent._gate;
            {
                id = Bridge.identity(this._parent._leftID, ($t = (this._parent._leftID + 1) | 0, this._parent._leftID = $t, $t));
                rightID = this._parent._rightID;
                this._parent._leftMap.add(id, value);
            }

            var md = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._parent._group.add(md);

            var duration = null;
            try {
                duration = this._parent._parent._leftDurationSelector(value);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                this._parent.dispose();
                return;
            }

            md.setDisposable(System.ObservableExtensions.subscribeSafe(TLeftDuration, duration, new (System.Reactive.Linq.ObservableImpl.Join$5._.LeftObserver.Delta(TLeft,TRight,TLeftDuration,TRightDuration,TResult))(this, id, md)));

            this._parent._gate;
            {
                $t1 = Bridge.getEnumerator(this._parent._rightMap);
                while ($t1.moveNext()) {
                    var rightValue = $t1.getCurrent();
                    if (rightValue.key < rightID) {
                        var result = Bridge.getDefaultValue(TResult);
                        try {
                            result = this._parent._parent._resultSelector(value, rightValue.value);
                        }
                        catch (exception1) {
                            exception1 = System.Exception.create(exception1);
                            this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception1);
                            this._parent.dispose();
                            return;
                        }

                        this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
                    }
                }
            }
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._gate;
            {
                this._parent._leftDone = true;
                if (this._parent._rightDone || this._parent._leftMap.getCount() === 0) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    this._parent.dispose();
                } else {
                    this._self.System$IDisposable$dispose();
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Join$5._.LeftObserver.Delta", function (TLeft, TRight, TLeftDuration, TRightDuration, TResult) { return {
        inherits: [System.IObserver$1(TLeftDuration)],
        _parent: null,
        _id: 0,
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TLeftDuration) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TLeftDuration) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TLeftDuration) + "$onCompleted"
            ]
        },
        ctor: function (parent, id, self) {
            this.$initialize();
            this._parent = parent;
            this._id = id;
            this._self = self;
        },
        onNext: function (value) {
            this._parent.expire(this._id, this._self);
        },
        onError: function (error) {
            this._parent.onError(error);
        },
        onCompleted: function () {
            this._parent.expire(this._id, this._self);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Join$5._.RightObserver", function (TLeft, TRight, TLeftDuration, TRightDuration, TResult) { return {
        inherits: [System.IObserver$1(TRight)],
        _parent: null,
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TRight) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TRight) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TRight) + "$onCompleted"
            ]
        },
        ctor: function (parent, self) {
            this.$initialize();
            this._parent = parent;
            this._self = self;
        },
        expire: function (id, resource) {
            this._parent._gate;
            {
                if (this._parent._rightMap.remove(id) && this._parent._rightMap.getCount() === 0 && this._parent._rightDone) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    this._parent.dispose();
                }
            }

            this._parent._group.remove(resource);
        },
        onNext: function (value) {
            var $t, $t1;
            var id = 0;
            var leftID = 0;
            this._parent._gate;
            {
                id = Bridge.identity(this._parent._rightID, ($t = (this._parent._rightID + 1) | 0, this._parent._rightID = $t, $t));
                leftID = this._parent._leftID;
                this._parent._rightMap.add(id, value);
            }

            var md = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._parent._group.add(md);

            var duration = null;
            try {
                duration = this._parent._parent._rightDurationSelector(value);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                this._parent.dispose();
                return;
            }

            md.setDisposable(System.ObservableExtensions.subscribeSafe(TRightDuration, duration, new (System.Reactive.Linq.ObservableImpl.Join$5._.RightObserver.Delta(TLeft,TRight,TLeftDuration,TRightDuration,TResult))(this, id, md)));

            this._parent._gate;
            {
                $t1 = Bridge.getEnumerator(this._parent._leftMap);
                while ($t1.moveNext()) {
                    var leftValue = $t1.getCurrent();
                    if (leftValue.key < leftID) {
                        var result = Bridge.getDefaultValue(TResult);
                        try {
                            result = this._parent._parent._resultSelector(leftValue.value, value);
                        }
                        catch (exception1) {
                            exception1 = System.Exception.create(exception1);
                            this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception1);
                            this._parent.dispose();
                            return;
                        }

                        this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
                    }
                }
            }
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._gate;
            {
                this._parent._rightDone = true;
                if (this._parent._leftDone || this._parent._rightMap.getCount() === 0) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    this._parent.dispose();
                } else {
                    this._self.System$IDisposable$dispose();
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Join$5._.RightObserver.Delta", function (TLeft, TRight, TLeftDuration, TRightDuration, TResult) { return {
        inherits: [System.IObserver$1(TRightDuration)],
        _parent: null,
        _id: 0,
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TRightDuration) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TRightDuration) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TRightDuration) + "$onCompleted"
            ]
        },
        ctor: function (parent, id, self) {
            this.$initialize();
            this._parent = parent;
            this._id = id;
            this._self = self;
        },
        onNext: function (value) {
            this._parent.expire(this._id, this._self);
        },
        onError: function (error) {
            this._parent.onError(error);
        },
        onCompleted: function () {
            this._parent.expire(this._id, this._self);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.LastAsync$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _value: Bridge.getDefaultValue(TSource),
        _seenValue: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;

            this._value = Bridge.getDefaultValue(TSource);
            this._seenValue = false;
        },
        onNext: function (value) {
            this._value = value;
            this._seenValue = true;
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._seenValue && this._parent._throwOnEmpty) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            } else {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._value);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            }

            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.LastAsync$1.LastAsyncImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _value: Bridge.getDefaultValue(TSource),
        _seenValue: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;

            this._value = Bridge.getDefaultValue(TSource);
            this._seenValue = false;
        },
        onNext: function (value) {
            var b = false;

            try {
                b = this._parent._predicate(value);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                return;
            }

            if (b) {
                this._value = value;
                this._seenValue = true;
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._seenValue && this._parent._throwOnEmpty) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_MATCHING_ELEMENTS));
            } else {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._value);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            }

            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Latest$1", function (TSource) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.PushToPullAdapter$2(TSource,TSource)],
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.PushToPullAdapter$2(TSource,TSource).ctor.call(this, source);
        },
        run: function (subscription) {
            return new (System.Reactive.Linq.ObservableImpl.Latest$1._(TSource))(subscription);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.LongCount$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.Int64),System.IObserver$1(TSource)],
        _count: System.Int64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Int64).ctor.call(this, observer, cancel);
            this._count = System.Int64(0);
        },
        onNext: function (value) {
            try {
                this._count = this._count.inc(1);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer.System$IObserver$1$System$Int64$onError(ex);
                System.Reactive.Sink$1(System.Int64).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Int64$onError(error);
            System.Reactive.Sink$1(System.Int64).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Int64$onNext(this._count);
            this._observer.System$IObserver$1$System$Int64$onCompleted();
            System.Reactive.Sink$1(System.Int64).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.LongCount$1.LongCountImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.Int64),System.IObserver$1(TSource)],
        _parent: null,
        _count: System.Int64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Int64).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._count = System.Int64(0);
        },
        onNext: function (value) {
            try {
                if (this._parent._predicate(value)) {
                    this._count = this._count.inc(1);
                }
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer.System$IObserver$1$System$Int64$onError(ex);
                System.Reactive.Sink$1(System.Int64).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Int64$onError(error);
            System.Reactive.Sink$1(System.Int64).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Int64$onNext(this._count);
            this._observer.System$IObserver$1$System$Int64$onCompleted();
            System.Reactive.Sink$1(System.Int64).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Materialize$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.Reactive.Notification$1(TSource)),System.IObserver$1(TSource)],
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Reactive.Notification$1(TSource)).ctor.call(this, observer, cancel);
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$System$Reactive$Notification$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](System.Reactive.Notification.system.reactive.notification.createOnNext(value));
        },
        onError: function (error) {
            this._observer["System$IObserver$1$System$Reactive$Notification$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](System.Reactive.Notification.system.reactive.notification.createOnError(error));
            this._observer["System$IObserver$1$System$Reactive$Notification$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(System.Reactive.Notification$1(TSource)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$System$Reactive$Notification$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](System.Reactive.Notification.system.reactive.notification.createOnCompleted());
            this._observer["System$IObserver$1$System$Reactive$Notification$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(System.Reactive.Notification$1(TSource)).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Max$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _lastValue: Bridge.getDefaultValue(TSource),
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;

            this._lastValue = Bridge.getDefaultValue(TSource);
        },
        onNext: function (value) {
            if (value != null) {
                if (this._lastValue == null) {
                    this._lastValue = value;
                } else {
                    var comparison = 0;

                    try {
                        comparison = this._parent._comparer["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TSource) + "$compare"](value, this._lastValue);
                    }
                    catch (ex) {
                        ex = System.Exception.create(ex);
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex);
                        System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                        return;
                    }

                    if (comparison > 0) {
                        this._lastValue = value;
                    }
                }
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._lastValue);
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Max$1.Delta", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _hasValue: false,
        _lastValue: Bridge.getDefaultValue(TSource),
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;

            this._hasValue = false;
            this._lastValue = Bridge.getDefaultValue(TSource);
        },
        onNext: function (value) {
            if (this._hasValue) {
                var comparison = 0;

                try {
                    comparison = this._parent._comparer["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TSource) + "$compare"](value, this._lastValue);
                }
                catch (ex) {
                    ex = System.Exception.create(ex);
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex);
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                    return;
                }

                if (comparison > 0) {
                    this._lastValue = value;
                }
            } else {
                this._hasValue = true;
                this._lastValue = value;
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._hasValue) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            } else {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._lastValue);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            }

            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxBy$2._", function (TSource, TKey) { return {
        inherits: [System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        _hasValue: false,
        _lastKey: Bridge.getDefaultValue(TKey),
        _list: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;

            this._hasValue = false;
            this._lastKey = Bridge.getDefaultValue(TKey);
            this._list = new (System.Collections.Generic.List$1(TSource))();
        },
        onNext: function (value) {
            var key = Bridge.getDefaultValue(TKey);
            try {
                key = this._parent._keySelector(value);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex);
                System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
                return;
            }

            var comparison = 0;

            if (!this._hasValue) {
                this._hasValue = true;
                this._lastKey = key;
            } else {
                try {
                    comparison = this._parent._comparer["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TKey) + "$compare"](key, this._lastKey);
                }
                catch (ex1) {
                    ex1 = System.Exception.create(ex1);
                    this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex1);
                    System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
                    return;
                }
            }

            if (comparison > 0) {
                this._lastKey = key;
                this._list.clear();
            }

            if (comparison >= 0) {
                this._list.add(value);
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._list);
            this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxDecimal._", {
        inherits: [System.Reactive.Sink$1(System.Decimal),System.IObserver$1(System.Decimal)],
        _hasValue: false,
        _lastValue: System.Decimal(0.0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Decimal$onNext",
            "onError", "System$IObserver$1$System$Decimal$onError",
            "onCompleted", "System$IObserver$1$System$Decimal$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Decimal).ctor.call(this, observer, cancel);
            this._hasValue = false;
            this._lastValue = Bridge.getDefaultValue(System.Decimal);
        },
        onNext: function (value) {
            if (this._hasValue) {
                if (value.gt(this._lastValue)) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
                this._hasValue = true;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Decimal$onError(error);
            System.Reactive.Sink$1(System.Decimal).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._hasValue) {
                this._observer.System$IObserver$1$System$Decimal$onError(new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            } else {
                this._observer.System$IObserver$1$System$Decimal$onNext(this._lastValue);
                this._observer.System$IObserver$1$System$Decimal$onCompleted();
            }

            System.Reactive.Sink$1(System.Decimal).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxDecimalNullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Decimal)),System.IObserver$1(System.Nullable$1(System.Decimal))],
        _lastValue: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Decimal$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Decimal$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Decimal$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Decimal)).ctor.call(this, observer, cancel);
            this._lastValue = null;
        },
        onNext: function (value) {
            if (!System.Nullable.hasValue(value)) {
                return;
            }

            if (System.Nullable.hasValue(this._lastValue)) {
                if (System.Nullable.liftcmp("gt", value, this._lastValue)) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Decimal$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Decimal)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Nullable$1$System$Decimal$onNext(this._lastValue);
            this._observer.System$IObserver$1$System$Nullable$1$System$Decimal$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Decimal)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxDouble._", {
        inherits: [System.Reactive.Sink$1(System.Double),System.IObserver$1(System.Double)],
        _hasValue: false,
        _lastValue: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Double$onNext",
            "onError", "System$IObserver$1$System$Double$onError",
            "onCompleted", "System$IObserver$1$System$Double$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Double).ctor.call(this, observer, cancel);
            this._hasValue = false;
            this._lastValue = Bridge.getDefaultValue(System.Double);
        },
        onNext: function (value) {
            if (this._hasValue) {
                if (value > this._lastValue || isNaN(value)) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
                this._hasValue = true;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Double$onError(error);
            System.Reactive.Sink$1(System.Double).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._hasValue) {
                this._observer.System$IObserver$1$System$Double$onError(new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            } else {
                this._observer.System$IObserver$1$System$Double$onNext(this._lastValue);
                this._observer.System$IObserver$1$System$Double$onCompleted();
            }

            System.Reactive.Sink$1(System.Double).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxDoubleNullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Double)),System.IObserver$1(System.Nullable$1(System.Double))],
        _lastValue: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Double$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Double$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Double$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).ctor.call(this, observer, cancel);
            this._lastValue = null;
        },
        onNext: function (value) {
            if (!System.Nullable.hasValue(value)) {
                return;
            }

            if (System.Nullable.hasValue(this._lastValue)) {
                if (System.Nullable.gt(value, this._lastValue) || isNaN(System.Nullable.getValue(value))) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Double$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Nullable$1$System$Double$onNext(this._lastValue);
            this._observer.System$IObserver$1$System$Nullable$1$System$Double$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxInt32._", {
        inherits: [System.Reactive.Sink$1(System.Int32),System.IObserver$1(System.Int32)],
        _hasValue: false,
        _lastValue: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Int32$onNext",
            "onError", "System$IObserver$1$System$Int32$onError",
            "onCompleted", "System$IObserver$1$System$Int32$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Int32).ctor.call(this, observer, cancel);
            this._hasValue = false;
            this._lastValue = Bridge.getDefaultValue(System.Int32);
        },
        onNext: function (value) {
            if (this._hasValue) {
                if (value > this._lastValue) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
                this._hasValue = true;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Int32$onError(error);
            System.Reactive.Sink$1(System.Int32).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._hasValue) {
                this._observer.System$IObserver$1$System$Int32$onError(new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            } else {
                this._observer.System$IObserver$1$System$Int32$onNext(this._lastValue);
                this._observer.System$IObserver$1$System$Int32$onCompleted();
            }

            System.Reactive.Sink$1(System.Int32).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxInt32Nullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Int32)),System.IObserver$1(System.Nullable$1(System.Int32))],
        _lastValue: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Int32$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Int32$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Int32$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Int32)).ctor.call(this, observer, cancel);
            this._lastValue = null;
        },
        onNext: function (value) {
            if (!System.Nullable.hasValue(value)) {
                return;
            }

            if (System.Nullable.hasValue(this._lastValue)) {
                if (System.Nullable.gt(value, this._lastValue)) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Int32$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Int32)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Nullable$1$System$Int32$onNext(this._lastValue);
            this._observer.System$IObserver$1$System$Nullable$1$System$Int32$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Int32)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxInt64._", {
        inherits: [System.Reactive.Sink$1(System.Int64),System.IObserver$1(System.Int64)],
        _hasValue: false,
        _lastValue: System.Int64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Int64$onNext",
            "onError", "System$IObserver$1$System$Int64$onError",
            "onCompleted", "System$IObserver$1$System$Int64$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Int64).ctor.call(this, observer, cancel);
            this._hasValue = false;
            this._lastValue = Bridge.getDefaultValue(System.Int64);
        },
        onNext: function (value) {
            if (this._hasValue) {
                if (value.gt(this._lastValue)) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
                this._hasValue = true;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Int64$onError(error);
            System.Reactive.Sink$1(System.Int64).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._hasValue) {
                this._observer.System$IObserver$1$System$Int64$onError(new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            } else {
                this._observer.System$IObserver$1$System$Int64$onNext(this._lastValue);
                this._observer.System$IObserver$1$System$Int64$onCompleted();
            }

            System.Reactive.Sink$1(System.Int64).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxInt64Nullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Int64)),System.IObserver$1(System.Nullable$1(System.Int64))],
        _lastValue: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Int64$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Int64$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Int64$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Int64)).ctor.call(this, observer, cancel);
            this._lastValue = null;
        },
        onNext: function (value) {
            if (!System.Nullable.hasValue(value)) {
                return;
            }

            if (System.Nullable.hasValue(this._lastValue)) {
                if (System.Nullable.liftcmp("gt", value, this._lastValue)) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Int64$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Int64)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Nullable$1$System$Int64$onNext(this._lastValue);
            this._observer.System$IObserver$1$System$Nullable$1$System$Int64$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Int64)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxSingle._", {
        inherits: [System.Reactive.Sink$1(System.Single),System.IObserver$1(System.Single)],
        _hasValue: false,
        _lastValue: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Single$onNext",
            "onError", "System$IObserver$1$System$Single$onError",
            "onCompleted", "System$IObserver$1$System$Single$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Single).ctor.call(this, observer, cancel);
            this._hasValue = false;
            this._lastValue = Bridge.getDefaultValue(System.Single);
        },
        onNext: function (value) {
            if (this._hasValue) {
                if (value > this._lastValue || isNaN(value)) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
                this._hasValue = true;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Single$onError(error);
            System.Reactive.Sink$1(System.Single).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._hasValue) {
                this._observer.System$IObserver$1$System$Single$onError(new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            } else {
                this._observer.System$IObserver$1$System$Single$onNext(this._lastValue);
                this._observer.System$IObserver$1$System$Single$onCompleted();
            }

            System.Reactive.Sink$1(System.Single).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxSingleNullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Single)),System.IObserver$1(System.Nullable$1(System.Single))],
        _lastValue: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Single$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Single$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Single$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Single)).ctor.call(this, observer, cancel);
            this._lastValue = null;
        },
        onNext: function (value) {
            if (!System.Nullable.hasValue(value)) {
                return;
            }

            if (System.Nullable.hasValue(this._lastValue)) {
                if (System.Nullable.gt(value, this._lastValue) || isNaN(System.Nullable.getValue(value))) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Single$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Single)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Nullable$1$System$Single$onNext(this._lastValue);
            this._observer.System$IObserver$1$System$Nullable$1$System$Single$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Single)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Merge$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(System.IObservable$1(TSource))],
        _parent: null,
        _gate: null,
        _isStopped: false,
        _group: null,
        _sourceSubscription: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };
            this._isStopped = false;
            this._group = new System.Reactive.Disposables.CompositeDisposable.ctor();

            this._sourceSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._group.add(this._sourceSubscription);
            this._sourceSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(System.IObservable$1(TSource), this._parent._sources, this));

            return this._group;
        },
        onNext: function (value) {
            var innerSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._group.add(innerSubscription);
            innerSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, value, new (System.Reactive.Linq.ObservableImpl.Merge$1._.Iter(TSource))(this, innerSubscription)));
        },
        onError: function (error) {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._isStopped = true;
            if (this._group.getCount() === 1) {
                //
                // Notice there can be a race between OnCompleted of the source and any
                // of the inner sequences, where both see _group.Count == 1, and one is
                // waiting for the lock. There won't be a double OnCompleted observation
                // though, because the call to Dispose silences the observer by swapping
                // in a NopObserver<T>.
                //
                this._gate;
                {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                }
            } else {
                this._sourceSubscription.dispose();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Merge$1._.Iter", function (TSource) { return {
        inherits: [System.IObserver$1(TSource)],
        _parent: null,
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, self) {
            this.$initialize();
            this._parent = parent;
            this._self = self;
        },
        onNext: function (value) {
            this._parent._gate;
            this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._group.remove(this._self);
            if (this._parent._isStopped && this._parent._group.getCount() === 1) {
                //
                // Notice there can be a race between OnCompleted of the source and any
                // of the inner sequences, where both see _group.Count == 1, and one is
                // waiting for the lock. There won't be a double OnCompleted observation
                // though, because the call to Dispose silences the observer by swapping
                // in a NopObserver<T>.
                //
                this._parent._gate;
                {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    this._parent.dispose();
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Merge$1.MergeConcurrent", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(System.IObservable$1(TSource))],
        _parent: null,
        _gate: null,
        _q: null,
        _isStopped: false,
        _sourceSubscription: null,
        _group: null,
        _activeCount: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };
            this._q = new (System.Collections.Generic.Queue$1(System.IObservable$1(TSource))).ctor();
            this._isStopped = false;
            this._activeCount = 0;

            this._group = new System.Reactive.Disposables.CompositeDisposable.ctor();
            this._sourceSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._sourceSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(System.IObservable$1(TSource), this._parent._sources, this));
            this._group.add(this._sourceSubscription);

            return this._group;
        },
        onNext: function (value) {
            this._gate;
            {
                if (this._activeCount < this._parent._maxConcurrent) {
                    this._activeCount = (this._activeCount + 1) | 0;
                    this.subscribe(value);
                } else {
                    this._q.enqueue(value);
                }
            }
        },
        onError: function (error) {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._gate;
            {
                this._isStopped = true;
                if (this._activeCount === 0) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                } else {
                    this._sourceSubscription.dispose();
                }
            }
        },
        subscribe: function (innerSource) {
            var subscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._group.add(subscription);
            subscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, innerSource, new (System.Reactive.Linq.ObservableImpl.Merge$1.MergeConcurrent.Iter(TSource))(this, subscription)));
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Merge$1.MergeConcurrent.Iter", function (TSource) { return {
        inherits: [System.IObserver$1(TSource)],
        _parent: null,
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, self) {
            this.$initialize();
            this._parent = parent;
            this._self = self;
        },
        onNext: function (value) {
            this._parent._gate;
            this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._group.remove(this._self);
            this._parent._gate;
            {
                if (this._parent._q.getCount() > 0) {
                    var s = this._parent._q.dequeue();
                    this._parent.subscribe(s);
                } else {
                    this._parent._activeCount = (this._parent._activeCount - 1) | 0;
                    if (this._parent._isStopped && this._parent._activeCount === 0) {
                        this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                        this._parent.dispose();
                    }
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Min$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _lastValue: Bridge.getDefaultValue(TSource),
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;

            this._lastValue = Bridge.getDefaultValue(TSource);
        },
        onNext: function (value) {
            if (value != null) {
                if (this._lastValue == null) {
                    this._lastValue = value;
                } else {
                    var comparison = 0;

                    try {
                        comparison = this._parent._comparer["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TSource) + "$compare"](value, this._lastValue);
                    }
                    catch (ex) {
                        ex = System.Exception.create(ex);
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex);
                        System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                        return;
                    }

                    if (comparison < 0) {
                        this._lastValue = value;
                    }
                }
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._lastValue);
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Min$1.Delta", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _hasValue: false,
        _lastValue: Bridge.getDefaultValue(TSource),
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;

            this._hasValue = false;
            this._lastValue = Bridge.getDefaultValue(TSource);
        },
        onNext: function (value) {
            if (this._hasValue) {
                var comparison = 0;

                try {
                    comparison = this._parent._comparer["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TSource) + "$compare"](value, this._lastValue);
                }
                catch (ex) {
                    ex = System.Exception.create(ex);
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex);
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                    return;
                }

                if (comparison < 0) {
                    this._lastValue = value;
                }
            } else {
                this._hasValue = true;
                this._lastValue = value;
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._hasValue) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            } else {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._lastValue);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            }

            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinBy$2._", function (TSource, TKey) { return {
        inherits: [System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        _hasValue: false,
        _lastKey: Bridge.getDefaultValue(TKey),
        _list: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;

            this._hasValue = false;
            this._lastKey = Bridge.getDefaultValue(TKey);
            this._list = new (System.Collections.Generic.List$1(TSource))();
        },
        onNext: function (value) {
            var key = Bridge.getDefaultValue(TKey);
            try {
                key = this._parent._keySelector(value);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex);
                System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
                return;
            }

            var comparison = 0;

            if (!this._hasValue) {
                this._hasValue = true;
                this._lastKey = key;
            } else {
                try {
                    comparison = this._parent._comparer["System$Collections$Generic$IComparer$1$" + Bridge.getTypeAlias(TKey) + "$compare"](key, this._lastKey);
                }
                catch (ex1) {
                    ex1 = System.Exception.create(ex1);
                    this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex1);
                    System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
                    return;
                }
            }

            if (comparison < 0) {
                this._lastKey = key;
                this._list.clear();
            }

            if (comparison <= 0) {
                this._list.add(value);
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._list);
            this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinDecimal._", {
        inherits: [System.Reactive.Sink$1(System.Decimal),System.IObserver$1(System.Decimal)],
        _hasValue: false,
        _lastValue: System.Decimal(0.0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Decimal$onNext",
            "onError", "System$IObserver$1$System$Decimal$onError",
            "onCompleted", "System$IObserver$1$System$Decimal$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Decimal).ctor.call(this, observer, cancel);
            this._hasValue = false;
            this._lastValue = Bridge.getDefaultValue(System.Decimal);
        },
        onNext: function (value) {
            if (this._hasValue) {
                if (value.lt(this._lastValue)) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
                this._hasValue = true;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Decimal$onError(error);
            System.Reactive.Sink$1(System.Decimal).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._hasValue) {
                this._observer.System$IObserver$1$System$Decimal$onError(new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            } else {
                this._observer.System$IObserver$1$System$Decimal$onNext(this._lastValue);
                this._observer.System$IObserver$1$System$Decimal$onCompleted();
            }

            System.Reactive.Sink$1(System.Decimal).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinDecimalNullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Decimal)),System.IObserver$1(System.Nullable$1(System.Decimal))],
        _lastValue: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Decimal$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Decimal$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Decimal$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Decimal)).ctor.call(this, observer, cancel);
            this._lastValue = null;
        },
        onNext: function (value) {
            if (!System.Nullable.hasValue(value)) {
                return;
            }

            if (System.Nullable.hasValue(this._lastValue)) {
                if (System.Nullable.liftcmp("lt", value, this._lastValue)) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Decimal$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Decimal)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Nullable$1$System$Decimal$onNext(this._lastValue);
            this._observer.System$IObserver$1$System$Nullable$1$System$Decimal$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Decimal)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinDouble._", {
        inherits: [System.Reactive.Sink$1(System.Double),System.IObserver$1(System.Double)],
        _hasValue: false,
        _lastValue: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Double$onNext",
            "onError", "System$IObserver$1$System$Double$onError",
            "onCompleted", "System$IObserver$1$System$Double$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Double).ctor.call(this, observer, cancel);
            this._hasValue = false;
            this._lastValue = Bridge.getDefaultValue(System.Double);
        },
        onNext: function (value) {
            if (this._hasValue) {
                if (value < this._lastValue || isNaN(value)) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
                this._hasValue = true;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Double$onError(error);
            System.Reactive.Sink$1(System.Double).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._hasValue) {
                this._observer.System$IObserver$1$System$Double$onError(new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            } else {
                this._observer.System$IObserver$1$System$Double$onNext(this._lastValue);
                this._observer.System$IObserver$1$System$Double$onCompleted();
            }

            System.Reactive.Sink$1(System.Double).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinDoubleNullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Double)),System.IObserver$1(System.Nullable$1(System.Double))],
        _lastValue: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Double$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Double$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Double$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).ctor.call(this, observer, cancel);
            this._lastValue = null;
        },
        onNext: function (value) {
            if (!System.Nullable.hasValue(value)) {
                return;
            }

            if (System.Nullable.hasValue(this._lastValue)) {
                if (System.Nullable.lt(value, this._lastValue) || isNaN(System.Nullable.getValue(value))) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Double$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Nullable$1$System$Double$onNext(this._lastValue);
            this._observer.System$IObserver$1$System$Nullable$1$System$Double$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinInt32._", {
        inherits: [System.Reactive.Sink$1(System.Int32),System.IObserver$1(System.Int32)],
        _hasValue: false,
        _lastValue: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Int32$onNext",
            "onError", "System$IObserver$1$System$Int32$onError",
            "onCompleted", "System$IObserver$1$System$Int32$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Int32).ctor.call(this, observer, cancel);
            this._hasValue = false;
            this._lastValue = Bridge.getDefaultValue(System.Int32);
        },
        onNext: function (value) {
            if (this._hasValue) {
                if (value < this._lastValue) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
                this._hasValue = true;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Int32$onError(error);
            System.Reactive.Sink$1(System.Int32).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._hasValue) {
                this._observer.System$IObserver$1$System$Int32$onError(new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            } else {
                this._observer.System$IObserver$1$System$Int32$onNext(this._lastValue);
                this._observer.System$IObserver$1$System$Int32$onCompleted();
            }

            System.Reactive.Sink$1(System.Int32).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinInt32Nullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Int32)),System.IObserver$1(System.Nullable$1(System.Int32))],
        _lastValue: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Int32$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Int32$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Int32$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Int32)).ctor.call(this, observer, cancel);
            this._lastValue = null;
        },
        onNext: function (value) {
            if (!System.Nullable.hasValue(value)) {
                return;
            }

            if (System.Nullable.hasValue(this._lastValue)) {
                if (System.Nullable.lt(value, this._lastValue)) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Int32$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Int32)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Nullable$1$System$Int32$onNext(this._lastValue);
            this._observer.System$IObserver$1$System$Nullable$1$System$Int32$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Int32)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinInt64._", {
        inherits: [System.Reactive.Sink$1(System.Int64),System.IObserver$1(System.Int64)],
        _hasValue: false,
        _lastValue: System.Int64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Int64$onNext",
            "onError", "System$IObserver$1$System$Int64$onError",
            "onCompleted", "System$IObserver$1$System$Int64$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Int64).ctor.call(this, observer, cancel);
            this._hasValue = false;
            this._lastValue = Bridge.getDefaultValue(System.Int64);
        },
        onNext: function (value) {
            if (this._hasValue) {
                if (value.lt(this._lastValue)) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
                this._hasValue = true;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Int64$onError(error);
            System.Reactive.Sink$1(System.Int64).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._hasValue) {
                this._observer.System$IObserver$1$System$Int64$onError(new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            } else {
                this._observer.System$IObserver$1$System$Int64$onNext(this._lastValue);
                this._observer.System$IObserver$1$System$Int64$onCompleted();
            }

            System.Reactive.Sink$1(System.Int64).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinInt64Nullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Int64)),System.IObserver$1(System.Nullable$1(System.Int64))],
        _lastValue: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Int64$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Int64$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Int64$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Int64)).ctor.call(this, observer, cancel);
            this._lastValue = null;
        },
        onNext: function (value) {
            if (!System.Nullable.hasValue(value)) {
                return;
            }

            if (System.Nullable.hasValue(this._lastValue)) {
                if (System.Nullable.liftcmp("lt", value, this._lastValue)) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Int64$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Int64)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Nullable$1$System$Int64$onNext(this._lastValue);
            this._observer.System$IObserver$1$System$Nullable$1$System$Int64$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Int64)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinSingle._", {
        inherits: [System.Reactive.Sink$1(System.Single),System.IObserver$1(System.Single)],
        _hasValue: false,
        _lastValue: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Single$onNext",
            "onError", "System$IObserver$1$System$Single$onError",
            "onCompleted", "System$IObserver$1$System$Single$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Single).ctor.call(this, observer, cancel);
            this._hasValue = false;
            this._lastValue = Bridge.getDefaultValue(System.Single);
        },
        onNext: function (value) {
            if (this._hasValue) {
                if (value < this._lastValue || isNaN(value)) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
                this._hasValue = true;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Single$onError(error);
            System.Reactive.Sink$1(System.Single).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._hasValue) {
                this._observer.System$IObserver$1$System$Single$onError(new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            } else {
                this._observer.System$IObserver$1$System$Single$onNext(this._lastValue);
                this._observer.System$IObserver$1$System$Single$onCompleted();
            }

            System.Reactive.Sink$1(System.Single).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinSingleNullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Single)),System.IObserver$1(System.Nullable$1(System.Single))],
        _lastValue: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Single$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Single$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Single$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Single)).ctor.call(this, observer, cancel);
            this._lastValue = null;
        },
        onNext: function (value) {
            if (!System.Nullable.hasValue(value)) {
                return;
            }

            if (System.Nullable.hasValue(this._lastValue)) {
                if (System.Nullable.lt(value, this._lastValue) || isNaN(System.Nullable.getValue(value))) {
                    this._lastValue = value;
                }
            } else {
                this._lastValue = value;
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Single$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Single)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Nullable$1$System$Single$onNext(this._lastValue);
            this._observer.System$IObserver$1$System$Nullable$1$System$Single$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Single)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MostRecent$1", function (TSource) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.PushToPullAdapter$2(TSource,TSource)],
        _initialValue: Bridge.getDefaultValue(TSource),
        ctor: function (source, initialValue) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.PushToPullAdapter$2(TSource,TSource).ctor.call(this, source);
            this._initialValue = initialValue;
        },
        run: function (subscription) {
            return new (System.Reactive.Linq.ObservableImpl.MostRecent$1._(TSource))(this._initialValue, subscription);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Multicast$3._", function (TSource, TIntermediate, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.IObserver$1(TResult)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var observable = null;
            var connectable = null;
            try {
                var subject = this._parent._subjectSelector();
                connectable = new (System.Reactive.Subjects.ConnectableObservable$2(TSource,TIntermediate))(this._parent._source, subject);
                observable = this._parent._selector(connectable);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return System.Reactive.Disposables.Disposable.getEmpty();
            }

            var subscription = System.ObservableExtensions.subscribeSafe(TResult, observable, this);
            var connection = connectable["System$Reactive$Subjects$IConnectableObservable$1$" + Bridge.getTypeAlias(TIntermediate) + "$connect"]();

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(subscription, connection);
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](value);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Never$1", function (TResult) { return {
        inherits: [System.IObservable$1(TResult)],
        config: {
            alias: [
            "subscribe", "System$IObservable$1$" + Bridge.getTypeAlias(TResult) + "$subscribe"
            ]
        },
        subscribe: function (observer) {
            if (observer == null) {
                throw new System.ArgumentNullException("observer");
            }

            return System.Reactive.Disposables.Disposable.getEmpty();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Next$1", function (TSource) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.PushToPullAdapter$2(TSource,TSource)],
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.PushToPullAdapter$2(TSource,TSource).ctor.call(this, source);
        },
        run: function (subscription) {
            return new (System.Reactive.Linq.ObservableImpl.Next$1._(TSource))(subscription);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.OfType$2._", function (TSource, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.IObserver$1(TSource)],
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
        },
        onNext: function (value) {
            if (Bridge.is(value, TResult)) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](Bridge.cast(value, TResult));
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Range._", {
        inherits: [System.Reactive.Sink$1(System.Int32)],
        _parent: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Int32).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var longRunning = System.Reactive.Concurrency.Scheduler.asLongRunning(this._parent._scheduler);
            if (longRunning != null) {
                return longRunning.System$Reactive$Concurrency$ISchedulerLongRunning$scheduleLongRunning(System.Int32, 0, Bridge.fn.bind(this, this.loop));
            } else {
                return System.Reactive.Concurrency.Scheduler.schedule$6(System.Int32, this._parent._scheduler, 0, Bridge.fn.bind(this, this.loopRec));
            }
        },
        loop: function (i, cancel) {
            while (!cancel.System$Reactive$Disposables$ICancelable$getIsDisposed() && i < this._parent._count) {
                this._observer.System$IObserver$1$System$Int32$onNext(((this._parent._start + i) | 0));
                i = (i + 1) | 0;
            }

            if (!cancel.System$Reactive$Disposables$ICancelable$getIsDisposed()) {
                this._observer.System$IObserver$1$System$Int32$onCompleted();
            }

            System.Reactive.Sink$1(System.Int32).prototype.dispose.call(this);
        },
        loopRec: function (i, recurse) {
            if (i < this._parent._count) {
                this._observer.System$IObserver$1$System$Int32$onNext(((this._parent._start + i) | 0));
                recurse(((i + 1) | 0));
            } else {
                this._observer.System$IObserver$1$System$Int32$onCompleted();
                System.Reactive.Sink$1(System.Int32).prototype.dispose.call(this);
            }
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.RefCount$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var $t;
            var subscription = System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this);

            this._parent._gate;
            {
                if ((($t = (this._parent._count + 1) | 0, this._parent._count = $t, $t)) === 1) {
                    this._parent._connectableSubscription = this._parent._source["System$Reactive$Subjects$IConnectableObservable$1$" + Bridge.getTypeAlias(TSource) + "$connect"]();
                }
            }

            return System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, function () {
                var $t1;
                subscription.System$IDisposable$dispose();

                this._parent._gate;
                {
                    if ((($t1 = (this._parent._count - 1) | 0, this._parent._count = $t1, $t1)) === 0) {
                        this._parent._connectableSubscription.System$IDisposable$dispose();
                    }
                }
            }));
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Repeat$1._", function (TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult)],
        _parent: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var longRunning = System.Reactive.Concurrency.Scheduler.asLongRunning(this._parent._scheduler);
            if (longRunning != null) {
                return this.run$2(longRunning);
            } else {
                return this.run$1(this._parent._scheduler);
            }
        },
        run$1: function (scheduler) {
            if (this._parent._repeatCount == null) {
                return System.Reactive.Concurrency.Scheduler.schedule$1(scheduler, Bridge.fn.bind(this, this.loopRecInf));
            } else {
                return System.Reactive.Concurrency.Scheduler.schedule$6(System.Int32, scheduler, System.Nullable.getValue(this._parent._repeatCount), Bridge.fn.bind(this, this.loopRec));
            }
        },
        run$2: function (scheduler) {
            if (this._parent._repeatCount == null) {
                return System.Reactive.Concurrency.Scheduler.scheduleLongRunning(scheduler, Bridge.fn.bind(this, this.loopInf));
            } else {
                return scheduler.System$Reactive$Concurrency$ISchedulerLongRunning$scheduleLongRunning(System.Int32, System.Nullable.getValue(this._parent._repeatCount), Bridge.fn.bind(this, this.loop));
            }
        },
        loopRecInf: function (recurse) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](this._parent._value);
            recurse();
        },
        loopRec: function (n, recurse) {
            if (n > 0) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](this._parent._value);
                n = (n - 1) | 0;
            }

            if (n === 0) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return;
            }

            recurse(n);
        },
        loopInf: function (cancel) {
            var value = this._parent._value;
            while (!cancel.System$Reactive$Disposables$ICancelable$getIsDisposed()) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](value);
            }

            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        },
        loop: function (n, cancel) {
            var value = this._parent._value;
            while (n > 0 && !cancel.System$Reactive$Disposables$ICancelable$getIsDisposed()) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](value);
                n = (n - 1) | 0;
            }

            if (!cancel.System$Reactive$Disposables$ICancelable$getIsDisposed()) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
            }

            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Return$1._", function (TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult)],
        _parent: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            return System.Reactive.Concurrency.Scheduler.schedule(this._parent._scheduler, Bridge.fn.bind(this, this.invoke));
        },
        invoke: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](this._parent._value);
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Sample$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        _sourceSubscription: null,
        _hasValue: false,
        _value: Bridge.getDefaultValue(TSource),
        _atEnd: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };

            var sourceSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._sourceSubscription = sourceSubscription;
            sourceSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(sourceSubscription, System.Reactive.Concurrency.Scheduler.schedulePeriodic(this._parent._scheduler, this._parent._interval, Bridge.fn.bind(this, this.tick)));
        },
        tick: function () {
            this._gate;
            {
                if (this._hasValue) {
                    this._hasValue = false;
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._value);
                }

                if (this._atEnd) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                }
            }
        },
        onNext: function (value) {
            this._gate;
            {
                this._hasValue = true;
                this._value = value;
            }
        },
        onError: function (error) {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._gate;
            {
                this._atEnd = true;
                this._sourceSubscription.System$IDisposable$dispose();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Sample$2._", function (TSource, TSample) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        _sourceSubscription: null,
        _hasValue: false,
        _value: Bridge.getDefaultValue(TSource),
        _atEnd: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };

            var sourceSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._sourceSubscription = sourceSubscription;
            sourceSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            var samplerSubscription = System.ObservableExtensions.subscribeSafe(TSample, this._parent._sampler, new (System.Reactive.Linq.ObservableImpl.Sample$2._.SampleImpl(TSource,TSample))(this));

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(this._sourceSubscription, samplerSubscription);
        },
        onNext: function (value) {
            this._gate;
            {
                this._hasValue = true;
                this._value = value;
            }
        },
        onError: function (error) {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._gate;
            {
                this._atEnd = true;
                this._sourceSubscription.System$IDisposable$dispose();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Sample$2._.SampleImpl", function (TSource, TSample) { return {
        inherits: [System.IObserver$1(TSample)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSample) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSample) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSample) + "$onCompleted"
            ]
        },
        ctor: function (parent) {
            this.$initialize();
            this._parent = parent;
        },
        onNext: function (value) {
            this._parent._gate;
            {
                if (this._parent._hasValue) {
                    this._parent._hasValue = false;
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._parent._value);
                }

                if (this._parent._atEnd) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    this._parent.dispose();
                }
            }
        },
        onError: function (error) {
            // BREAKING CHANGE v2 > v1.x - This error used to be swallowed
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._gate;
            {
                if (this._parent._hasValue) {
                    this._parent._hasValue = false;
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._parent._value);
                }

                if (this._parent._atEnd) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    this._parent.dispose();
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Scan$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _accumulation: Bridge.getDefaultValue(TSource),
        _hasAccumulation: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._accumulation = Bridge.getDefaultValue(TSource);
            this._hasAccumulation = false;
        },
        onNext: function (value) {
            try {
                if (this._hasAccumulation) {
                    this._accumulation = this._parent._accumulator(this._accumulation, value);
                } else {
                    this._accumulation = value;
                    this._hasAccumulation = true;
                }
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](exception);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                return;
            }

            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._accumulation);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Scan$2._", function (TSource, TAccumulate) { return {
        inherits: [System.Reactive.Sink$1(TAccumulate),System.IObserver$1(TSource)],
        _parent: null,
        _accumulation: Bridge.getDefaultValue(TAccumulate),
        _hasAccumulation: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TAccumulate).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._accumulation = Bridge.getDefaultValue(TAccumulate);
            this._hasAccumulation = false;
        },
        onNext: function (value) {
            try {
                if (this._hasAccumulation) {
                    this._accumulation = this._parent._accumulator(this._accumulation, value);
                } else {
                    this._accumulation = this._parent._accumulator(this._parent._seed, value);
                    this._hasAccumulation = true;
                }
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TAccumulate) + "$onError"](exception);
                System.Reactive.Sink$1(TAccumulate).prototype.dispose.call(this);
                return;
            }

            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TAccumulate) + "$onNext"](this._accumulation);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TAccumulate) + "$onError"](error);
            System.Reactive.Sink$1(TAccumulate).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TAccumulate) + "$onCompleted"]();
            System.Reactive.Sink$1(TAccumulate).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Select$2._", function (TSource, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.IObserver$1(TSource)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        onNext: function (value) {
            var result = Bridge.getDefaultValue(TResult);
            try {
                result = this._parent._selector(value);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return;
            }

            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Select$2.SelectImpl", function (TSource, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.IObserver$1(TSource)],
        _parent: null,
        _index: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._index = 0;
        },
        onNext: function (value) {
            var result = Bridge.getDefaultValue(TResult);
            try {
                result = this._parent._selectorI(value, Bridge.identity(this._index, (this._index = Bridge.Int.check(this._index + 1, System.Int32))));
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return;
            }

            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SelectMany$2._", function (TSource, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        _isStopped: false,
        _group: null,
        _sourceSubscription: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };
            this._isStopped = false;
            this._group = new System.Reactive.Disposables.CompositeDisposable.ctor();

            this._sourceSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._group.add(this._sourceSubscription);
            this._sourceSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            return this._group;
        },
        onNext: function (value) {
            var inner = null;

            try {
                inner = this._parent._selector(value);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._gate;
                {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                }
                return;
            }

            this.subscribeInner(inner);
        },
        onError: function (error) {
            if (!Bridge.staticEquals(this._parent._selectorOnError, null)) {
                var inner = null;

                try {
                    inner = this._parent._selectorOnError(error);
                }
                catch (ex) {
                    ex = System.Exception.create(ex);
                    this._gate;
                    {
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                        System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                    }
                    return;
                }

                this.subscribeInner(inner);

                this.final();
            } else {
                this._gate;
                {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                }
            }
        },
        onCompleted: function () {
            if (!Bridge.staticEquals(this._parent._selectorOnCompleted, null)) {
                var inner = null;

                try {
                    inner = this._parent._selectorOnCompleted();
                }
                catch (ex) {
                    ex = System.Exception.create(ex);
                    this._gate;
                    {
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                        System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                    }
                    return;
                }

                this.subscribeInner(inner);
            }

            this.final();
        },
        final: function () {
            this._isStopped = true;
            if (this._group.getCount() === 1) {
                //
                // Notice there can be a race between OnCompleted of the source and any
                // of the inner sequences, where both see _group.Count == 1, and one is
                // waiting for the lock. There won't be a double OnCompleted observation
                // though, because the call to Dispose silences the observer by swapping
                // in a NopObserver<T>.
                //
                this._gate;
                {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                }
            } else {
                this._sourceSubscription.dispose();
            }
        },
        subscribeInner: function (inner) {
            var innerSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._group.add(innerSubscription);
            innerSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TResult, inner, new (System.Reactive.Linq.ObservableImpl.SelectMany$2._.Iter(TSource,TResult))(this, innerSubscription)));
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SelectMany$2._.Iter", function (TSource, TResult) { return {
        inherits: [System.IObserver$1(TResult)],
        _parent: null,
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"
            ]
        },
        ctor: function (parent, self) {
            this.$initialize();
            this._parent = parent;
            this._self = self;
        },
        onNext: function (value) {
            this._parent._gate;
            this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](value);
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._group.remove(this._self);
            if (this._parent._isStopped && this._parent._group.getCount() === 1) {
                //
                // Notice there can be a race between OnCompleted of the source and any
                // of the inner sequences, where both see _group.Count == 1, and one is
                // waiting for the lock. There won't be a double OnCompleted observation
                // though, because the call to Dispose silences the observer by swapping
                // in a NopObserver<T>.
                //
                this._parent._gate;
                {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    this._parent.dispose();
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SelectMany$2.IndexSelectorImpl", function (TSource, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        _isStopped: false,
        _group: null,
        _sourceSubscription: null,
        _index: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };
            this._isStopped = false;
            this._group = new System.Reactive.Disposables.CompositeDisposable.ctor();

            this._sourceSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._group.add(this._sourceSubscription);
            this._sourceSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            return this._group;
        },
        onNext: function (value) {
            var inner = null;

            try {
                inner = this._parent._selectorI(value, Bridge.identity(this._index, (this._index = Bridge.Int.check(this._index + 1, System.Int32))));
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._gate;
                {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                }
                return;
            }

            this.subscribeInner(inner);
        },
        onError: function (error) {
            if (!Bridge.staticEquals(this._parent._selectorOnError, null)) {
                var inner = null;

                try {
                    inner = this._parent._selectorOnError(error);
                }
                catch (ex) {
                    ex = System.Exception.create(ex);
                    this._gate;
                    {
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                        System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                    }
                    return;
                }

                this.subscribeInner(inner);

                this.final();
            } else {
                this._gate;
                {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                }
            }
        },
        onCompleted: function () {
            if (!Bridge.staticEquals(this._parent._selectorOnCompleted, null)) {
                var inner = null;

                try {
                    inner = this._parent._selectorOnCompleted();
                }
                catch (ex) {
                    ex = System.Exception.create(ex);
                    this._gate;
                    {
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                        System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                    }
                    return;
                }

                this.subscribeInner(inner);
            }

            this.final();
        },
        final: function () {
            this._isStopped = true;
            if (this._group.getCount() === 1) {
                //
                // Notice there can be a race between OnCompleted of the source and any
                // of the inner sequences, where both see _group.Count == 1, and one is
                // waiting for the lock. There won't be a double OnCompleted observation
                // though, because the call to Dispose silences the observer by swapping
                // in a NopObserver<T>.
                //
                this._gate;
                {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                }
            } else {
                this._sourceSubscription.dispose();
            }
        },
        subscribeInner: function (inner) {
            var innerSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._group.add(innerSubscription);
            innerSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TResult, inner, new (System.Reactive.Linq.ObservableImpl.SelectMany$2.IndexSelectorImpl.Iter(TSource,TResult))(this, innerSubscription)));
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SelectMany$2.IndexSelectorImpl.Iter", function (TSource, TResult) { return {
        inherits: [System.IObserver$1(TResult)],
        _parent: null,
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"
            ]
        },
        ctor: function (parent, self) {
            this.$initialize();
            this._parent = parent;
            this._self = self;
        },
        onNext: function (value) {
            this._parent._gate;
            this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](value);
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._group.remove(this._self);
            if (this._parent._isStopped && this._parent._group.getCount() === 1) {
                //
                // Notice there can be a race between OnCompleted of the source and any
                // of the inner sequences, where both see _group.Count == 1, and one is
                // waiting for the lock. There won't be a double OnCompleted observation
                // though, because the call to Dispose silences the observer by swapping
                // in a NopObserver<T>.
                //
                this._parent._gate;
                {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    this._parent.dispose();
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SelectMany$2.NoSelectorImpl", function (TSource, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.IObserver$1(TSource)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        onNext: function (value) {
            var xs = null;
            try {
                xs = this._parent._selectorE(value);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return;
            }

            var e = null;
            try {
                e = Bridge.getEnumerator(xs, TResult);
            }
            catch (exception1) {
                exception1 = System.Exception.create(exception1);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception1);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return;
            }

            try {
                var hasNext = true;
                while (hasNext) {
                    hasNext = false;
                    var current = Bridge.getDefaultValue(TResult);

                    try {
                        hasNext = e.System$Collections$IEnumerator$moveNext();
                        if (hasNext) {
                            current = e[Bridge.geti(e, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(TResult) + "$getCurrent$1", "getCurrent$1")]();
                        }
                    }
                    catch (exception2) {
                        exception2 = System.Exception.create(exception2);
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception2);
                        System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                        return;
                    }

                    if (hasNext) {
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](current);
                    }
                }
            }
            finally {
                if (e != null) {
                    e.System$IDisposable$dispose();
                }
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SelectMany$2.Omega", function (TSource, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.IObserver$1(TSource)],
        _parent: null,
        _index: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        onNext: function (value) {
            var xs = null;
            try {
                xs = this._parent._selectorEI(value, Bridge.identity(this._index, (this._index = Bridge.Int.check(this._index + 1, System.Int32))));
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return;
            }

            var e = null;
            try {
                e = Bridge.getEnumerator(xs, TResult);
            }
            catch (exception1) {
                exception1 = System.Exception.create(exception1);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception1);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return;
            }

            try {
                var hasNext = true;
                while (hasNext) {
                    hasNext = false;
                    var current = Bridge.getDefaultValue(TResult);

                    try {
                        hasNext = e.System$Collections$IEnumerator$moveNext();
                        if (hasNext) {
                            current = e[Bridge.geti(e, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(TResult) + "$getCurrent$1", "getCurrent$1")]();
                        }
                    }
                    catch (exception2) {
                        exception2 = System.Exception.create(exception2);
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception2);
                        System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                        return;
                    }

                    if (hasNext) {
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](current);
                    }
                }
            }
            finally {
                if (e != null) {
                    e.System$IDisposable$dispose();
                }
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SelectMany$3._", function (TSource, TCollection, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        _isStopped: false,
        _group: null,
        _sourceSubscription: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };
            this._isStopped = false;
            this._group = new System.Reactive.Disposables.CompositeDisposable.ctor();

            this._sourceSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._group.add(this._sourceSubscription);
            this._sourceSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            return this._group;
        },
        onNext: function (value) {
            var collection = null;

            try {
                collection = this._parent._collectionSelector(value);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._gate;
                {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                }
                return;
            }

            var innerSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._group.add(innerSubscription);
            innerSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TCollection, collection, new (System.Reactive.Linq.ObservableImpl.SelectMany$3._.Iter(TSource,TCollection,TResult))(this, value, innerSubscription)));
        },
        onError: function (error) {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._isStopped = true;
            if (this._group.getCount() === 1) {
                //
                // Notice there can be a race between OnCompleted of the source and any
                // of the inner sequences, where both see _group.Count == 1, and one is
                // waiting for the lock. There won't be a double OnCompleted observation
                // though, because the call to Dispose silences the observer by swapping
                // in a NopObserver<T>.
                //
                this._gate;
                {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                }
            } else {
                this._sourceSubscription.dispose();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SelectMany$3._.Iter", function (TSource, TCollection, TResult) { return {
        inherits: [System.IObserver$1(TCollection)],
        _parent: null,
        _value: Bridge.getDefaultValue(TSource),
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TCollection) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TCollection) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TCollection) + "$onCompleted"
            ]
        },
        ctor: function (parent, value, self) {
            this.$initialize();
            this._parent = parent;
            this._value = value;
            this._self = self;
        },
        onNext: function (value) {
            var res = Bridge.getDefaultValue(TResult);

            try {
                res = this._parent._parent._resultSelector(this._value, value);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._parent._gate;
                {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                    this._parent.dispose();
                }
                return;
            }

            this._parent._gate;
            this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](res);
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._group.remove(this._self);
            if (this._parent._isStopped && this._parent._group.getCount() === 1) {
                //
                // Notice there can be a race between OnCompleted of the source and any
                // of the inner sequences, where both see _group.Count == 1, and one is
                // waiting for the lock. There won't be a double OnCompleted observation
                // though, because the call to Dispose silences the observer by swapping
                // in a NopObserver<T>.
                //
                this._parent._gate;
                {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    this._parent.dispose();
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SelectMany$3.IndexSelectorImpl", function (TSource, TCollection, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        _isStopped: false,
        _group: null,
        _sourceSubscription: null,
        _index: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };
            this._isStopped = false;
            this._group = new System.Reactive.Disposables.CompositeDisposable.ctor();

            this._sourceSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._group.add(this._sourceSubscription);
            this._sourceSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            return this._group;
        },
        onNext: function (value) {
            var index = Bridge.identity(this._index, (this._index = Bridge.Int.check(this._index + 1, System.Int32)));
            var collection = null;

            try {
                collection = this._parent._collectionSelectorI(value, index);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._gate;
                {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                }
                return;
            }

            var innerSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._group.add(innerSubscription);
            innerSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TCollection, collection, new (System.Reactive.Linq.ObservableImpl.SelectMany$3.IndexSelectorImpl.Iter(TSource,TCollection,TResult))(this, value, index, innerSubscription)));
        },
        onError: function (error) {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._isStopped = true;
            if (this._group.getCount() === 1) {
                //
                // Notice there can be a race between OnCompleted of the source and any
                // of the inner sequences, where both see _group.Count == 1, and one is
                // waiting for the lock. There won't be a double OnCompleted observation
                // though, because the call to Dispose silences the observer by swapping
                // in a NopObserver<T>.
                //
                this._gate;
                {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                }
            } else {
                this._sourceSubscription.dispose();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SelectMany$3.IndexSelectorImpl.Iter", function (TSource, TCollection, TResult) { return {
        inherits: [System.IObserver$1(TCollection)],
        _parent: null,
        _value: Bridge.getDefaultValue(TSource),
        _valueIndex: 0,
        _self: null,
        _index: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TCollection) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TCollection) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TCollection) + "$onCompleted"
            ]
        },
        ctor: function (parent, value, index, self) {
            this.$initialize();
            this._parent = parent;
            this._value = value;
            this._valueIndex = index;
            this._self = self;
        },
        onNext: function (value) {
            var res = Bridge.getDefaultValue(TResult);

            try {
                res = this._parent._parent._resultSelectorI(this._value, this._valueIndex, value, Bridge.identity(this._index, (this._index = Bridge.Int.check(this._index + 1, System.Int32))));
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._parent._gate;
                {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                    this._parent.dispose();
                }
                return;
            }

            this._parent._gate;
            this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](res);
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._group.remove(this._self);
            if (this._parent._isStopped && this._parent._group.getCount() === 1) {
                //
                // Notice there can be a race between OnCompleted of the source and any
                // of the inner sequences, where both see _group.Count == 1, and one is
                // waiting for the lock. There won't be a double OnCompleted observation
                // though, because the call to Dispose silences the observer by swapping
                // in a NopObserver<T>.
                //
                this._parent._gate;
                {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    this._parent.dispose();
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SelectMany$3.NoSelectorImpl", function (TSource, TCollection, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.IObserver$1(TSource)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        onNext: function (value) {
            var xs = null;
            try {
                xs = this._parent._collectionSelectorE(value);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return;
            }

            var e = null;
            try {
                e = Bridge.getEnumerator(xs, TCollection);
            }
            catch (exception1) {
                exception1 = System.Exception.create(exception1);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception1);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return;
            }

            try {
                var hasNext = true;
                while (hasNext) {
                    hasNext = false;
                    var current = Bridge.getDefaultValue(TResult);

                    try {
                        hasNext = e.System$Collections$IEnumerator$moveNext();
                        if (hasNext) {
                            current = this._parent._resultSelector(value, e[Bridge.geti(e, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(TCollection) + "$getCurrent$1", "getCurrent$1")]());
                        }
                    }
                    catch (exception2) {
                        exception2 = System.Exception.create(exception2);
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception2);
                        System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                        return;
                    }

                    if (hasNext) {
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](current);
                    }
                }
            }
            finally {
                if (e != null) {
                    e.System$IDisposable$dispose();
                }
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SelectMany$3.Omega", function (TSource, TCollection, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.IObserver$1(TSource)],
        _parent: null,
        _index: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        onNext: function (value) {
            var index = Bridge.identity(this._index, (this._index = Bridge.Int.check(this._index + 1, System.Int32)));

            var xs = null;
            try {
                xs = this._parent._collectionSelectorEI(value, index);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return;
            }

            var e = null;
            try {
                e = Bridge.getEnumerator(xs, TCollection);
            }
            catch (exception1) {
                exception1 = System.Exception.create(exception1);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception1);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return;
            }

            try {
                var eIndex = 0;
                var hasNext = true;
                while (hasNext) {
                    hasNext = false;
                    var current = Bridge.getDefaultValue(TResult);

                    try {
                        hasNext = e.System$Collections$IEnumerator$moveNext();
                        if (hasNext) {
                            current = this._parent._resultSelectorI(value, index, e[Bridge.geti(e, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(TCollection) + "$getCurrent$1", "getCurrent$1")](), Bridge.identity(eIndex, (eIndex = Bridge.Int.check(eIndex + 1, System.Int32))));
                        }
                    }
                    catch (exception2) {
                        exception2 = System.Exception.create(exception2);
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception2);
                        System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                        return;
                    }

                    if (hasNext) {
                        this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](current);
                    }
                }
            }
            finally {
                if (e != null) {
                    e.System$IDisposable$dispose();
                }
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SequenceEqual$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(Boolean)],
        _parent: null,
        _gate: null,
        _donel: false,
        _doner: false,
        _ql: null,
        _qr: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(Boolean).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };
            this._donel = false;
            this._doner = false;
            this._ql = new (System.Collections.Generic.Queue$1(TSource)).ctor();
            this._qr = new (System.Collections.Generic.Queue$1(TSource)).ctor();

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(System.ObservableExtensions.subscribeSafe(TSource, this._parent._first, new (System.Reactive.Linq.ObservableImpl.SequenceEqual$1._.F(TSource))(this)), System.ObservableExtensions.subscribeSafe(TSource, this._parent._second, new (System.Reactive.Linq.ObservableImpl.SequenceEqual$1._.S(TSource))(this)));
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SequenceEqual$1._.F", function (TSource) { return {
        inherits: [System.IObserver$1(TSource)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent) {
            this.$initialize();
            this._parent = parent;
        },
        onNext: function (value) {
            this._parent._gate;
            {
                if (this._parent._qr.getCount() > 0) {
                    var equal = false;
                    var v = this._parent._qr.dequeue();
                    try {
                        equal = this._parent._parent._comparer["System$Collections$Generic$IEqualityComparer$1$" + Bridge.getTypeAlias(TSource) + "$equals2"](value, v);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        this._parent._observer.System$IObserver$1$Boolean$onError(exception);
                        this._parent.dispose();
                        return;
                    }
                    if (!equal) {
                        this._parent._observer.System$IObserver$1$Boolean$onNext(false);
                        this._parent._observer.System$IObserver$1$Boolean$onCompleted();
                        this._parent.dispose();
                    }
                } else if (this._parent._doner) {
                    this._parent._observer.System$IObserver$1$Boolean$onNext(false);
                    this._parent._observer.System$IObserver$1$Boolean$onCompleted();
                    this._parent.dispose();
                } else {
                    this._parent._ql.enqueue(value);
                }
            }
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer.System$IObserver$1$Boolean$onError(error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._gate;
            {
                this._parent._donel = true;
                if (this._parent._ql.getCount() === 0) {
                    if (this._parent._qr.getCount() > 0) {
                        this._parent._observer.System$IObserver$1$Boolean$onNext(false);
                        this._parent._observer.System$IObserver$1$Boolean$onCompleted();
                        this._parent.dispose();
                    } else if (this._parent._doner) {
                        this._parent._observer.System$IObserver$1$Boolean$onNext(true);
                        this._parent._observer.System$IObserver$1$Boolean$onCompleted();
                        this._parent.dispose();
                    }
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SequenceEqual$1._.S", function (TSource) { return {
        inherits: [System.IObserver$1(TSource)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent) {
            this.$initialize();
            this._parent = parent;
        },
        onNext: function (value) {
            this._parent._gate;
            {
                if (this._parent._ql.getCount() > 0) {
                    var equal = false;
                    var v = this._parent._ql.dequeue();
                    try {
                        equal = this._parent._parent._comparer["System$Collections$Generic$IEqualityComparer$1$" + Bridge.getTypeAlias(TSource) + "$equals2"](v, value);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        this._parent._observer.System$IObserver$1$Boolean$onError(exception);
                        this._parent.dispose();
                        return;
                    }
                    if (!equal) {
                        this._parent._observer.System$IObserver$1$Boolean$onNext(false);
                        this._parent._observer.System$IObserver$1$Boolean$onCompleted();
                        this._parent.dispose();
                    }
                } else if (this._parent._donel) {
                    this._parent._observer.System$IObserver$1$Boolean$onNext(false);
                    this._parent._observer.System$IObserver$1$Boolean$onCompleted();
                    this._parent.dispose();
                } else {
                    this._parent._qr.enqueue(value);
                }
            }
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer.System$IObserver$1$Boolean$onError(error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._gate;
            {
                this._parent._doner = true;
                if (this._parent._qr.getCount() === 0) {
                    if (this._parent._ql.getCount() > 0) {
                        this._parent._observer.System$IObserver$1$Boolean$onNext(false);
                        this._parent._observer.System$IObserver$1$Boolean$onCompleted();
                        this._parent.dispose();
                    } else if (this._parent._donel) {
                        this._parent._observer.System$IObserver$1$Boolean$onNext(true);
                        this._parent._observer.System$IObserver$1$Boolean$onCompleted();
                        this._parent.dispose();
                    }
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SequenceEqual$1.SequenceEqualImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(Boolean),System.IObserver$1(TSource)],
        _parent: null,
        _enumerator: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(Boolean).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            //
            // Notice the evaluation order of obtaining the enumerator and subscribing to the
            // observable sequence is reversed compared to the operator's signature. This is
            // required to make sure the enumerator is available as soon as the observer can
            // be called. Otherwise, we end up having a race for the initialization and use
            // of the _rightEnumerator field.
            //
            try {
                this._enumerator = Bridge.getEnumerator(this._parent._secondE, TSource);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer.System$IObserver$1$Boolean$onError(exception);
                System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
                return System.Reactive.Disposables.Disposable.getEmpty();
            }

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(System.ObservableExtensions.subscribeSafe(TSource, this._parent._first, this), this._enumerator);
        },
        onNext: function (value) {
            var equal = false;

            try {
                if (this._enumerator.System$Collections$IEnumerator$moveNext()) {
                    var current = this._enumerator[Bridge.geti(this._enumerator, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(TSource) + "$getCurrent$1", "getCurrent$1")]();
                    equal = this._parent._comparer["System$Collections$Generic$IEqualityComparer$1$" + Bridge.getTypeAlias(TSource) + "$equals2"](value, current);
                }
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer.System$IObserver$1$Boolean$onError(exception);
                System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
                return;
            }

            if (!equal) {
                this._observer.System$IObserver$1$Boolean$onNext(false);
                this._observer.System$IObserver$1$Boolean$onCompleted();
                System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$Boolean$onError(error);
            System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
        },
        onCompleted: function () {
            var hasNext = false;

            try {
                hasNext = this._enumerator.System$Collections$IEnumerator$moveNext();
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer.System$IObserver$1$Boolean$onError(exception);
                System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
                return;
            }

            this._observer.System$IObserver$1$Boolean$onNext(!hasNext);
            this._observer.System$IObserver$1$Boolean$onCompleted();
            System.Reactive.Sink$1(Boolean).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SingleAsync$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _value: Bridge.getDefaultValue(TSource),
        _seenValue: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;

            this._value = Bridge.getDefaultValue(TSource);
            this._seenValue = false;
        },
        onNext: function (value) {
            if (this._seenValue) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](new System.InvalidOperationException(System.Reactive.Strings_Linq.MORE_THAN_ONE_ELEMENT));
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                return;
            }

            this._value = value;
            this._seenValue = true;
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._seenValue && this._parent._throwOnEmpty) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS));
            } else {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._value);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            }

            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SingleAsync$1.SingleAsyncImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _value: Bridge.getDefaultValue(TSource),
        _seenValue: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;

            this._value = Bridge.getDefaultValue(TSource);
            this._seenValue = false;
        },
        onNext: function (value) {
            var b = false;

            try {
                b = this._parent._predicate(value);
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                return;
            }

            if (b) {
                if (this._seenValue) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](new System.InvalidOperationException(System.Reactive.Strings_Linq.MORE_THAN_ONE_MATCHING_ELEMENT));
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                    return;
                }

                this._value = value;
                this._seenValue = true;
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            if (!this._seenValue && this._parent._throwOnEmpty) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_MATCHING_ELEMENTS));
            } else {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._value);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            }

            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Skip$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _remaining: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._remaining = this._parent._count;
        },
        onNext: function (value) {
            if (this._remaining <= 0) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
            } else {
                this._remaining = (this._remaining - 1) | 0;
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Skip$1.SkipImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _open: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var t = System.Reactive.Concurrency.Scheduler.schedule$4(this._parent._scheduler, this._parent._duration, Bridge.fn.bind(this, this.tick));
            var d = System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this);
            return System.Reactive.Disposables.StableCompositeDisposable.create$1(t, d);
        },
        tick: function () {
            this._open = true;
        },
        onNext: function (value) {
            if (this._open) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SkipLast$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _queue: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._queue = new (System.Collections.Generic.Queue$1(TSource)).ctor();
        },
        onNext: function (value) {
            this._queue.enqueue(value);
            if (this._queue.getCount() > this._parent._count) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._queue.dequeue());
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SkipLast$1.SkipLastImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _queue: null,
        _watch: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._queue = new (System.Collections.Generic.Queue$1(System.Reactive.TimeInterval$1(TSource))).ctor();
        },
        run: function () {
            this._watch = System.Reactive.Concurrency.Scheduler.startStopwatch(this._parent._scheduler);

            return System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this);
        },
        onNext: function (value) {
            var now = this._watch.System$Reactive$Concurrency$IStopwatch$getElapsed();
            this._queue.enqueue(new (System.Reactive.TimeInterval$1(TSource)).$ctor1(value, now));
            while (this._queue.getCount() > 0 && System.TimeSpan.gte(System.TimeSpan.sub(now, this._queue.peek().getInterval()), this._parent._duration)) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._queue.dequeue().getValue());
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            var now = this._watch.System$Reactive$Concurrency$IStopwatch$getElapsed();
            while (this._queue.getCount() > 0 && System.TimeSpan.gte(System.TimeSpan.sub(now, this._queue.peek().getInterval()), this._parent._duration)) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._queue.dequeue().getValue());
            }

            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SkipUntil$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _open: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var t = System.Reactive.Concurrency.Scheduler.schedule$2(this._parent._scheduler, this._parent._startTime.$clone(), Bridge.fn.bind(this, this.tick));
            var d = System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this);
            return System.Reactive.Disposables.StableCompositeDisposable.create$1(t, d);
        },
        tick: function () {
            this._open = true;
        },
        onNext: function (value) {
            if (this._open) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SkipUntil$2._", function (TSource, TOther) { return {
        inherits: [System.Reactive.Sink$1(TSource)],
        _parent: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var sourceObserver = new (System.Reactive.Linq.ObservableImpl.SkipUntil$2._.T(TSource,TOther))(this);
            var otherObserver = new (System.Reactive.Linq.ObservableImpl.SkipUntil$2._.O(TSource,TOther))(this, sourceObserver);

            var sourceSubscription = System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, sourceObserver);
            var otherSubscription = System.ObservableExtensions.subscribeSafe(TOther, this._parent._other, otherObserver);

            sourceObserver.setDisposable(sourceSubscription);
            otherObserver.setDisposable(otherSubscription);

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(sourceSubscription, otherSubscription);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SkipUntil$2._.O", function (TSource, TOther) { return {
        inherits: [System.IObserver$1(TOther)],
        _parent: null,
        _sourceObserver: null,
        _subscription: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TOther) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TOther) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TOther) + "$onCompleted"
            ]
        },
        ctor: function (parent, sourceObserver) {
            this.$initialize();
            this._parent = parent;
            this._sourceObserver = sourceObserver;
            this._subscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
        },
        setDisposable: function (value) {
            this._subscription.setDisposable(value);
        },
        onNext: function (value) {
            this._sourceObserver._observer = this._parent._observer;
            this._subscription.dispose();
        },
        onError: function (error) {
            this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            this._parent.dispose();
        },
        onCompleted: function () {
            this._subscription.dispose();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SkipUntil$2._.T", function (TSource, TOther) { return {
        inherits: [System.IObserver$1(TSource)],
        _parent: null,
        _observer: null,
        _subscription: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent) {
            this.$initialize();
            this._parent = parent;
            this._observer = System.Reactive.NopObserver$1(TSource).instance;
            this._subscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
        },
        setDisposable: function (value) {
            this._subscription.setDisposable(value);
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            this._parent.dispose();
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            this._subscription.dispose(); // We can't cancel the other stream yet, it may be on its way to dispatch an OnError message and we don't want to have a race.
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SkipWhile$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _running: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._running = false;
        },
        onNext: function (value) {
            if (!this._running) {
                try {
                    this._running = !this._parent._predicate(value);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](exception);
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                    return;
                }
            }

            if (this._running) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SkipWhile$1.SkipWhileImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _running: false,
        _index: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._running = false;
            this._index = 0;
        },
        onNext: function (value) {
            if (!this._running) {
                try {
                    this._running = !this._parent._predicateI(value, Bridge.identity(this._index, (this._index = Bridge.Int.check(this._index + 1, System.Int32))));
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](exception);
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                    return;
                }
            }

            if (this._running) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumDecimal._", {
        inherits: [System.Reactive.Sink$1(System.Decimal),System.IObserver$1(System.Decimal)],
        _sum: System.Decimal(0.0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Decimal$onNext",
            "onError", "System$IObserver$1$System$Decimal$onError",
            "onCompleted", "System$IObserver$1$System$Decimal$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Decimal).ctor.call(this, observer, cancel);
            this._sum = System.Decimal(0.0);
        },
        onNext: function (value) {
            this._sum = this._sum.add(value);
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Decimal$onError(error);
            System.Reactive.Sink$1(System.Decimal).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Decimal$onNext(this._sum);
            this._observer.System$IObserver$1$System$Decimal$onCompleted();
            System.Reactive.Sink$1(System.Decimal).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumDecimalNullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Decimal)),System.IObserver$1(System.Nullable$1(System.Decimal))],
        _sum: System.Decimal(0.0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Decimal$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Decimal$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Decimal$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Decimal)).ctor.call(this, observer, cancel);
            this._sum = System.Decimal(0.0);
        },
        onNext: function (value) {
            if (System.Nullable.liftne("ne", value, System.Decimal.lift(null))) {
                this._sum = this._sum.add(System.Nullable.getValue(value));
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Decimal$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Decimal)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Nullable$1$System$Decimal$onNext(this._sum);
            this._observer.System$IObserver$1$System$Nullable$1$System$Decimal$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Decimal)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumDouble._", {
        inherits: [System.Reactive.Sink$1(System.Double),System.IObserver$1(System.Double)],
        _sum: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Double$onNext",
            "onError", "System$IObserver$1$System$Double$onError",
            "onCompleted", "System$IObserver$1$System$Double$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Double).ctor.call(this, observer, cancel);
            this._sum = 0.0;
        },
        onNext: function (value) {
            this._sum += value;
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Double$onError(error);
            System.Reactive.Sink$1(System.Double).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Double$onNext(this._sum);
            this._observer.System$IObserver$1$System$Double$onCompleted();
            System.Reactive.Sink$1(System.Double).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumDoubleNullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Double)),System.IObserver$1(System.Nullable$1(System.Double))],
        _sum: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Double$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Double$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Double$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).ctor.call(this, observer, cancel);
            this._sum = 0.0;
        },
        onNext: function (value) {
            if (value != null) {
                this._sum += System.Nullable.getValue(value);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Double$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Nullable$1$System$Double$onNext(this._sum);
            this._observer.System$IObserver$1$System$Nullable$1$System$Double$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Double)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumInt32._", {
        inherits: [System.Reactive.Sink$1(System.Int32),System.IObserver$1(System.Int32)],
        _sum: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Int32$onNext",
            "onError", "System$IObserver$1$System$Int32$onError",
            "onCompleted", "System$IObserver$1$System$Int32$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Int32).ctor.call(this, observer, cancel);
            this._sum = 0;
        },
        onNext: function (value) {
            try {
                this._sum = Bridge.Int.check(this._sum + value, System.Int32);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer.System$IObserver$1$System$Int32$onError(exception);
                System.Reactive.Sink$1(System.Int32).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Int32$onError(error);
            System.Reactive.Sink$1(System.Int32).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Int32$onNext(this._sum);
            this._observer.System$IObserver$1$System$Int32$onCompleted();
            System.Reactive.Sink$1(System.Int32).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumInt32Nullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Int32)),System.IObserver$1(System.Nullable$1(System.Int32))],
        _sum: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Int32$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Int32$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Int32$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Int32)).ctor.call(this, observer, cancel);
            this._sum = 0;
        },
        onNext: function (value) {
            try {
                if (value != null) {
                    this._sum = Bridge.Int.check(this._sum + System.Nullable.getValue(value), System.Int32);
                }
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer.System$IObserver$1$System$Nullable$1$System$Int32$onError(exception);
                System.Reactive.Sink$1(System.Nullable$1(System.Int32)).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Int32$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Int32)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Nullable$1$System$Int32$onNext(this._sum);
            this._observer.System$IObserver$1$System$Nullable$1$System$Int32$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Int32)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumInt64._", {
        inherits: [System.Reactive.Sink$1(System.Int64),System.IObserver$1(System.Int64)],
        _sum: System.Int64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Int64$onNext",
            "onError", "System$IObserver$1$System$Int64$onError",
            "onCompleted", "System$IObserver$1$System$Int64$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Int64).ctor.call(this, observer, cancel);
            this._sum = System.Int64(0);
        },
        onNext: function (value) {
            try {
                this._sum = this._sum.add(value, 1);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer.System$IObserver$1$System$Int64$onError(exception);
                System.Reactive.Sink$1(System.Int64).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Int64$onError(error);
            System.Reactive.Sink$1(System.Int64).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Int64$onNext(this._sum);
            this._observer.System$IObserver$1$System$Int64$onCompleted();
            System.Reactive.Sink$1(System.Int64).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumInt64Nullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Int64)),System.IObserver$1(System.Nullable$1(System.Int64))],
        _sum: System.Int64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Int64$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Int64$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Int64$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Int64)).ctor.call(this, observer, cancel);
            this._sum = System.Int64(0);
        },
        onNext: function (value) {
            try {
                if (System.Nullable.liftne("ne", value, System.Int64.lift(null))) {
                    this._sum = this._sum.add(System.Nullable.getValue(value), 1);
                }
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer.System$IObserver$1$System$Nullable$1$System$Int64$onError(exception);
                System.Reactive.Sink$1(System.Nullable$1(System.Int64)).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Int64$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Int64)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Nullable$1$System$Int64$onNext(this._sum);
            this._observer.System$IObserver$1$System$Nullable$1$System$Int64$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Int64)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumSingle._", {
        inherits: [System.Reactive.Sink$1(System.Single),System.IObserver$1(System.Single)],
        _sum: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Single$onNext",
            "onError", "System$IObserver$1$System$Single$onError",
            "onCompleted", "System$IObserver$1$System$Single$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Single).ctor.call(this, observer, cancel);
            this._sum = 0.0; // This is what LINQ to Objects does!
        },
        onNext: function (value) {
            this._sum += value; // This is what LINQ to Objects does!
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Single$onError(error);
            System.Reactive.Sink$1(System.Single).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Single$onNext(this._sum); // This is what LINQ to Objects does!
            this._observer.System$IObserver$1$System$Single$onCompleted();
            System.Reactive.Sink$1(System.Single).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumSingleNullable._", {
        inherits: [System.Reactive.Sink$1(System.Nullable$1(System.Single)),System.IObserver$1(System.Nullable$1(System.Single))],
        _sum: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$Nullable$1$System$Single$onNext",
            "onError", "System$IObserver$1$System$Nullable$1$System$Single$onError",
            "onCompleted", "System$IObserver$1$System$Nullable$1$System$Single$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Nullable$1(System.Single)).ctor.call(this, observer, cancel);
            this._sum = 0.0; // This is what LINQ to Objects does!
        },
        onNext: function (value) {
            if (value != null) {
                this._sum += System.Nullable.getValue(value);
            } // This is what LINQ to Objects does!
        },
        onError: function (error) {
            this._observer.System$IObserver$1$System$Nullable$1$System$Single$onError(error);
            System.Reactive.Sink$1(System.Nullable$1(System.Single)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$System$Nullable$1$System$Single$onNext(this._sum); // This is what LINQ to Objects does!
            this._observer.System$IObserver$1$System$Nullable$1$System$Single$onCompleted();
            System.Reactive.Sink$1(System.Nullable$1(System.Single)).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Switch$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(System.IObservable$1(TSource))],
        _parent: null,
        _gate: null,
        _subscription: null,
        _innerSubscription: null,
        _isStopped: false,
        _latest: System.UInt64(0),
        _hasLatest: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };
            this._innerSubscription = new System.Reactive.Disposables.SerialDisposable();
            this._isStopped = false;
            this._latest = System.UInt64(0);
            this._hasLatest = false;

            var subscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._subscription = subscription;
            subscription.setDisposable(System.ObservableExtensions.subscribeSafe(System.IObservable$1(TSource), this._parent._sources, this));

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(this._subscription, this._innerSubscription);
        },
        onNext: function (value) {
            var id = Bridge.getDefaultValue(System.UInt64);
            this._gate;
            {
                id = (this._latest = this._latest.inc());
                this._hasLatest = true;
            }

            var d = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._innerSubscription.setDisposable(d);
            d.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, value, new (System.Reactive.Linq.ObservableImpl.Switch$1._.Iter(TSource))(this, id, d)));
        },
        onError: function (error) {
            this._gate;
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);

            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._gate;
            {
                this._subscription.System$IDisposable$dispose();

                this._isStopped = true;
                if (!this._hasLatest) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Switch$1._.Iter", function (TSource) { return {
        inherits: [System.IObserver$1(TSource)],
        _parent: null,
        _id: System.UInt64(0),
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, id, self) {
            this.$initialize();
            this._parent = parent;
            this._id = id;
            this._self = self;
        },
        onNext: function (value) {
            this._parent._gate;
            {
                if (this._parent._latest.equals(this._id)) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
                }
            }
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._self.System$IDisposable$dispose();

                if (this._parent._latest.equals(this._id)) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                    this._parent.dispose();
                }
            }
        },
        onCompleted: function () {
            this._parent._gate;
            {
                this._self.System$IDisposable$dispose();

                if (this._parent._latest.equals(this._id)) {
                    this._parent._hasLatest = false;

                    if (this._parent._isStopped) {
                        this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                        this._parent.dispose();
                    }
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Synchronize$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            var $t;
            this._parent = parent;
            this._gate = ($t = this._parent._gate, $t != null ? $t : {  });
    },
    onNext: function (value) {
        this._gate;
        {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        }
    },
    onError: function (error) {
        this._gate;
        {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    },
    onCompleted: function () {
        this._gate;
        {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Take$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _remaining: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._remaining = this._parent._count;
        },
        onNext: function (value) {
            if (this._remaining > 0) {
                this._remaining = (this._remaining - 1) | 0;
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);

                if (this._remaining === 0) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                }
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Take$1.TakeImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };

            var t = System.Reactive.Concurrency.Scheduler.schedule$4(this._parent._scheduler, this._parent._duration, Bridge.fn.bind(this, this.tick));
            var d = System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this);
            return System.Reactive.Disposables.StableCompositeDisposable.create$1(t, d);
        },
        tick: function () {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        onNext: function (value) {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
            }
        },
        onError: function (error) {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.TakeLast$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _queue: null,
        _subscription: null,
        _loop: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._queue = new (System.Collections.Generic.Queue$1(TSource)).ctor();
        },
        run: function () {
            this._subscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._loop = new System.Reactive.Disposables.SingleAssignmentDisposable();

            this._subscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(this._subscription, this._loop);
        },
        onNext: function (value) {
            this._queue.enqueue(value);
            if (this._queue.getCount() > this._parent._count) {
                this._queue.dequeue();
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._subscription.dispose();

            var longRunning = System.Reactive.Concurrency.Scheduler.asLongRunning(this._parent._loopScheduler);
            if (longRunning != null) {
                this._loop.setDisposable(System.Reactive.Concurrency.Scheduler.scheduleLongRunning(longRunning, Bridge.fn.bind(this, this.loop)));
            } else {
                this._loop.setDisposable(System.Reactive.Concurrency.Scheduler.schedule$1(this._parent._loopScheduler, Bridge.fn.bind(this, this.loopRec)));
            }
        },
        loopRec: function (recurse) {
            if (this._queue.getCount() > 0) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._queue.dequeue());
                recurse();
            } else {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        loop: function (cancel) {
            var n = this._queue.getCount();

            while (!cancel.System$Reactive$Disposables$ICancelable$getIsDisposed()) {
                if (n === 0) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    break;
                } else {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._queue.dequeue());
                }

                n = (n - 1) | 0;
            }

            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.TakeLast$1.TakeLastImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _queue: null,
        _subscription: null,
        _loop: null,
        _watch: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._queue = new (System.Collections.Generic.Queue$1(System.Reactive.TimeInterval$1(TSource))).ctor();
        },
        run: function () {
            this._subscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._loop = new System.Reactive.Disposables.SingleAssignmentDisposable();

            this._watch = System.Reactive.Concurrency.Scheduler.startStopwatch(this._parent._scheduler);
            this._subscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(this._subscription, this._loop);
        },
        onNext: function (value) {
            var now = this._watch.System$Reactive$Concurrency$IStopwatch$getElapsed();
            this._queue.enqueue(new (System.Reactive.TimeInterval$1(TSource)).$ctor1(value, now));
            this.trim(now);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._subscription.dispose();

            var now = this._watch.System$Reactive$Concurrency$IStopwatch$getElapsed();
            this.trim(now);

            var longRunning = System.Reactive.Concurrency.Scheduler.asLongRunning(this._parent._loopScheduler);
            if (longRunning != null) {
                this._loop.setDisposable(System.Reactive.Concurrency.Scheduler.scheduleLongRunning(longRunning, Bridge.fn.bind(this, this.loop)));
            } else {
                this._loop.setDisposable(System.Reactive.Concurrency.Scheduler.schedule$1(this._parent._loopScheduler, Bridge.fn.bind(this, this.loopRec)));
            }
        },
        loopRec: function (recurse) {
            if (this._queue.getCount() > 0) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._queue.dequeue().getValue());
                recurse();
            } else {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        loop: function (cancel) {
            var n = this._queue.getCount();

            while (!cancel.System$Reactive$Disposables$ICancelable$getIsDisposed()) {
                if (n === 0) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    break;
                } else {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._queue.dequeue().getValue());
                }

                n = (n - 1) | 0;
            }

            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        trim: function (now) {
            while (this._queue.getCount() > 0 && System.TimeSpan.gte(System.TimeSpan.sub(now, this._queue.peek().getInterval()), this._parent._duration)) {
                this._queue.dequeue();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.TakeLastBuffer$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        _queue: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._queue = new (System.Collections.Generic.Queue$1(TSource)).ctor();
        },
        onNext: function (value) {
            this._queue.enqueue(value);
            if (this._queue.getCount() > this._parent._count) {
                this._queue.dequeue();
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            var res = new (System.Collections.Generic.List$1(TSource))(this._queue.getCount());
            while (this._queue.getCount() > 0) {
                res.add(this._queue.dequeue());
            }

            this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](res);
            this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.TakeLastBuffer$1.Impl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        _queue: null,
        _watch: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._queue = new (System.Collections.Generic.Queue$1(System.Reactive.TimeInterval$1(TSource))).ctor();
        },
        run: function () {
            this._watch = System.Reactive.Concurrency.Scheduler.startStopwatch(this._parent._scheduler);

            return System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this);
        },
        onNext: function (value) {
            var now = this._watch.System$Reactive$Concurrency$IStopwatch$getElapsed();
            this._queue.enqueue(new (System.Reactive.TimeInterval$1(TSource)).$ctor1(value, now));
            this.trim(now);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            var now = this._watch.System$Reactive$Concurrency$IStopwatch$getElapsed();
            this.trim(now);

            var res = new (System.Collections.Generic.List$1(TSource))(this._queue.getCount());
            while (this._queue.getCount() > 0) {
                res.add(this._queue.dequeue().getValue());
            }

            this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](res);
            this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
        },
        trim: function (now) {
            while (this._queue.getCount() > 0 && System.TimeSpan.gte(System.TimeSpan.sub(now, this._queue.peek().getInterval()), this._parent._duration)) {
                this._queue.dequeue();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.TakeUntil$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };

            var t = System.Reactive.Concurrency.Scheduler.schedule$2(this._parent._scheduler, this._parent._endTime.$clone(), Bridge.fn.bind(this, this.tick));
            var d = System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this);
            return System.Reactive.Disposables.StableCompositeDisposable.create$1(t, d);
        },
        tick: function () {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        onNext: function (value) {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
            }
        },
        onError: function (error) {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.TakeUntil$2._", function (TSource, TOther) { return {
        inherits: [System.Reactive.Sink$1(TSource)],
        _parent: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var sourceObserver = new (System.Reactive.Linq.ObservableImpl.TakeUntil$2._.T(TSource,TOther))(this);
            var otherObserver = new (System.Reactive.Linq.ObservableImpl.TakeUntil$2._.O(TSource,TOther))(this, sourceObserver);

            // COMPAT - Order of Subscribe calls per v1.0.10621
            var otherSubscription = System.ObservableExtensions.subscribeSafe(TOther, this._parent._other, otherObserver);
            otherObserver.setDisposable(otherSubscription);

            var sourceSubscription = System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, sourceObserver);

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(otherSubscription, sourceSubscription);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.TakeUntil$2._.O", function (TSource, TOther) { return {
        inherits: [System.IObserver$1(TOther)],
        _parent: null,
        _sourceObserver: null,
        _subscription: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TOther) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TOther) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TOther) + "$onCompleted"
            ]
        },
        ctor: function (parent, sourceObserver) {
            this.$initialize();
            this._parent = parent;
            this._sourceObserver = sourceObserver;
            this._subscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
        },
        setDisposable: function (value) {
            this._subscription.setDisposable(value);
        },
        onNext: function (value) {
            this._parent;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                this._parent.dispose();
            }
        },
        onError: function (error) {
            this._parent;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent;
            {
                this._sourceObserver._open = true;
                this._subscription.dispose();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.TakeUntil$2._.T", function (TSource, TOther) { return {
        inherits: [System.IObserver$1(TSource)],
        _parent: null,
        _open: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent) {
            this.$initialize();
            this._parent = parent;
            this._open = false;
        },
        onNext: function (value) {
            if (this._open) {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
            } else {
                this._parent;
                {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
                }
            }
        },
        onError: function (error) {
            this._parent;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                this._parent.dispose();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.TakeWhile$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _running: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._running = true;
        },
        onNext: function (value) {
            if (this._running) {
                try {
                    this._running = this._parent._predicate(value);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](exception);
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                    return;
                }

                if (this._running) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
                } else {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                }
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.TakeWhile$1.TakeWhileImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _running: false,
        _index: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._running = true;
            this._index = 0;
        },
        onNext: function (value) {
            if (this._running) {
                try {
                    this._running = this._parent._predicateI(value, Bridge.identity(this._index, (this._index = Bridge.Int.check(this._index + 1, System.Int32))));
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](exception);
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                    return;
                }

                if (this._running) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
                } else {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                }
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Throttle$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        _value: Bridge.getDefaultValue(TSource),
        _hasValue: false,
        _cancelable: null,
        _id: System.UInt64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };
            this._value = Bridge.getDefaultValue(TSource);
            this._hasValue = false;
            this._cancelable = new System.Reactive.Disposables.SerialDisposable();
            this._id = System.UInt64(0);

            var subscription = System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this);

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(subscription, this._cancelable);
        },
        onNext: function (value) {
            var currentid = Bridge.getDefaultValue(System.UInt64);
            this._gate;
            {
                this._hasValue = true;
                this._value = value;
                this._id = this._id.add(System.UInt64(1));
                currentid = this._id;
            }
            var d = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._cancelable.setDisposable(d);
            d.setDisposable(this._parent._scheduler.System$Reactive$Concurrency$IScheduler$schedule$2(System.UInt64, currentid, this._parent._dueTime, Bridge.fn.bind(this, this.propagate)));
        },
        propagate: function (self, currentid) {
            this._gate;
            {
                if (this._hasValue && this._id.equals(currentid)) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._value);
                }
                this._hasValue = false;
            }

            return System.Reactive.Disposables.Disposable.getEmpty();
        },
        onError: function (error) {
            this._cancelable.dispose();

            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);

                this._hasValue = false;
                this._id = this._id.add(System.UInt64(1));
            }
        },
        onCompleted: function () {
            this._cancelable.dispose();

            this._gate;
            {
                if (this._hasValue) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._value);
                }

                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);

                this._hasValue = false;
                this._id = this._id.add(System.UInt64(1));
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Throttle$2._", function (TSource, TThrottle) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        _value: Bridge.getDefaultValue(TSource),
        _hasValue: false,
        _cancelable: null,
        _id: System.UInt64(0),
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };
            this._value = Bridge.getDefaultValue(TSource);
            this._hasValue = false;
            this._cancelable = new System.Reactive.Disposables.SerialDisposable();
            this._id = System.UInt64(0);

            var subscription = System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this);

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(subscription, this._cancelable);
        },
        onNext: function (value) {
            var throttle = null;
            try {
                throttle = this._parent._throttleSelector(value);
            }
            catch (error) {
                error = System.Exception.create(error);
                this._gate;
                {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                }

                return;
            }

            var currentid;
            this._gate;
            {
                this._hasValue = true;
                this._value = value;
                this._id = this._id.add(System.UInt64(1));
                currentid = this._id;
            }

            var d = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._cancelable.setDisposable(d);
            d.setDisposable(System.ObservableExtensions.subscribeSafe(TThrottle, throttle, new (System.Reactive.Linq.ObservableImpl.Throttle$2._.Delta(TSource,TThrottle))(this, value, currentid, d)));
        },
        onError: function (error) {
            this._cancelable.dispose();

            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);

                this._hasValue = false;
                this._id = this._id.add(System.UInt64(1));
            }
        },
        onCompleted: function () {
            this._cancelable.dispose();

            this._gate;
            {
                if (this._hasValue) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._value);
                }

                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);

                this._hasValue = false;
                this._id = this._id.add(System.UInt64(1));
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Throttle$2._.Delta", function (TSource, TThrottle) { return {
        inherits: [System.IObserver$1(TThrottle)],
        _parent: null,
        _value: Bridge.getDefaultValue(TSource),
        _currentid: System.UInt64(0),
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TThrottle) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TThrottle) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TThrottle) + "$onCompleted"
            ]
        },
        ctor: function (parent, value, currentid, self) {
            this.$initialize();
            this._parent = parent;
            this._value = value;
            this._currentid = currentid;
            this._self = self;
        },
        onNext: function (value) {
            this._parent._gate;
            {
                if (this._parent._hasValue && this._parent._id.equals(this._currentid)) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._value);
                }

                this._parent._hasValue = false;
                this._self.System$IDisposable$dispose();
            }
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._gate;
            {
                if (this._parent._hasValue && this._parent._id.equals(this._currentid)) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._value);
                }

                this._parent._hasValue = false;
                this._self.System$IDisposable$dispose();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Throw$1._", function (TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult)],
        _parent: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            return System.Reactive.Concurrency.Scheduler.schedule(this._parent._scheduler, Bridge.fn.bind(this, this.invoke));
        },
        invoke: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](this._parent._exception);
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.TimeInterval$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.Reactive.TimeInterval$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        _watch: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ],
            init: function () {
                this._last = new System.TimeSpan();
            }
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Reactive.TimeInterval$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._watch = System.Reactive.Concurrency.Scheduler.startStopwatch(this._parent._scheduler);
            this._last = System.TimeSpan.zero;

            return this._parent._source["System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$subscribe"](this);
        },
        onNext: function (value) {
            var now = this._watch.System$Reactive$Concurrency$IStopwatch$getElapsed();
            var span = now.subtract(this._last);
            this._last = now;
            this._observer["System$IObserver$1$System$Reactive$TimeInterval$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](new (System.Reactive.TimeInterval$1(TSource)).$ctor1(value, span));
        },
        onError: function (error) {
            this._observer["System$IObserver$1$System$Reactive$TimeInterval$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            this.dispose();
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$System$Reactive$TimeInterval$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            this.dispose();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Timeout$1.TimeA", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _subscription: null,
        _gate: null,
        _switched: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._subscription = new System.Reactive.Disposables.SerialDisposable();
            var original = new System.Reactive.Disposables.SingleAssignmentDisposable();

            this._subscription.setDisposable(original);

            this._gate = {  };
            this._switched = false;

            var timer = System.Reactive.Concurrency.Scheduler.schedule$2(this._parent._scheduler, System.Nullable.getValue(this._parent._dueTimeA), Bridge.fn.bind(this, this.timeout));

            original.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(this._subscription, timer);
        },
        timeout: function () {
            var timerWins = false;

            this._gate;
            {
                timerWins = !this._switched;
                this._switched = true;
            }

            if (timerWins) {
                this._subscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._other, this.getForwarder()));
            }
        },
        onNext: function (value) {
            this._gate;
            {
                if (!this._switched) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
                }
            }
        },
        onError: function (error) {
            var onErrorWins = false;

            this._gate;
            {
                onErrorWins = !this._switched;
                this._switched = true;
            }

            if (onErrorWins) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            var onCompletedWins = false;

            this._gate;
            {
                onCompletedWins = !this._switched;
                this._switched = true;
            }

            if (onCompletedWins) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Timeout$1.TimeR", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _subscription: null,
        _timer: null,
        _gate: null,
        _id: System.UInt64(0),
        _switched: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._subscription = new System.Reactive.Disposables.SerialDisposable();
            this._timer = new System.Reactive.Disposables.SerialDisposable();
            var original = new System.Reactive.Disposables.SingleAssignmentDisposable();

            this._subscription.setDisposable(original);

            this._gate = {  };
            this._id = System.UInt64(0);
            this._switched = false;

            this.createTimer();

            original.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(this._subscription, this._timer);
        },
        createTimer: function () {
            this._timer.setDisposable(this._parent._scheduler.System$Reactive$Concurrency$IScheduler$schedule$2(System.UInt64, this._id, System.Nullable.getValue(this._parent._dueTimeR), Bridge.fn.bind(this, this.timeout)));
        },
        timeout: function (_, myid) {
            var timerWins = false;

            this._gate;
            {
                this._switched = (this._id.equals(myid));
                timerWins = this._switched;
            }

            if (timerWins) {
                this._subscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._other, this.getForwarder()));
            }

            return System.Reactive.Disposables.Disposable.getEmpty();
        },
        onNext: function (value) {
            var onNextWins = false;

            this._gate;
            {
                onNextWins = !this._switched;
                if (onNextWins) {
                    this._id = this._id.add(System.UInt64(1));
                }
            }

            if (onNextWins) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
                this.createTimer();
            }
        },
        onError: function (error) {
            var onErrorWins = false;

            this._gate;
            {
                onErrorWins = !this._switched;
                if (onErrorWins) {
                    this._id = this._id.add(System.UInt64(1));
                }
            }

            if (onErrorWins) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            var onCompletedWins = false;

            this._gate;
            {
                onCompletedWins = !this._switched;
                if (onCompletedWins) {
                    this._id = this._id.add(System.UInt64(1));
                }
            }

            if (onCompletedWins) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Timeout$2._", function (TSource, TTimeout) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _subscription: null,
        _timer: null,
        _gate: null,
        _id: System.UInt64(0),
        _switched: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._subscription = new System.Reactive.Disposables.SerialDisposable();
            this._timer = new System.Reactive.Disposables.SerialDisposable();
            var original = new System.Reactive.Disposables.SingleAssignmentDisposable();

            this._subscription.setDisposable(original);

            this._gate = {  };
            this._id = System.UInt64(0);
            this._switched = false;

            this.setTimer(this._parent._firstTimeout);

            original.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(this._subscription, this._timer);
        },
        onNext: function (value) {
            if (this.observerWins()) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);

                var timeout = null;
                try {
                    timeout = this._parent._timeoutSelector(value);
                }
                catch (error) {
                    error = System.Exception.create(error);
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                    System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                    return;
                }

                this.setTimer(timeout);
            }
        },
        onError: function (error) {
            if (this.observerWins()) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            if (this.observerWins()) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
            }
        },
        setTimer: function (timeout) {
            var myid = this._id;

            var d = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._timer.setDisposable(d);
            d.setDisposable(System.ObservableExtensions.subscribeSafe(TTimeout, timeout, new (System.Reactive.Linq.ObservableImpl.Timeout$2._.TimeoutImpl(TSource,TTimeout))(this, myid, d)));
        },
        observerWins: function () {
            var res = false;

            this._gate;
            {
                res = !this._switched;
                if (res) {
                    this._id = this._id.add(System.UInt64(1));
                }
            }

            return res;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Timeout$2._.TimeoutImpl", function (TSource, TTimeout) { return {
        inherits: [System.IObserver$1(TTimeout)],
        _parent: null,
        _id: System.UInt64(0),
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TTimeout) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TTimeout) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TTimeout) + "$onCompleted"
            ]
        },
        ctor: function (parent, id, self) {
            this.$initialize();
            this._parent = parent;
            this._id = id;
            this._self = self;
        },
        onNext: function (value) {
            if (this.timerWins()) {
                this._parent._subscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._parent._other, this._parent.getForwarder()));
            }

            this._self.System$IDisposable$dispose();
        },
        onError: function (error) {
            if (this.timerWins()) {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            if (this.timerWins()) {
                this._parent._subscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._parent._other, this._parent.getForwarder()));
            }
        },
        timerWins: function () {
            var res = false;

            this._parent._gate;
            {
                this._parent._switched = (this._parent._id.equals(this._id));
                res = this._parent._switched;
            }

            return res;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Timer._", {
        inherits: [System.Reactive.Sink$1(System.Int64)],
        _parent: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Int64).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            if (System.Nullable.hasValue(System.Nullable.lift1("$clone", this._parent._dueTimeA))) {
                return System.Reactive.Concurrency.Scheduler.schedule$2(this._parent._scheduler, System.Nullable.getValue(System.Nullable.lift1("$clone", this._parent._dueTimeA)), Bridge.fn.bind(this, this.invoke));
            } else {
                return System.Reactive.Concurrency.Scheduler.schedule$4(this._parent._scheduler, System.Nullable.getValue(this._parent._dueTimeR), Bridge.fn.bind(this, this.invoke));
            }
        },
        invoke: function () {
            this._observer.System$IObserver$1$System$Int64$onNext(System.Int64(0));
            this._observer.System$IObserver$1$System$Int64$onCompleted();
            System.Reactive.Sink$1(System.Int64).prototype.dispose.call(this);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Timer.TimerImpl", {
        inherits: [System.Reactive.Sink$1(System.Int64)],
        _parent: null,
        _pendingTickCount: 0,
        _periodic: null,
        config: {
            init: function () {
                this._period = new System.TimeSpan();
            }
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Int64).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._period = System.Nullable.getValue(this._parent._period);
        },
        run: function () {
            if (System.Nullable.hasValue(System.Nullable.lift1("$clone", this._parent._dueTimeA))) {
                var dueTime = System.Nullable.getValue(System.Nullable.lift1("$clone", this._parent._dueTimeA));
                return this._parent._scheduler.System$Reactive$Concurrency$IScheduler$schedule$1(Object, null, dueTime.$clone(), Bridge.fn.bind(this, this.invokeStart));
            } else {
                var dueTime1 = System.Nullable.getValue(this._parent._dueTimeR);

                //
                // Optimize for the case of Observable.Interval.
                //
                if (System.TimeSpan.eq(dueTime1, this._period)) {
                    return System.Reactive.Concurrency.Scheduler.schedulePeriodic$2(System.Int64, this._parent._scheduler, System.Int64(0), this._period, Bridge.fn.bind(this, this.tick));
                }

                return this._parent._scheduler.System$Reactive$Concurrency$IScheduler$schedule$2(Object, null, dueTime1, Bridge.fn.bind(this, this.invokeStart));
            }
        },
        tick: function (count) {
            this._observer.System$IObserver$1$System$Int64$onNext(count);
            return count.add(System.Int64(1));
        },
        invokeStart: function (self, state) {
            //
            // Notice the first call to OnNext will introduce skew if it takes significantly long when
            // using the following naive implementation:
            //
            //    Code:  base._observer.OnNext(0L);
            //           return self.SchedulePeriodicEmulated(1L, _period, (Func<long, long>)Tick);
            //
            // What we're saying here is that Observable.Timer(dueTime, period) is pretty much the same
            // as writing Observable.Timer(dueTime).Concat(Observable.Interval(period)).
            //
            //    Expected:  dueTime
            //                  |
            //                  0--period--1--period--2--period--3--period--4--...
            //                  |
            //                  +-OnNext(0L)-|
            //    
            //    Actual:    dueTime
            //                  |
            //                  0------------#--period--1--period--2--period--3--period--4--...
            //                  |
            //                  +-OnNext(0L)-|
            //
            // Different solutions for this behavior have different problems:
            //
            // 1. Scheduling the periodic job first and using an AsyncLock to serialize the OnNext calls
            //    has the drawback that InvokeStart may never return. This happens when every callback
            //    doesn't meet the period's deadline, hence the periodic job keeps queueing stuff up. In
            //    this case, InvokeStart stays the owner of the AsyncLock and the call to Wait will never
            //    return, thus not allowing any interleaving of work on this scheduler's logical thread.
            //
            // 2. Scheduling the periodic job first and using a (blocking) synchronization primitive to
            //    signal completion of the OnNext(0L) call to the Tick call requires quite a bit of state
            //    and careful handling of the case when OnNext(0L) throws. What's worse is the blocking
            //    behavior inside Tick.
            //
            // In order to avoid blocking behavior, we need a scheme much like SchedulePeriodic emulation
            // where work to dispatch OnNext(n + 1) is delegated to a catch up loop in case OnNext(n) was
            // still running. Because SchedulePeriodic emulation exhibits such behavior in all cases, we
            // only need to deal with the overlap of OnNext(0L) with future periodic OnNext(n) dispatch
            // jobs. In the worst case where every callback takes longer than the deadline implied by the
            // period, the periodic job will just queue up work that's dispatched by the tail-recursive
            // catch up loop. In the best case, all work will be dispatched on the periodic scheduler.
            //

            //
            // We start with one tick pending because we're about to start doing OnNext(0L).
            //
            this._pendingTickCount = 1;

            var d = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._periodic = d;
            d.setDisposable(System.Reactive.Concurrency.Scheduler.schedulePeriodic$2(System.Int64, self, System.Int64(1), this._period, Bridge.fn.bind(this, this.tock)));

            try {
                this._observer.System$IObserver$1$System$Int64$onNext(System.Int64(0));
            }
            catch (e) {
                e = System.Exception.create(e);
                d.dispose();
                System.Reactive.ExceptionHelpers.throw(e);
            }

            //
            // If the periodic scheduling job already ran before we finished dispatching the OnNext(0L)
            // call, we'll find pendingTickCount to be > 1. In this case, we need to catch up by dispatching
            // subsequent calls to OnNext as fast as possible, but without running a loop in order to ensure
            // fair play with the scheduler. So, we run a tail-recursive loop in CatchUp instead.
            //
            if (System.Interlocked.decrement(Bridge.ref(this, "_pendingTickCount")) > 0) {
                var c = new System.Reactive.Disposables.SingleAssignmentDisposable();
                c.setDisposable(System.Reactive.Concurrency.Scheduler.schedule$6(System.Int64, self, System.Int64(1), Bridge.fn.bind(this, this.catchUp)));

                return System.Reactive.Disposables.StableCompositeDisposable.create$1(d, c);
            }

            return d;
        },
        tock: function (count) {
            //
            // Notice the handler for (emulated) periodic scheduling is non-reentrant.
            //
            // When there's no overlap with the OnNext(0L) call, the following code will cycle through
            // pendingTickCount 0 -> 1 -> 0 for the remainder of the timer's execution.
            //
            // If there's overlap with the OnNext(0L) call, pendingTickCount will increase to record
            // the number of catch up OnNext calls required, which will be dispatched by the recursive
            // scheduling loop in CatchUp (which quits when it reaches 0 pending ticks).
            //
            if (System.Interlocked.increment(Bridge.ref(this, "_pendingTickCount")) === 1) {
                this._observer.System$IObserver$1$System$Int64$onNext(count);
                System.Interlocked.decrement(Bridge.ref(this, "_pendingTickCount"));
            }

            return count.add(System.Int64(1));
        },
        catchUp: function (count, recurse) {
            try {
                this._observer.System$IObserver$1$System$Int64$onNext(count);
            }
            catch (e) {
                e = System.Exception.create(e);
                this._periodic.System$IDisposable$dispose();
                System.Reactive.ExceptionHelpers.throw(e);
            }

            //
            // We can simply bail out if we decreased the tick count to 0. In that case, the Tock
            // method will take over when it sees the 0 -> 1 transition.
            //
            if (System.Interlocked.decrement(Bridge.ref(this, "_pendingTickCount")) > 0) {
                recurse(count.add(System.Int64(1)));
            }
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Timestamp$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.Reactive.Timestamped$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Reactive.Timestamped$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$System$Reactive$Timestamped$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](new (System.Reactive.Timestamped$1(TSource)).$ctor1(value, this._parent._scheduler.System$Reactive$Concurrency$IScheduler$getNow().$clone()));
        },
        onError: function (error) {
            this._observer["System$IObserver$1$System$Reactive$Timestamped$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(System.Reactive.Timestamped$1(TSource)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$System$Reactive$Timestamped$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(System.Reactive.Timestamped$1(TSource)).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ToArray$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(Array),System.IObserver$1(TSource)],
        _list: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(Array).ctor.call(this, observer, cancel);
            this._list = new (System.Collections.Generic.List$1(TSource))();
        },
        onNext: function (value) {
            this._list.add(value);
        },
        onError: function (error) {
            this._observer.System$IObserver$1$Array$onError(error);
            System.Reactive.Sink$1(Array).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer.System$IObserver$1$Array$onNext(this._list.toArray());
            this._observer.System$IObserver$1$Array$onCompleted();
            System.Reactive.Sink$1(Array).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ToDictionary$3._", function (TSource, TKey, TElement) { return {
        inherits: [System.Reactive.Sink$1(System.Collections.Generic.IDictionary$2(TKey,TElement)),System.IObserver$1(TSource)],
        _parent: null,
        _dictionary: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Collections.Generic.IDictionary$2(TKey,TElement)).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._dictionary = new (System.Collections.Generic.Dictionary$2(TKey, TElement))(null, this._parent._comparer);
        },
        onNext: function (value) {
            try {
                this._dictionary.add(this._parent._keySelector(value), this._parent._elementSelector(value));
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer["System$IObserver$1$System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TElement) + "$onError"](ex);
                System.Reactive.Sink$1(System.Collections.Generic.IDictionary$2(TKey,TElement)).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TElement) + "$onError"](error);
            System.Reactive.Sink$1(System.Collections.Generic.IDictionary$2(TKey,TElement)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TElement) + "$onNext"](this._dictionary);
            this._observer["System$IObserver$1$System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TElement) + "$onCompleted"]();
            System.Reactive.Sink$1(System.Collections.Generic.IDictionary$2(TKey,TElement)).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ToList$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)),System.IObserver$1(TSource)],
        _list: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this, observer, cancel);
            this._list = new (System.Collections.Generic.List$1(TSource))();
        },
        onNext: function (value) {
            this._list.add(value);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](this._list);
            this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ToObservable$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource)],
        _parent: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var e = null;
            try {
                e = Bridge.getEnumerator(this._parent._source, TSource);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](exception);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                return System.Reactive.Disposables.Disposable.getEmpty();
            }

            var longRunning = System.Reactive.Concurrency.Scheduler.asLongRunning(this._parent._scheduler);
            if (longRunning != null) {
                //
                // Long-running schedulers have the contract they should *never* prevent
                // the work from starting, such that the scheduled work has the chance
                // to observe the cancellation and perform proper clean-up. In this case,
                // we're sure Loop will be entered, allowing us to dispose the enumerator.
                //
                return longRunning.System$Reactive$Concurrency$ISchedulerLongRunning$scheduleLongRunning(System.Collections.Generic.IEnumerator$1(TSource), e, Bridge.fn.bind(this, this.loop));
            } else {
                //
                // We never allow the scheduled work to be cancelled. Instead, the flag
                // is used to have LoopRec bail out and perform proper clean-up of the
                // enumerator.
                //
                var flag = new System.Reactive.Disposables.BooleanDisposable.ctor();
                System.Reactive.Concurrency.Scheduler.schedule$6(System.Reactive.Linq.ObservableImpl.ToObservable$1._.State(TSource), this._parent._scheduler, new (System.Reactive.Linq.ObservableImpl.ToObservable$1._.State(TSource))(flag, e), Bridge.fn.bind(this, this.loopRec));
                return flag;
            }
        },
        loopRec: function (state, recurse) {
            var hasNext = false;
            var ex = null;
            var current = Bridge.getDefaultValue(TSource);

            if (state.flag.System$Reactive$Disposables$ICancelable$getIsDisposed()) {
                state.enumerator.System$IDisposable$dispose();
                return;
            }

            try {
                hasNext = state.enumerator.System$Collections$IEnumerator$moveNext();
                if (hasNext) {
                    current = state.enumerator[Bridge.geti(state.enumerator, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(TSource) + "$getCurrent$1", "getCurrent$1")]();
                }
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                ex = exception;
            }

            if (ex != null) {
                state.enumerator.System$IDisposable$dispose();

                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                return;
            }

            if (!hasNext) {
                state.enumerator.System$IDisposable$dispose();

                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                return;
            }

            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](current);
            recurse(state);
        },
        loop: function (enumerator, cancel) {
            while (!cancel.System$Reactive$Disposables$ICancelable$getIsDisposed()) {
                var hasNext = false;
                var ex = null;
                var current = Bridge.getDefaultValue(TSource);

                try {
                    hasNext = enumerator.System$Collections$IEnumerator$moveNext();
                    if (hasNext) {
                        current = enumerator[Bridge.geti(enumerator, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(TSource) + "$getCurrent$1", "getCurrent$1")]();
                    }
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    ex = exception;
                }

                if (ex != null) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](ex);
                    break;
                }

                if (!hasNext) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    break;
                }

                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](current);
            }

            enumerator.System$IDisposable$dispose();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Using$2._", function (TSource, TResource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var source = null;
            var disposable = System.Reactive.Disposables.Disposable.getEmpty();
            try {
                var resource = this._parent._resourceFactory();
                if (resource != null) {
                    disposable = resource;
                }
                source = this._parent._observableFactory(resource);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                return System.Reactive.Disposables.StableCompositeDisposable.create$1(System.ObservableExtensions.subscribeSafe(TSource, System.Reactive.Linq.Observable.system.reactive.linq.observable.throw(exception), this), disposable);
            }

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(System.ObservableExtensions.subscribeSafe(TSource, source, this), disposable);
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Where$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        onNext: function (value) {
            var shouldRun = Bridge.getDefaultValue(Boolean);
            try {
                shouldRun = this._parent._predicate(value);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](exception);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                return;
            }

            if (shouldRun) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Where$1.WhereImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(TSource),System.IObserver$1(TSource)],
        _parent: null,
        _index: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TSource).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._index = 0;
        },
        onNext: function (value) {
            var shouldRun = Bridge.getDefaultValue(Boolean);
            try {
                shouldRun = this._parent._predicateI(value, Bridge.identity(this._index, (this._index = Bridge.Int.check(this._index + 1, System.Int32))));
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](exception);
                System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
                return;
            }

            if (shouldRun) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Window$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.IObservable$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        _queue: null,
        _n: 0,
        _m: null,
        _refCountDisposable: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.IObservable$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._queue = new (System.Collections.Generic.Queue$1(System.Reactive.Subjects.ISubject$1(TSource))).ctor();
            this._n = 0;
            this._m = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._refCountDisposable = new System.Reactive.Disposables.RefCountDisposable.ctor(this._m);

            var firstWindow = this.createWindow();
            this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](firstWindow);

            this._m.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            return this._refCountDisposable;
        },
        createWindow: function () {
            var s = new (System.Reactive.Subjects.Subject$1(TSource))();
            this._queue.enqueue(s);
            return new (System.Reactive.Linq.ObservableImpl.WindowObservable$1(TSource))(s, this._refCountDisposable);
        },
        onNext: function (value) {
            var $t;
            $t = Bridge.getEnumerator(this._queue);
            while ($t.moveNext()) {
                var s = $t.getCurrent();
                s["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
            }

            var c = (((this._n - this._parent._count) | 0) + 1) | 0;
            if (c >= 0 && c % this._parent._skip === 0) {
                var s1 = this._queue.dequeue();
                s1["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            }

            this._n = (this._n + 1) | 0;
            if (this._n % this._parent._skip === 0) {
                var newWindow = this.createWindow();
                this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](newWindow);
            }
        },
        onError: function (error) {
            while (this._queue.getCount() > 0) {
                this._queue.dequeue()["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            }

            this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.Sink$1(System.IObservable$1(TSource)).prototype.dispose.call(this);
        },
        onCompleted: function () {
            while (this._queue.getCount() > 0) {
                this._queue.dequeue()["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            }

            this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.Sink$1(System.IObservable$1(TSource)).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Window$1.BoundedWindowImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.IObservable$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        _s: null,
        _n: 0,
        _windowId: 0,
        _timerD: null,
        _refCountDisposable: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.IObservable$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };
            this._s = null;
            this._n = 0;
            this._windowId = 0;

            this._timerD = new System.Reactive.Disposables.SerialDisposable();
            var groupDisposable = Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Window$1.BoundedWindowImpl.f1)(new System.Reactive.Disposables.CompositeDisposable.$ctor3(2));
            this._refCountDisposable = new System.Reactive.Disposables.RefCountDisposable.ctor(groupDisposable);

            this._s = new (System.Reactive.Subjects.Subject$1(TSource))();
            this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](new (System.Reactive.Linq.ObservableImpl.WindowObservable$1(TSource))(this._s, this._refCountDisposable));
            this.createTimer(0);

            groupDisposable.add(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            return this._refCountDisposable;
        },
        createTimer: function (id) {
            var m = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._timerD.setDisposable(m);

            m.setDisposable(this._parent._scheduler.System$Reactive$Concurrency$IScheduler$schedule$2(System.Int32, id, this._parent._timeSpan, Bridge.fn.bind(this, this.tick)));
        },
        tick: function (self, id) {
            var d = System.Reactive.Disposables.Disposable.getEmpty();

            var newId = 0;
            this._gate;
            {
                if (id !== this._windowId) {
                    return d;
                }

                this._n = 0;
                newId = ((this._windowId = (this._windowId + 1) | 0));

                this._s["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                this._s = new (System.Reactive.Subjects.Subject$1(TSource))();
                this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](new (System.Reactive.Linq.ObservableImpl.WindowObservable$1(TSource))(this._s, this._refCountDisposable));
            }

            this.createTimer(newId);

            return d;
        },
        onNext: function (value) {
            var newWindow = false;
            var newId = 0;

            this._gate;
            {
                this._s["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);

                this._n = (this._n + 1) | 0;
                if (this._n === this._parent._count) {
                    newWindow = true;
                    this._n = 0;
                    newId = ((this._windowId = (this._windowId + 1) | 0));

                    this._s["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    this._s = new (System.Reactive.Subjects.Subject$1(TSource))();
                    this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](new (System.Reactive.Linq.ObservableImpl.WindowObservable$1(TSource))(this._s, this._refCountDisposable));
                }
            }

            if (newWindow) {
                this.createTimer(newId);
            }
        },
        onError: function (error) {
            this._gate;
            {
                this._s["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(System.IObservable$1(TSource)).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._gate;
            {
                this._s["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(System.IObservable$1(TSource)).prototype.dispose.call(this);
            }
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Window$1.BoundedWindowImpl", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Window$1.BoundedWindowImpl, {
        f1: function (_o3) {
            _o3.add(this._timerD);
            return _o3;
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Window$1.TimeShiftImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.IObservable$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        _subject: null,
        _refCountDisposable: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.IObservable$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };

            var groupDisposable = new System.Reactive.Disposables.CompositeDisposable.$ctor3(2);
            this._refCountDisposable = new System.Reactive.Disposables.RefCountDisposable.ctor(groupDisposable);

            this.createWindow();

            groupDisposable.add(System.Reactive.Concurrency.Scheduler.schedulePeriodic(this._parent._scheduler, this._parent._timeSpan, Bridge.fn.bind(this, this.tick)));
            groupDisposable.add(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            return this._refCountDisposable;
        },
        tick: function () {
            this._gate;
            {
                this._subject.onCompleted();
                this.createWindow();
            }
        },
        createWindow: function () {
            this._subject = new (System.Reactive.Subjects.Subject$1(TSource))();
            this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](new (System.Reactive.Linq.ObservableImpl.WindowObservable$1(TSource))(this._subject, this._refCountDisposable));
        },
        onNext: function (value) {
            this._gate;
            {
                this._subject.onNext(value);
            }
        },
        onError: function (error) {
            this._gate;
            {
                this._subject.onError(error);

                this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(System.IObservable$1(TSource)).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._gate;
            {
                this._subject.onCompleted();

                this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(System.IObservable$1(TSource)).prototype.dispose.call(this);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Window$1.WindowImpl", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.IObservable$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        _gate: null,
        _q: null,
        _timerD: null,
        _refCountDisposable: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ],
            init: function () {
                this._totalTime = new System.TimeSpan();
                this._nextShift = new System.TimeSpan();
                this._nextSpan = new System.TimeSpan();
            }
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.IObservable$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._totalTime = System.TimeSpan.zero;
            this._nextShift = this._parent._timeShift;
            this._nextSpan = this._parent._timeSpan;

            this._gate = {  };
            this._q = new (System.Collections.Generic.Queue$1(System.Reactive.Subjects.ISubject$1(TSource))).ctor();

            this._timerD = new System.Reactive.Disposables.SerialDisposable();

            var groupDisposable = Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Window$1.WindowImpl.f1)(new System.Reactive.Disposables.CompositeDisposable.$ctor3(2));
            this._refCountDisposable = new System.Reactive.Disposables.RefCountDisposable.ctor(groupDisposable);

            this.createWindow();
            this.createTimer();

            groupDisposable.add(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            return this._refCountDisposable;
        },
        createWindow: function () {
            var s = new (System.Reactive.Subjects.Subject$1(TSource))();
            this._q.enqueue(s);
            this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](new (System.Reactive.Linq.ObservableImpl.WindowObservable$1(TSource))(s, this._refCountDisposable));
        },
        createTimer: function () {
            var m = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._timerD.setDisposable(m);

            var isSpan = false;
            var isShift = false;
            if (System.TimeSpan.eq(this._nextSpan, this._nextShift)) {
                isSpan = true;
                isShift = true;
            } else if (System.TimeSpan.lt(this._nextSpan, this._nextShift)) {
                isSpan = true;
            } else {
                isShift = true;
            }

            var newTotalTime = isSpan ? this._nextSpan : this._nextShift;
            var ts = System.TimeSpan.sub(newTotalTime, this._totalTime);
            this._totalTime = newTotalTime;

            if (isSpan) {
                this._nextSpan = System.TimeSpan.add(this._nextSpan, this._parent._timeShift);
            }
            if (isShift) {
                this._nextShift = System.TimeSpan.add(this._nextShift, this._parent._timeShift);
            }

            m.setDisposable(this._parent._scheduler.System$Reactive$Concurrency$IScheduler$schedule$2(System.Reactive.Linq.ObservableImpl.Window$1.WindowImpl.State(TSource), Bridge.merge(new (System.Reactive.Linq.ObservableImpl.Window$1.WindowImpl.State(TSource))(), {
                isSpan: isSpan,
                isShift: isShift
            } ), ts, Bridge.fn.bind(this, this.tick)));
        },
        tick: function (self, state) {
            this._gate;
            {
                //
                // BREAKING CHANGE v2 > v1.x - Making behavior of sending OnCompleted to the window
                //                             before sending out a new window consistent across all
                //                             overloads of Window and Buffer. Before v2, the two
                //                             operations below were reversed.
                //
                if (state.isSpan) {
                    var s = this._q.dequeue();
                    s["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                }

                if (state.isShift) {
                    this.createWindow();
                }
            }

            this.createTimer();

            return System.Reactive.Disposables.Disposable.getEmpty();
        },
        onNext: function (value) {
            var $t;
            this._gate;
            {
                $t = Bridge.getEnumerator(this._q);
                while ($t.moveNext()) {
                    var s = $t.getCurrent();
                    s["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
                }
            }
        },
        onError: function (error) {
            var $t;
            this._gate;
            {
                $t = Bridge.getEnumerator(this._q);
                while ($t.moveNext()) {
                    var s = $t.getCurrent();
                    s["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                }

                this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(System.IObservable$1(TSource)).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            var $t;
            this._gate;
            {
                $t = Bridge.getEnumerator(this._q);
                while ($t.moveNext()) {
                    var s = $t.getCurrent();
                    s["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                }

                this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(System.IObservable$1(TSource)).prototype.dispose.call(this);
            }
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Window$1.WindowImpl", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Window$1.WindowImpl, {
        f1: function (_o2) {
            _o2.add(this._timerD);
            return _o2;
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Window$2._", function (TSource, TWindowClosing) { return {
        inherits: [System.Reactive.Sink$1(System.IObservable$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        _window: null,
        _gate: null,
        _windowGate: null,
        _m: null,
        _refCountDisposable: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.IObservable$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._window = new (System.Reactive.Subjects.Subject$1(TSource))();
            this._gate = {  };
            this._windowGate = new System.Reactive.Concurrency.AsyncLock();

            this._m = new System.Reactive.Disposables.SerialDisposable();
            var groupDisposable = Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Window$2._.f1)(new System.Reactive.Disposables.CompositeDisposable.$ctor3(2));
            this._refCountDisposable = new System.Reactive.Disposables.RefCountDisposable.ctor(groupDisposable);

            var $window = new (System.Reactive.Linq.ObservableImpl.WindowObservable$1(TSource))(this._window, this._refCountDisposable);
            this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onNext"]($window);

            groupDisposable.add(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));

            this._windowGate.wait(Bridge.fn.bind(this, this.createWindowClose));

            return this._refCountDisposable;
        },
        createWindowClose: function () {
            var windowClose = null;
            try {
                windowClose = this._parent._windowClosingSelector();
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._gate;
                {
                    this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onError"](exception);
                    System.Reactive.Sink$1(System.IObservable$1(TSource)).prototype.dispose.call(this);
                }
                return;
            }

            var closingSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this._m.setDisposable(closingSubscription);
            closingSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TWindowClosing, windowClose, new (System.Reactive.Linq.ObservableImpl.Window$2._.Omega(TSource,TWindowClosing))(this, closingSubscription)));
        },
        closeWindow: function (closingSubscription) {
            closingSubscription.System$IDisposable$dispose();

            this._gate;
            {
                this._window["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                this._window = new (System.Reactive.Subjects.Subject$1(TSource))();

                var $window = new (System.Reactive.Linq.ObservableImpl.WindowObservable$1(TSource))(this._window, this._refCountDisposable);
                this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onNext"]($window);
            }

            this._windowGate.wait(Bridge.fn.bind(this, this.createWindowClose));
        },
        onNext: function (value) {
            this._gate;
            {
                this._window["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
            }
        },
        onError: function (error) {
            this._gate;
            {
                this._window["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(System.IObservable$1(TSource)).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._gate;
            {
                this._window["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(System.IObservable$1(TSource)).prototype.dispose.call(this);
            }
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Window$2._", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Window$2._, {
        f1: function (_o4) {
            _o4.add(this._m);
            return _o4;
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Window$2._.Omega", function (TSource, TWindowClosing) { return {
        inherits: [System.IObserver$1(TWindowClosing)],
        _parent: null,
        _self: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TWindowClosing) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TWindowClosing) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TWindowClosing) + "$onCompleted"
            ]
        },
        ctor: function (parent, self) {
            this.$initialize();
            this._parent = parent;
            this._self = self;
        },
        onNext: function (value) {
            this._parent.closeWindow(this._self);
        },
        onError: function (error) {
            this._parent.onError(error);
        },
        onCompleted: function () {
            this._parent.closeWindow(this._self);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Window$2.Beta", function (TSource, TWindowClosing) { return {
        inherits: [System.Reactive.Sink$1(System.IObservable$1(TSource)),System.IObserver$1(TSource)],
        _parent: null,
        _window: null,
        _gate: null,
        _refCountDisposable: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.IObservable$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._window = new (System.Reactive.Subjects.Subject$1(TSource))();
            this._gate = {  };

            var d = new System.Reactive.Disposables.CompositeDisposable.$ctor3(2);
            this._refCountDisposable = new System.Reactive.Disposables.RefCountDisposable.ctor(d);

            var $window = new (System.Reactive.Linq.ObservableImpl.WindowObservable$1(TSource))(this._window, this._refCountDisposable);
            this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onNext"]($window);

            d.add(System.ObservableExtensions.subscribeSafe(TSource, this._parent._source, this));
            d.add(System.ObservableExtensions.subscribeSafe(TWindowClosing, this._parent._windowBoundaries, new (System.Reactive.Linq.ObservableImpl.Window$2.Beta.Omega(TSource,TWindowClosing))(this)));

            return this._refCountDisposable;
        },
        onNext: function (value) {
            this._gate;
            {
                this._window["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
            }
        },
        onError: function (error) {
            this._gate;
            {
                this._window["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(System.IObservable$1(TSource)).prototype.dispose.call(this);
            }
        },
        onCompleted: function () {
            this._gate;
            {
                this._window["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                this._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                System.Reactive.Sink$1(System.IObservable$1(TSource)).prototype.dispose.call(this);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Window$2.Beta.Omega", function (TSource, TWindowClosing) { return {
        inherits: [System.IObserver$1(TWindowClosing)],
        _parent: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TWindowClosing) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TWindowClosing) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TWindowClosing) + "$onCompleted"
            ]
        },
        ctor: function (parent) {
            this.$initialize();
            this._parent = parent;
        },
        onNext: function (value) {
            this._parent._gate;
            {
                this._parent._window["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                this._parent._window = new (System.Reactive.Subjects.Subject$1(TSource))();

                var $window = new (System.Reactive.Linq.ObservableImpl.WindowObservable$1(TSource))(this._parent._window, this._parent._refCountDisposable);
                this._parent._observer["System$IObserver$1$System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$onNext"]($window);
            }
        },
        onError: function (error) {
            this._parent.onError(error);
        },
        onCompleted: function () {
            this._parent.onCompleted();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.WithLatestFrom$3._", function (TFirst, TSecond, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult)],
        _parent: null,
        _gate: null,
        _hasLatest: false,
        _latest: Bridge.getDefaultValue(TSecond),
        _latestGate: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };
            this._latestGate = {  };

            var sndSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();

            var fstO = new (System.Reactive.Linq.ObservableImpl.WithLatestFrom$3._.F(TFirst,TSecond,TResult))(this);
            var sndO = new (System.Reactive.Linq.ObservableImpl.WithLatestFrom$3._.S(TFirst,TSecond,TResult))(this, sndSubscription);

            var fstSubscription = System.ObservableExtensions.subscribeSafe(TFirst, this._parent._first, fstO);
            sndSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSecond, this._parent._second, sndO));

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(fstSubscription, sndSubscription);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.WithLatestFrom$3._.F", function (TFirst, TSecond, TResult) { return {
        inherits: [System.IObserver$1(TFirst)],
        _parent: null,
        config: {
            alias: [
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TFirst) + "$onCompleted",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TFirst) + "$onError",
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TFirst) + "$onNext"
            ]
        },
        ctor: function (parent) {
            this.$initialize();
            this._parent = parent;
        },
        onCompleted: function () {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                this._parent.dispose();
            }
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onNext: function (value) {
            if (this._parent._hasLatest) {

                var latest;

                this._parent._latestGate;
                {
                    latest = this._parent._latest;
                }

                var res = Bridge.getDefaultValue(TResult);

                try {
                    res = this._parent._parent._resultSelector(value, latest);
                }
                catch (ex) {
                    ex = System.Exception.create(ex);
                    this._parent._gate;
                    {
                        this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                        this._parent.dispose();
                    }

                    return;
                }

                this._parent._gate;
                {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](res);
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.WithLatestFrom$3._.S", function (TFirst, TSecond, TResult) { return {
        inherits: [System.IObserver$1(TSecond)],
        _parent: null,
        _self: null,
        config: {
            alias: [
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSecond) + "$onCompleted",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSecond) + "$onError",
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSecond) + "$onNext"
            ]
        },
        ctor: function (parent, self) {
            this.$initialize();
            this._parent = parent;
            this._self = self;
        },
        onCompleted: function () {
            this._self.System$IDisposable$dispose();
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onNext: function (value) {
            this._parent._latestGate;
            {
                this._parent._latest = value;
            }

            if (!this._parent._hasLatest) {
                this._parent._hasLatest = true;
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$1._", function (TSource) { return {
        inherits: [System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource))],
        _parent: null,
        _gate: null,
        _queues: null,
        _isDone: null,
        _subscriptions: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var srcs = System.Linq.Enumerable.from(this._parent._sources).toArray();

            var N = srcs.length;

            this._queues = System.Array.init(N, null);
            for (var i = 0; i < N; i = (i + 1) | 0) {
                this._queues[i] = new (System.Collections.Generic.Queue$1(TSource)).ctor();
            }

            this._isDone = System.Array.init(N, false);

            this._subscriptions = System.Array.init(N, null);

            this._gate = {  };

            for (var i1 = 0; i1 < N; i1 = (i1 + 1) | 0) {
                var j = i1;

                var d = new System.Reactive.Disposables.SingleAssignmentDisposable();
                this._subscriptions[j] = d;

                var o = new (System.Reactive.Linq.ObservableImpl.Zip$1._.O(TSource))(this, j);
                d.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, srcs[j], o));
            }

            return Bridge.fn.bind(this, function (_o5) {
                    _o5.add(System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, function () {
                        var $t;
                        $t = Bridge.getEnumerator(this._queues);
                        while ($t.moveNext()) {
                            var q = $t.getCurrent();
                            q.clear();
                        }
                    })));
                    return _o5;
                })(new System.Reactive.Disposables.CompositeDisposable.$ctor2(this._subscriptions));
        },
        onNext: function (index, value) {
            this._gate;
            {
                this._queues[index].enqueue(value);

                if (System.Linq.Enumerable.from(this._queues).all($asm.$.System.Reactive.Linq.ObservableImpl.Zip$1._.f1)) {
                    var res = System.Linq.Enumerable.from(this._queues).select($asm.$.System.Reactive.Linq.ObservableImpl.Zip$1._.f2).toList(TSource);
                    this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](res);
                } else if (System.Linq.Enumerable.from(this._isDone).where(function (x, i) {
                        return i !== index;
                    }).all(System.Reactive.Stubs$1(Boolean).i)) {
                    this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
                    return;
                }
            }
        },
        onError: function (error) {
            this._gate;
            {
                this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
                System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
            }
        },
        onCompleted: function (index) {
            this._gate;
            {
                this._isDone[index] = true;

                if (System.Linq.Enumerable.from(this._isDone).all(System.Reactive.Stubs$1(Boolean).i)) {
                    this._observer["System$IObserver$1$System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
                    System.Reactive.Sink$1(System.Collections.Generic.IList$1(TSource)).prototype.dispose.call(this);
                    return;
                } else {
                    this._subscriptions[index].System$IDisposable$dispose();
                }
            }
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Zip$1._", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Zip$1._, {
        f1: function (q) {
            return q.getCount() > 0;
        },
        f2: function (q) {
            return q.dequeue();
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$1._.O", function (TSource) { return {
        inherits: [System.IObserver$1(TSource)],
        _parent: null,
        _index: 0,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, index) {
            this.$initialize();
            this._parent = parent;
            this._index = index;
        },
        onNext: function (value) {
            this._parent.onNext(this._index, value);
        },
        onError: function (error) {
            this._parent.onError(error);
        },
        onCompleted: function () {
            this._parent.onCompleted(this._index);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ZipSink$1", function (TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.Reactive.Linq.ObservableImpl.IZip],
        _gate: null,
        _queues: null,
        _isDone: null,
        config: {
            alias: [
            "next", "System$Reactive$Linq$ObservableImpl$IZip$next",
            "fail", "System$Reactive$Linq$ObservableImpl$IZip$fail",
            "done", "System$Reactive$Linq$ObservableImpl$IZip$done"
            ]
        },
        ctor: function (arity, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._gate = {  };

            this._isDone = System.Array.init(arity, false);
            this._queues = System.Array.init(arity, null);
        },
        getQueues: function () {
            return this._queues;
        },
        next: function (index) {
            var $t;
            var hasValueAll = true;
            $t = Bridge.getEnumerator(this._queues);
            while ($t.moveNext()) {
                var queue = $t.getCurrent();
                if (System.Array.getCount(queue) === 0) {
                    hasValueAll = false;
                    break;
                }
            }

            if (hasValueAll) {
                var res = Bridge.getDefaultValue(TResult);
                try {
                    res = this.getResult();
                }
                catch (ex) {
                    ex = System.Exception.create(ex);
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                    return;
                }

                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](res);
            } else {
                var allOthersDone = true;
                for (var i = 0; i < this._isDone.length; i = (i + 1) | 0) {
                    if (i !== index && !this._isDone[i]) {
                        allOthersDone = false;
                        break;
                    }
                }

                if (allOthersDone) {
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                }
            }
        },
        fail: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        },
        done: function (index) {
            var $t;
            this._isDone[index] = true;

            var allDone = true;
            $t = Bridge.getEnumerator(this._isDone);
            while ($t.moveNext()) {
                var isDone = $t.getCurrent();
                if (!isDone) {
                    allDone = false;
                    break;
                }
            }

            if (allDone) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return;
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$3._", function (TFirst, TSecond, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult)],
        _parent: null,
        _gate: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            this._gate = {  };

            var fstSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            var sndSubscription = new System.Reactive.Disposables.SingleAssignmentDisposable();

            var fstO = new (System.Reactive.Linq.ObservableImpl.Zip$3._.F(TFirst,TSecond,TResult))(this, fstSubscription);
            var sndO = new (System.Reactive.Linq.ObservableImpl.Zip$3._.S(TFirst,TSecond,TResult))(this, sndSubscription);

            fstO.setOther(sndO);
            sndO.setOther(fstO);

            fstSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TFirst, this._parent._first, fstO));
            sndSubscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSecond, this._parent._second, sndO));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2([fstSubscription, sndSubscription, fstO, sndO]);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$3._.F", function (TFirst, TSecond, TResult) { return {
        inherits: [System.IObserver$1(TFirst),System.IDisposable],
        _parent: null,
        _self: null,
        _other: null,
        _queue: null,
        config: {
            properties: {
                Done: false
            },
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TFirst) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TFirst) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TFirst) + "$onCompleted",
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function (parent, self) {
            this.$initialize();
            this._parent = parent;
            this._self = self;
            this._queue = new (System.Collections.Generic.Queue$1(TFirst)).ctor();
        },
        setOther: function (value) {
            this._other = value;
        },
        getQueue: function () {
            return this._queue;
        },
        onNext: function (value) {
            this._parent._gate;
            {
                if (this._other.getQueue().getCount() > 0) {
                    var r = this._other.getQueue().dequeue();

                    var res = Bridge.getDefaultValue(TResult);
                    try {
                        res = this._parent._parent._resultSelector(value, r);
                    }
                    catch (ex) {
                        ex = System.Exception.create(ex);
                        this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                        this._parent.dispose();
                        return;
                    }

                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](res);
                } else {
                    if (this._other.getDone()) {
                        this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                        this._parent.dispose();
                        return;
                    }

                    this._queue.enqueue(value);
                }
            }
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._gate;
            {
                this.setDone(true);

                if (this._other.getDone()) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    this._parent.dispose();
                    return;
                } else {
                    this._self.System$IDisposable$dispose();
                }
            }
        },
        dispose: function () {
            this._queue.clear();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$3._.S", function (TFirst, TSecond, TResult) { return {
        inherits: [System.IObserver$1(TSecond),System.IDisposable],
        _parent: null,
        _self: null,
        _other: null,
        _queue: null,
        config: {
            properties: {
                Done: false
            },
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSecond) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSecond) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSecond) + "$onCompleted",
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function (parent, self) {
            this.$initialize();
            this._parent = parent;
            this._self = self;
            this._queue = new (System.Collections.Generic.Queue$1(TSecond)).ctor();
        },
        setOther: function (value) {
            this._other = value;
        },
        getQueue: function () {
            return this._queue;
        },
        onNext: function (value) {
            this._parent._gate;
            {
                if (this._other.getQueue().getCount() > 0) {
                    var l = this._other.getQueue().dequeue();

                    var res = Bridge.getDefaultValue(TResult);
                    try {
                        res = this._parent._parent._resultSelector(l, value);
                    }
                    catch (ex) {
                        ex = System.Exception.create(ex);
                        this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                        this._parent.dispose();
                        return;
                    }

                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](res);
                } else {
                    if (this._other.getDone()) {
                        this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                        this._parent.dispose();
                        return;
                    }

                    this._queue.enqueue(value);
                }
            }
        },
        onError: function (error) {
            this._parent._gate;
            {
                this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
                this._parent.dispose();
            }
        },
        onCompleted: function () {
            this._parent._gate;
            {
                this.setDone(true);

                if (this._other.getDone()) {
                    this._parent._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                    this._parent.dispose();
                    return;
                } else {
                    this._self.System$IDisposable$dispose();
                }
            }
        },
        dispose: function () {
            this._queue.clear();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$3.ZipImpl", function (TFirst, TSecond, TResult) { return {
        inherits: [System.Reactive.Sink$1(TResult),System.IObserver$1(TFirst)],
        _parent: null,
        _rightEnumerator: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TFirst) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TFirst) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TFirst) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(TResult).ctor.call(this, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            //
            // Notice the evaluation order of obtaining the enumerator and subscribing to the
            // observable sequence is reversed compared to the operator's signature. This is
            // required to make sure the enumerator is available as soon as the observer can
            // be called. Otherwise, we end up having a race for the initialization and use
            // of the _rightEnumerator field.
            //
            try {
                this._rightEnumerator = Bridge.getEnumerator(this._parent._secondE, TSecond);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return System.Reactive.Disposables.Disposable.getEmpty();
            }

            var leftSubscription = System.ObservableExtensions.subscribeSafe(TFirst, this._parent._first, this);

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(leftSubscription, this._rightEnumerator);
        },
        onNext: function (value) {
            var hasNext = false;
            try {
                hasNext = this._rightEnumerator.System$Collections$IEnumerator$moveNext();
            }
            catch (ex) {
                ex = System.Exception.create(ex);
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex);
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                return;
            }

            if (hasNext) {
                var right = Bridge.getDefaultValue(TSecond);
                try {
                    right = this._rightEnumerator[Bridge.geti(this._rightEnumerator, "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(TSecond) + "$getCurrent$1", "getCurrent$1")]();
                }
                catch (ex1) {
                    ex1 = System.Exception.create(ex1);
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex1);
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                    return;
                }

                var result;
                try {
                    result = this._parent._resultSelector(value, right);
                }
                catch (ex2) {
                    ex2 = System.Exception.create(ex2);
                    this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](ex2);
                    System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
                    return;
                }

                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](result);
            } else {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
            }
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
            System.Reactive.Sink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ZipObserver$1", function (T) { return {
        inherits: [System.IObserver$1(T)],
        _gate: null,
        _parent: null,
        _index: 0,
        _self: null,
        _values: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"
            ]
        },
        ctor: function (gate, parent, index, self) {
            this.$initialize();
            this._gate = gate;
            this._parent = parent;
            this._index = index;
            this._self = self;
            this._values = new (System.Collections.Generic.Queue$1(T)).ctor();
        },
        getValues: function () {
            return this._values;
        },
        onNext: function (value) {
            this._gate;
            {
                this._values.enqueue(value);
                this._parent.System$Reactive$Linq$ObservableImpl$IZip$next(this._index);
            }
        },
        onError: function (error) {
            this._self.System$IDisposable$dispose();

            this._gate;
            {
                this._parent.System$Reactive$Linq$ObservableImpl$IZip$fail(error);
            }
        },
        onCompleted: function () {
            this._self.System$IDisposable$dispose();

            this._gate;
            {
                this._parent.System$Reactive$Linq$ObservableImpl$IZip$done(this._index);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.QueryLanguage", {
        inherits: [System.Reactive.Linq.IQueryLanguage],
        statics: {
            collect_: function (TSource, TResult, source, getInitialCollector, merge, getNewCollector) {
                return new (System.Reactive.Linq.ObservableImpl.Collect$2(TSource,TResult))(source, getInitialCollector, merge, getNewCollector);
            },
            firstOrDefaultInternal: function (TSource, source, throwOnEmpty) {
                var $t;
                var value = Bridge.getDefaultValue(TSource);
                var seenValue = false;
                var ex = null;

                var evt = new System.Reactive.Linq.QueryLanguage.WaitAndSetOnce();
                try {
                    //
                    // [OK] Use of unsafe Subscribe: fine to throw to our caller, behavior indistinguishable from going through the sink.
                    //
                    $t = source["System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$subscribe"](new (System.Reactive.AnonymousObserver$1(TSource)).$ctor3(function (v) {
                        if (!seenValue) {
                            value = v;
                        }
                        seenValue = true;
                        evt.set();
                    }, function (e) {
                        ex = e;
                        evt.set();
                    }, function () {
                        evt.set();
                    }));
                    try {
                        evt.waitOne();
                    }
                    finally {
                        if (Bridge.hasValue($t)) {
                            $t.dispose();
                        }
                    }
                }
                finally {
                    if (Bridge.hasValue(evt)) {
                        evt.dispose();
                    }
                }

                System.Reactive.ExceptionHelpers.throwIfNotNull(ex);

                if (throwOnEmpty && !seenValue) {
                    throw new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS);
                }

                return value;
            },
            lastOrDefaultInternal: function (TSource, source, throwOnEmpty) {
                var $t;
                var value = Bridge.getDefaultValue(TSource);
                var seenValue = false;
                var ex = null;

                var evt = new System.Reactive.Linq.QueryLanguage.WaitAndSetOnce();
                try {
                    //
                    // [OK] Use of unsafe Subscribe: fine to throw to our caller, behavior indistinguishable from going through the sink.
                    //
                    $t = source["System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$subscribe"](new (System.Reactive.AnonymousObserver$1(TSource)).$ctor3(function (v) {
                        seenValue = true;
                        value = v;
                    }, function (e) {
                        ex = e;
                        evt.set();
                    }, function () {
                        evt.set();
                    }));
                    try {
                        evt.waitOne();
                    }
                    finally {
                        if (Bridge.hasValue($t)) {
                            $t.dispose();
                        }
                    }
                }
                finally {
                    if (Bridge.hasValue(evt)) {
                        evt.dispose();
                    }
                }

                System.Reactive.ExceptionHelpers.throwIfNotNull(ex);

                if (throwOnEmpty && !seenValue) {
                    throw new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS);
                }

                return value;
            },
            singleOrDefaultInternal: function (TSource, source, throwOnEmpty) {
                var $t;
                var value = Bridge.getDefaultValue(TSource);
                var seenValue = false;
                var ex = null;

                var evt = new System.Reactive.Linq.QueryLanguage.WaitAndSetOnce();
                try {
                    //
                    // [OK] Use of unsafe Subscribe: fine to throw to our caller, behavior indistinguishable from going through the sink.
                    //
                    $t = source["System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$subscribe"](new (System.Reactive.AnonymousObserver$1(TSource)).$ctor3(function (v) {
                        if (seenValue) {
                            ex = new System.InvalidOperationException(System.Reactive.Strings_Linq.MORE_THAN_ONE_ELEMENT);
                            evt.set();
                        }

                        value = v;
                        seenValue = true;
                    }, function (e) {
                        ex = e;
                        evt.set();
                    }, function () {
                        evt.set();
                    }));
                    try {
                        evt.waitOne();
                    }
                    finally {
                        if (Bridge.hasValue($t)) {
                            $t.dispose();
                        }
                    }
                }
                finally {
                    if (Bridge.hasValue(evt)) {
                        evt.dispose();
                    }
                }

                System.Reactive.ExceptionHelpers.throwIfNotNull(ex);

                if (throwOnEmpty && !seenValue) {
                    throw new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS);
                }

                return value;
            },
            pushToPull: function (TSource, TResult, source, push, pull) {
                var subscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
                var adapter = new (System.Reactive.PushPullAdapter$2(TSource,TResult))(push, pull, Bridge.fn.bind(subscription, subscription.dispose));
                subscription.setDisposable(System.ObservableExtensions.subscribeSafe(TSource, source, adapter));
                return adapter;
            },
            subscribe_: function (TSource, source, observer, scheduler) {
                //
                // [OK] Use of unsafe Subscribe: we're calling into a known producer implementation.
                //
                return new (System.Reactive.Linq.ObservableImpl.ToObservable$1(TSource))(source, scheduler).subscribe(observer);
            },
            range_: function (start, count, scheduler) {
                return new System.Reactive.Linq.ObservableImpl.Range(start, count, scheduler);
            },
            fromEventPattern_$6: function (addHandler, removeHandler, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.FromEventPattern.Impl$2(Function,Object)).$ctor1($asm.$.System.Reactive.Linq.QueryLanguage.f1, addHandler, removeHandler, scheduler);
            },
            fromEventPattern_$4: function (TDelegate, TEventArgs, addHandler, removeHandler, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.FromEventPattern.Impl$2(TDelegate,TEventArgs)).ctor(addHandler, removeHandler, scheduler);
            },
            fromEventPattern_$5: function (TDelegate, TEventArgs, conversion, addHandler, removeHandler, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.FromEventPattern.Impl$2(TDelegate,TEventArgs)).$ctor1(conversion, addHandler, removeHandler, scheduler);
            },
            fromEventPattern_$11: function (TDelegate, TSender, TEventArgs, addHandler, removeHandler, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.FromEventPattern.Impl$3(TDelegate,TSender,TEventArgs))(addHandler, removeHandler, scheduler);
            },
            fromEventPattern_$1: function (TEventArgs, addHandler, removeHandler, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.FromEventPattern.Impl$2(Function,TEventArgs)).$ctor1($asm.$.System.Reactive.Linq.QueryLanguage.f2, addHandler, removeHandler, scheduler);
            },
            fromEventPattern_$7: function (target, eventName, scheduler) {
                return System.Reactive.Linq.QueryLanguage.fromEventPattern_(Object, Object, System.Reactive.EventPattern$1(Object), Bridge.getType(target), target, eventName, $asm.$.System.Reactive.Linq.QueryLanguage.f3, scheduler);
            },
            fromEventPattern_$2: function (TEventArgs, target, eventName, scheduler) {
                return System.Reactive.Linq.QueryLanguage.fromEventPattern_(Object, TEventArgs, System.Reactive.EventPattern$1(TEventArgs), Bridge.getType(target), target, eventName, function (sender, args) {
                    return new (System.Reactive.EventPattern$1(TEventArgs))(sender, args);
                }, scheduler);
            },
            fromEventPattern_$9: function (TSender, TEventArgs, target, eventName, scheduler) {
                return System.Reactive.Linq.QueryLanguage.fromEventPattern_(TSender, TEventArgs, System.Reactive.EventPattern$2(TSender,TEventArgs), Bridge.getType(target), target, eventName, function (sender, args) {
                    return new (System.Reactive.EventPattern$2(TSender,TEventArgs))(sender, args);
                }, scheduler);
            },
            fromEventPattern_$8: function (type, eventName, scheduler) {
                return System.Reactive.Linq.QueryLanguage.fromEventPattern_(Object, Object, System.Reactive.EventPattern$1(Object), type, null, eventName, $asm.$.System.Reactive.Linq.QueryLanguage.f3, scheduler);
            },
            fromEventPattern_$3: function (TEventArgs, type, eventName, scheduler) {
                return System.Reactive.Linq.QueryLanguage.fromEventPattern_(Object, TEventArgs, System.Reactive.EventPattern$1(TEventArgs), type, null, eventName, function (sender, args) {
                    return new (System.Reactive.EventPattern$1(TEventArgs))(sender, args);
                }, scheduler);
            },
            fromEventPattern_$10: function (TSender, TEventArgs, type, eventName, scheduler) {
                return System.Reactive.Linq.QueryLanguage.fromEventPattern_(TSender, TEventArgs, System.Reactive.EventPattern$2(TSender,TEventArgs), type, null, eventName, function (sender, args) {
                    return new (System.Reactive.EventPattern$2(TSender,TEventArgs))(sender, args);
                }, scheduler);
            },
            fromEventPattern_: function (TSender, TEventArgs, TResult, targetType, target, eventName, getResult, scheduler) {
                var addMethod = { v : null };
                var removeMethod = { v : null };
                var delegateType = { v : null };
                var isWinRT = { v : Bridge.getDefaultValue(Boolean) };
                System.Reactive.ReflectionUtils.getEventMethods(TSender, TEventArgs, targetType, target, eventName, addMethod, removeMethod, delegateType, isWinRT);


                return new (System.Reactive.Linq.ObservableImpl.FromEventPattern.Handler$3(TSender,TEventArgs,TResult))(target, delegateType.v, addMethod.v, removeMethod.v, getResult, false, scheduler);
            },
            fromEvent_$2: function (TDelegate, TEventArgs, conversion, addHandler, removeHandler, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.FromEvent$2(TDelegate,TEventArgs)).$ctor1(conversion, addHandler, removeHandler, scheduler);
            },
            fromEvent_$1: function (TDelegate, TEventArgs, addHandler, removeHandler, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.FromEvent$2(TDelegate,TEventArgs)).ctor(addHandler, removeHandler, scheduler);
            },
            fromEvent_: function (TEventArgs, addHandler, removeHandler, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.FromEvent$2(Function,TEventArgs)).$ctor1($asm.$.System.Reactive.Linq.QueryLanguage.f4, addHandler, removeHandler, scheduler);
            },
            fromEvent_$3: function (addHandler, removeHandler, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.FromEvent$2(Function,System.Reactive.Unit)).$ctor1($asm.$.System.Reactive.Linq.QueryLanguage.f5, addHandler, removeHandler, scheduler);
            },
            getSchedulerForCurrentContext: function () {
                return System.Reactive.Concurrency.SchedulerDefaults.getConstantTimeOperations();
            },
            amb_: function (TSource, sources) {
                return System.Linq.Enumerable.from(sources).aggregate(System.Reactive.Linq.Observable.never(TSource), function (previous, current) {
                        return System.Reactive.Linq.Observable.amb$1(TSource, previous, current);
                    });
            },
            amb_$1: function (TSource, leftSource, rightSource) {
                return new (System.Reactive.Linq.ObservableImpl.Amb$1(TSource))(leftSource, rightSource);
            },
            catch_: function (TSource, sources) {
                return new (System.Reactive.Linq.ObservableImpl.Catch$1(TSource))(sources);
            },
            combineLatest_: function (TSource, TResult, sources, resultSelector) {
                return new (System.Reactive.Linq.ObservableImpl.CombineLatest$2(TSource,TResult))(sources, resultSelector);
            },
            concat_: function (TSource, sources) {
                return new (System.Reactive.Linq.ObservableImpl.Concat$1(TSource))(sources);
            },
            merge_: function (TSource, sources) {
                return new (System.Reactive.Linq.ObservableImpl.Merge$1(TSource)).ctor(sources);
            },
            merge_$1: function (TSource, sources, maxConcurrent) {
                return new (System.Reactive.Linq.ObservableImpl.Merge$1(TSource)).$ctor1(sources, maxConcurrent);
            },
            onErrorResumeNext_: function (TSource, sources) {
                return new (System.Reactive.Linq.ObservableImpl.OnErrorResumeNext$1(TSource))(sources);
            },
            zip_: function (TSource, sources) {
                return new (System.Reactive.Linq.ObservableImpl.Zip$1(TSource))(sources);
            },
            buffer_: function (TSource, source, count, skip) {
                return new (System.Reactive.Linq.ObservableImpl.Buffer$1(TSource)).ctor(source, count, skip);
            },
            buffer_$2: function (TSource, source, timeSpan, timeShift, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.Buffer$1(TSource)).$ctor2(source, timeSpan, timeShift, scheduler);
            },
            buffer_$1: function (TSource, source, timeSpan, count, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.Buffer$1(TSource)).$ctor1(source, timeSpan, count, scheduler);
            },
            distinctUntilChanged_: function (TSource, TKey, source, keySelector, comparer) {
                return new (System.Reactive.Linq.ObservableImpl.DistinctUntilChanged$2(TSource,TKey))(source, keySelector, comparer);
            },
            do_: function (TSource, source, onNext, onError, onCompleted) {
                return new (System.Reactive.Linq.ObservableImpl.Do$1(TSource))(source, onNext, onError, onCompleted);
            },
            repeatInfinite: function (T, value) {
                var $yield = [];
                while (true) {
                    $yield.push(value);
                }
                return System.Array.toEnumerable($yield);
            },
            startWith_: function (TSource, source, scheduler, values) {
                if (values === void 0) { values = []; }
                return System.Reactive.Linq.Observable.concat$1(TSource, System.Reactive.Linq.Observable.toObservable$1(TSource, values, scheduler), source);
            },
            takeLast_: function (TSource, source, count, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.TakeLast$1(TSource)).ctor(source, count, scheduler);
            },
            takeLast_$1: function (TSource, source, duration, timerScheduler, loopScheduler) {
                return new (System.Reactive.Linq.ObservableImpl.TakeLast$1(TSource)).$ctor1(source, duration, timerScheduler, loopScheduler);
            },
            window_: function (TSource, source, count, skip) {
                return new (System.Reactive.Linq.ObservableImpl.Window$1(TSource)).ctor(source, count, skip);
            },
            window_$2: function (TSource, source, timeSpan, timeShift, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.Window$1(TSource)).$ctor2(source, timeSpan, timeShift, scheduler);
            },
            window_$1: function (TSource, source, timeSpan, count, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.Window$1(TSource)).$ctor1(source, timeSpan, count, scheduler);
            },
            groupBy_: function (TSource, TKey, TElement, source, keySelector, elementSelector, capacity, comparer) {
                return new (System.Reactive.Linq.ObservableImpl.GroupBy$3(TSource,TKey,TElement))(source, keySelector, elementSelector, capacity, comparer);
            },
            groupByUntil_: function (TSource, TKey, TElement, TDuration, source, keySelector, elementSelector, durationSelector, capacity, comparer) {
                return new (System.Reactive.Linq.ObservableImpl.GroupByUntil$4(TSource,TKey,TElement,TDuration))(source, keySelector, elementSelector, durationSelector, capacity, comparer);
            },
            groupJoin_: function (TLeft, TRight, TLeftDuration, TRightDuration, TResult, left, right, leftDurationSelector, rightDurationSelector, resultSelector) {
                return new (System.Reactive.Linq.ObservableImpl.GroupJoin$5(TLeft,TRight,TLeftDuration,TRightDuration,TResult))(left, right, leftDurationSelector, rightDurationSelector, resultSelector);
            },
            join_: function (TLeft, TRight, TLeftDuration, TRightDuration, TResult, left, right, leftDurationSelector, rightDurationSelector, resultSelector) {
                return new (System.Reactive.Linq.ObservableImpl.Join$5(TLeft,TRight,TLeftDuration,TRightDuration,TResult))(left, right, leftDurationSelector, rightDurationSelector, resultSelector);
            },
            selectMany_: function (TSource, TResult, source, selector) {
                return new (System.Reactive.Linq.ObservableImpl.SelectMany$2(TSource,TResult)).$ctor1(source, selector);
            },
            selectMany_$1: function (TSource, TResult, source, selector) {
                return new (System.Reactive.Linq.ObservableImpl.SelectMany$2(TSource,TResult)).$ctor4(source, selector);
            },
            selectMany_$3: function (TSource, TCollection, TResult, source, collectionSelector, resultSelector) {
                return new (System.Reactive.Linq.ObservableImpl.SelectMany$3(TSource,TCollection,TResult)).$ctor1(source, collectionSelector, resultSelector);
            },
            selectMany_$5: function (TSource, TCollection, TResult, source, collectionSelector, resultSelector) {
                return new (System.Reactive.Linq.ObservableImpl.SelectMany$3(TSource,TCollection,TResult)).$ctor3(source, collectionSelector, resultSelector);
            },
            selectMany_$2: function (TSource, TCollection, TResult, source, collectionSelector, resultSelector) {
                return new (System.Reactive.Linq.ObservableImpl.SelectMany$3(TSource,TCollection,TResult)).ctor(source, collectionSelector, resultSelector);
            },
            selectMany_$4: function (TSource, TCollection, TResult, source, collectionSelector, resultSelector) {
                return new (System.Reactive.Linq.ObservableImpl.SelectMany$3(TSource,TCollection,TResult)).$ctor2(source, collectionSelector, resultSelector);
            },
            take_: function (TSource, source, count) {
                var take = Bridge.as(source, System.Reactive.Linq.ObservableImpl.Take$1(TSource));
                if (take != null && take._scheduler == null) {
                    return take.omega(count);
                }

                return new (System.Reactive.Linq.ObservableImpl.Take$1(TSource)).ctor(source, count);
            },
            take_$1: function (TSource, source, duration, scheduler) {
                var take = Bridge.as(source, System.Reactive.Linq.ObservableImpl.Take$1(TSource));
                if (take != null && Bridge.referenceEquals(take._scheduler, scheduler)) {
                    return take.omega$1(duration);
                }

                return new (System.Reactive.Linq.ObservableImpl.Take$1(TSource)).$ctor1(source, duration, scheduler);
            },
            delay_$1: function (TSource, source, dueTime, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.Delay$1(TSource)).$ctor1(source, dueTime, scheduler);
            },
            delay_: function (TSource, source, dueTime, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.Delay$1(TSource)).ctor(source, dueTime.$clone(), scheduler);
            },
            delay_$2: function (TSource, TDelay, source, subscriptionDelay, delayDurationSelector) {
                return new (System.Reactive.Linq.ObservableImpl.Delay$2(TSource,TDelay))(source, subscriptionDelay, delayDurationSelector);
            },
            delaySubscription_$1: function (TSource, source, dueTime, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.DelaySubscription$1(TSource)).$ctor1(source, dueTime, scheduler);
            },
            delaySubscription_: function (TSource, source, dueTime, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.DelaySubscription$1(TSource)).ctor(source, dueTime.$clone(), scheduler);
            },
            generate_$1: function (TState, TResult, initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.Generate$2(TState,TResult)).$ctor1(initialState, condition, iterate, resultSelector, timeSelector, scheduler);
            },
            generate_: function (TState, TResult, initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.Generate$2(TState,TResult)).ctor(initialState, condition, iterate, resultSelector, timeSelector, scheduler);
            },
            sample_: function (TSource, source, interval, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.Sample$1(TSource))(source, interval, scheduler);
            },
            sample_$1: function (TSource, TSample, source, sampler) {
                return new (System.Reactive.Linq.ObservableImpl.Sample$2(TSource,TSample))(source, sampler);
            },
            skip_: function (TSource, source, duration, scheduler) {
                var skip = Bridge.as(source, System.Reactive.Linq.ObservableImpl.Skip$1(TSource));
                if (skip != null && Bridge.referenceEquals(skip._scheduler, scheduler)) {
                    return skip.omega$1(duration);
                }

                return new (System.Reactive.Linq.ObservableImpl.Skip$1(TSource)).$ctor1(source, duration, scheduler);
            },
            skipLast_: function (TSource, source, duration, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.SkipLast$1(TSource)).$ctor1(source, duration, scheduler);
            },
            skipUntil_: function (TSource, source, startTime, scheduler) {
                var skipUntil = Bridge.as(source, System.Reactive.Linq.ObservableImpl.SkipUntil$1(TSource));
                if (skipUntil != null && Bridge.referenceEquals(skipUntil._scheduler, scheduler)) {
                    return skipUntil.omega(startTime.$clone());
                }

                return new (System.Reactive.Linq.ObservableImpl.SkipUntil$1(TSource))(source, startTime.$clone(), scheduler);
            },
            takeLastBuffer_: function (TSource, source, duration, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.TakeLastBuffer$1(TSource)).$ctor1(source, duration, scheduler);
            },
            takeUntil_: function (TSource, source, endTime, scheduler) {
                var takeUntil = Bridge.as(source, System.Reactive.Linq.ObservableImpl.TakeUntil$1(TSource));
                if (takeUntil != null && Bridge.referenceEquals(takeUntil._scheduler, scheduler)) {
                    return takeUntil.omega(endTime.$clone());
                }

                return new (System.Reactive.Linq.ObservableImpl.TakeUntil$1(TSource))(source, endTime.$clone(), scheduler);
            },
            throttle_: function (TSource, source, dueTime, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.Throttle$1(TSource))(source, dueTime, scheduler);
            },
            timeInterval_: function (TSource, source, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.TimeInterval$1(TSource))(source, scheduler);
            },
            timeout_$1: function (TSource, source, dueTime, other, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.Timeout$1(TSource)).$ctor1(source, dueTime, other, scheduler);
            },
            timeout_: function (TSource, source, dueTime, other, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.Timeout$1(TSource)).ctor(source, dueTime.$clone(), other, scheduler);
            },
            timeout_$2: function (TSource, TTimeout, source, firstTimeout, timeoutDurationSelector, other) {
                return new (System.Reactive.Linq.ObservableImpl.Timeout$2(TSource,TTimeout))(source, firstTimeout, timeoutDurationSelector, other);
            },
            timer_$2: function (dueTime, scheduler) {
                return new System.Reactive.Linq.ObservableImpl.Timer.$ctor1(dueTime, null, scheduler);
            },
            timer_$3: function (dueTime, period, scheduler) {
                return new System.Reactive.Linq.ObservableImpl.Timer.$ctor1(dueTime, period, scheduler);
            },
            timer_: function (dueTime, scheduler) {
                return new System.Reactive.Linq.ObservableImpl.Timer.ctor(dueTime.$clone(), null, scheduler);
            },
            timer_$1: function (dueTime, period, scheduler) {
                return new System.Reactive.Linq.ObservableImpl.Timer.ctor(dueTime.$clone(), period, scheduler);
            },
            timestamp_: function (TSource, source, scheduler) {
                return new (System.Reactive.Linq.ObservableImpl.Timestamp$1(TSource))(source, scheduler);
            }
        },
        config: {
            alias: [
            "aggregate$1", "System$Reactive$Linq$IQueryLanguage$aggregate$1",
            "aggregate$2", "System$Reactive$Linq$IQueryLanguage$aggregate$2",
            "aggregate", "System$Reactive$Linq$IQueryLanguage$aggregate",
            "average$5", "System$Reactive$Linq$IQueryLanguage$average$5",
            "average$19", "System$Reactive$Linq$IQueryLanguage$average$19",
            "average$1", "System$Reactive$Linq$IQueryLanguage$average$1",
            "average$6", "System$Reactive$Linq$IQueryLanguage$average$6",
            "average$7", "System$Reactive$Linq$IQueryLanguage$average$7",
            "average$13", "System$Reactive$Linq$IQueryLanguage$average$13",
            "average$17", "System$Reactive$Linq$IQueryLanguage$average$17",
            "average$9", "System$Reactive$Linq$IQueryLanguage$average$9",
            "average$14", "System$Reactive$Linq$IQueryLanguage$average$14",
            "average$15", "System$Reactive$Linq$IQueryLanguage$average$15",
            "all", "System$Reactive$Linq$IQueryLanguage$all",
            "any", "System$Reactive$Linq$IQueryLanguage$any",
            "any$1", "System$Reactive$Linq$IQueryLanguage$any$1",
            "average$2", "System$Reactive$Linq$IQueryLanguage$average$2",
            "average$18", "System$Reactive$Linq$IQueryLanguage$average$18",
            "average", "System$Reactive$Linq$IQueryLanguage$average",
            "average$3", "System$Reactive$Linq$IQueryLanguage$average$3",
            "average$4", "System$Reactive$Linq$IQueryLanguage$average$4",
            "average$10", "System$Reactive$Linq$IQueryLanguage$average$10",
            "average$16", "System$Reactive$Linq$IQueryLanguage$average$16",
            "average$8", "System$Reactive$Linq$IQueryLanguage$average$8",
            "average$11", "System$Reactive$Linq$IQueryLanguage$average$11",
            "average$12", "System$Reactive$Linq$IQueryLanguage$average$12",
            "contains", "System$Reactive$Linq$IQueryLanguage$contains",
            "contains$1", "System$Reactive$Linq$IQueryLanguage$contains$1",
            "count", "System$Reactive$Linq$IQueryLanguage$count",
            "count$1", "System$Reactive$Linq$IQueryLanguage$count$1",
            "elementAt", "System$Reactive$Linq$IQueryLanguage$elementAt",
            "elementAtOrDefault", "System$Reactive$Linq$IQueryLanguage$elementAtOrDefault",
            "firstAsync", "System$Reactive$Linq$IQueryLanguage$firstAsync",
            "firstAsync$1", "System$Reactive$Linq$IQueryLanguage$firstAsync$1",
            "firstOrDefaultAsync", "System$Reactive$Linq$IQueryLanguage$firstOrDefaultAsync",
            "firstOrDefaultAsync$1", "System$Reactive$Linq$IQueryLanguage$firstOrDefaultAsync$1",
            "isEmpty", "System$Reactive$Linq$IQueryLanguage$isEmpty",
            "lastAsync", "System$Reactive$Linq$IQueryLanguage$lastAsync",
            "lastAsync$1", "System$Reactive$Linq$IQueryLanguage$lastAsync$1",
            "lastOrDefaultAsync", "System$Reactive$Linq$IQueryLanguage$lastOrDefaultAsync",
            "lastOrDefaultAsync$1", "System$Reactive$Linq$IQueryLanguage$lastOrDefaultAsync$1",
            "longCount", "System$Reactive$Linq$IQueryLanguage$longCount",
            "longCount$1", "System$Reactive$Linq$IQueryLanguage$longCount$1",
            "max", "System$Reactive$Linq$IQueryLanguage$max",
            "max$1", "System$Reactive$Linq$IQueryLanguage$max$1",
            "max$6", "System$Reactive$Linq$IQueryLanguage$max$6",
            "max$22", "System$Reactive$Linq$IQueryLanguage$max$22",
            "max$4", "System$Reactive$Linq$IQueryLanguage$max$4",
            "max$8", "System$Reactive$Linq$IQueryLanguage$max$8",
            "max$10", "System$Reactive$Linq$IQueryLanguage$max$10",
            "max$14", "System$Reactive$Linq$IQueryLanguage$max$14",
            "max$20", "System$Reactive$Linq$IQueryLanguage$max$20",
            "max$12", "System$Reactive$Linq$IQueryLanguage$max$12",
            "max$16", "System$Reactive$Linq$IQueryLanguage$max$16",
            "max$18", "System$Reactive$Linq$IQueryLanguage$max$18",
            "max$2", "System$Reactive$Linq$IQueryLanguage$max$2",
            "max$3", "System$Reactive$Linq$IQueryLanguage$max$3",
            "max$7", "System$Reactive$Linq$IQueryLanguage$max$7",
            "max$23", "System$Reactive$Linq$IQueryLanguage$max$23",
            "max$5", "System$Reactive$Linq$IQueryLanguage$max$5",
            "max$9", "System$Reactive$Linq$IQueryLanguage$max$9",
            "max$11", "System$Reactive$Linq$IQueryLanguage$max$11",
            "max$15", "System$Reactive$Linq$IQueryLanguage$max$15",
            "max$21", "System$Reactive$Linq$IQueryLanguage$max$21",
            "max$13", "System$Reactive$Linq$IQueryLanguage$max$13",
            "max$17", "System$Reactive$Linq$IQueryLanguage$max$17",
            "max$19", "System$Reactive$Linq$IQueryLanguage$max$19",
            "maxBy", "System$Reactive$Linq$IQueryLanguage$maxBy",
            "maxBy$1", "System$Reactive$Linq$IQueryLanguage$maxBy$1",
            "min", "System$Reactive$Linq$IQueryLanguage$min",
            "min$1", "System$Reactive$Linq$IQueryLanguage$min$1",
            "min$6", "System$Reactive$Linq$IQueryLanguage$min$6",
            "min$22", "System$Reactive$Linq$IQueryLanguage$min$22",
            "min$4", "System$Reactive$Linq$IQueryLanguage$min$4",
            "min$8", "System$Reactive$Linq$IQueryLanguage$min$8",
            "min$10", "System$Reactive$Linq$IQueryLanguage$min$10",
            "min$14", "System$Reactive$Linq$IQueryLanguage$min$14",
            "min$20", "System$Reactive$Linq$IQueryLanguage$min$20",
            "min$12", "System$Reactive$Linq$IQueryLanguage$min$12",
            "min$16", "System$Reactive$Linq$IQueryLanguage$min$16",
            "min$18", "System$Reactive$Linq$IQueryLanguage$min$18",
            "min$2", "System$Reactive$Linq$IQueryLanguage$min$2",
            "min$3", "System$Reactive$Linq$IQueryLanguage$min$3",
            "min$7", "System$Reactive$Linq$IQueryLanguage$min$7",
            "min$23", "System$Reactive$Linq$IQueryLanguage$min$23",
            "min$5", "System$Reactive$Linq$IQueryLanguage$min$5",
            "min$9", "System$Reactive$Linq$IQueryLanguage$min$9",
            "min$11", "System$Reactive$Linq$IQueryLanguage$min$11",
            "min$15", "System$Reactive$Linq$IQueryLanguage$min$15",
            "min$21", "System$Reactive$Linq$IQueryLanguage$min$21",
            "min$13", "System$Reactive$Linq$IQueryLanguage$min$13",
            "min$17", "System$Reactive$Linq$IQueryLanguage$min$17",
            "min$19", "System$Reactive$Linq$IQueryLanguage$min$19",
            "minBy", "System$Reactive$Linq$IQueryLanguage$minBy",
            "minBy$1", "System$Reactive$Linq$IQueryLanguage$minBy$1",
            "sequenceEqual$2", "System$Reactive$Linq$IQueryLanguage$sequenceEqual$2",
            "sequenceEqual$3", "System$Reactive$Linq$IQueryLanguage$sequenceEqual$3",
            "sequenceEqual", "System$Reactive$Linq$IQueryLanguage$sequenceEqual",
            "sequenceEqual$1", "System$Reactive$Linq$IQueryLanguage$sequenceEqual$1",
            "singleAsync", "System$Reactive$Linq$IQueryLanguage$singleAsync",
            "singleAsync$1", "System$Reactive$Linq$IQueryLanguage$singleAsync$1",
            "singleOrDefaultAsync", "System$Reactive$Linq$IQueryLanguage$singleOrDefaultAsync",
            "singleOrDefaultAsync$1", "System$Reactive$Linq$IQueryLanguage$singleOrDefaultAsync$1",
            "sum$2", "System$Reactive$Linq$IQueryLanguage$sum$2",
            "sum$18", "System$Reactive$Linq$IQueryLanguage$sum$18",
            "sum", "System$Reactive$Linq$IQueryLanguage$sum",
            "sum$4", "System$Reactive$Linq$IQueryLanguage$sum$4",
            "sum$6", "System$Reactive$Linq$IQueryLanguage$sum$6",
            "sum$10", "System$Reactive$Linq$IQueryLanguage$sum$10",
            "sum$16", "System$Reactive$Linq$IQueryLanguage$sum$16",
            "sum$8", "System$Reactive$Linq$IQueryLanguage$sum$8",
            "sum$12", "System$Reactive$Linq$IQueryLanguage$sum$12",
            "sum$14", "System$Reactive$Linq$IQueryLanguage$sum$14",
            "sum$3", "System$Reactive$Linq$IQueryLanguage$sum$3",
            "sum$19", "System$Reactive$Linq$IQueryLanguage$sum$19",
            "sum$1", "System$Reactive$Linq$IQueryLanguage$sum$1",
            "sum$5", "System$Reactive$Linq$IQueryLanguage$sum$5",
            "sum$7", "System$Reactive$Linq$IQueryLanguage$sum$7",
            "sum$11", "System$Reactive$Linq$IQueryLanguage$sum$11",
            "sum$17", "System$Reactive$Linq$IQueryLanguage$sum$17",
            "sum$9", "System$Reactive$Linq$IQueryLanguage$sum$9",
            "sum$13", "System$Reactive$Linq$IQueryLanguage$sum$13",
            "sum$15", "System$Reactive$Linq$IQueryLanguage$sum$15",
            "toArray", "System$Reactive$Linq$IQueryLanguage$toArray",
            "toDictionary$3", "System$Reactive$Linq$IQueryLanguage$toDictionary$3",
            "toDictionary$2", "System$Reactive$Linq$IQueryLanguage$toDictionary$2",
            "toDictionary$1", "System$Reactive$Linq$IQueryLanguage$toDictionary$1",
            "toDictionary", "System$Reactive$Linq$IQueryLanguage$toDictionary",
            "toList", "System$Reactive$Linq$IQueryLanguage$toList",
            "toLookup$3", "System$Reactive$Linq$IQueryLanguage$toLookup$3",
            "toLookup$1", "System$Reactive$Linq$IQueryLanguage$toLookup$1",
            "toLookup$2", "System$Reactive$Linq$IQueryLanguage$toLookup$2",
            "toLookup", "System$Reactive$Linq$IQueryLanguage$toLookup",
            "fromAsyncPattern", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern",
            "fromAsyncPattern$14", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$14",
            "fromAsyncPattern$16", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$16",
            "fromAsyncPattern$18", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$18",
            "fromAsyncPattern$20", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$20",
            "fromAsyncPattern$22", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$22",
            "fromAsyncPattern$24", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$24",
            "fromAsyncPattern$26", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$26",
            "fromAsyncPattern$28", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$28",
            "fromAsyncPattern$2", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$2",
            "fromAsyncPattern$4", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$4",
            "fromAsyncPattern$6", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$6",
            "fromAsyncPattern$8", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$8",
            "fromAsyncPattern$10", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$10",
            "fromAsyncPattern$12", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$12",
            "fromAsyncPattern$1", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$1",
            "fromAsyncPattern$15", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$15",
            "fromAsyncPattern$17", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$17",
            "fromAsyncPattern$19", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$19",
            "fromAsyncPattern$21", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$21",
            "fromAsyncPattern$23", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$23",
            "fromAsyncPattern$25", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$25",
            "fromAsyncPattern$27", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$27",
            "fromAsyncPattern$29", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$29",
            "fromAsyncPattern$3", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$3",
            "fromAsyncPattern$5", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$5",
            "fromAsyncPattern$7", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$7",
            "fromAsyncPattern$9", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$9",
            "fromAsyncPattern$11", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$11",
            "fromAsyncPattern$13", "System$Reactive$Linq$IQueryLanguage$fromAsyncPattern$13",
            "start", "System$Reactive$Linq$IQueryLanguage$start",
            "start$1", "System$Reactive$Linq$IQueryLanguage$start$1",
            "start$2", "System$Reactive$Linq$IQueryLanguage$start$2",
            "start$3", "System$Reactive$Linq$IQueryLanguage$start$3",
            "toAsync", "System$Reactive$Linq$IQueryLanguage$toAsync",
            "toAsync$1", "System$Reactive$Linq$IQueryLanguage$toAsync$1",
            "toAsync$36", "System$Reactive$Linq$IQueryLanguage$toAsync$36",
            "toAsync$37", "System$Reactive$Linq$IQueryLanguage$toAsync$37",
            "toAsync$40", "System$Reactive$Linq$IQueryLanguage$toAsync$40",
            "toAsync$41", "System$Reactive$Linq$IQueryLanguage$toAsync$41",
            "toAsync$44", "System$Reactive$Linq$IQueryLanguage$toAsync$44",
            "toAsync$45", "System$Reactive$Linq$IQueryLanguage$toAsync$45",
            "toAsync$48", "System$Reactive$Linq$IQueryLanguage$toAsync$48",
            "toAsync$49", "System$Reactive$Linq$IQueryLanguage$toAsync$49",
            "toAsync$52", "System$Reactive$Linq$IQueryLanguage$toAsync$52",
            "toAsync$53", "System$Reactive$Linq$IQueryLanguage$toAsync$53",
            "toAsync$56", "System$Reactive$Linq$IQueryLanguage$toAsync$56",
            "toAsync$57", "System$Reactive$Linq$IQueryLanguage$toAsync$57",
            "toAsync$60", "System$Reactive$Linq$IQueryLanguage$toAsync$60",
            "toAsync$61", "System$Reactive$Linq$IQueryLanguage$toAsync$61",
            "toAsync$64", "System$Reactive$Linq$IQueryLanguage$toAsync$64",
            "toAsync$65", "System$Reactive$Linq$IQueryLanguage$toAsync$65",
            "toAsync$4", "System$Reactive$Linq$IQueryLanguage$toAsync$4",
            "toAsync$5", "System$Reactive$Linq$IQueryLanguage$toAsync$5",
            "toAsync$8", "System$Reactive$Linq$IQueryLanguage$toAsync$8",
            "toAsync$9", "System$Reactive$Linq$IQueryLanguage$toAsync$9",
            "toAsync$12", "System$Reactive$Linq$IQueryLanguage$toAsync$12",
            "toAsync$13", "System$Reactive$Linq$IQueryLanguage$toAsync$13",
            "toAsync$16", "System$Reactive$Linq$IQueryLanguage$toAsync$16",
            "toAsync$17", "System$Reactive$Linq$IQueryLanguage$toAsync$17",
            "toAsync$20", "System$Reactive$Linq$IQueryLanguage$toAsync$20",
            "toAsync$21", "System$Reactive$Linq$IQueryLanguage$toAsync$21",
            "toAsync$24", "System$Reactive$Linq$IQueryLanguage$toAsync$24",
            "toAsync$25", "System$Reactive$Linq$IQueryLanguage$toAsync$25",
            "toAsync$28", "System$Reactive$Linq$IQueryLanguage$toAsync$28",
            "toAsync$29", "System$Reactive$Linq$IQueryLanguage$toAsync$29",
            "toAsync$32", "System$Reactive$Linq$IQueryLanguage$toAsync$32",
            "toAsync$33", "System$Reactive$Linq$IQueryLanguage$toAsync$33",
            "toAsync$2", "System$Reactive$Linq$IQueryLanguage$toAsync$2",
            "toAsync$3", "System$Reactive$Linq$IQueryLanguage$toAsync$3",
            "toAsync$38", "System$Reactive$Linq$IQueryLanguage$toAsync$38",
            "toAsync$39", "System$Reactive$Linq$IQueryLanguage$toAsync$39",
            "toAsync$42", "System$Reactive$Linq$IQueryLanguage$toAsync$42",
            "toAsync$43", "System$Reactive$Linq$IQueryLanguage$toAsync$43",
            "toAsync$46", "System$Reactive$Linq$IQueryLanguage$toAsync$46",
            "toAsync$47", "System$Reactive$Linq$IQueryLanguage$toAsync$47",
            "toAsync$50", "System$Reactive$Linq$IQueryLanguage$toAsync$50",
            "toAsync$51", "System$Reactive$Linq$IQueryLanguage$toAsync$51",
            "toAsync$54", "System$Reactive$Linq$IQueryLanguage$toAsync$54",
            "toAsync$55", "System$Reactive$Linq$IQueryLanguage$toAsync$55",
            "toAsync$58", "System$Reactive$Linq$IQueryLanguage$toAsync$58",
            "toAsync$59", "System$Reactive$Linq$IQueryLanguage$toAsync$59",
            "toAsync$62", "System$Reactive$Linq$IQueryLanguage$toAsync$62",
            "toAsync$63", "System$Reactive$Linq$IQueryLanguage$toAsync$63",
            "toAsync$66", "System$Reactive$Linq$IQueryLanguage$toAsync$66",
            "toAsync$67", "System$Reactive$Linq$IQueryLanguage$toAsync$67",
            "toAsync$6", "System$Reactive$Linq$IQueryLanguage$toAsync$6",
            "toAsync$7", "System$Reactive$Linq$IQueryLanguage$toAsync$7",
            "toAsync$10", "System$Reactive$Linq$IQueryLanguage$toAsync$10",
            "toAsync$11", "System$Reactive$Linq$IQueryLanguage$toAsync$11",
            "toAsync$14", "System$Reactive$Linq$IQueryLanguage$toAsync$14",
            "toAsync$15", "System$Reactive$Linq$IQueryLanguage$toAsync$15",
            "toAsync$18", "System$Reactive$Linq$IQueryLanguage$toAsync$18",
            "toAsync$19", "System$Reactive$Linq$IQueryLanguage$toAsync$19",
            "toAsync$22", "System$Reactive$Linq$IQueryLanguage$toAsync$22",
            "toAsync$23", "System$Reactive$Linq$IQueryLanguage$toAsync$23",
            "toAsync$26", "System$Reactive$Linq$IQueryLanguage$toAsync$26",
            "toAsync$27", "System$Reactive$Linq$IQueryLanguage$toAsync$27",
            "toAsync$30", "System$Reactive$Linq$IQueryLanguage$toAsync$30",
            "toAsync$31", "System$Reactive$Linq$IQueryLanguage$toAsync$31",
            "toAsync$34", "System$Reactive$Linq$IQueryLanguage$toAsync$34",
            "toAsync$35", "System$Reactive$Linq$IQueryLanguage$toAsync$35",
            "multicast$1", "System$Reactive$Linq$IQueryLanguage$multicast$1",
            "multicast", "System$Reactive$Linq$IQueryLanguage$multicast",
            "publish$2", "System$Reactive$Linq$IQueryLanguage$publish$2",
            "publish", "System$Reactive$Linq$IQueryLanguage$publish",
            "publish$3", "System$Reactive$Linq$IQueryLanguage$publish$3",
            "publish$1", "System$Reactive$Linq$IQueryLanguage$publish$1",
            "publishLast$1", "System$Reactive$Linq$IQueryLanguage$publishLast$1",
            "publishLast", "System$Reactive$Linq$IQueryLanguage$publishLast",
            "refCount", "System$Reactive$Linq$IQueryLanguage$refCount",
            "replay$8", "System$Reactive$Linq$IQueryLanguage$replay$8",
            "replay$13", "System$Reactive$Linq$IQueryLanguage$replay$13",
            "replay", "System$Reactive$Linq$IQueryLanguage$replay",
            "replay$5", "System$Reactive$Linq$IQueryLanguage$replay$5",
            "replay$14", "System$Reactive$Linq$IQueryLanguage$replay$14",
            "replay$6", "System$Reactive$Linq$IQueryLanguage$replay$6",
            "replay$15", "System$Reactive$Linq$IQueryLanguage$replay$15",
            "replay$7", "System$Reactive$Linq$IQueryLanguage$replay$7",
            "replay$10", "System$Reactive$Linq$IQueryLanguage$replay$10",
            "replay$2", "System$Reactive$Linq$IQueryLanguage$replay$2",
            "replay$9", "System$Reactive$Linq$IQueryLanguage$replay$9",
            "replay$1", "System$Reactive$Linq$IQueryLanguage$replay$1",
            "replay$11", "System$Reactive$Linq$IQueryLanguage$replay$11",
            "replay$3", "System$Reactive$Linq$IQueryLanguage$replay$3",
            "replay$12", "System$Reactive$Linq$IQueryLanguage$replay$12",
            "replay$4", "System$Reactive$Linq$IQueryLanguage$replay$4",
            "chunkify", "System$Reactive$Linq$IQueryLanguage$chunkify",
            "collect", "System$Reactive$Linq$IQueryLanguage$collect",
            "collect$1", "System$Reactive$Linq$IQueryLanguage$collect$1",
            "first", "System$Reactive$Linq$IQueryLanguage$first",
            "first$1", "System$Reactive$Linq$IQueryLanguage$first$1",
            "firstOrDefault", "System$Reactive$Linq$IQueryLanguage$firstOrDefault",
            "firstOrDefault$1", "System$Reactive$Linq$IQueryLanguage$firstOrDefault$1",
            "forEach", "System$Reactive$Linq$IQueryLanguage$forEach",
            "forEach$1", "System$Reactive$Linq$IQueryLanguage$forEach$1",
            "getEnumerator", "System$Reactive$Linq$IQueryLanguage$getEnumerator",
            "last", "System$Reactive$Linq$IQueryLanguage$last",
            "last$1", "System$Reactive$Linq$IQueryLanguage$last$1",
            "lastOrDefault", "System$Reactive$Linq$IQueryLanguage$lastOrDefault",
            "lastOrDefault$1", "System$Reactive$Linq$IQueryLanguage$lastOrDefault$1",
            "latest", "System$Reactive$Linq$IQueryLanguage$latest",
            "mostRecent", "System$Reactive$Linq$IQueryLanguage$mostRecent",
            "next", "System$Reactive$Linq$IQueryLanguage$next",
            "single", "System$Reactive$Linq$IQueryLanguage$single",
            "single$1", "System$Reactive$Linq$IQueryLanguage$single$1",
            "singleOrDefault", "System$Reactive$Linq$IQueryLanguage$singleOrDefault",
            "singleOrDefault$1", "System$Reactive$Linq$IQueryLanguage$singleOrDefault$1",
            "wait", "System$Reactive$Linq$IQueryLanguage$wait",
            "observeOn", "System$Reactive$Linq$IQueryLanguage$observeOn",
            "subscribeOn", "System$Reactive$Linq$IQueryLanguage$subscribeOn",
            "synchronize", "System$Reactive$Linq$IQueryLanguage$synchronize",
            "synchronize$1", "System$Reactive$Linq$IQueryLanguage$synchronize$1",
            "subscribe", "System$Reactive$Linq$IQueryLanguage$subscribe",
            "subscribe$1", "System$Reactive$Linq$IQueryLanguage$subscribe$1",
            "toEnumerable", "System$Reactive$Linq$IQueryLanguage$toEnumerable",
            "toEvent$1", "System$Reactive$Linq$IQueryLanguage$toEvent$1",
            "toEvent", "System$Reactive$Linq$IQueryLanguage$toEvent",
            "toEventPattern", "System$Reactive$Linq$IQueryLanguage$toEventPattern",
            "toObservable", "System$Reactive$Linq$IQueryLanguage$toObservable",
            "toObservable$1", "System$Reactive$Linq$IQueryLanguage$toObservable$1",
            "create$1", "System$Reactive$Linq$IQueryLanguage$create$1",
            "create", "System$Reactive$Linq$IQueryLanguage$create",
            "defer", "System$Reactive$Linq$IQueryLanguage$defer",
            "empty", "System$Reactive$Linq$IQueryLanguage$empty",
            "empty$1", "System$Reactive$Linq$IQueryLanguage$empty$1",
            "generate", "System$Reactive$Linq$IQueryLanguage$generate",
            "generate$1", "System$Reactive$Linq$IQueryLanguage$generate$1",
            "never", "System$Reactive$Linq$IQueryLanguage$never",
            "range", "System$Reactive$Linq$IQueryLanguage$range",
            "range$1", "System$Reactive$Linq$IQueryLanguage$range$1",
            "repeat", "System$Reactive$Linq$IQueryLanguage$repeat",
            "repeat$3", "System$Reactive$Linq$IQueryLanguage$repeat$3",
            "repeat$1", "System$Reactive$Linq$IQueryLanguage$repeat$1",
            "repeat$2", "System$Reactive$Linq$IQueryLanguage$repeat$2",
            "return", "System$Reactive$Linq$IQueryLanguage$return",
            "return$1", "System$Reactive$Linq$IQueryLanguage$return$1",
            "throw", "System$Reactive$Linq$IQueryLanguage$throw",
            "throw$1", "System$Reactive$Linq$IQueryLanguage$throw$1",
            "using", "System$Reactive$Linq$IQueryLanguage$using",
            "fromEventPattern$10", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$10",
            "fromEventPattern$11", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$11",
            "fromEventPattern$6", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$6",
            "fromEventPattern$7", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$7",
            "fromEventPattern$8", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$8",
            "fromEventPattern$9", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$9",
            "fromEventPattern$20", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$20",
            "fromEventPattern$21", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$21",
            "fromEventPattern", "System$Reactive$Linq$IQueryLanguage$fromEventPattern",
            "fromEventPattern$1", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$1",
            "fromEventPattern$12", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$12",
            "fromEventPattern$13", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$13",
            "fromEventPattern$2", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$2",
            "fromEventPattern$3", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$3",
            "fromEventPattern$16", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$16",
            "fromEventPattern$17", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$17",
            "fromEventPattern$14", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$14",
            "fromEventPattern$15", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$15",
            "fromEventPattern$4", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$4",
            "fromEventPattern$5", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$5",
            "fromEventPattern$18", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$18",
            "fromEventPattern$19", "System$Reactive$Linq$IQueryLanguage$fromEventPattern$19",
            "fromEvent$4", "System$Reactive$Linq$IQueryLanguage$fromEvent$4",
            "fromEvent$5", "System$Reactive$Linq$IQueryLanguage$fromEvent$5",
            "fromEvent$2", "System$Reactive$Linq$IQueryLanguage$fromEvent$2",
            "fromEvent$3", "System$Reactive$Linq$IQueryLanguage$fromEvent$3",
            "fromEvent", "System$Reactive$Linq$IQueryLanguage$fromEvent",
            "fromEvent$1", "System$Reactive$Linq$IQueryLanguage$fromEvent$1",
            "fromEvent$6", "System$Reactive$Linq$IQueryLanguage$fromEvent$6",
            "fromEvent$7", "System$Reactive$Linq$IQueryLanguage$fromEvent$7",
            "case", "System$Reactive$Linq$IQueryLanguage$case",
            "case$2", "System$Reactive$Linq$IQueryLanguage$case$2",
            "case$1", "System$Reactive$Linq$IQueryLanguage$case$1",
            "doWhile", "System$Reactive$Linq$IQueryLanguage$doWhile",
            "for", "System$Reactive$Linq$IQueryLanguage$for",
            "if", "System$Reactive$Linq$IQueryLanguage$if",
            "if$2", "System$Reactive$Linq$IQueryLanguage$if$2",
            "if$1", "System$Reactive$Linq$IQueryLanguage$if$1",
            "while", "System$Reactive$Linq$IQueryLanguage$while",
            "and", "System$Reactive$Linq$IQueryLanguage$and",
            "then", "System$Reactive$Linq$IQueryLanguage$then",
            "when$1", "System$Reactive$Linq$IQueryLanguage$when$1",
            "when", "System$Reactive$Linq$IQueryLanguage$when",
            "amb$1", "System$Reactive$Linq$IQueryLanguage$amb$1",
            "amb$2", "System$Reactive$Linq$IQueryLanguage$amb$2",
            "amb", "System$Reactive$Linq$IQueryLanguage$amb",
            "buffer$8", "System$Reactive$Linq$IQueryLanguage$buffer$8",
            "buffer$10", "System$Reactive$Linq$IQueryLanguage$buffer$10",
            "buffer$9", "System$Reactive$Linq$IQueryLanguage$buffer$9",
            "catch$3", "System$Reactive$Linq$IQueryLanguage$catch$3",
            "catch$1", "System$Reactive$Linq$IQueryLanguage$catch$1",
            "catch$2", "System$Reactive$Linq$IQueryLanguage$catch$2",
            "catch", "System$Reactive$Linq$IQueryLanguage$catch",
            "combineLatest$8", "System$Reactive$Linq$IQueryLanguage$combineLatest$8",
            "combineLatest$9", "System$Reactive$Linq$IQueryLanguage$combineLatest$9",
            "combineLatest$10", "System$Reactive$Linq$IQueryLanguage$combineLatest$10",
            "combineLatest$11", "System$Reactive$Linq$IQueryLanguage$combineLatest$11",
            "combineLatest$12", "System$Reactive$Linq$IQueryLanguage$combineLatest$12",
            "combineLatest$13", "System$Reactive$Linq$IQueryLanguage$combineLatest$13",
            "combineLatest$14", "System$Reactive$Linq$IQueryLanguage$combineLatest$14",
            "combineLatest$15", "System$Reactive$Linq$IQueryLanguage$combineLatest$15",
            "combineLatest$1", "System$Reactive$Linq$IQueryLanguage$combineLatest$1",
            "combineLatest$2", "System$Reactive$Linq$IQueryLanguage$combineLatest$2",
            "combineLatest$3", "System$Reactive$Linq$IQueryLanguage$combineLatest$3",
            "combineLatest$4", "System$Reactive$Linq$IQueryLanguage$combineLatest$4",
            "combineLatest$5", "System$Reactive$Linq$IQueryLanguage$combineLatest$5",
            "combineLatest$6", "System$Reactive$Linq$IQueryLanguage$combineLatest$6",
            "combineLatest$7", "System$Reactive$Linq$IQueryLanguage$combineLatest$7",
            "combineLatest", "System$Reactive$Linq$IQueryLanguage$combineLatest",
            "combineLatest$16", "System$Reactive$Linq$IQueryLanguage$combineLatest$16",
            "combineLatest$17", "System$Reactive$Linq$IQueryLanguage$combineLatest$17",
            "concat$1", "System$Reactive$Linq$IQueryLanguage$concat$1",
            "concat$2", "System$Reactive$Linq$IQueryLanguage$concat$2",
            "concat", "System$Reactive$Linq$IQueryLanguage$concat",
            "concat$3", "System$Reactive$Linq$IQueryLanguage$concat$3",
            "merge$7", "System$Reactive$Linq$IQueryLanguage$merge$7",
            "merge$8", "System$Reactive$Linq$IQueryLanguage$merge$8",
            "merge$1", "System$Reactive$Linq$IQueryLanguage$merge$1",
            "merge$2", "System$Reactive$Linq$IQueryLanguage$merge$2",
            "merge$4", "System$Reactive$Linq$IQueryLanguage$merge$4",
            "merge$5", "System$Reactive$Linq$IQueryLanguage$merge$5",
            "merge$6", "System$Reactive$Linq$IQueryLanguage$merge$6",
            "merge$9", "System$Reactive$Linq$IQueryLanguage$merge$9",
            "merge", "System$Reactive$Linq$IQueryLanguage$merge",
            "merge$3", "System$Reactive$Linq$IQueryLanguage$merge$3",
            "onErrorResumeNext$1", "System$Reactive$Linq$IQueryLanguage$onErrorResumeNext$1",
            "onErrorResumeNext$2", "System$Reactive$Linq$IQueryLanguage$onErrorResumeNext$2",
            "onErrorResumeNext", "System$Reactive$Linq$IQueryLanguage$onErrorResumeNext",
            "skipUntil$2", "System$Reactive$Linq$IQueryLanguage$skipUntil$2",
            "switch", "System$Reactive$Linq$IQueryLanguage$switch",
            "takeUntil$2", "System$Reactive$Linq$IQueryLanguage$takeUntil$2",
            "window$8", "System$Reactive$Linq$IQueryLanguage$window$8",
            "window$10", "System$Reactive$Linq$IQueryLanguage$window$10",
            "window$9", "System$Reactive$Linq$IQueryLanguage$window$9",
            "withLatestFrom", "System$Reactive$Linq$IQueryLanguage$withLatestFrom",
            "zip$9", "System$Reactive$Linq$IQueryLanguage$zip$9",
            "zip", "System$Reactive$Linq$IQueryLanguage$zip",
            "zip$17", "System$Reactive$Linq$IQueryLanguage$zip$17",
            "zip$18", "System$Reactive$Linq$IQueryLanguage$zip$18",
            "zip$10", "System$Reactive$Linq$IQueryLanguage$zip$10",
            "zip$11", "System$Reactive$Linq$IQueryLanguage$zip$11",
            "zip$12", "System$Reactive$Linq$IQueryLanguage$zip$12",
            "zip$13", "System$Reactive$Linq$IQueryLanguage$zip$13",
            "zip$14", "System$Reactive$Linq$IQueryLanguage$zip$14",
            "zip$15", "System$Reactive$Linq$IQueryLanguage$zip$15",
            "zip$16", "System$Reactive$Linq$IQueryLanguage$zip$16",
            "zip$1", "System$Reactive$Linq$IQueryLanguage$zip$1",
            "zip$2", "System$Reactive$Linq$IQueryLanguage$zip$2",
            "zip$3", "System$Reactive$Linq$IQueryLanguage$zip$3",
            "zip$4", "System$Reactive$Linq$IQueryLanguage$zip$4",
            "zip$5", "System$Reactive$Linq$IQueryLanguage$zip$5",
            "zip$6", "System$Reactive$Linq$IQueryLanguage$zip$6",
            "zip$7", "System$Reactive$Linq$IQueryLanguage$zip$7",
            "zip$8", "System$Reactive$Linq$IQueryLanguage$zip$8",
            "asObservable", "System$Reactive$Linq$IQueryLanguage$asObservable",
            "buffer", "System$Reactive$Linq$IQueryLanguage$buffer",
            "buffer$1", "System$Reactive$Linq$IQueryLanguage$buffer$1",
            "dematerialize", "System$Reactive$Linq$IQueryLanguage$dematerialize",
            "distinctUntilChanged", "System$Reactive$Linq$IQueryLanguage$distinctUntilChanged",
            "distinctUntilChanged$1", "System$Reactive$Linq$IQueryLanguage$distinctUntilChanged$1",
            "distinctUntilChanged$2", "System$Reactive$Linq$IQueryLanguage$distinctUntilChanged$2",
            "distinctUntilChanged$3", "System$Reactive$Linq$IQueryLanguage$distinctUntilChanged$3",
            "do", "System$Reactive$Linq$IQueryLanguage$do",
            "do$1", "System$Reactive$Linq$IQueryLanguage$do$1",
            "do$2", "System$Reactive$Linq$IQueryLanguage$do$2",
            "do$3", "System$Reactive$Linq$IQueryLanguage$do$3",
            "do$4", "System$Reactive$Linq$IQueryLanguage$do$4",
            "finally", "System$Reactive$Linq$IQueryLanguage$finally",
            "ignoreElements", "System$Reactive$Linq$IQueryLanguage$ignoreElements",
            "materialize", "System$Reactive$Linq$IQueryLanguage$materialize",
            "repeat$4", "System$Reactive$Linq$IQueryLanguage$repeat$4",
            "repeat$5", "System$Reactive$Linq$IQueryLanguage$repeat$5",
            "retry", "System$Reactive$Linq$IQueryLanguage$retry",
            "retry$1", "System$Reactive$Linq$IQueryLanguage$retry$1",
            "scan$1", "System$Reactive$Linq$IQueryLanguage$scan$1",
            "scan", "System$Reactive$Linq$IQueryLanguage$scan",
            "skipLast", "System$Reactive$Linq$IQueryLanguage$skipLast",
            "startWith", "System$Reactive$Linq$IQueryLanguage$startWith",
            "startWith$2", "System$Reactive$Linq$IQueryLanguage$startWith$2",
            "startWith$1", "System$Reactive$Linq$IQueryLanguage$startWith$1",
            "startWith$3", "System$Reactive$Linq$IQueryLanguage$startWith$3",
            "takeLast", "System$Reactive$Linq$IQueryLanguage$takeLast",
            "takeLast$1", "System$Reactive$Linq$IQueryLanguage$takeLast$1",
            "takeLastBuffer", "System$Reactive$Linq$IQueryLanguage$takeLastBuffer",
            "window$1", "System$Reactive$Linq$IQueryLanguage$window$1",
            "window", "System$Reactive$Linq$IQueryLanguage$window",
            "cast", "System$Reactive$Linq$IQueryLanguage$cast",
            "defaultIfEmpty", "System$Reactive$Linq$IQueryLanguage$defaultIfEmpty",
            "defaultIfEmpty$1", "System$Reactive$Linq$IQueryLanguage$defaultIfEmpty$1",
            "distinct", "System$Reactive$Linq$IQueryLanguage$distinct",
            "distinct$1", "System$Reactive$Linq$IQueryLanguage$distinct$1",
            "distinct$2", "System$Reactive$Linq$IQueryLanguage$distinct$2",
            "distinct$3", "System$Reactive$Linq$IQueryLanguage$distinct$3",
            "groupBy$4", "System$Reactive$Linq$IQueryLanguage$groupBy$4",
            "groupBy$1", "System$Reactive$Linq$IQueryLanguage$groupBy$1",
            "groupBy", "System$Reactive$Linq$IQueryLanguage$groupBy",
            "groupBy$5", "System$Reactive$Linq$IQueryLanguage$groupBy$5",
            "groupBy$6", "System$Reactive$Linq$IQueryLanguage$groupBy$6",
            "groupBy$3", "System$Reactive$Linq$IQueryLanguage$groupBy$3",
            "groupBy$2", "System$Reactive$Linq$IQueryLanguage$groupBy$2",
            "groupBy$7", "System$Reactive$Linq$IQueryLanguage$groupBy$7",
            "groupByUntil$5", "System$Reactive$Linq$IQueryLanguage$groupByUntil$5",
            "groupByUntil$4", "System$Reactive$Linq$IQueryLanguage$groupByUntil$4",
            "groupByUntil$1", "System$Reactive$Linq$IQueryLanguage$groupByUntil$1",
            "groupByUntil", "System$Reactive$Linq$IQueryLanguage$groupByUntil",
            "groupByUntil$7", "System$Reactive$Linq$IQueryLanguage$groupByUntil$7",
            "groupByUntil$6", "System$Reactive$Linq$IQueryLanguage$groupByUntil$6",
            "groupByUntil$3", "System$Reactive$Linq$IQueryLanguage$groupByUntil$3",
            "groupByUntil$2", "System$Reactive$Linq$IQueryLanguage$groupByUntil$2",
            "groupJoin", "System$Reactive$Linq$IQueryLanguage$groupJoin",
            "join", "System$Reactive$Linq$IQueryLanguage$join",
            "ofType", "System$Reactive$Linq$IQueryLanguage$ofType",
            "select", "System$Reactive$Linq$IQueryLanguage$select",
            "select$1", "System$Reactive$Linq$IQueryLanguage$select$1",
            "selectMany$6", "System$Reactive$Linq$IQueryLanguage$selectMany$6",
            "selectMany$1", "System$Reactive$Linq$IQueryLanguage$selectMany$1",
            "selectMany$4", "System$Reactive$Linq$IQueryLanguage$selectMany$4",
            "selectMany$8", "System$Reactive$Linq$IQueryLanguage$selectMany$8",
            "selectMany$10", "System$Reactive$Linq$IQueryLanguage$selectMany$10",
            "selectMany$2", "System$Reactive$Linq$IQueryLanguage$selectMany$2",
            "selectMany$5", "System$Reactive$Linq$IQueryLanguage$selectMany$5",
            "selectMany", "System$Reactive$Linq$IQueryLanguage$selectMany",
            "selectMany$3", "System$Reactive$Linq$IQueryLanguage$selectMany$3",
            "selectMany$7", "System$Reactive$Linq$IQueryLanguage$selectMany$7",
            "selectMany$9", "System$Reactive$Linq$IQueryLanguage$selectMany$9",
            "skip", "System$Reactive$Linq$IQueryLanguage$skip",
            "skipWhile", "System$Reactive$Linq$IQueryLanguage$skipWhile",
            "skipWhile$1", "System$Reactive$Linq$IQueryLanguage$skipWhile$1",
            "take", "System$Reactive$Linq$IQueryLanguage$take",
            "take$1", "System$Reactive$Linq$IQueryLanguage$take$1",
            "takeWhile", "System$Reactive$Linq$IQueryLanguage$takeWhile",
            "takeWhile$1", "System$Reactive$Linq$IQueryLanguage$takeWhile$1",
            "where", "System$Reactive$Linq$IQueryLanguage$where",
            "where$1", "System$Reactive$Linq$IQueryLanguage$where$1",
            "buffer$2", "System$Reactive$Linq$IQueryLanguage$buffer$2",
            "buffer$5", "System$Reactive$Linq$IQueryLanguage$buffer$5",
            "buffer$6", "System$Reactive$Linq$IQueryLanguage$buffer$6",
            "buffer$7", "System$Reactive$Linq$IQueryLanguage$buffer$7",
            "buffer$3", "System$Reactive$Linq$IQueryLanguage$buffer$3",
            "buffer$4", "System$Reactive$Linq$IQueryLanguage$buffer$4",
            "delay$2", "System$Reactive$Linq$IQueryLanguage$delay$2",
            "delay$3", "System$Reactive$Linq$IQueryLanguage$delay$3",
            "delay", "System$Reactive$Linq$IQueryLanguage$delay",
            "delay$1", "System$Reactive$Linq$IQueryLanguage$delay$1",
            "delay$4", "System$Reactive$Linq$IQueryLanguage$delay$4",
            "delay$5", "System$Reactive$Linq$IQueryLanguage$delay$5",
            "delaySubscription$2", "System$Reactive$Linq$IQueryLanguage$delaySubscription$2",
            "delaySubscription$3", "System$Reactive$Linq$IQueryLanguage$delaySubscription$3",
            "delaySubscription", "System$Reactive$Linq$IQueryLanguage$delaySubscription",
            "delaySubscription$1", "System$Reactive$Linq$IQueryLanguage$delaySubscription$1",
            "generate$4", "System$Reactive$Linq$IQueryLanguage$generate$4",
            "generate$5", "System$Reactive$Linq$IQueryLanguage$generate$5",
            "generate$2", "System$Reactive$Linq$IQueryLanguage$generate$2",
            "generate$3", "System$Reactive$Linq$IQueryLanguage$generate$3",
            "interval", "System$Reactive$Linq$IQueryLanguage$interval",
            "interval$1", "System$Reactive$Linq$IQueryLanguage$interval$1",
            "sample", "System$Reactive$Linq$IQueryLanguage$sample",
            "sample$1", "System$Reactive$Linq$IQueryLanguage$sample$1",
            "sample$2", "System$Reactive$Linq$IQueryLanguage$sample$2",
            "skip$1", "System$Reactive$Linq$IQueryLanguage$skip$1",
            "skip$2", "System$Reactive$Linq$IQueryLanguage$skip$2",
            "skipLast$1", "System$Reactive$Linq$IQueryLanguage$skipLast$1",
            "skipLast$2", "System$Reactive$Linq$IQueryLanguage$skipLast$2",
            "skipUntil", "System$Reactive$Linq$IQueryLanguage$skipUntil",
            "skipUntil$1", "System$Reactive$Linq$IQueryLanguage$skipUntil$1",
            "take$2", "System$Reactive$Linq$IQueryLanguage$take$2",
            "take$3", "System$Reactive$Linq$IQueryLanguage$take$3",
            "takeLast$2", "System$Reactive$Linq$IQueryLanguage$takeLast$2",
            "takeLast$3", "System$Reactive$Linq$IQueryLanguage$takeLast$3",
            "takeLast$4", "System$Reactive$Linq$IQueryLanguage$takeLast$4",
            "takeLastBuffer$1", "System$Reactive$Linq$IQueryLanguage$takeLastBuffer$1",
            "takeLastBuffer$2", "System$Reactive$Linq$IQueryLanguage$takeLastBuffer$2",
            "takeUntil", "System$Reactive$Linq$IQueryLanguage$takeUntil",
            "takeUntil$1", "System$Reactive$Linq$IQueryLanguage$takeUntil$1",
            "throttle", "System$Reactive$Linq$IQueryLanguage$throttle",
            "throttle$1", "System$Reactive$Linq$IQueryLanguage$throttle$1",
            "throttle$2", "System$Reactive$Linq$IQueryLanguage$throttle$2",
            "timeInterval", "System$Reactive$Linq$IQueryLanguage$timeInterval",
            "timeInterval$1", "System$Reactive$Linq$IQueryLanguage$timeInterval$1",
            "timeout$4", "System$Reactive$Linq$IQueryLanguage$timeout$4",
            "timeout$7", "System$Reactive$Linq$IQueryLanguage$timeout$7",
            "timeout$5", "System$Reactive$Linq$IQueryLanguage$timeout$5",
            "timeout$6", "System$Reactive$Linq$IQueryLanguage$timeout$6",
            "timeout", "System$Reactive$Linq$IQueryLanguage$timeout",
            "timeout$3", "System$Reactive$Linq$IQueryLanguage$timeout$3",
            "timeout$1", "System$Reactive$Linq$IQueryLanguage$timeout$1",
            "timeout$2", "System$Reactive$Linq$IQueryLanguage$timeout$2",
            "timeout$8", "System$Reactive$Linq$IQueryLanguage$timeout$8",
            "timeout$9", "System$Reactive$Linq$IQueryLanguage$timeout$9",
            "timeout$10", "System$Reactive$Linq$IQueryLanguage$timeout$10",
            "timeout$11", "System$Reactive$Linq$IQueryLanguage$timeout$11",
            "timer$4", "System$Reactive$Linq$IQueryLanguage$timer$4",
            "timer", "System$Reactive$Linq$IQueryLanguage$timer",
            "timer$6", "System$Reactive$Linq$IQueryLanguage$timer$6",
            "timer$2", "System$Reactive$Linq$IQueryLanguage$timer$2",
            "timer$5", "System$Reactive$Linq$IQueryLanguage$timer$5",
            "timer$1", "System$Reactive$Linq$IQueryLanguage$timer$1",
            "timer$7", "System$Reactive$Linq$IQueryLanguage$timer$7",
            "timer$3", "System$Reactive$Linq$IQueryLanguage$timer$3",
            "timestamp", "System$Reactive$Linq$IQueryLanguage$timestamp",
            "timestamp$1", "System$Reactive$Linq$IQueryLanguage$timestamp$1",
            "window$2", "System$Reactive$Linq$IQueryLanguage$window$2",
            "window$5", "System$Reactive$Linq$IQueryLanguage$window$5",
            "window$6", "System$Reactive$Linq$IQueryLanguage$window$6",
            "window$7", "System$Reactive$Linq$IQueryLanguage$window$7",
            "window$3", "System$Reactive$Linq$IQueryLanguage$window$3",
            "window$4", "System$Reactive$Linq$IQueryLanguage$window$4"
            ]
        },
        aggregate$1: function (TSource, TAccumulate, source, seed, accumulator) {
            return new (System.Reactive.Linq.ObservableImpl.Aggregate$3(TSource,TAccumulate,TAccumulate))(source, seed, accumulator, System.Reactive.Stubs$1(TAccumulate).i);
        },
        aggregate$2: function (TSource, TAccumulate, TResult, source, seed, accumulator, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Aggregate$3(TSource,TAccumulate,TResult))(source, seed, accumulator, resultSelector);
        },
        aggregate: function (TSource, source, accumulator) {
            return new (System.Reactive.Linq.ObservableImpl.Aggregate$1(TSource))(source, accumulator);
        },
        average$5: function (TSource, source, selector) {
            return this.average$2(this.select(TSource, System.Double, source, selector));
        },
        average$19: function (TSource, source, selector) {
            return this.average$18(this.select(TSource, System.Single, source, selector));
        },
        average$1: function (TSource, source, selector) {
            return this.average(this.select(TSource, System.Decimal, source, selector));
        },
        average$6: function (TSource, source, selector) {
            return this.average$3(this.select(TSource, System.Int32, source, selector));
        },
        average$7: function (TSource, source, selector) {
            return this.average$4(this.select(TSource, System.Int64, source, selector));
        },
        average$13: function (TSource, source, selector) {
            return this.average$10(this.select(TSource, System.Nullable$1(System.Double), source, selector));
        },
        average$17: function (TSource, source, selector) {
            return this.average$16(this.select(TSource, System.Nullable$1(System.Single), source, selector));
        },
        average$9: function (TSource, source, selector) {
            return this.average$8(this.select(TSource, System.Nullable$1(System.Decimal), source, selector));
        },
        average$14: function (TSource, source, selector) {
            return this.average$11(this.select(TSource, System.Nullable$1(System.Int32), source, selector));
        },
        average$15: function (TSource, source, selector) {
            return this.average$12(this.select(TSource, System.Nullable$1(System.Int64), source, selector));
        },
        average$2: function (source) {
            return new System.Reactive.Linq.ObservableImpl.AverageDouble(source);
        },
        average$18: function (source) {
            return new System.Reactive.Linq.ObservableImpl.AverageSingle(source);
        },
        average: function (source) {
            return new System.Reactive.Linq.ObservableImpl.AverageDecimal(source);
        },
        average$3: function (source) {
            return new System.Reactive.Linq.ObservableImpl.AverageInt32(source);
        },
        average$4: function (source) {
            return new System.Reactive.Linq.ObservableImpl.AverageInt64(source);
        },
        average$10: function (source) {
            return new System.Reactive.Linq.ObservableImpl.AverageDoubleNullable(source);
        },
        average$16: function (source) {
            return new System.Reactive.Linq.ObservableImpl.AverageSingleNullable(source);
        },
        average$8: function (source) {
            return new System.Reactive.Linq.ObservableImpl.AverageDecimalNullable(source);
        },
        average$11: function (source) {
            return new System.Reactive.Linq.ObservableImpl.AverageInt32Nullable(source);
        },
        average$12: function (source) {
            return new System.Reactive.Linq.ObservableImpl.AverageInt64Nullable(source);
        },
        all: function (TSource, source, predicate) {
            return new (System.Reactive.Linq.ObservableImpl.All$1(TSource))(source, predicate);
        },
        any: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.Any$1(TSource)).ctor(source);
        },
        any$1: function (TSource, source, predicate) {
            return new (System.Reactive.Linq.ObservableImpl.Any$1(TSource)).$ctor1(source, predicate);
        },
        contains: function (TSource, source, value) {
            return new (System.Reactive.Linq.ObservableImpl.Contains$1(TSource))(source, value, System.Collections.Generic.EqualityComparer$1(TSource).def);
        },
        contains$1: function (TSource, source, value, comparer) {
            return new (System.Reactive.Linq.ObservableImpl.Contains$1(TSource))(source, value, comparer);
        },
        count: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.Count$1(TSource)).ctor(source);
        },
        count$1: function (TSource, source, predicate) {
            return new (System.Reactive.Linq.ObservableImpl.Count$1(TSource)).$ctor1(source, predicate);
        },
        elementAt: function (TSource, source, index) {
            return new (System.Reactive.Linq.ObservableImpl.ElementAt$1(TSource))(source, index, true);
        },
        elementAtOrDefault: function (TSource, source, index) {
            return new (System.Reactive.Linq.ObservableImpl.ElementAt$1(TSource))(source, index, false);
        },
        firstAsync: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.FirstAsync$1(TSource))(source, null, true);
        },
        firstAsync$1: function (TSource, source, predicate) {
            return new (System.Reactive.Linq.ObservableImpl.FirstAsync$1(TSource))(source, predicate, true);
        },
        firstOrDefaultAsync: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.FirstAsync$1(TSource))(source, null, false);
        },
        firstOrDefaultAsync$1: function (TSource, source, predicate) {
            return new (System.Reactive.Linq.ObservableImpl.FirstAsync$1(TSource))(source, predicate, false);
        },
        isEmpty: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.IsEmpty$1(TSource))(source);
        },
        lastAsync: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.LastAsync$1(TSource))(source, null, true);
        },
        lastAsync$1: function (TSource, source, predicate) {
            return new (System.Reactive.Linq.ObservableImpl.LastAsync$1(TSource))(source, predicate, true);
        },
        lastOrDefaultAsync: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.LastAsync$1(TSource))(source, null, false);
        },
        lastOrDefaultAsync$1: function (TSource, source, predicate) {
            return new (System.Reactive.Linq.ObservableImpl.LastAsync$1(TSource))(source, predicate, false);
        },
        longCount: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.LongCount$1(TSource)).ctor(source);
        },
        longCount$1: function (TSource, source, predicate) {
            return new (System.Reactive.Linq.ObservableImpl.LongCount$1(TSource)).$ctor1(source, predicate);
        },
        max: function (TSource, source) {
            // BREAKING CHANGE v2 > v1.x - Behavior for reference types
            return new (System.Reactive.Linq.ObservableImpl.Max$1(TSource))(source, new (System.Collections.Generic.Comparer$1(TSource))(System.Collections.Generic.Comparer$1.$default.fn));
        },
        max$1: function (TSource, source, comparer) {
            // BREAKING CHANGE v2 > v1.x - Behavior for reference types
            return new (System.Reactive.Linq.ObservableImpl.Max$1(TSource))(source, comparer);
        },
        max$6: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MaxDouble(source);
        },
        max$22: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MaxSingle(source);
        },
        max$4: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MaxDecimal(source);
        },
        max$8: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MaxInt32(source);
        },
        max$10: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MaxInt64(source);
        },
        max$14: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MaxDoubleNullable(source);
        },
        max$20: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MaxSingleNullable(source);
        },
        max$12: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MaxDecimalNullable(source);
        },
        max$16: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MaxInt32Nullable(source);
        },
        max$18: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MaxInt64Nullable(source);
        },
        max$2: function (TSource, TResult, source, selector) {
            return this.max(TResult, this.select(TSource, TResult, source, selector));
        },
        max$3: function (TSource, TResult, source, selector, comparer) {
            return this.max$1(TResult, this.select(TSource, TResult, source, selector), comparer);
        },
        max$7: function (TSource, source, selector) {
            return this.max$6(this.select(TSource, System.Double, source, selector));
        },
        max$23: function (TSource, source, selector) {
            return this.max$22(this.select(TSource, System.Single, source, selector));
        },
        max$5: function (TSource, source, selector) {
            return this.max$4(this.select(TSource, System.Decimal, source, selector));
        },
        max$9: function (TSource, source, selector) {
            return this.max$8(this.select(TSource, System.Int32, source, selector));
        },
        max$11: function (TSource, source, selector) {
            return this.max$10(this.select(TSource, System.Int64, source, selector));
        },
        max$15: function (TSource, source, selector) {
            return this.max$14(this.select(TSource, System.Nullable$1(System.Double), source, selector));
        },
        max$21: function (TSource, source, selector) {
            return this.max$20(this.select(TSource, System.Nullable$1(System.Single), source, selector));
        },
        max$13: function (TSource, source, selector) {
            return this.max$12(this.select(TSource, System.Nullable$1(System.Decimal), source, selector));
        },
        max$17: function (TSource, source, selector) {
            return this.max$16(this.select(TSource, System.Nullable$1(System.Int32), source, selector));
        },
        max$19: function (TSource, source, selector) {
            return this.max$18(this.select(TSource, System.Nullable$1(System.Int64), source, selector));
        },
        maxBy: function (TSource, TKey, source, keySelector) {
            return new (System.Reactive.Linq.ObservableImpl.MaxBy$2(TSource,TKey))(source, keySelector, new (System.Collections.Generic.Comparer$1(TKey))(System.Collections.Generic.Comparer$1.$default.fn));
        },
        maxBy$1: function (TSource, TKey, source, keySelector, comparer) {
            return new (System.Reactive.Linq.ObservableImpl.MaxBy$2(TSource,TKey))(source, keySelector, comparer);
        },
        min: function (TSource, source) {
            // BREAKING CHANGE v2 > v1.x - Behavior for reference types
            return new (System.Reactive.Linq.ObservableImpl.Min$1(TSource))(source, new (System.Collections.Generic.Comparer$1(TSource))(System.Collections.Generic.Comparer$1.$default.fn));
        },
        min$1: function (TSource, source, comparer) {
            // BREAKING CHANGE v2 > v1.x - Behavior for reference types
            return new (System.Reactive.Linq.ObservableImpl.Min$1(TSource))(source, comparer);
        },
        min$6: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MinDouble(source);
        },
        min$22: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MinSingle(source);
        },
        min$4: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MinDecimal(source);
        },
        min$8: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MinInt32(source);
        },
        min$10: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MinInt64(source);
        },
        min$14: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MinDoubleNullable(source);
        },
        min$20: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MinSingleNullable(source);
        },
        min$12: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MinDecimalNullable(source);
        },
        min$16: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MinInt32Nullable(source);
        },
        min$18: function (source) {
            return new System.Reactive.Linq.ObservableImpl.MinInt64Nullable(source);
        },
        min$2: function (TSource, TResult, source, selector) {
            return this.min(TResult, this.select(TSource, TResult, source, selector));
        },
        min$3: function (TSource, TResult, source, selector, comparer) {
            return this.min$1(TResult, this.select(TSource, TResult, source, selector), comparer);
        },
        min$7: function (TSource, source, selector) {
            return this.min$6(this.select(TSource, System.Double, source, selector));
        },
        min$23: function (TSource, source, selector) {
            return this.min$22(this.select(TSource, System.Single, source, selector));
        },
        min$5: function (TSource, source, selector) {
            return this.min$4(this.select(TSource, System.Decimal, source, selector));
        },
        min$9: function (TSource, source, selector) {
            return this.min$8(this.select(TSource, System.Int32, source, selector));
        },
        min$11: function (TSource, source, selector) {
            return this.min$10(this.select(TSource, System.Int64, source, selector));
        },
        min$15: function (TSource, source, selector) {
            return this.min$14(this.select(TSource, System.Nullable$1(System.Double), source, selector));
        },
        min$21: function (TSource, source, selector) {
            return this.min$20(this.select(TSource, System.Nullable$1(System.Single), source, selector));
        },
        min$13: function (TSource, source, selector) {
            return this.min$12(this.select(TSource, System.Nullable$1(System.Decimal), source, selector));
        },
        min$17: function (TSource, source, selector) {
            return this.min$16(this.select(TSource, System.Nullable$1(System.Int32), source, selector));
        },
        min$19: function (TSource, source, selector) {
            return this.min$18(this.select(TSource, System.Nullable$1(System.Int64), source, selector));
        },
        minBy: function (TSource, TKey, source, keySelector) {
            return new (System.Reactive.Linq.ObservableImpl.MinBy$2(TSource,TKey))(source, keySelector, new (System.Collections.Generic.Comparer$1(TKey))(System.Collections.Generic.Comparer$1.$default.fn));
        },
        minBy$1: function (TSource, TKey, source, keySelector, comparer) {
            return new (System.Reactive.Linq.ObservableImpl.MinBy$2(TSource,TKey))(source, keySelector, comparer);
        },
        sequenceEqual$2: function (TSource, first, second) {
            return new (System.Reactive.Linq.ObservableImpl.SequenceEqual$1(TSource)).$ctor1(first, second, System.Collections.Generic.EqualityComparer$1(TSource).def);
        },
        sequenceEqual$3: function (TSource, first, second, comparer) {
            return new (System.Reactive.Linq.ObservableImpl.SequenceEqual$1(TSource)).$ctor1(first, second, comparer);
        },
        sequenceEqual: function (TSource, first, second) {
            return new (System.Reactive.Linq.ObservableImpl.SequenceEqual$1(TSource)).ctor(first, second, System.Collections.Generic.EqualityComparer$1(TSource).def);
        },
        sequenceEqual$1: function (TSource, first, second, comparer) {
            return new (System.Reactive.Linq.ObservableImpl.SequenceEqual$1(TSource)).ctor(first, second, comparer);
        },
        singleAsync: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.SingleAsync$1(TSource))(source, null, true);
        },
        singleAsync$1: function (TSource, source, predicate) {
            return new (System.Reactive.Linq.ObservableImpl.SingleAsync$1(TSource))(source, predicate, true);
        },
        singleOrDefaultAsync: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.SingleAsync$1(TSource))(source, null, false);
        },
        singleOrDefaultAsync$1: function (TSource, source, predicate) {
            return new (System.Reactive.Linq.ObservableImpl.SingleAsync$1(TSource))(source, predicate, false);
        },
        sum$2: function (source) {
            return new System.Reactive.Linq.ObservableImpl.SumDouble(source);
        },
        sum$18: function (source) {
            return new System.Reactive.Linq.ObservableImpl.SumSingle(source);
        },
        sum: function (source) {
            return new System.Reactive.Linq.ObservableImpl.SumDecimal(source);
        },
        sum$4: function (source) {
            return new System.Reactive.Linq.ObservableImpl.SumInt32(source);
        },
        sum$6: function (source) {
            return new System.Reactive.Linq.ObservableImpl.SumInt64(source);
        },
        sum$10: function (source) {
            return new System.Reactive.Linq.ObservableImpl.SumDoubleNullable(source);
        },
        sum$16: function (source) {
            return new System.Reactive.Linq.ObservableImpl.SumSingleNullable(source);
        },
        sum$8: function (source) {
            return new System.Reactive.Linq.ObservableImpl.SumDecimalNullable(source);
        },
        sum$12: function (source) {
            return new System.Reactive.Linq.ObservableImpl.SumInt32Nullable(source);
        },
        sum$14: function (source) {
            return new System.Reactive.Linq.ObservableImpl.SumInt64Nullable(source);
        },
        sum$3: function (TSource, source, selector) {
            return this.sum$2(this.select(TSource, System.Double, source, selector));
        },
        sum$19: function (TSource, source, selector) {
            return this.sum$18(this.select(TSource, System.Single, source, selector));
        },
        sum$1: function (TSource, source, selector) {
            return this.sum(this.select(TSource, System.Decimal, source, selector));
        },
        sum$5: function (TSource, source, selector) {
            return this.sum$4(this.select(TSource, System.Int32, source, selector));
        },
        sum$7: function (TSource, source, selector) {
            return this.sum$6(this.select(TSource, System.Int64, source, selector));
        },
        sum$11: function (TSource, source, selector) {
            return this.sum$10(this.select(TSource, System.Nullable$1(System.Double), source, selector));
        },
        sum$17: function (TSource, source, selector) {
            return this.sum$16(this.select(TSource, System.Nullable$1(System.Single), source, selector));
        },
        sum$9: function (TSource, source, selector) {
            return this.sum$8(this.select(TSource, System.Nullable$1(System.Decimal), source, selector));
        },
        sum$13: function (TSource, source, selector) {
            return this.sum$12(this.select(TSource, System.Nullable$1(System.Int32), source, selector));
        },
        sum$15: function (TSource, source, selector) {
            return this.sum$14(this.select(TSource, System.Nullable$1(System.Int64), source, selector));
        },
        toArray: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.ToArray$1(TSource))(source);
        },
        toDictionary$3: function (TSource, TKey, TElement, source, keySelector, elementSelector, comparer) {
            return new (System.Reactive.Linq.ObservableImpl.ToDictionary$3(TSource,TKey,TElement))(source, keySelector, elementSelector, comparer);
        },
        toDictionary$2: function (TSource, TKey, TElement, source, keySelector, elementSelector) {
            return new (System.Reactive.Linq.ObservableImpl.ToDictionary$3(TSource,TKey,TElement))(source, keySelector, elementSelector, System.Collections.Generic.EqualityComparer$1(TKey).def);
        },
        toDictionary$1: function (TSource, TKey, source, keySelector, comparer) {
            return new (System.Reactive.Linq.ObservableImpl.ToDictionary$3(TSource,TKey,TSource))(source, keySelector, $asm.$.System.Reactive.Linq.QueryLanguage.f6, comparer);
        },
        toDictionary: function (TSource, TKey, source, keySelector) {
            return new (System.Reactive.Linq.ObservableImpl.ToDictionary$3(TSource,TKey,TSource))(source, keySelector, $asm.$.System.Reactive.Linq.QueryLanguage.f6, System.Collections.Generic.EqualityComparer$1(TKey).def);
        },
        toList: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.ToList$1(TSource))(source);
        },
        toLookup$3: function (TSource, TKey, TElement, source, keySelector, elementSelector, comparer) {
            throw new System.NotSupportedException("All your base are belong to us");
        },
        toLookup$1: function (TSource, TKey, source, keySelector, comparer) {
            throw new System.NotSupportedException("All your base are belong to us");
        },
        toLookup$2: function (TSource, TKey, TElement, source, keySelector, elementSelector) {
            throw new System.NotSupportedException("All your base are belong to us");
        },
        toLookup: function (TSource, TKey, source, keySelector) {
            throw new System.NotSupportedException("All your base are belong to us");
        },
        fromAsyncPattern: function (TResult, begin, end) {
            return function () {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                try {
                    begin(function (iar) {
                        // Note: Even if the callback completes synchronously, outgoing On* calls
                        //       cannot throw in user code since there can't be any subscribers
                        //       to the AsyncSubject yet. Therefore, there is no need to protect
                        //       against exceptions that'd be caught below and sent (incorrectly)
                        //       into the Observable.Throw sequence being constructed.
                        var result;
                        try {
                            result = end(iar);
                        }
                        catch (exception) {
                            exception = System.Exception.create(exception);
                            subject.onError(exception);
                            return;
                        }
                        subject.onNext(result);
                        subject.onCompleted();
                    }, null);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    return System.Reactive.Linq.Observable.throw$2(TResult, exception, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
                }
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        fromAsyncPattern$14: function (T1, TResult, begin, end) {
            return function (x) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                try {
                    begin(x, function (iar) {
                        // See remark on FromAsyncPattern<TResult>.
                        var result;
                        try {
                            result = end(iar);
                        }
                        catch (exception) {
                            exception = System.Exception.create(exception);
                            subject.onError(exception);
                            return;
                        }
                        subject.onNext(result);
                        subject.onCompleted();
                    }, null);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    return System.Reactive.Linq.Observable.throw$2(TResult, exception, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
                }
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        fromAsyncPattern$16: function (T1, T2, TResult, begin, end) {
            return function (x, y) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                try {
                    begin(x, y, function (iar) {
                        // See remark on FromAsyncPattern<TResult>.
                        var result;
                        try {
                            result = end(iar);
                        }
                        catch (exception) {
                            exception = System.Exception.create(exception);
                            subject.onError(exception);
                            return;
                        }
                        subject.onNext(result);
                        subject.onCompleted();
                    }, null);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    return System.Reactive.Linq.Observable.throw$2(TResult, exception, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
                }
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        fromAsyncPattern$18: function (T1, T2, T3, TResult, begin, end) {
            return function (x, y, z) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                try {
                    begin(x, y, z, function (iar) {
                        // See remark on FromAsyncPattern<TResult>.
                        var result;
                        try {
                            result = end(iar);
                        }
                        catch (exception) {
                            exception = System.Exception.create(exception);
                            subject.onError(exception);
                            return;
                        }
                        subject.onNext(result);
                        subject.onCompleted();
                    }, null);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    return System.Reactive.Linq.Observable.throw$2(TResult, exception, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
                }
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        fromAsyncPattern$20: function (T1, T2, T3, T4, TResult, begin, end) {
            return function (x, y, z, a) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                try {
                    begin(x, y, z, a, function (iar) {
                        // See remark on FromAsyncPattern<TResult>.
                        var result;
                        try {
                            result = end(iar);
                        }
                        catch (exception) {
                            exception = System.Exception.create(exception);
                            subject.onError(exception);
                            return;
                        }
                        subject.onNext(result);
                        subject.onCompleted();
                    }, null);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    return System.Reactive.Linq.Observable.throw$2(TResult, exception, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
                }
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        fromAsyncPattern$22: function (T1, T2, T3, T4, T5, TResult, begin, end) {
            return function (x, y, z, a, b) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                try {
                    begin(x, y, z, a, b, function (iar) {
                        // See remark on FromAsyncPattern<TResult>.
                        var result;
                        try {
                            result = end(iar);
                        }
                        catch (exception) {
                            exception = System.Exception.create(exception);
                            subject.onError(exception);
                            return;
                        }
                        subject.onNext(result);
                        subject.onCompleted();
                    }, null);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    return System.Reactive.Linq.Observable.throw$2(TResult, exception, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
                }
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        fromAsyncPattern$24: function (T1, T2, T3, T4, T5, T6, TResult, begin, end) {
            return function (x, y, z, a, b, c) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                try {
                    begin(x, y, z, a, b, c, function (iar) {
                        // See remark on FromAsyncPattern<TResult>.
                        var result;
                        try {
                            result = end(iar);
                        }
                        catch (exception) {
                            exception = System.Exception.create(exception);
                            subject.onError(exception);
                            return;
                        }
                        subject.onNext(result);
                        subject.onCompleted();
                    }, null);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    return System.Reactive.Linq.Observable.throw$2(TResult, exception, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
                }
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        fromAsyncPattern$26: function (T1, T2, T3, T4, T5, T6, T7, TResult, begin, end) {
            return function (x, y, z, a, b, c, d) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                try {
                    begin(x, y, z, a, b, c, d, function (iar) {
                        // See remark on FromAsyncPattern<TResult>.
                        var result;
                        try {
                            result = end(iar);
                        }
                        catch (exception) {
                            exception = System.Exception.create(exception);
                            subject.onError(exception);
                            return;
                        }
                        subject.onNext(result);
                        subject.onCompleted();
                    }, null);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    return System.Reactive.Linq.Observable.throw$2(TResult, exception, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
                }
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        fromAsyncPattern$28: function (T1, T2, T3, T4, T5, T6, T7, T8, TResult, begin, end) {
            return function (x, y, z, a, b, c, d, e) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                try {
                    begin(x, y, z, a, b, c, d, e, function (iar) {
                        // See remark on FromAsyncPattern<TResult>.
                        var result;
                        try {
                            result = end(iar);
                        }
                        catch (exception) {
                            exception = System.Exception.create(exception);
                            subject.onError(exception);
                            return;
                        }
                        subject.onNext(result);
                        subject.onCompleted();
                    }, null);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    return System.Reactive.Linq.Observable.throw$2(TResult, exception, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
                }
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        fromAsyncPattern$2: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult, begin, end) {
            return function (x, y, z, a, b, c, d, e, f) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                try {
                    begin(x, y, z, a, b, c, d, e, f, function (iar) {
                        // See remark on FromAsyncPattern<TResult>.
                        var result;
                        try {
                            result = end(iar);
                        }
                        catch (exception) {
                            exception = System.Exception.create(exception);
                            subject.onError(exception);
                            return;
                        }
                        subject.onNext(result);
                        subject.onCompleted();
                    }, null);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    return System.Reactive.Linq.Observable.throw$2(TResult, exception, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
                }
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        fromAsyncPattern$4: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult, begin, end) {
            return function (x, y, z, a, b, c, d, e, f, g) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                try {
                    begin(x, y, z, a, b, c, d, e, f, g, function (iar) {
                        // See remark on FromAsyncPattern<TResult>.
                        var result;
                        try {
                            result = end(iar);
                        }
                        catch (exception) {
                            exception = System.Exception.create(exception);
                            subject.onError(exception);
                            return;
                        }
                        subject.onNext(result);
                        subject.onCompleted();
                    }, null);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    return System.Reactive.Linq.Observable.throw$2(TResult, exception, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
                }
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        fromAsyncPattern$6: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult, begin, end) {
            return function (x, y, z, a, b, c, d, e, f, g, h) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                try {
                    begin(x, y, z, a, b, c, d, e, f, g, h, function (iar) {
                        // See remark on FromAsyncPattern<TResult>.
                        var result;
                        try {
                            result = end(iar);
                        }
                        catch (exception) {
                            exception = System.Exception.create(exception);
                            subject.onError(exception);
                            return;
                        }
                        subject.onNext(result);
                        subject.onCompleted();
                    }, null);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    return System.Reactive.Linq.Observable.throw$2(TResult, exception, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
                }
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        fromAsyncPattern$8: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult, begin, end) {
            return function (x, y, z, a, b, c, d, e, f, g, h, i) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                try {
                    begin(x, y, z, a, b, c, d, e, f, g, h, i, function (iar) {
                        // See remark on FromAsyncPattern<TResult>.
                        var result;
                        try {
                            result = end(iar);
                        }
                        catch (exception) {
                            exception = System.Exception.create(exception);
                            subject.onError(exception);
                            return;
                        }
                        subject.onNext(result);
                        subject.onCompleted();
                    }, null);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    return System.Reactive.Linq.Observable.throw$2(TResult, exception, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
                }
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        fromAsyncPattern$10: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult, begin, end) {
            return function (x, y, z, a, b, c, d, e, f, g, h, i, j) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                try {
                    begin(x, y, z, a, b, c, d, e, f, g, h, i, j, function (iar) {
                        // See remark on FromAsyncPattern<TResult>.
                        var result;
                        try {
                            result = end(iar);
                        }
                        catch (exception) {
                            exception = System.Exception.create(exception);
                            subject.onError(exception);
                            return;
                        }
                        subject.onNext(result);
                        subject.onCompleted();
                    }, null);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    return System.Reactive.Linq.Observable.throw$2(TResult, exception, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
                }
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        fromAsyncPattern$12: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult, begin, end) {
            return function (x, y, z, a, b, c, d, e, f, g, h, i, j, k) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                try {
                    begin(x, y, z, a, b, c, d, e, f, g, h, i, j, k, function (iar) {
                        // See remark on FromAsyncPattern<TResult>.
                        var result;
                        try {
                            result = end(iar);
                        }
                        catch (exception) {
                            exception = System.Exception.create(exception);
                            subject.onError(exception);
                            return;
                        }
                        subject.onNext(result);
                        subject.onCompleted();
                    }, null);
                }
                catch (exception) {
                    exception = System.Exception.create(exception);
                    return System.Reactive.Linq.Observable.throw$2(TResult, exception, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
                }
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        fromAsyncPattern$1: function (begin, end) {
            return this.fromAsyncPattern(System.Reactive.Unit, begin, function (iar) {
                end(iar);
                return System.Reactive.Unit.getDefault();
            });
        },
        fromAsyncPattern$15: function (T1, begin, end) {
            return this.fromAsyncPattern$14(T1, System.Reactive.Unit, begin, function (iar) {
                end(iar);
                return System.Reactive.Unit.getDefault();
            });
        },
        fromAsyncPattern$17: function (T1, T2, begin, end) {
            return this.fromAsyncPattern$16(T1, T2, System.Reactive.Unit, begin, function (iar) {
                end(iar);
                return System.Reactive.Unit.getDefault();
            });
        },
        fromAsyncPattern$19: function (T1, T2, T3, begin, end) {
            return this.fromAsyncPattern$18(T1, T2, T3, System.Reactive.Unit, begin, function (iar) {
                end(iar);
                return System.Reactive.Unit.getDefault();
            });
        },
        fromAsyncPattern$21: function (T1, T2, T3, T4, begin, end) {
            return this.fromAsyncPattern$20(T1, T2, T3, T4, System.Reactive.Unit, begin, function (iar) {
                end(iar);
                return System.Reactive.Unit.getDefault();
            });
        },
        fromAsyncPattern$23: function (T1, T2, T3, T4, T5, begin, end) {
            return this.fromAsyncPattern$22(T1, T2, T3, T4, T5, System.Reactive.Unit, begin, function (iar) {
                end(iar);
                return System.Reactive.Unit.getDefault();
            });
        },
        fromAsyncPattern$25: function (T1, T2, T3, T4, T5, T6, begin, end) {
            return this.fromAsyncPattern$24(T1, T2, T3, T4, T5, T6, System.Reactive.Unit, begin, function (iar) {
                end(iar);
                return System.Reactive.Unit.getDefault();
            });
        },
        fromAsyncPattern$27: function (T1, T2, T3, T4, T5, T6, T7, begin, end) {
            return this.fromAsyncPattern$26(T1, T2, T3, T4, T5, T6, T7, System.Reactive.Unit, begin, function (iar) {
                end(iar);
                return System.Reactive.Unit.getDefault();
            });
        },
        fromAsyncPattern$29: function (T1, T2, T3, T4, T5, T6, T7, T8, begin, end) {
            return this.fromAsyncPattern$28(T1, T2, T3, T4, T5, T6, T7, T8, System.Reactive.Unit, begin, function (iar) {
                end(iar);
                return System.Reactive.Unit.getDefault();
            });
        },
        fromAsyncPattern$3: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, begin, end) {
            return this.fromAsyncPattern$2(T1, T2, T3, T4, T5, T6, T7, T8, T9, System.Reactive.Unit, begin, function (iar) {
                end(iar);
                return System.Reactive.Unit.getDefault();
            });
        },
        fromAsyncPattern$5: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, begin, end) {
            return this.fromAsyncPattern$4(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, System.Reactive.Unit, begin, function (iar) {
                end(iar);
                return System.Reactive.Unit.getDefault();
            });
        },
        fromAsyncPattern$7: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, begin, end) {
            return this.fromAsyncPattern$6(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, System.Reactive.Unit, begin, function (iar) {
                end(iar);
                return System.Reactive.Unit.getDefault();
            });
        },
        fromAsyncPattern$9: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, begin, end) {
            return this.fromAsyncPattern$8(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, System.Reactive.Unit, begin, function (iar) {
                end(iar);
                return System.Reactive.Unit.getDefault();
            });
        },
        fromAsyncPattern$11: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, begin, end) {
            return this.fromAsyncPattern$10(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, System.Reactive.Unit, begin, function (iar) {
                end(iar);
                return System.Reactive.Unit.getDefault();
            });
        },
        fromAsyncPattern$13: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, begin, end) {
            return this.fromAsyncPattern$12(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, System.Reactive.Unit, begin, function (iar) {
                end(iar);
                return System.Reactive.Unit.getDefault();
            });
        },
        start: function (TSource, $function) {
            return this.toAsync(TSource, $function)();
        },
        start$1: function (TSource, $function, scheduler) {
            return this.toAsync$1(TSource, $function, scheduler)();
        },
        start$2: function (action) {
            return this.toAsync$3(action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions())();
        },
        start$3: function (action, scheduler) {
            return this.toAsync$3(action, scheduler)();
        },
        toAsync: function (TResult, $function) {
            return this.toAsync$1(TResult, $function, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$1: function (TResult, $function, scheduler) {
            return function () {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    var result = Bridge.getDefaultValue(TResult);
                    try {
                        result = $function();
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(result);
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        toAsync$36: function (T, TResult, $function) {
            return this.toAsync$37(T, TResult, $function, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$37: function (T, TResult, $function, scheduler) {
            return function (first) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    var result = Bridge.getDefaultValue(TResult);
                    try {
                        result = $function(first);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(result);
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        toAsync$40: function (T1, T2, TResult, $function) {
            return this.toAsync$41(T1, T2, TResult, $function, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$41: function (T1, T2, TResult, $function, scheduler) {
            return function (first, second) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    var result = Bridge.getDefaultValue(TResult);
                    try {
                        result = $function(first, second);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(result);
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        toAsync$44: function (T1, T2, T3, TResult, $function) {
            return this.toAsync$45(T1, T2, T3, TResult, $function, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$45: function (T1, T2, T3, TResult, $function, scheduler) {
            return function (first, second, third) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    var result = Bridge.getDefaultValue(TResult);
                    try {
                        result = $function(first, second, third);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(result);
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        toAsync$48: function (T1, T2, T3, T4, TResult, $function) {
            return this.toAsync$49(T1, T2, T3, T4, TResult, $function, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$49: function (T1, T2, T3, T4, TResult, $function, scheduler) {
            return function (first, second, third, fourth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    var result = Bridge.getDefaultValue(TResult);
                    try {
                        result = $function(first, second, third, fourth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(result);
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        toAsync$52: function (T1, T2, T3, T4, T5, TResult, $function) {
            return this.toAsync$53(T1, T2, T3, T4, T5, TResult, $function, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$53: function (T1, T2, T3, T4, T5, TResult, $function, scheduler) {
            return function (first, second, third, fourth, fifth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    var result = Bridge.getDefaultValue(TResult);
                    try {
                        result = $function(first, second, third, fourth, fifth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(result);
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        toAsync$56: function (T1, T2, T3, T4, T5, T6, TResult, $function) {
            return this.toAsync$57(T1, T2, T3, T4, T5, T6, TResult, $function, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$57: function (T1, T2, T3, T4, T5, T6, TResult, $function, scheduler) {
            return function (first, second, third, fourth, fifth, sixth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    var result = Bridge.getDefaultValue(TResult);
                    try {
                        result = $function(first, second, third, fourth, fifth, sixth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(result);
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        toAsync$60: function (T1, T2, T3, T4, T5, T6, T7, TResult, $function) {
            return this.toAsync$61(T1, T2, T3, T4, T5, T6, T7, TResult, $function, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$61: function (T1, T2, T3, T4, T5, T6, T7, TResult, $function, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    var result = Bridge.getDefaultValue(TResult);
                    try {
                        result = $function(first, second, third, fourth, fifth, sixth, seventh);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(result);
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        toAsync$64: function (T1, T2, T3, T4, T5, T6, T7, T8, TResult, $function) {
            return this.toAsync$65(T1, T2, T3, T4, T5, T6, T7, T8, TResult, $function, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$65: function (T1, T2, T3, T4, T5, T6, T7, T8, TResult, $function, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eight) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    var result = Bridge.getDefaultValue(TResult);
                    try {
                        result = $function(first, second, third, fourth, fifth, sixth, seventh, eight);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(result);
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        toAsync$4: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult, $function) {
            return this.toAsync$5(T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult, $function, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$5: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult, $function, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eight, ninth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    var result = Bridge.getDefaultValue(TResult);
                    try {
                        result = $function(first, second, third, fourth, fifth, sixth, seventh, eight, ninth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(result);
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        toAsync$8: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult, $function) {
            return this.toAsync$9(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult, $function, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$9: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult, $function, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eight, ninth, tenth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    var result = Bridge.getDefaultValue(TResult);
                    try {
                        result = $function(first, second, third, fourth, fifth, sixth, seventh, eight, ninth, tenth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(result);
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        toAsync$12: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult, $function) {
            return this.toAsync$13(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult, $function, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$13: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult, $function, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eight, ninth, tenth, eleventh) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    var result = Bridge.getDefaultValue(TResult);
                    try {
                        result = $function(first, second, third, fourth, fifth, sixth, seventh, eight, ninth, tenth, eleventh);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(result);
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        toAsync$16: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult, $function) {
            return this.toAsync$17(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult, $function, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$17: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult, $function, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eight, ninth, tenth, eleventh, twelfth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    var result = Bridge.getDefaultValue(TResult);
                    try {
                        result = $function(first, second, third, fourth, fifth, sixth, seventh, eight, ninth, tenth, eleventh, twelfth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(result);
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        toAsync$20: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult, $function) {
            return this.toAsync$21(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult, $function, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$21: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult, $function, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eight, ninth, tenth, eleventh, twelfth, thirteenth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    var result = Bridge.getDefaultValue(TResult);
                    try {
                        result = $function(first, second, third, fourth, fifth, sixth, seventh, eight, ninth, tenth, eleventh, twelfth, thirteenth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(result);
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        toAsync$24: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult, $function) {
            return this.toAsync$25(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult, $function, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$25: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult, $function, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eight, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    var result = Bridge.getDefaultValue(TResult);
                    try {
                        result = $function(first, second, third, fourth, fifth, sixth, seventh, eight, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(result);
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        toAsync$28: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult, $function) {
            return this.toAsync$29(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult, $function, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$29: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult, $function, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eight, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    var result = Bridge.getDefaultValue(TResult);
                    try {
                        result = $function(first, second, third, fourth, fifth, sixth, seventh, eight, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(result);
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        toAsync$32: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult, $function) {
            return this.toAsync$33(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult, $function, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$33: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult, $function, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eight, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth, sixteenth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(TResult))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    var result = Bridge.getDefaultValue(TResult);
                    try {
                        result = $function(first, second, third, fourth, fifth, sixth, seventh, eight, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth, sixteenth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(result);
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(TResult, subject);
            };
        },
        toAsync$2: function (action) {
            return this.toAsync$3(action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$3: function (action, scheduler) {
            return function () {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(System.Reactive.Unit))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    try {
                        action();
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(System.Reactive.Unit.getDefault());
                    subject.onCompleted();
                });

                return System.Reactive.Linq.Observable.asObservable(System.Reactive.Unit, subject);
            };
        },
        toAsync$38: function (TSource, action) {
            return this.toAsync$39(TSource, action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$39: function (TSource, action, scheduler) {
            return function (first) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(System.Reactive.Unit))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    try {
                        action(first);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(System.Reactive.Unit.getDefault());
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(System.Reactive.Unit, subject);
            };
        },
        toAsync$42: function (T1, T2, action) {
            return this.toAsync$43(T1, T2, action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$43: function (T1, T2, action, scheduler) {
            return function (first, second) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(System.Reactive.Unit))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    try {
                        action(first, second);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(System.Reactive.Unit.getDefault());
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(System.Reactive.Unit, subject);
            };
        },
        toAsync$46: function (T1, T2, T3, action) {
            return this.toAsync$47(T1, T2, T3, action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$47: function (T1, T2, T3, action, scheduler) {
            return function (first, second, third) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(System.Reactive.Unit))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    try {
                        action(first, second, third);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(System.Reactive.Unit.getDefault());
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(System.Reactive.Unit, subject);
            };
        },
        toAsync$50: function (T1, T2, T3, T4, action) {
            return this.toAsync$51(T1, T2, T3, T4, action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$51: function (T1, T2, T3, T4, action, scheduler) {
            return function (first, second, third, fourth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(System.Reactive.Unit))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    try {
                        action(first, second, third, fourth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(System.Reactive.Unit.getDefault());
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(System.Reactive.Unit, subject);
            };
        },
        toAsync$54: function (T1, T2, T3, T4, T5, action) {
            return this.toAsync$55(T1, T2, T3, T4, T5, action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$55: function (T1, T2, T3, T4, T5, action, scheduler) {
            return function (first, second, third, fourth, fifth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(System.Reactive.Unit))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    try {
                        action(first, second, third, fourth, fifth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(System.Reactive.Unit.getDefault());
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(System.Reactive.Unit, subject);
            };
        },
        toAsync$58: function (T1, T2, T3, T4, T5, T6, action) {
            return this.toAsync$59(T1, T2, T3, T4, T5, T6, action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$59: function (T1, T2, T3, T4, T5, T6, action, scheduler) {
            return function (first, second, third, fourth, fifth, sixth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(System.Reactive.Unit))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    try {
                        action(first, second, third, fourth, fifth, sixth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(System.Reactive.Unit.getDefault());
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(System.Reactive.Unit, subject);
            };
        },
        toAsync$62: function (T1, T2, T3, T4, T5, T6, T7, action) {
            return this.toAsync$63(T1, T2, T3, T4, T5, T6, T7, action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$63: function (T1, T2, T3, T4, T5, T6, T7, action, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(System.Reactive.Unit))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    try {
                        action(first, second, third, fourth, fifth, sixth, seventh);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(System.Reactive.Unit.getDefault());
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(System.Reactive.Unit, subject);
            };
        },
        toAsync$66: function (T1, T2, T3, T4, T5, T6, T7, T8, action) {
            return this.toAsync$67(T1, T2, T3, T4, T5, T6, T7, T8, action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$67: function (T1, T2, T3, T4, T5, T6, T7, T8, action, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eight) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(System.Reactive.Unit))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    try {
                        action(first, second, third, fourth, fifth, sixth, seventh, eight);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(System.Reactive.Unit.getDefault());
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(System.Reactive.Unit, subject);
            };
        },
        toAsync$6: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, action) {
            return this.toAsync$7(T1, T2, T3, T4, T5, T6, T7, T8, T9, action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$7: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, action, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(System.Reactive.Unit))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    try {
                        action(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(System.Reactive.Unit.getDefault());
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(System.Reactive.Unit, subject);
            };
        },
        toAsync$10: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, action) {
            return this.toAsync$11(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$11: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, action, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(System.Reactive.Unit))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    try {
                        action(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(System.Reactive.Unit.getDefault());
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(System.Reactive.Unit, subject);
            };
        },
        toAsync$14: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, action) {
            return this.toAsync$15(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$15: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, action, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(System.Reactive.Unit))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    try {
                        action(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(System.Reactive.Unit.getDefault());
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(System.Reactive.Unit, subject);
            };
        },
        toAsync$18: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, action) {
            return this.toAsync$19(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$19: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, action, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(System.Reactive.Unit))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    try {
                        action(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(System.Reactive.Unit.getDefault());
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(System.Reactive.Unit, subject);
            };
        },
        toAsync$22: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, action) {
            return this.toAsync$23(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$23: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, action, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(System.Reactive.Unit))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    try {
                        action(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(System.Reactive.Unit.getDefault());
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(System.Reactive.Unit, subject);
            };
        },
        toAsync$26: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, action) {
            return this.toAsync$27(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$27: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, action, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(System.Reactive.Unit))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    try {
                        action(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(System.Reactive.Unit.getDefault());
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(System.Reactive.Unit, subject);
            };
        },
        toAsync$30: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, action) {
            return this.toAsync$31(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$31: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, action, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(System.Reactive.Unit))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    try {
                        action(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(System.Reactive.Unit.getDefault());
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(System.Reactive.Unit, subject);
            };
        },
        toAsync$34: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, action) {
            return this.toAsync$35(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, action, System.Reactive.Concurrency.SchedulerDefaults.getAsyncConversions());
        },
        toAsync$35: function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, action, scheduler) {
            return function (first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth, sixteenth) {
                var subject = new (System.Reactive.Subjects.AsyncSubject$1(System.Reactive.Unit))();
                System.Reactive.Concurrency.Scheduler.schedule(scheduler, function () {
                    try {
                        action(first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth, eleventh, twelfth, thirteenth, fourteenth, fifteenth, sixteenth);
                    }
                    catch (exception) {
                        exception = System.Exception.create(exception);
                        subject.onError(exception);
                        return;
                    }
                    subject.onNext(System.Reactive.Unit.getDefault());
                    subject.onCompleted();
                });
                return System.Reactive.Linq.Observable.asObservable(System.Reactive.Unit, subject);
            };
        },
        multicast$1: function (TSource, TResult, source, subject) {
            return new (System.Reactive.Subjects.ConnectableObservable$2(TSource,TResult))(source, subject);
        },
        multicast: function (TSource, TIntermediate, TResult, source, subjectSelector, selector) {
            return new (System.Reactive.Linq.ObservableImpl.Multicast$3(TSource,TIntermediate,TResult))(source, subjectSelector, selector);
        },
        publish$2: function (TSource, source) {
            return System.Reactive.Linq.Observable.multicast$1(TSource, TSource, source, new (System.Reactive.Subjects.Subject$1(TSource))());
        },
        publish: function (TSource, TResult, source, selector) {
            return System.Reactive.Linq.Observable.multicast(TSource, TSource, TResult, source, function () {
                return new (System.Reactive.Subjects.Subject$1(TSource))();
            }, selector);
        },
        publish$3: function (TSource, source, initialValue) {
            return System.Reactive.Linq.Observable.multicast$1(TSource, TSource, source, new (System.Reactive.Subjects.BehaviorSubject$1(TSource))(initialValue));
        },
        publish$1: function (TSource, TResult, source, selector, initialValue) {
            return System.Reactive.Linq.Observable.multicast(TSource, TSource, TResult, source, function () {
                return new (System.Reactive.Subjects.BehaviorSubject$1(TSource))(initialValue);
            }, selector);
        },
        publishLast$1: function (TSource, source) {
            return System.Reactive.Linq.Observable.multicast$1(TSource, TSource, source, new (System.Reactive.Subjects.AsyncSubject$1(TSource))());
        },
        publishLast: function (TSource, TResult, source, selector) {
            return System.Reactive.Linq.Observable.multicast(TSource, TSource, TResult, source, function () {
                return new (System.Reactive.Subjects.AsyncSubject$1(TSource))();
            }, selector);
        },
        refCount: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.RefCount$1(TSource))(source);
        },
        replay$8: function (TSource, source) {
            return System.Reactive.Linq.Observable.multicast$1(TSource, TSource, source, new (System.Reactive.Subjects.ReplaySubject$1(TSource)).ctor());
        },
        replay$13: function (TSource, source, scheduler) {
            return System.Reactive.Linq.Observable.multicast$1(TSource, TSource, source, new (System.Reactive.Subjects.ReplaySubject$1(TSource)).$ctor5(scheduler));
        },
        replay: function (TSource, TResult, source, selector) {
            return System.Reactive.Linq.Observable.multicast(TSource, TSource, TResult, source, function () {
                return new (System.Reactive.Subjects.ReplaySubject$1(TSource)).ctor();
            }, selector);
        },
        replay$5: function (TSource, TResult, source, selector, scheduler) {
            return System.Reactive.Linq.Observable.multicast(TSource, TSource, TResult, source, function () {
                return new (System.Reactive.Subjects.ReplaySubject$1(TSource)).$ctor5(scheduler);
            }, selector);
        },
        replay$14: function (TSource, source, $window) {
            return System.Reactive.Linq.Observable.multicast$1(TSource, TSource, source, new (System.Reactive.Subjects.ReplaySubject$1(TSource)).$ctor6($window));
        },
        replay$6: function (TSource, TResult, source, selector, $window) {
            return System.Reactive.Linq.Observable.multicast(TSource, TSource, TResult, source, function () {
                return new (System.Reactive.Subjects.ReplaySubject$1(TSource)).$ctor6($window);
            }, selector);
        },
        replay$15: function (TSource, source, $window, scheduler) {
            return System.Reactive.Linq.Observable.multicast$1(TSource, TSource, source, new (System.Reactive.Subjects.ReplaySubject$1(TSource)).$ctor7($window, scheduler));
        },
        replay$7: function (TSource, TResult, source, selector, $window, scheduler) {
            return System.Reactive.Linq.Observable.multicast(TSource, TSource, TResult, source, function () {
                return new (System.Reactive.Subjects.ReplaySubject$1(TSource)).$ctor7($window, scheduler);
            }, selector);
        },
        replay$10: function (TSource, source, bufferSize, scheduler) {
            return System.Reactive.Linq.Observable.multicast$1(TSource, TSource, source, new (System.Reactive.Subjects.ReplaySubject$1(TSource)).$ctor2(bufferSize, scheduler));
        },
        replay$2: function (TSource, TResult, source, selector, bufferSize, scheduler) {
            return System.Reactive.Linq.Observable.multicast(TSource, TSource, TResult, source, function () {
                return new (System.Reactive.Subjects.ReplaySubject$1(TSource)).$ctor2(bufferSize, scheduler);
            }, selector);
        },
        replay$9: function (TSource, source, bufferSize) {
            return System.Reactive.Linq.Observable.multicast$1(TSource, TSource, source, new (System.Reactive.Subjects.ReplaySubject$1(TSource)).$ctor1(bufferSize));
        },
        replay$1: function (TSource, TResult, source, selector, bufferSize) {
            return System.Reactive.Linq.Observable.multicast(TSource, TSource, TResult, source, function () {
                return new (System.Reactive.Subjects.ReplaySubject$1(TSource)).$ctor1(bufferSize);
            }, selector);
        },
        replay$11: function (TSource, source, bufferSize, $window) {
            return System.Reactive.Linq.Observable.multicast$1(TSource, TSource, source, new (System.Reactive.Subjects.ReplaySubject$1(TSource)).$ctor3(bufferSize, $window));
        },
        replay$3: function (TSource, TResult, source, selector, bufferSize, $window) {
            return System.Reactive.Linq.Observable.multicast(TSource, TSource, TResult, source, function () {
                return new (System.Reactive.Subjects.ReplaySubject$1(TSource)).$ctor3(bufferSize, $window);
            }, selector);
        },
        replay$12: function (TSource, source, bufferSize, $window, scheduler) {
            return System.Reactive.Linq.Observable.multicast$1(TSource, TSource, source, new (System.Reactive.Subjects.ReplaySubject$1(TSource)).$ctor4(bufferSize, $window, scheduler));
        },
        replay$4: function (TSource, TResult, source, selector, bufferSize, $window, scheduler) {
            return System.Reactive.Linq.Observable.multicast(TSource, TSource, TResult, source, function () {
                return new (System.Reactive.Subjects.ReplaySubject$1(TSource)).$ctor4(bufferSize, $window, scheduler);
            }, selector);
        },
        chunkify: function (TSource, source) {
            return System.Reactive.Linq.Observable.collect$1(TSource, System.Collections.Generic.IList$1(TSource), source, function () {
                return new (System.Collections.Generic.List$1(TSource))();
            }, function (lst, x) {
                System.Array.add(lst, x, TSource);
                return lst;
            }, function (_) {
                return new (System.Collections.Generic.List$1(TSource))();
            });
        },
        collect: function (TSource, TResult, source, newCollector, merge) {
            return System.Reactive.Linq.QueryLanguage.collect_(TSource, TResult, source, newCollector, merge, function (_) {
                return newCollector();
            });
        },
        collect$1: function (TSource, TResult, source, getInitialCollector, merge, getNewCollector) {
            return System.Reactive.Linq.QueryLanguage.collect_(TSource, TResult, source, getInitialCollector, merge, getNewCollector);
        },
        first: function (TSource, source) {
            return System.Reactive.Linq.QueryLanguage.firstOrDefaultInternal(TSource, source, true);
        },
        first$1: function (TSource, source, predicate) {
            return this.first(TSource, this.where(TSource, source, predicate));
        },
        firstOrDefault: function (TSource, source) {
            return System.Reactive.Linq.QueryLanguage.firstOrDefaultInternal(TSource, source, false);
        },
        firstOrDefault$1: function (TSource, source, predicate) {
            return this.firstOrDefault(TSource, this.where(TSource, source, predicate));
        },
        forEach: function (TSource, source, onNext) {
            var $t;
            var evt = new System.Reactive.Linq.QueryLanguage.WaitAndSetOnce();
            try {
                var sink = new (System.Reactive.Linq.ObservableImpl.ForEach$1._(TSource))(onNext, function () {
                    evt.set();
                });

                $t = System.ObservableExtensions.subscribeSafe(TSource, source, sink);
                try {
                    evt.waitOne();
                }
                finally {
                    if (Bridge.hasValue($t)) {
                        $t.dispose();
                    }
                }

                System.Reactive.ExceptionHelpers.throwIfNotNull(sink.getError());
            }
            finally {
                if (Bridge.hasValue(evt)) {
                    evt.dispose();
                }
            }
        },
        forEach$1: function (TSource, source, onNext) {
            var $t;
            var evt = new System.Reactive.Linq.QueryLanguage.WaitAndSetOnce();
            try {
                var sink = new (System.Reactive.Linq.ObservableImpl.ForEach$1.ForEachImpl(TSource))(onNext, function () {
                    evt.set();
                });

                $t = System.ObservableExtensions.subscribeSafe(TSource, source, sink);
                try {
                    evt.waitOne();
                }
                finally {
                    if (Bridge.hasValue($t)) {
                        $t.dispose();
                    }
                }

                System.Reactive.ExceptionHelpers.throwIfNotNull(sink.getError());
            }
            finally {
                if (Bridge.hasValue(evt)) {
                    evt.dispose();
                }
            }
        },
        getEnumerator: function (TSource, source) {
            var q = new (System.Collections.Generic.Queue$1(System.Reactive.Notification$1(TSource))).ctor();
            var s = new System.Reactive.Threading.Semaphore(0, 2147483647);
            return System.Reactive.Linq.QueryLanguage.pushToPull(TSource, TSource, source, function (x) {
                q;
                q.enqueue(x);
                s.release();
            }, function () {
                s.waitOne();
                q;
                return q.dequeue();
            });
        },
        last: function (TSource, source) {
            return System.Reactive.Linq.QueryLanguage.lastOrDefaultInternal(TSource, source, true);
        },
        last$1: function (TSource, source, predicate) {
            return this.last(TSource, this.where(TSource, source, predicate));
        },
        lastOrDefault: function (TSource, source) {
            return System.Reactive.Linq.QueryLanguage.lastOrDefaultInternal(TSource, source, false);
        },
        lastOrDefault$1: function (TSource, source, predicate) {
            return this.lastOrDefault(TSource, this.where(TSource, source, predicate));
        },
        latest: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.Latest$1(TSource))(source);
        },
        mostRecent: function (TSource, source, initialValue) {
            return new (System.Reactive.Linq.ObservableImpl.MostRecent$1(TSource))(source, initialValue);
        },
        next: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.Next$1(TSource))(source);
        },
        single: function (TSource, source) {
            return System.Reactive.Linq.QueryLanguage.singleOrDefaultInternal(TSource, source, true);
        },
        single$1: function (TSource, source, predicate) {
            return this.single(TSource, this.where(TSource, source, predicate));
        },
        singleOrDefault: function (TSource, source) {
            return System.Reactive.Linq.QueryLanguage.singleOrDefaultInternal(TSource, source, false);
        },
        singleOrDefault$1: function (TSource, source, predicate) {
            return this.singleOrDefault(TSource, this.where(TSource, source, predicate));
        },
        wait: function (TSource, source) {
            return System.Reactive.Linq.QueryLanguage.lastOrDefaultInternal(TSource, source, true);
        },
        observeOn: function (TSource, source, scheduler) {
            return System.Reactive.Concurrency.Synchronization.observeOn(TSource, source, scheduler);
        },
        subscribeOn: function (TSource, source, scheduler) {
            return System.Reactive.Concurrency.Synchronization.subscribeOn(TSource, source, scheduler);
        },
        synchronize: function (TSource, source) {
            return System.Reactive.Concurrency.Synchronization.synchronize(TSource, source);
        },
        synchronize$1: function (TSource, source, gate) {
            return System.Reactive.Concurrency.Synchronization.synchronize$1(TSource, source, gate);
        },
        subscribe: function (TSource, source, observer) {
            return System.Reactive.Linq.QueryLanguage.subscribe_(TSource, source, observer, System.Reactive.Concurrency.SchedulerDefaults.getIteration());
        },
        subscribe$1: function (TSource, source, observer, scheduler) {
            return System.Reactive.Linq.QueryLanguage.subscribe_(TSource, source, observer, scheduler);
        },
        toEnumerable: function (TSource, source) {
            return new (System.Reactive.AnonymousEnumerable$1(TSource))(function () {
                return System.Reactive.Linq.Observable.getEnumerator(TSource, source);
            });
        },
        toEvent$1: function (source) {
            return new (System.Reactive.EventSource$1(System.Reactive.Unit))(source, $asm.$.System.Reactive.Linq.QueryLanguage.f7);
        },
        toEvent: function (TSource, source) {
            return new (System.Reactive.EventSource$1(TSource))(source, function (h, value) {
                h(value);
            });
        },
        toEventPattern: function (TEventArgs, source) {
            throw new System.NotSupportedException("All your base are belong to us");
        },
        toObservable: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.ToObservable$1(TSource))(source, System.Reactive.Concurrency.SchedulerDefaults.getIteration());
        },
        toObservable$1: function (TSource, source, scheduler) {
            return new (System.Reactive.Linq.ObservableImpl.ToObservable$1(TSource))(source, scheduler);
        },
        create$1: function (TSource, subscribe) {
            return new (System.Reactive.AnonymousObservable$1(TSource))(subscribe);
        },
        create: function (TSource, subscribe) {
            return new (System.Reactive.AnonymousObservable$1(TSource))(function (o) {
                var a = subscribe(o);
                return !Bridge.staticEquals(a, null) ? System.Reactive.Disposables.Disposable.create(a) : System.Reactive.Disposables.Disposable.getEmpty();
            });
        },
        defer: function (TValue, observableFactory) {
            return new (System.Reactive.Linq.ObservableImpl.Defer$1(TValue))(observableFactory);
        },
        empty: function (TResult) {
            return new (System.Reactive.Linq.ObservableImpl.Empty$1(TResult))(System.Reactive.Concurrency.SchedulerDefaults.getConstantTimeOperations());
        },
        empty$1: function (TResult, scheduler) {
            return new (System.Reactive.Linq.ObservableImpl.Empty$1(TResult))(scheduler);
        },
        generate: function (TState, TResult, initialState, condition, iterate, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Generate$2(TState,TResult)).$ctor2(initialState, condition, iterate, resultSelector, System.Reactive.Concurrency.SchedulerDefaults.getIteration());
        },
        generate$1: function (TState, TResult, initialState, condition, iterate, resultSelector, scheduler) {
            return new (System.Reactive.Linq.ObservableImpl.Generate$2(TState,TResult)).$ctor2(initialState, condition, iterate, resultSelector, scheduler);
        },
        generate$4: function (TState, TResult, initialState, condition, iterate, resultSelector, timeSelector) {
            return System.Reactive.Linq.QueryLanguage.generate_$1(TState, TResult, initialState, condition, iterate, resultSelector, timeSelector, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        generate$5: function (TState, TResult, initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
            return System.Reactive.Linq.QueryLanguage.generate_$1(TState, TResult, initialState, condition, iterate, resultSelector, timeSelector, scheduler);
        },
        generate$2: function (TState, TResult, initialState, condition, iterate, resultSelector, timeSelector) {
            return System.Reactive.Linq.QueryLanguage.generate_(TState, TResult, initialState, condition, iterate, resultSelector, timeSelector, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        generate$3: function (TState, TResult, initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
            return System.Reactive.Linq.QueryLanguage.generate_(TState, TResult, initialState, condition, iterate, resultSelector, timeSelector, scheduler);
        },
        never: function (TResult) {
            return new (System.Reactive.Linq.ObservableImpl.Never$1(TResult))();
        },
        range: function (start, count) {
            return System.Reactive.Linq.QueryLanguage.range_(start, count, System.Reactive.Concurrency.SchedulerDefaults.getIteration());
        },
        range$1: function (start, count, scheduler) {
            return System.Reactive.Linq.QueryLanguage.range_(start, count, scheduler);
        },
        repeat: function (TResult, value) {
            return new (System.Reactive.Linq.ObservableImpl.Repeat$1(TResult))(value, null, System.Reactive.Concurrency.SchedulerDefaults.getIteration());
        },
        repeat$3: function (TResult, value, scheduler) {
            return new (System.Reactive.Linq.ObservableImpl.Repeat$1(TResult))(value, null, scheduler);
        },
        repeat$1: function (TResult, value, repeatCount) {
            return new (System.Reactive.Linq.ObservableImpl.Repeat$1(TResult))(value, repeatCount, System.Reactive.Concurrency.SchedulerDefaults.getIteration());
        },
        repeat$2: function (TResult, value, repeatCount, scheduler) {
            return new (System.Reactive.Linq.ObservableImpl.Repeat$1(TResult))(value, repeatCount, scheduler);
        },
        repeat$4: function (TSource, source) {
            return System.Reactive.Linq.Observable.concat(TSource, System.Reactive.Linq.QueryLanguage.repeatInfinite(System.IObservable$1(TSource), source));
        },
        repeat$5: function (TSource, source, repeatCount) {
            return System.Reactive.Linq.Observable.concat(TSource, System.Linq.Enumerable.repeat(source, repeatCount));
        },
        return: function (TResult, value) {
            return new (System.Reactive.Linq.ObservableImpl.Return$1(TResult))(value, System.Reactive.Concurrency.SchedulerDefaults.getConstantTimeOperations());
        },
        return$1: function (TResult, value, scheduler) {
            return new (System.Reactive.Linq.ObservableImpl.Return$1(TResult))(value, scheduler);
        },
        throw: function (TResult, exception) {
            return new (System.Reactive.Linq.ObservableImpl.Throw$1(TResult))(exception, System.Reactive.Concurrency.SchedulerDefaults.getConstantTimeOperations());
        },
        throw$1: function (TResult, exception, scheduler) {
            return new (System.Reactive.Linq.ObservableImpl.Throw$1(TResult))(exception, scheduler);
        },
        using: function (TSource, TResource, resourceFactory, observableFactory) {
            return new (System.Reactive.Linq.ObservableImpl.Using$2(TSource,TResource))(resourceFactory, observableFactory);
        },
        fromEventPattern$10: function (addHandler, removeHandler) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$6(addHandler, removeHandler, System.Reactive.Linq.QueryLanguage.getSchedulerForCurrentContext());
        },
        fromEventPattern$11: function (addHandler, removeHandler, scheduler) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$6(addHandler, removeHandler, scheduler);
        },
        fromEventPattern$6: function (TDelegate, TEventArgs, addHandler, removeHandler) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$4(TDelegate, TEventArgs, addHandler, removeHandler, System.Reactive.Linq.QueryLanguage.getSchedulerForCurrentContext());
        },
        fromEventPattern$7: function (TDelegate, TEventArgs, addHandler, removeHandler, scheduler) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$4(TDelegate, TEventArgs, addHandler, removeHandler, scheduler);
        },
        fromEventPattern$8: function (TDelegate, TEventArgs, conversion, addHandler, removeHandler) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$5(TDelegate, TEventArgs, conversion, addHandler, removeHandler, System.Reactive.Linq.QueryLanguage.getSchedulerForCurrentContext());
        },
        fromEventPattern$9: function (TDelegate, TEventArgs, conversion, addHandler, removeHandler, scheduler) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$5(TDelegate, TEventArgs, conversion, addHandler, removeHandler, scheduler);
        },
        fromEventPattern$20: function (TDelegate, TSender, TEventArgs, addHandler, removeHandler) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$11(TDelegate, TSender, TEventArgs, addHandler, removeHandler, System.Reactive.Linq.QueryLanguage.getSchedulerForCurrentContext());
        },
        fromEventPattern$21: function (TDelegate, TSender, TEventArgs, addHandler, removeHandler, scheduler) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$11(TDelegate, TSender, TEventArgs, addHandler, removeHandler, scheduler);
        },
        fromEventPattern: function (TEventArgs, addHandler, removeHandler) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$1(TEventArgs, addHandler, removeHandler, System.Reactive.Linq.QueryLanguage.getSchedulerForCurrentContext());
        },
        fromEventPattern$1: function (TEventArgs, addHandler, removeHandler, scheduler) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$1(TEventArgs, addHandler, removeHandler, scheduler);
        },
        fromEventPattern$12: function (target, eventName) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$7(target, eventName, System.Reactive.Linq.QueryLanguage.getSchedulerForCurrentContext());
        },
        fromEventPattern$13: function (target, eventName, scheduler) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$7(target, eventName, scheduler);
        },
        fromEventPattern$2: function (TEventArgs, target, eventName) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$2(TEventArgs, target, eventName, System.Reactive.Linq.QueryLanguage.getSchedulerForCurrentContext());
        },
        fromEventPattern$3: function (TEventArgs, target, eventName, scheduler) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$2(TEventArgs, target, eventName, scheduler);
        },
        fromEventPattern$16: function (TSender, TEventArgs, target, eventName) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$9(TSender, TEventArgs, target, eventName, System.Reactive.Linq.QueryLanguage.getSchedulerForCurrentContext());
        },
        fromEventPattern$17: function (TSender, TEventArgs, target, eventName, scheduler) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$9(TSender, TEventArgs, target, eventName, scheduler);
        },
        fromEventPattern$14: function (type, eventName) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$8(type, eventName, System.Reactive.Linq.QueryLanguage.getSchedulerForCurrentContext());
        },
        fromEventPattern$15: function (type, eventName, scheduler) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$8(type, eventName, scheduler);
        },
        fromEventPattern$4: function (TEventArgs, type, eventName) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$3(TEventArgs, type, eventName, System.Reactive.Linq.QueryLanguage.getSchedulerForCurrentContext());
        },
        fromEventPattern$5: function (TEventArgs, type, eventName, scheduler) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$3(TEventArgs, type, eventName, scheduler);
        },
        fromEventPattern$18: function (TSender, TEventArgs, type, eventName) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$10(TSender, TEventArgs, type, eventName, System.Reactive.Linq.QueryLanguage.getSchedulerForCurrentContext());
        },
        fromEventPattern$19: function (TSender, TEventArgs, type, eventName, scheduler) {
            return System.Reactive.Linq.QueryLanguage.fromEventPattern_$10(TSender, TEventArgs, type, eventName, scheduler);
        },
        fromEvent$4: function (TDelegate, TEventArgs, conversion, addHandler, removeHandler) {
            return System.Reactive.Linq.QueryLanguage.fromEvent_$2(TDelegate, TEventArgs, conversion, addHandler, removeHandler, System.Reactive.Linq.QueryLanguage.getSchedulerForCurrentContext());
        },
        fromEvent$5: function (TDelegate, TEventArgs, conversion, addHandler, removeHandler, scheduler) {
            return System.Reactive.Linq.QueryLanguage.fromEvent_$2(TDelegate, TEventArgs, conversion, addHandler, removeHandler, scheduler);
        },
        fromEvent$2: function (TDelegate, TEventArgs, addHandler, removeHandler) {
            return System.Reactive.Linq.QueryLanguage.fromEvent_$1(TDelegate, TEventArgs, addHandler, removeHandler, System.Reactive.Linq.QueryLanguage.getSchedulerForCurrentContext());
        },
        fromEvent$3: function (TDelegate, TEventArgs, addHandler, removeHandler, scheduler) {
            return System.Reactive.Linq.QueryLanguage.fromEvent_$1(TDelegate, TEventArgs, addHandler, removeHandler, scheduler);
        },
        fromEvent: function (TEventArgs, addHandler, removeHandler) {
            return System.Reactive.Linq.QueryLanguage.fromEvent_(TEventArgs, addHandler, removeHandler, System.Reactive.Linq.QueryLanguage.getSchedulerForCurrentContext());
        },
        fromEvent$1: function (TEventArgs, addHandler, removeHandler, scheduler) {
            return System.Reactive.Linq.QueryLanguage.fromEvent_(TEventArgs, addHandler, removeHandler, scheduler);
        },
        fromEvent$6: function (addHandler, removeHandler) {
            return System.Reactive.Linq.QueryLanguage.fromEvent_$3(addHandler, removeHandler, System.Reactive.Linq.QueryLanguage.getSchedulerForCurrentContext());
        },
        fromEvent$7: function (addHandler, removeHandler, scheduler) {
            return System.Reactive.Linq.QueryLanguage.fromEvent_$3(addHandler, removeHandler, scheduler);
        },
        case: function (TValue, TResult, selector, sources) {
            return this.case$1(TValue, TResult, selector, sources, this.empty(TResult));
        },
        case$2: function (TValue, TResult, selector, sources, scheduler) {
            return this.case$1(TValue, TResult, selector, sources, this.empty$1(TResult, scheduler));
        },
        case$1: function (TValue, TResult, selector, sources, defaultSource) {
            return new (System.Reactive.Linq.ObservableImpl.Case$2(TValue,TResult))(selector, sources, defaultSource);
        },
        doWhile: function (TSource, source, condition) {
            return new (System.Reactive.Linq.ObservableImpl.DoWhile$1(TSource))(source, condition);
        },
        for: function (TSource, TResult, source, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.For$2(TSource,TResult))(source, resultSelector);
        },
        if: function (TResult, condition, thenSource) {
            return this.if$1(TResult, condition, thenSource, this.empty(TResult));
        },
        if$2: function (TResult, condition, thenSource, scheduler) {
            return this.if$1(TResult, condition, thenSource, this.empty$1(TResult, scheduler));
        },
        if$1: function (TResult, condition, thenSource, elseSource) {
            return new (System.Reactive.Linq.ObservableImpl.If$1(TResult))(condition, thenSource, elseSource);
        },
        while: function (TSource, condition, source) {
            return new (System.Reactive.Linq.ObservableImpl.While$1(TSource))(condition, source);
        },
        and: function (TLeft, TRight, left, right) {
            return new (System.Reactive.Joins.Pattern$2(TLeft,TRight))(left, right);
        },
        then: function (TSource, TResult, source, selector) {
            return new (System.Reactive.Joins.Pattern$1(TSource))(source).then(TResult, selector);
        },
        when$1: function (TResult, plans) {
            if (plans === void 0) { plans = []; }
            return this.when(TResult, Bridge.cast(plans, System.Collections.Generic.IEnumerable$1(System.Reactive.Joins.Plan$1(TResult))));
        },
        when: function (TResult, plans) {
            return new (System.Reactive.AnonymousObservable$1(TResult))(Bridge.fn.bind(this, function (observer) {
                var $t, $t1;
                var externalSubscriptions = new (System.Collections.Generic.Dictionary$2(Object,System.Reactive.Joins.IJoinObserver))();
                var gate = {  };
                var activePlans = new (System.Collections.Generic.List$1(System.Reactive.Joins.ActivePlan))();
                var outObserver = System.Reactive.Observer.create$3(TResult, Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"]), function (exception) {
                    var $t;
                    $t = Bridge.getEnumerator(externalSubscriptions.getValues(), System.Reactive.Joins.IJoinObserver);
                    while ($t.moveNext()) {
                        var po = $t.getCurrent();
                        po.System$IDisposable$dispose();
                    }
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](exception);
                }, Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]));
                try {
                    $t = Bridge.getEnumerator(plans, System.Reactive.Joins.Plan$1(TResult));
                    while ($t.moveNext()) {
                        (function () {
                            var plan = $t.getCurrent();
                            activePlans.add(plan.activate(externalSubscriptions, outObserver, function (activePlan) {
                                activePlans.remove(activePlan);
                                if (activePlans.getCount() === 0) {
                                    outObserver["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
                                }
                            }));
                        }).call(this);
                    }
                }
                catch (e) {
                    e = System.Exception.create(e);
                    //
                    // [OK] Use of unsafe Subscribe: we're calling into a known producer implementation.
                    //
                    return this.throw(TResult, e)["System$IObservable$1$" + Bridge.getTypeAlias(TResult) + "$subscribe"](observer);
                }

                var group = new System.Reactive.Disposables.CompositeDisposable.$ctor3(System.Array.getCount(externalSubscriptions.getValues(), System.Reactive.Joins.IJoinObserver));
                $t1 = Bridge.getEnumerator(externalSubscriptions.getValues(), System.Reactive.Joins.IJoinObserver);
                while ($t1.moveNext()) {
                    var joinObserver = $t1.getCurrent();
                    joinObserver.System$Reactive$Joins$IJoinObserver$subscribe(gate);
                    group.add(joinObserver);
                }
                return group;
            }));
        },
        amb$1: function (TSource, first, second) {
            return System.Reactive.Linq.QueryLanguage.amb_$1(TSource, first, second);
        },
        amb$2: function (TSource, sources) {
            if (sources === void 0) { sources = []; }
            return System.Reactive.Linq.QueryLanguage.amb_(TSource, sources);
        },
        amb: function (TSource, sources) {
            return System.Reactive.Linq.QueryLanguage.amb_(TSource, sources);
        },
        buffer$8: function (TSource, TBufferClosing, source, bufferClosingSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Buffer$2(TSource,TBufferClosing)).ctor(source, bufferClosingSelector);
        },
        buffer$10: function (TSource, TBufferOpening, TBufferClosing, source, bufferOpenings, bufferClosingSelector) {
            return System.Reactive.Linq.Observable.selectMany$1(System.IObservable$1(TSource), System.Collections.Generic.IList$1(TSource), System.Reactive.Linq.Observable.window$10(TSource, TBufferOpening, TBufferClosing, source, bufferOpenings, bufferClosingSelector), Bridge.fn.bind(this, function (source) { return this.toList(TSource, source); }));
        },
        buffer$9: function (TSource, TBufferBoundary, source, bufferBoundaries) {
            return new (System.Reactive.Linq.ObservableImpl.Buffer$2(TSource,TBufferBoundary)).$ctor1(source, bufferBoundaries);
        },
        buffer: function (TSource, source, count) {
            return System.Reactive.Linq.QueryLanguage.buffer_(TSource, source, count, count);
        },
        buffer$1: function (TSource, source, count, skip) {
            return System.Reactive.Linq.QueryLanguage.buffer_(TSource, source, count, skip);
        },
        buffer$2: function (TSource, source, timeSpan) {
            return System.Reactive.Linq.QueryLanguage.buffer_$2(TSource, source, timeSpan, timeSpan, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        buffer$5: function (TSource, source, timeSpan, scheduler) {
            return System.Reactive.Linq.QueryLanguage.buffer_$2(TSource, source, timeSpan, timeSpan, scheduler);
        },
        buffer$6: function (TSource, source, timeSpan, timeShift) {
            return System.Reactive.Linq.QueryLanguage.buffer_$2(TSource, source, timeSpan, timeShift, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        buffer$7: function (TSource, source, timeSpan, timeShift, scheduler) {
            return System.Reactive.Linq.QueryLanguage.buffer_$2(TSource, source, timeSpan, timeShift, scheduler);
        },
        buffer$3: function (TSource, source, timeSpan, count) {
            return System.Reactive.Linq.QueryLanguage.buffer_$1(TSource, source, timeSpan, count, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        buffer$4: function (TSource, source, timeSpan, count, scheduler) {
            return System.Reactive.Linq.QueryLanguage.buffer_$1(TSource, source, timeSpan, count, scheduler);
        },
        catch$3: function (TSource, TException, source, handler) {
            return new (System.Reactive.Linq.ObservableImpl.Catch$2(TSource,TException))(source, handler);
        },
        catch$1: function (TSource, first, second) {
            return System.Reactive.Linq.QueryLanguage.catch_(TSource, [first, second]);
        },
        catch$2: function (TSource, sources) {
            if (sources === void 0) { sources = []; }
            return System.Reactive.Linq.QueryLanguage.catch_(TSource, sources);
        },
        catch: function (TSource, sources) {
            return System.Reactive.Linq.QueryLanguage.catch_(TSource, sources);
        },
        combineLatest$8: function (TFirst, TSecond, TResult, first, second, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.CombineLatest$3(TFirst,TSecond,TResult))(first, second, resultSelector);
        },
        combineLatest$9: function (TSource1, TSource2, TSource3, TResult, source1, source2, source3, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.CombineLatest$4(TSource1,TSource2,TSource3,TResult))(source1, source2, source3, resultSelector);
        },
        combineLatest$10: function (TSource1, TSource2, TSource3, TSource4, TResult, source1, source2, source3, source4, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.CombineLatest$5(TSource1,TSource2,TSource3,TSource4,TResult))(source1, source2, source3, source4, resultSelector);
        },
        combineLatest$11: function (TSource1, TSource2, TSource3, TSource4, TSource5, TResult, source1, source2, source3, source4, source5, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.CombineLatest$6(TSource1,TSource2,TSource3,TSource4,TSource5,TResult))(source1, source2, source3, source4, source5, resultSelector);
        },
        combineLatest$12: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TResult, source1, source2, source3, source4, source5, source6, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.CombineLatest$7(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TResult))(source1, source2, source3, source4, source5, source6, resultSelector);
        },
        combineLatest$13: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TResult, source1, source2, source3, source4, source5, source6, source7, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.CombineLatest$8(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TResult))(source1, source2, source3, source4, source5, source6, source7, resultSelector);
        },
        combineLatest$14: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TResult, source1, source2, source3, source4, source5, source6, source7, source8, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.CombineLatest$9(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, resultSelector);
        },
        combineLatest$15: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.CombineLatest$10(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, source9, resultSelector);
        },
        combineLatest$1: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.CombineLatest$11(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, resultSelector);
        },
        combineLatest$2: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.CombineLatest$12(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, resultSelector);
        },
        combineLatest$3: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.CombineLatest$13(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, resultSelector);
        },
        combineLatest$4: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.CombineLatest$14(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TSource13,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, resultSelector);
        },
        combineLatest$5: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.CombineLatest$15(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TSource13,TSource14,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, resultSelector);
        },
        combineLatest$6: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TSource15, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.CombineLatest$16(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TSource13,TSource14,TSource15,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, resultSelector);
        },
        combineLatest$7: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TSource15, TSource16, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, source16, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.CombineLatest$17(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TSource13,TSource14,TSource15,TSource16,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, source16, resultSelector);
        },
        combineLatest: function (TSource, TResult, sources, resultSelector) {
            return System.Reactive.Linq.QueryLanguage.combineLatest_(TSource, TResult, sources, resultSelector);
        },
        combineLatest$16: function (TSource, sources) {
            return System.Reactive.Linq.QueryLanguage.combineLatest_(TSource, System.Collections.Generic.IList$1(TSource), sources, function (res) {
                return System.Linq.Enumerable.from(res).toList(TSource);
            });
        },
        combineLatest$17: function (TSource, sources) {
            if (sources === void 0) { sources = []; }
            return System.Reactive.Linq.QueryLanguage.combineLatest_(TSource, System.Collections.Generic.IList$1(TSource), sources, function (res) {
                return System.Linq.Enumerable.from(res).toList(TSource);
            });
        },
        concat$1: function (TSource, first, second) {
            return System.Reactive.Linq.QueryLanguage.concat_(TSource, [first, second]);
        },
        concat$2: function (TSource, sources) {
            if (sources === void 0) { sources = []; }
            return System.Reactive.Linq.QueryLanguage.concat_(TSource, sources);
        },
        concat: function (TSource, sources) {
            return System.Reactive.Linq.QueryLanguage.concat_(TSource, sources);
        },
        concat$3: function (TSource, sources) {
            return this.concat_(TSource, sources);
        },
        concat_: function (TSource, sources) {
            return this.merge$8(TSource, sources, 1);
        },
        merge$7: function (TSource, sources) {
            return System.Reactive.Linq.QueryLanguage.merge_(TSource, sources);
        },
        merge$8: function (TSource, sources, maxConcurrent) {
            return System.Reactive.Linq.QueryLanguage.merge_$1(TSource, sources, maxConcurrent);
        },
        merge$1: function (TSource, sources, maxConcurrent) {
            return System.Reactive.Linq.QueryLanguage.merge_$1(TSource, System.Reactive.Linq.Observable.toObservable$1(System.IObservable$1(TSource), sources, System.Reactive.Concurrency.SchedulerDefaults.getConstantTimeOperations()), maxConcurrent);
        },
        merge$2: function (TSource, sources, maxConcurrent, scheduler) {
            return System.Reactive.Linq.QueryLanguage.merge_$1(TSource, System.Reactive.Linq.Observable.toObservable$1(System.IObservable$1(TSource), sources, scheduler), maxConcurrent);
        },
        merge$4: function (TSource, first, second) {
            return System.Reactive.Linq.QueryLanguage.merge_(TSource, System.Reactive.Linq.Observable.toObservable$1(System.IObservable$1(TSource), [first, second], System.Reactive.Concurrency.SchedulerDefaults.getConstantTimeOperations()));
        },
        merge$5: function (TSource, first, second, scheduler) {
            return System.Reactive.Linq.QueryLanguage.merge_(TSource, System.Reactive.Linq.Observable.toObservable$1(System.IObservable$1(TSource), [first, second], scheduler));
        },
        merge$6: function (TSource, sources) {
            if (sources === void 0) { sources = []; }
            return System.Reactive.Linq.QueryLanguage.merge_(TSource, System.Reactive.Linq.Observable.toObservable$1(System.IObservable$1(TSource), sources, System.Reactive.Concurrency.SchedulerDefaults.getConstantTimeOperations()));
        },
        merge$9: function (TSource, scheduler, sources) {
            if (sources === void 0) { sources = []; }
            return System.Reactive.Linq.QueryLanguage.merge_(TSource, System.Reactive.Linq.Observable.toObservable$1(System.IObservable$1(TSource), sources, scheduler));
        },
        merge: function (TSource, sources) {
            return System.Reactive.Linq.QueryLanguage.merge_(TSource, System.Reactive.Linq.Observable.toObservable$1(System.IObservable$1(TSource), sources, System.Reactive.Concurrency.SchedulerDefaults.getConstantTimeOperations()));
        },
        merge$3: function (TSource, sources, scheduler) {
            return System.Reactive.Linq.QueryLanguage.merge_(TSource, System.Reactive.Linq.Observable.toObservable$1(System.IObservable$1(TSource), sources, scheduler));
        },
        onErrorResumeNext$1: function (TSource, first, second) {
            return System.Reactive.Linq.QueryLanguage.onErrorResumeNext_(TSource, [first, second]);
        },
        onErrorResumeNext$2: function (TSource, sources) {
            if (sources === void 0) { sources = []; }
            return System.Reactive.Linq.QueryLanguage.onErrorResumeNext_(TSource, sources);
        },
        onErrorResumeNext: function (TSource, sources) {
            return System.Reactive.Linq.QueryLanguage.onErrorResumeNext_(TSource, sources);
        },
        skipUntil$2: function (TSource, TOther, source, other) {
            return new (System.Reactive.Linq.ObservableImpl.SkipUntil$2(TSource,TOther))(source, other);
        },
        skipUntil: function (TSource, source, startTime) {
            return System.Reactive.Linq.QueryLanguage.skipUntil_(TSource, source, startTime.$clone(), System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        skipUntil$1: function (TSource, source, startTime, scheduler) {
            return System.Reactive.Linq.QueryLanguage.skipUntil_(TSource, source, startTime.$clone(), scheduler);
        },
        switch: function (TSource, sources) {
            return this.switch_(TSource, sources);
        },
        switch_: function (TSource, sources) {
            return new (System.Reactive.Linq.ObservableImpl.Switch$1(TSource))(sources);
        },
        takeUntil$2: function (TSource, TOther, source, other) {
            return new (System.Reactive.Linq.ObservableImpl.TakeUntil$2(TSource,TOther))(source, other);
        },
        takeUntil: function (TSource, source, endTime) {
            return System.Reactive.Linq.QueryLanguage.takeUntil_(TSource, source, endTime.$clone(), System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        takeUntil$1: function (TSource, source, endTime, scheduler) {
            return System.Reactive.Linq.QueryLanguage.takeUntil_(TSource, source, endTime.$clone(), scheduler);
        },
        window$8: function (TSource, TWindowClosing, source, windowClosingSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Window$2(TSource,TWindowClosing)).ctor(source, windowClosingSelector);
        },
        window$10: function (TSource, TWindowOpening, TWindowClosing, source, windowOpenings, windowClosingSelector) {
            return System.Reactive.Linq.Observable.groupJoin(TWindowOpening, TSource, TWindowClosing, System.Reactive.Unit, System.IObservable$1(TSource), windowOpenings, source, windowClosingSelector, $asm.$.System.Reactive.Linq.QueryLanguage.f8, $asm.$.System.Reactive.Linq.QueryLanguage.f9);
        },
        window$9: function (TSource, TWindowBoundary, source, windowBoundaries) {
            return new (System.Reactive.Linq.ObservableImpl.Window$2(TSource,TWindowBoundary)).$ctor1(source, windowBoundaries);
        },
        window$1: function (TSource, source, count, skip) {
            return System.Reactive.Linq.QueryLanguage.window_(TSource, source, count, skip);
        },
        window: function (TSource, source, count) {
            return System.Reactive.Linq.QueryLanguage.window_(TSource, source, count, count);
        },
        window$2: function (TSource, source, timeSpan) {
            return System.Reactive.Linq.QueryLanguage.window_$2(TSource, source, timeSpan, timeSpan, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        window$5: function (TSource, source, timeSpan, scheduler) {
            return System.Reactive.Linq.QueryLanguage.window_$2(TSource, source, timeSpan, timeSpan, scheduler);
        },
        window$6: function (TSource, source, timeSpan, timeShift) {
            return System.Reactive.Linq.QueryLanguage.window_$2(TSource, source, timeSpan, timeShift, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        window$7: function (TSource, source, timeSpan, timeShift, scheduler) {
            return System.Reactive.Linq.QueryLanguage.window_$2(TSource, source, timeSpan, timeShift, scheduler);
        },
        window$3: function (TSource, source, timeSpan, count) {
            return System.Reactive.Linq.QueryLanguage.window_$1(TSource, source, timeSpan, count, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        window$4: function (TSource, source, timeSpan, count, scheduler) {
            return System.Reactive.Linq.QueryLanguage.window_$1(TSource, source, timeSpan, count, scheduler);
        },
        withLatestFrom: function (TFirst, TSecond, TResult, first, second, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.WithLatestFrom$3(TFirst,TSecond,TResult))(first, second, resultSelector);
        },
        zip$9: function (TFirst, TSecond, TResult, first, second, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Zip$3(TFirst,TSecond,TResult)).$ctor1(first, second, resultSelector);
        },
        zip: function (TSource, TResult, sources, resultSelector) {
            return System.Reactive.Linq.Observable.select(System.Collections.Generic.IList$1(TSource), TResult, System.Reactive.Linq.QueryLanguage.zip_(TSource, sources), resultSelector);
        },
        zip$17: function (TSource, sources) {
            return System.Reactive.Linq.QueryLanguage.zip_(TSource, sources);
        },
        zip$18: function (TSource, sources) {
            if (sources === void 0) { sources = []; }
            return System.Reactive.Linq.QueryLanguage.zip_(TSource, sources);
        },
        zip$10: function (TSource1, TSource2, TSource3, TResult, source1, source2, source3, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Zip$4(TSource1,TSource2,TSource3,TResult))(source1, source2, source3, resultSelector);
        },
        zip$11: function (TSource1, TSource2, TSource3, TSource4, TResult, source1, source2, source3, source4, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Zip$5(TSource1,TSource2,TSource3,TSource4,TResult))(source1, source2, source3, source4, resultSelector);
        },
        zip$12: function (TSource1, TSource2, TSource3, TSource4, TSource5, TResult, source1, source2, source3, source4, source5, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Zip$6(TSource1,TSource2,TSource3,TSource4,TSource5,TResult))(source1, source2, source3, source4, source5, resultSelector);
        },
        zip$13: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TResult, source1, source2, source3, source4, source5, source6, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Zip$7(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TResult))(source1, source2, source3, source4, source5, source6, resultSelector);
        },
        zip$14: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TResult, source1, source2, source3, source4, source5, source6, source7, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Zip$8(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TResult))(source1, source2, source3, source4, source5, source6, source7, resultSelector);
        },
        zip$15: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TResult, source1, source2, source3, source4, source5, source6, source7, source8, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Zip$9(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, resultSelector);
        },
        zip$16: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Zip$10(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, source9, resultSelector);
        },
        zip$1: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Zip$11(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, resultSelector);
        },
        zip$2: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Zip$12(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, resultSelector);
        },
        zip$3: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Zip$13(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, resultSelector);
        },
        zip$4: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Zip$14(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TSource13,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, resultSelector);
        },
        zip$5: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Zip$15(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TSource13,TSource14,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, resultSelector);
        },
        zip$6: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TSource15, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Zip$16(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TSource13,TSource14,TSource15,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, resultSelector);
        },
        zip$7: function (TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TSource15, TSource16, TResult, source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, source16, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Zip$17(TSource1,TSource2,TSource3,TSource4,TSource5,TSource6,TSource7,TSource8,TSource9,TSource10,TSource11,TSource12,TSource13,TSource14,TSource15,TSource16,TResult))(source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, source16, resultSelector);
        },
        zip$8: function (TFirst, TSecond, TResult, first, second, resultSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Zip$3(TFirst,TSecond,TResult)).ctor(first, second, resultSelector);
        },
        asObservable: function (TSource, source) {
            var asObservable = Bridge.as(source, System.Reactive.Linq.ObservableImpl.AsObservable$1(TSource));
            if (asObservable != null) {
                return asObservable.omega();
            }

            return new (System.Reactive.Linq.ObservableImpl.AsObservable$1(TSource))(source);
        },
        dematerialize: function (TSource, source) {
            var materialize = Bridge.as(source, System.Reactive.Linq.ObservableImpl.Materialize$1(TSource));
            if (materialize != null) {
                return materialize.dematerialize();
            }

            return new (System.Reactive.Linq.ObservableImpl.Dematerialize$1(TSource))(source);
        },
        distinctUntilChanged: function (TSource, source) {
            return System.Reactive.Linq.QueryLanguage.distinctUntilChanged_(TSource, TSource, source, $asm.$.System.Reactive.Linq.QueryLanguage.f6, System.Collections.Generic.EqualityComparer$1(TSource).def);
        },
        distinctUntilChanged$1: function (TSource, source, comparer) {
            return System.Reactive.Linq.QueryLanguage.distinctUntilChanged_(TSource, TSource, source, $asm.$.System.Reactive.Linq.QueryLanguage.f6, comparer);
        },
        distinctUntilChanged$2: function (TSource, TKey, source, keySelector) {
            return System.Reactive.Linq.QueryLanguage.distinctUntilChanged_(TSource, TKey, source, keySelector, System.Collections.Generic.EqualityComparer$1(TKey).def);
        },
        distinctUntilChanged$3: function (TSource, TKey, source, keySelector, comparer) {
            return System.Reactive.Linq.QueryLanguage.distinctUntilChanged_(TSource, TKey, source, keySelector, comparer);
        },
        do: function (TSource, source, onNext) {
            return System.Reactive.Linq.QueryLanguage.do_(TSource, source, onNext, System.Reactive.Stubs$1(System.Exception).ignore, System.Reactive.Stubs.nop);
        },
        do$1: function (TSource, source, onNext, onCompleted) {
            return System.Reactive.Linq.QueryLanguage.do_(TSource, source, onNext, System.Reactive.Stubs$1(System.Exception).ignore, onCompleted);
        },
        do$2: function (TSource, source, onNext, onError) {
            return System.Reactive.Linq.QueryLanguage.do_(TSource, source, onNext, onError, System.Reactive.Stubs.nop);
        },
        do$3: function (TSource, source, onNext, onError, onCompleted) {
            return System.Reactive.Linq.QueryLanguage.do_(TSource, source, onNext, onError, onCompleted);
        },
        do$4: function (TSource, source, observer) {
            return System.Reactive.Linq.QueryLanguage.do_(TSource, source, Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"]), Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"]), Bridge.fn.bind(observer, observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]));
        },
        finally: function (TSource, source, finallyAction) {
            return new (System.Reactive.Linq.ObservableImpl.Finally$1(TSource))(source, finallyAction);
        },
        ignoreElements: function (TSource, source) {
            var ignoreElements = Bridge.as(source, System.Reactive.Linq.ObservableImpl.IgnoreElements$1(TSource));
            if (ignoreElements != null) {
                return ignoreElements.omega();
            }

            return new (System.Reactive.Linq.ObservableImpl.IgnoreElements$1(TSource))(source);
        },
        materialize: function (TSource, source) {
            //
            // NOTE: Peephole optimization of xs.Dematerialize().Materialize() should not be performed. It's possible for xs to
            //       contain multiple terminal notifications, which won't survive a Dematerialize().Materialize() chain. In case
            //       a reduction to xs.AsObservable() would be performed, those notification elements would survive.
            //

            return new (System.Reactive.Linq.ObservableImpl.Materialize$1(TSource))(source);
        },
        retry: function (TSource, source) {
            return System.Reactive.Linq.Observable.catch(TSource, System.Reactive.Linq.QueryLanguage.repeatInfinite(System.IObservable$1(TSource), source));
        },
        retry$1: function (TSource, source, retryCount) {
            return System.Reactive.Linq.Observable.catch(TSource, System.Linq.Enumerable.repeat(source, retryCount));
        },
        scan$1: function (TSource, TAccumulate, source, seed, accumulator) {
            return new (System.Reactive.Linq.ObservableImpl.Scan$2(TSource,TAccumulate))(source, seed, accumulator);
        },
        scan: function (TSource, source, accumulator) {
            return new (System.Reactive.Linq.ObservableImpl.Scan$1(TSource))(source, accumulator);
        },
        skipLast: function (TSource, source, count) {
            return new (System.Reactive.Linq.ObservableImpl.SkipLast$1(TSource)).ctor(source, count);
        },
        skipLast$1: function (TSource, source, duration) {
            return System.Reactive.Linq.QueryLanguage.skipLast_(TSource, source, duration, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        skipLast$2: function (TSource, source, duration, scheduler) {
            return System.Reactive.Linq.QueryLanguage.skipLast_(TSource, source, duration, scheduler);
        },
        startWith: function (TSource, source, values) {
            if (values === void 0) { values = []; }
            return System.Reactive.Linq.QueryLanguage.startWith_(TSource, source, System.Reactive.Concurrency.SchedulerDefaults.getConstantTimeOperations(), values);
        },
        startWith$2: function (TSource, source, scheduler, values) {
            if (values === void 0) { values = []; }
            return System.Reactive.Linq.QueryLanguage.startWith_(TSource, source, scheduler, values);
        },
        startWith$1: function (TSource, source, values) {
            return this.startWith$3(TSource, source, System.Reactive.Concurrency.SchedulerDefaults.getConstantTimeOperations(), values);
        },
        startWith$3: function (TSource, source, scheduler, values) {
            //
            // NOTE: For some reason, someone introduced this signature in the Observable class, which is inconsistent with the Rx pattern
            //       of putting the IScheduler last. It also wasn't wired up through IQueryLanguage. When introducing this method in the
            //       IQueryLanguage interface, we went for consistency with the public API, hence the odd position of the IScheduler.
            //

            var valueArray = Bridge.as(values, Array);
            if (valueArray == null) {
                var valueList = new (System.Collections.Generic.List$1(TSource))(values);
                valueArray = valueList.toArray();
            }

            return System.Reactive.Linq.QueryLanguage.startWith_(TSource, source, scheduler, valueArray);
        },
        takeLast: function (TSource, source, count) {
            return System.Reactive.Linq.QueryLanguage.takeLast_(TSource, source, count, System.Reactive.Concurrency.SchedulerDefaults.getIteration());
        },
        takeLast$1: function (TSource, source, count, scheduler) {
            return System.Reactive.Linq.QueryLanguage.takeLast_(TSource, source, count, scheduler);
        },
        takeLast$2: function (TSource, source, duration) {
            return System.Reactive.Linq.QueryLanguage.takeLast_$1(TSource, source, duration, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations(), System.Reactive.Concurrency.SchedulerDefaults.getIteration());
        },
        takeLast$3: function (TSource, source, duration, scheduler) {
            return System.Reactive.Linq.QueryLanguage.takeLast_$1(TSource, source, duration, scheduler, System.Reactive.Concurrency.SchedulerDefaults.getIteration());
        },
        takeLast$4: function (TSource, source, duration, timerScheduler, loopScheduler) {
            return System.Reactive.Linq.QueryLanguage.takeLast_$1(TSource, source, duration, timerScheduler, loopScheduler);
        },
        takeLastBuffer: function (TSource, source, count) {
            return new (System.Reactive.Linq.ObservableImpl.TakeLastBuffer$1(TSource)).ctor(source, count);
        },
        takeLastBuffer$1: function (TSource, source, duration) {
            return System.Reactive.Linq.QueryLanguage.takeLastBuffer_(TSource, source, duration, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        takeLastBuffer$2: function (TSource, source, duration, scheduler) {
            return System.Reactive.Linq.QueryLanguage.takeLastBuffer_(TSource, source, duration, scheduler);
        },
        cast: function (TResult, source) {
            return new (System.Reactive.Linq.ObservableImpl.Cast$2(Object,TResult))(source);
        },
        defaultIfEmpty: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.DefaultIfEmpty$1(TSource))(source, Bridge.getDefaultValue(TSource));
        },
        defaultIfEmpty$1: function (TSource, source, defaultValue) {
            return new (System.Reactive.Linq.ObservableImpl.DefaultIfEmpty$1(TSource))(source, defaultValue);
        },
        distinct: function (TSource, source) {
            return new (System.Reactive.Linq.ObservableImpl.Distinct$2(TSource,TSource))(source, $asm.$.System.Reactive.Linq.QueryLanguage.f6, System.Collections.Generic.EqualityComparer$1(TSource).def);
        },
        distinct$1: function (TSource, source, comparer) {
            return new (System.Reactive.Linq.ObservableImpl.Distinct$2(TSource,TSource))(source, $asm.$.System.Reactive.Linq.QueryLanguage.f6, comparer);
        },
        distinct$2: function (TSource, TKey, source, keySelector) {
            return new (System.Reactive.Linq.ObservableImpl.Distinct$2(TSource,TKey))(source, keySelector, System.Collections.Generic.EqualityComparer$1(TKey).def);
        },
        distinct$3: function (TSource, TKey, source, keySelector, comparer) {
            return new (System.Reactive.Linq.ObservableImpl.Distinct$2(TSource,TKey))(source, keySelector, comparer);
        },
        groupBy$4: function (TSource, TKey, TElement, source, keySelector, elementSelector) {
            return System.Reactive.Linq.QueryLanguage.groupBy_(TSource, TKey, TElement, source, keySelector, elementSelector, null, System.Collections.Generic.EqualityComparer$1(TKey).def);
        },
        groupBy$1: function (TSource, TKey, source, keySelector, comparer) {
            return System.Reactive.Linq.QueryLanguage.groupBy_(TSource, TKey, TSource, source, keySelector, $asm.$.System.Reactive.Linq.QueryLanguage.f6, null, comparer);
        },
        groupBy: function (TSource, TKey, source, keySelector) {
            return System.Reactive.Linq.QueryLanguage.groupBy_(TSource, TKey, TSource, source, keySelector, $asm.$.System.Reactive.Linq.QueryLanguage.f6, null, System.Collections.Generic.EqualityComparer$1(TKey).def);
        },
        groupBy$5: function (TSource, TKey, TElement, source, keySelector, elementSelector, comparer) {
            return System.Reactive.Linq.QueryLanguage.groupBy_(TSource, TKey, TElement, source, keySelector, elementSelector, null, comparer);
        },
        groupBy$6: function (TSource, TKey, TElement, source, keySelector, elementSelector, capacity) {
            return System.Reactive.Linq.QueryLanguage.groupBy_(TSource, TKey, TElement, source, keySelector, elementSelector, capacity, System.Collections.Generic.EqualityComparer$1(TKey).def);
        },
        groupBy$3: function (TSource, TKey, source, keySelector, capacity, comparer) {
            return System.Reactive.Linq.QueryLanguage.groupBy_(TSource, TKey, TSource, source, keySelector, $asm.$.System.Reactive.Linq.QueryLanguage.f6, capacity, comparer);
        },
        groupBy$2: function (TSource, TKey, source, keySelector, capacity) {
            return System.Reactive.Linq.QueryLanguage.groupBy_(TSource, TKey, TSource, source, keySelector, $asm.$.System.Reactive.Linq.QueryLanguage.f6, capacity, System.Collections.Generic.EqualityComparer$1(TKey).def);
        },
        groupBy$7: function (TSource, TKey, TElement, source, keySelector, elementSelector, capacity, comparer) {
            return System.Reactive.Linq.QueryLanguage.groupBy_(TSource, TKey, TElement, source, keySelector, elementSelector, capacity, comparer);
        },
        groupByUntil$5: function (TSource, TKey, TElement, TDuration, source, keySelector, elementSelector, durationSelector, comparer) {
            return System.Reactive.Linq.QueryLanguage.groupByUntil_(TSource, TKey, TElement, TDuration, source, keySelector, elementSelector, durationSelector, null, comparer);
        },
        groupByUntil$4: function (TSource, TKey, TElement, TDuration, source, keySelector, elementSelector, durationSelector) {
            return System.Reactive.Linq.QueryLanguage.groupByUntil_(TSource, TKey, TElement, TDuration, source, keySelector, elementSelector, durationSelector, null, System.Collections.Generic.EqualityComparer$1(TKey).def);
        },
        groupByUntil$1: function (TSource, TKey, TDuration, source, keySelector, durationSelector, comparer) {
            return System.Reactive.Linq.QueryLanguage.groupByUntil_(TSource, TKey, TSource, TDuration, source, keySelector, $asm.$.System.Reactive.Linq.QueryLanguage.f6, durationSelector, null, comparer);
        },
        groupByUntil: function (TSource, TKey, TDuration, source, keySelector, durationSelector) {
            return System.Reactive.Linq.QueryLanguage.groupByUntil_(TSource, TKey, TSource, TDuration, source, keySelector, $asm.$.System.Reactive.Linq.QueryLanguage.f6, durationSelector, null, System.Collections.Generic.EqualityComparer$1(TKey).def);
        },
        groupByUntil$7: function (TSource, TKey, TElement, TDuration, source, keySelector, elementSelector, durationSelector, capacity, comparer) {
            return System.Reactive.Linq.QueryLanguage.groupByUntil_(TSource, TKey, TElement, TDuration, source, keySelector, elementSelector, durationSelector, capacity, comparer);
        },
        groupByUntil$6: function (TSource, TKey, TElement, TDuration, source, keySelector, elementSelector, durationSelector, capacity) {
            return System.Reactive.Linq.QueryLanguage.groupByUntil_(TSource, TKey, TElement, TDuration, source, keySelector, elementSelector, durationSelector, capacity, System.Collections.Generic.EqualityComparer$1(TKey).def);
        },
        groupByUntil$3: function (TSource, TKey, TDuration, source, keySelector, durationSelector, capacity, comparer) {
            return System.Reactive.Linq.QueryLanguage.groupByUntil_(TSource, TKey, TSource, TDuration, source, keySelector, $asm.$.System.Reactive.Linq.QueryLanguage.f6, durationSelector, capacity, comparer);
        },
        groupByUntil$2: function (TSource, TKey, TDuration, source, keySelector, durationSelector, capacity) {
            return System.Reactive.Linq.QueryLanguage.groupByUntil_(TSource, TKey, TSource, TDuration, source, keySelector, $asm.$.System.Reactive.Linq.QueryLanguage.f6, durationSelector, capacity, System.Collections.Generic.EqualityComparer$1(TKey).def);
        },
        groupJoin: function (TLeft, TRight, TLeftDuration, TRightDuration, TResult, left, right, leftDurationSelector, rightDurationSelector, resultSelector) {
            return System.Reactive.Linq.QueryLanguage.groupJoin_(TLeft, TRight, TLeftDuration, TRightDuration, TResult, left, right, leftDurationSelector, rightDurationSelector, resultSelector);
        },
        join: function (TLeft, TRight, TLeftDuration, TRightDuration, TResult, left, right, leftDurationSelector, rightDurationSelector, resultSelector) {
            return System.Reactive.Linq.QueryLanguage.join_(TLeft, TRight, TLeftDuration, TRightDuration, TResult, left, right, leftDurationSelector, rightDurationSelector, resultSelector);
        },
        ofType: function (TResult, source) {
            return new (System.Reactive.Linq.ObservableImpl.OfType$2(Object,TResult))(source);
        },
        select: function (TSource, TResult, source, selector) {
            return new (System.Reactive.Linq.ObservableImpl.Select$2(TSource,TResult)).ctor(source, selector);
        },
        select$1: function (TSource, TResult, source, selector) {
            return new (System.Reactive.Linq.ObservableImpl.Select$2(TSource,TResult)).$ctor1(source, selector);
        },
        selectMany$6: function (TSource, TOther, source, other) {
            return System.Reactive.Linq.QueryLanguage.selectMany_(TSource, TOther, source, function (_) {
                return other;
            });
        },
        selectMany$1: function (TSource, TResult, source, selector) {
            return System.Reactive.Linq.QueryLanguage.selectMany_(TSource, TResult, source, selector);
        },
        selectMany$4: function (TSource, TResult, source, selector) {
            return System.Reactive.Linq.QueryLanguage.selectMany_$1(TSource, TResult, source, selector);
        },
        selectMany$8: function (TSource, TCollection, TResult, source, collectionSelector, resultSelector) {
            return System.Reactive.Linq.QueryLanguage.selectMany_$3(TSource, TCollection, TResult, source, collectionSelector, resultSelector);
        },
        selectMany$10: function (TSource, TCollection, TResult, source, collectionSelector, resultSelector) {
            return System.Reactive.Linq.QueryLanguage.selectMany_$5(TSource, TCollection, TResult, source, collectionSelector, resultSelector);
        },
        selectMany$2: function (TSource, TResult, source, onNext, onError, onCompleted) {
            return new (System.Reactive.Linq.ObservableImpl.SelectMany$2(TSource,TResult)).$ctor2(source, onNext, onError, onCompleted);
        },
        selectMany$5: function (TSource, TResult, source, onNext, onError, onCompleted) {
            return new (System.Reactive.Linq.ObservableImpl.SelectMany$2(TSource,TResult)).$ctor5(source, onNext, onError, onCompleted);
        },
        selectMany: function (TSource, TResult, source, selector) {
            return new (System.Reactive.Linq.ObservableImpl.SelectMany$2(TSource,TResult)).ctor(source, selector);
        },
        selectMany$3: function (TSource, TResult, source, selector) {
            return new (System.Reactive.Linq.ObservableImpl.SelectMany$2(TSource,TResult)).$ctor3(source, selector);
        },
        selectMany$7: function (TSource, TCollection, TResult, source, collectionSelector, resultSelector) {
            return System.Reactive.Linq.QueryLanguage.selectMany_$2(TSource, TCollection, TResult, source, collectionSelector, resultSelector);
        },
        selectMany$9: function (TSource, TCollection, TResult, source, collectionSelector, resultSelector) {
            return System.Reactive.Linq.QueryLanguage.selectMany_$4(TSource, TCollection, TResult, source, collectionSelector, resultSelector);
        },
        skip: function (TSource, source, count) {
            var skip = Bridge.as(source, System.Reactive.Linq.ObservableImpl.Skip$1(TSource));
            if (skip != null && skip._scheduler == null) {
                return skip.omega(count);
            }

            return new (System.Reactive.Linq.ObservableImpl.Skip$1(TSource)).ctor(source, count);
        },
        skip$1: function (TSource, source, duration) {
            return System.Reactive.Linq.QueryLanguage.skip_(TSource, source, duration, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        skip$2: function (TSource, source, duration, scheduler) {
            return System.Reactive.Linq.QueryLanguage.skip_(TSource, source, duration, scheduler);
        },
        skipWhile: function (TSource, source, predicate) {
            return new (System.Reactive.Linq.ObservableImpl.SkipWhile$1(TSource)).ctor(source, predicate);
        },
        skipWhile$1: function (TSource, source, predicate) {
            return new (System.Reactive.Linq.ObservableImpl.SkipWhile$1(TSource)).$ctor1(source, predicate);
        },
        take: function (TSource, source, count) {
            if (count === 0) {
                return this.empty(TSource);
            }

            return System.Reactive.Linq.QueryLanguage.take_(TSource, source, count);
        },
        take$1: function (TSource, source, count, scheduler) {
            if (count === 0) {
                return this.empty$1(TSource, scheduler);
            }

            return System.Reactive.Linq.QueryLanguage.take_(TSource, source, count);
        },
        take$2: function (TSource, source, duration) {
            return System.Reactive.Linq.QueryLanguage.take_$1(TSource, source, duration, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        take$3: function (TSource, source, duration, scheduler) {
            return System.Reactive.Linq.QueryLanguage.take_$1(TSource, source, duration, scheduler);
        },
        takeWhile: function (TSource, source, predicate) {
            return new (System.Reactive.Linq.ObservableImpl.TakeWhile$1(TSource)).ctor(source, predicate);
        },
        takeWhile$1: function (TSource, source, predicate) {
            return new (System.Reactive.Linq.ObservableImpl.TakeWhile$1(TSource)).$ctor1(source, predicate);
        },
        where: function (TSource, source, predicate) {
            var where = Bridge.as(source, System.Reactive.Linq.ObservableImpl.Where$1(TSource));
            if (where != null) {
                return where.omega(predicate);
            }

            return new (System.Reactive.Linq.ObservableImpl.Where$1(TSource)).ctor(source, predicate);
        },
        where$1: function (TSource, source, predicate) {
            return new (System.Reactive.Linq.ObservableImpl.Where$1(TSource)).$ctor1(source, predicate);
        },
        delay$2: function (TSource, source, dueTime) {
            return System.Reactive.Linq.QueryLanguage.delay_$1(TSource, source, dueTime, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        delay$3: function (TSource, source, dueTime, scheduler) {
            return System.Reactive.Linq.QueryLanguage.delay_$1(TSource, source, dueTime, scheduler);
        },
        delay: function (TSource, source, dueTime) {
            return System.Reactive.Linq.QueryLanguage.delay_(TSource, source, dueTime.$clone(), System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        delay$1: function (TSource, source, dueTime, scheduler) {
            return System.Reactive.Linq.QueryLanguage.delay_(TSource, source, dueTime.$clone(), scheduler);
        },
        delay$4: function (TSource, TDelay, source, delayDurationSelector) {
            return System.Reactive.Linq.QueryLanguage.delay_$2(TSource, TDelay, source, null, delayDurationSelector);
        },
        delay$5: function (TSource, TDelay, source, subscriptionDelay, delayDurationSelector) {
            return System.Reactive.Linq.QueryLanguage.delay_$2(TSource, TDelay, source, subscriptionDelay, delayDurationSelector);
        },
        delaySubscription$2: function (TSource, source, dueTime) {
            return System.Reactive.Linq.QueryLanguage.delaySubscription_$1(TSource, source, dueTime, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        delaySubscription$3: function (TSource, source, dueTime, scheduler) {
            return System.Reactive.Linq.QueryLanguage.delaySubscription_$1(TSource, source, dueTime, scheduler);
        },
        delaySubscription: function (TSource, source, dueTime) {
            return System.Reactive.Linq.QueryLanguage.delaySubscription_(TSource, source, dueTime.$clone(), System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        delaySubscription$1: function (TSource, source, dueTime, scheduler) {
            return System.Reactive.Linq.QueryLanguage.delaySubscription_(TSource, source, dueTime.$clone(), scheduler);
        },
        interval: function (period) {
            return System.Reactive.Linq.QueryLanguage.timer_$3(period, period, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        interval$1: function (period, scheduler) {
            return System.Reactive.Linq.QueryLanguage.timer_$3(period, period, scheduler);
        },
        sample: function (TSource, source, interval) {
            return System.Reactive.Linq.QueryLanguage.sample_(TSource, source, interval, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        sample$1: function (TSource, source, interval, scheduler) {
            return System.Reactive.Linq.QueryLanguage.sample_(TSource, source, interval, scheduler);
        },
        sample$2: function (TSource, TSample, source, sampler) {
            return System.Reactive.Linq.QueryLanguage.sample_$1(TSource, TSample, source, sampler);
        },
        throttle: function (TSource, source, dueTime) {
            return System.Reactive.Linq.QueryLanguage.throttle_(TSource, source, dueTime, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        throttle$1: function (TSource, source, dueTime, scheduler) {
            return System.Reactive.Linq.QueryLanguage.throttle_(TSource, source, dueTime, scheduler);
        },
        throttle$2: function (TSource, TThrottle, source, throttleDurationSelector) {
            return new (System.Reactive.Linq.ObservableImpl.Throttle$2(TSource,TThrottle))(source, throttleDurationSelector);
        },
        timeInterval: function (TSource, source) {
            return System.Reactive.Linq.QueryLanguage.timeInterval_(TSource, source, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        timeInterval$1: function (TSource, source, scheduler) {
            return System.Reactive.Linq.QueryLanguage.timeInterval_(TSource, source, scheduler);
        },
        timeout$4: function (TSource, source, dueTime) {
            return System.Reactive.Linq.QueryLanguage.timeout_$1(TSource, source, dueTime, System.Reactive.Linq.Observable.throw(TSource, new System.TimeoutException()), System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        timeout$7: function (TSource, source, dueTime, scheduler) {
            return System.Reactive.Linq.QueryLanguage.timeout_$1(TSource, source, dueTime, System.Reactive.Linq.Observable.throw(TSource, new System.TimeoutException()), scheduler);
        },
        timeout$5: function (TSource, source, dueTime, other) {
            return System.Reactive.Linq.QueryLanguage.timeout_$1(TSource, source, dueTime, other, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        timeout$6: function (TSource, source, dueTime, other, scheduler) {
            return System.Reactive.Linq.QueryLanguage.timeout_$1(TSource, source, dueTime, other, scheduler);
        },
        timeout: function (TSource, source, dueTime) {
            return System.Reactive.Linq.QueryLanguage.timeout_(TSource, source, dueTime.$clone(), System.Reactive.Linq.Observable.throw(TSource, new System.TimeoutException()), System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        timeout$3: function (TSource, source, dueTime, scheduler) {
            return System.Reactive.Linq.QueryLanguage.timeout_(TSource, source, dueTime.$clone(), System.Reactive.Linq.Observable.throw(TSource, new System.TimeoutException()), scheduler);
        },
        timeout$1: function (TSource, source, dueTime, other) {
            return System.Reactive.Linq.QueryLanguage.timeout_(TSource, source, dueTime.$clone(), other, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        timeout$2: function (TSource, source, dueTime, other, scheduler) {
            return System.Reactive.Linq.QueryLanguage.timeout_(TSource, source, dueTime.$clone(), other, scheduler);
        },
        timeout$8: function (TSource, TTimeout, source, timeoutDurationSelector) {
            return System.Reactive.Linq.QueryLanguage.timeout_$2(TSource, TTimeout, source, System.Reactive.Linq.Observable.never(TTimeout), timeoutDurationSelector, System.Reactive.Linq.Observable.throw(TSource, new System.TimeoutException()));
        },
        timeout$9: function (TSource, TTimeout, source, timeoutDurationSelector, other) {
            return System.Reactive.Linq.QueryLanguage.timeout_$2(TSource, TTimeout, source, System.Reactive.Linq.Observable.never(TTimeout), timeoutDurationSelector, other);
        },
        timeout$10: function (TSource, TTimeout, source, firstTimeout, timeoutDurationSelector) {
            return System.Reactive.Linq.QueryLanguage.timeout_$2(TSource, TTimeout, source, firstTimeout, timeoutDurationSelector, System.Reactive.Linq.Observable.throw(TSource, new System.TimeoutException()));
        },
        timeout$11: function (TSource, TTimeout, source, firstTimeout, timeoutDurationSelector, other) {
            return System.Reactive.Linq.QueryLanguage.timeout_$2(TSource, TTimeout, source, firstTimeout, timeoutDurationSelector, other);
        },
        timer$4: function (dueTime) {
            return System.Reactive.Linq.QueryLanguage.timer_$2(dueTime, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        timer: function (dueTime) {
            return System.Reactive.Linq.QueryLanguage.timer_(dueTime.$clone(), System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        timer$6: function (dueTime, period) {
            return System.Reactive.Linq.QueryLanguage.timer_$3(dueTime, period, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        timer$2: function (dueTime, period) {
            return System.Reactive.Linq.QueryLanguage.timer_$1(dueTime.$clone(), period, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        timer$5: function (dueTime, scheduler) {
            return System.Reactive.Linq.QueryLanguage.timer_$2(dueTime, scheduler);
        },
        timer$1: function (dueTime, scheduler) {
            return System.Reactive.Linq.QueryLanguage.timer_(dueTime.$clone(), scheduler);
        },
        timer$7: function (dueTime, period, scheduler) {
            return System.Reactive.Linq.QueryLanguage.timer_$3(dueTime, period, scheduler);
        },
        timer$3: function (dueTime, period, scheduler) {
            return System.Reactive.Linq.QueryLanguage.timer_$1(dueTime.$clone(), period, scheduler);
        },
        timestamp: function (TSource, source) {
            return System.Reactive.Linq.QueryLanguage.timestamp_(TSource, source, System.Reactive.Concurrency.SchedulerDefaults.getTimeBasedOperations());
        },
        timestamp$1: function (TSource, source, scheduler) {
            return System.Reactive.Linq.QueryLanguage.timestamp_(TSource, source, scheduler);
        }
    });

    Bridge.ns("System.Reactive.Linq.QueryLanguage", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.QueryLanguage, {
        f1: function (e) {
            return e;
        },
        f2: function (handler) {
            return handler;
        },
        f3: function (sender, args) {
            return new (System.Reactive.EventPattern$1(Object))(sender, args);
        },
        f4: function (h) {
            return h;
        },
        f5: function (h) {
            return function () {
                h(new System.Reactive.Unit());
            };
        },
        f6: function (x) {
            return x;
        },
        f7: function (h, _) {
            h(System.Reactive.Unit.getDefault());
        },
        f8: function (_) {
            return System.Reactive.Linq.Observable.empty(System.Reactive.Unit);
        },
        f9: function (_, $window) {
            return $window;
        }
    });

    Bridge.define("System.Reactive.NopObserver$1", function (T) { return {
        inherits: [System.IObserver$1(T)],
        statics: {
            instance: null,
            config: {
                init: function () {
                    this.instance = new (System.Reactive.NopObserver$1(T))();
                }
            }
        },
        config: {
            alias: [
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"
            ]
        },
        onCompleted: function () {
        },
        onError: function (error) {
        },
        onNext: function (value) {
        }
    }; });

    /**
     * Represents an OnCompleted notification to an observer.
     *
     * @class System.Reactive.Notification$1.OnCompletedNotification
     * @augments System.Reactive.Notification$1
     */
    Bridge.define("System.Reactive.Notification$1.OnCompletedNotification", function (T) { return {
        inherits: [System.Reactive.Notification$1(T)],
        config: {
            alias: [
            "equalsT", "System$IEquatable$1$System$Reactive$Notification$1$" + Bridge.getTypeAlias(T) + "$equalsT"
            ]
        },
        /**
         * Constructs a notification of the end of a sequence.
         *
         * @instance
         * @public
         * @this System.Reactive.Notification$1.OnCompletedNotification
         * @memberof System.Reactive.Notification$1.OnCompletedNotification
         * @return  {void}
         */
        ctor: function () {
            this.$initialize();
            System.Reactive.Notification$1(T).ctor.call(this);
        },
        /**
         * Throws an InvalidOperationException.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnCompletedNotification
         * @memberof System.Reactive.Notification$1.OnCompletedNotification
         * @function getValue
         * @return  {T}
         */
        /**
         * Throws an InvalidOperationException.
         *
         * @instance
         * @function setValue
         */
        getValue: function () {
            throw new System.InvalidOperationException(System.Reactive.Strings_Core.COMPLETED_NO_VALUE);
        },
        /**
         * Returns null.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnCompletedNotification
         * @memberof System.Reactive.Notification$1.OnCompletedNotification
         * @function getException
         * @return  {System.Exception}
         */
        /**
         * Returns null.
         *
         * @instance
         * @function setException
         */
        getException: function () {
            return null;
        },
        /**
         * Returns false.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnCompletedNotification
         * @memberof System.Reactive.Notification$1.OnCompletedNotification
         * @function getHasValue
         * @return  {boolean}
         */
        /**
         * Returns false.
         *
         * @instance
         * @function setHasValue
         */
        getHasValue: function () {
            return false;
        },
        /**
         * Returns NotificationKind.OnCompleted.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnCompletedNotification
         * @memberof System.Reactive.Notification$1.OnCompletedNotification
         * @function getKind
         * @return  {System.Reactive.NotificationKind}
         */
        /**
         * Returns NotificationKind.OnCompleted.
         *
         * @instance
         * @function setKind
         */
        getKind: function () {
            return System.Reactive.NotificationKind.OnCompleted;
        },
        /**
         * Returns the hash code for this instance.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnCompletedNotification
         * @memberof System.Reactive.Notification$1.OnCompletedNotification
         * @return  {number}
         */
        getHashCode: function () {
            return Bridge.getHashCode(T) ^ 8510;
        },
        /**
         * Indicates whether this instance and other are equal.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnCompletedNotification
         * @memberof System.Reactive.Notification$1.OnCompletedNotification
         * @param   {System.Reactive.Notification$1}    other
         * @return  {boolean}
         */
        equalsT: function (other) {
            if (Bridge.referenceEquals(this, other)) {
                return true;
            }
            if (Bridge.referenceEquals(other, null)) {
                return false;
            }
            return other.getKind() === System.Reactive.NotificationKind.OnCompleted;
        },
        /**
         * Returns a string representation of this instance.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnCompletedNotification
         * @memberof System.Reactive.Notification$1.OnCompletedNotification
         * @return  {string}
         */
        toString: function () {
            return "OnCompleted()";
        },
        /**
         * Invokes the observer's method corresponding to the notification.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnCompletedNotification
         * @memberof System.Reactive.Notification$1.OnCompletedNotification
         * @param   {System.IObserver$1}    observer    Observer to invoke the notification on.
         * @return  {void}
         */
        accept$3: function (observer) {
            if (observer == null) {
                throw new System.ArgumentNullException("observer");
            }

            observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
        },
        /**
         * Invokes the observer's method corresponding to the notification and returns the produced result.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnCompletedNotification
         * @memberof System.Reactive.Notification$1.OnCompletedNotification
         * @param   {Function}                       TResult     
         * @param   {System.Reactive.IObserver$2}    observer    Observer to invoke the notification on.
         * @return  {TResult}                                    Result produced by the observation.
         */
        accept: function (TResult, observer) {
            if (observer == null) {
                throw new System.ArgumentNullException("observer");
            }

            return observer["System$Reactive$IObserver$2$" + Bridge.getTypeAlias(T) + "$" + Bridge.getTypeAlias(TResult) + "$onCompleted"]();
        },
        /**
         * Invokes the delegate corresponding to the notification.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnCompletedNotification
         * @memberof System.Reactive.Notification$1.OnCompletedNotification
         * @param   {System.Action}    onNext         Delegate to invoke for an OnNext notification.
         * @param   {System.Action}    onError        Delegate to invoke for an OnError notification.
         * @param   {System.Action}    onCompleted    Delegate to invoke for an OnCompleted notification.
         * @return  {void}
         */
        accept$2: function (onNext, onError, onCompleted) {
            if (Bridge.staticEquals(onNext, null)) {
                throw new System.ArgumentNullException("onNext");
            }
            if (Bridge.staticEquals(onError, null)) {
                throw new System.ArgumentNullException("onError");
            }
            if (Bridge.staticEquals(onCompleted, null)) {
                throw new System.ArgumentNullException("onCompleted");
            }

            onCompleted();
        },
        /**
         * Invokes the delegate corresponding to the notification and returns the produced result.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnCompletedNotification
         * @memberof System.Reactive.Notification$1.OnCompletedNotification
         * @param   {Function}       TResult        
         * @param   {System.Func}    onNext         Delegate to invoke for an OnNext notification.
         * @param   {System.Func}    onError        Delegate to invoke for an OnError notification.
         * @param   {System.Func}    onCompleted    Delegate to invoke for an OnCompleted notification.
         * @return  {TResult}                       Result produced by the observation.
         */
        accept$1: function (TResult, onNext, onError, onCompleted) {
            if (Bridge.staticEquals(onNext, null)) {
                throw new System.ArgumentNullException("onNext");
            }
            if (Bridge.staticEquals(onError, null)) {
                throw new System.ArgumentNullException("onError");
            }
            if (Bridge.staticEquals(onCompleted, null)) {
                throw new System.ArgumentNullException("onCompleted");
            }

            return onCompleted();
        }
    }; });

    /**
     * Represents an OnError notification to an observer.
     *
     * @class System.Reactive.Notification$1.OnErrorNotification
     * @augments System.Reactive.Notification$1
     */
    Bridge.define("System.Reactive.Notification$1.OnErrorNotification", function (T) { return {
        inherits: [System.Reactive.Notification$1(T)],
        exception: null,
        config: {
            alias: [
            "equalsT", "System$IEquatable$1$System$Reactive$Notification$1$" + Bridge.getTypeAlias(T) + "$equalsT"
            ]
        },
        /**
         * Constructs a notification of an exception.
         *
         * @instance
         * @public
         * @this System.Reactive.Notification$1.OnErrorNotification
         * @memberof System.Reactive.Notification$1.OnErrorNotification
         * @param   {System.Exception}    exception
         * @return  {void}
         */
        ctor: function (exception) {
            this.$initialize();
            System.Reactive.Notification$1(T).ctor.call(this);
            this.exception = exception;
        },
        /**
         * Throws the exception.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnErrorNotification
         * @memberof System.Reactive.Notification$1.OnErrorNotification
         * @function getValue
         * @return  {T}
         */
        /**
         * Throws the exception.
         *
         * @instance
         * @function setValue
         */
        getValue: function () {
            System.Reactive.ExceptionHelpers.throw(this.exception);
            return Bridge.getDefaultValue(T);
        },
        /**
         * Returns the exception.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnErrorNotification
         * @memberof System.Reactive.Notification$1.OnErrorNotification
         * @function getException
         * @return  {System.Exception}
         */
        /**
         * Returns the exception.
         *
         * @instance
         * @function setException
         */
        getException: function () {
            return this.exception;
        },
        /**
         * Returns false.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnErrorNotification
         * @memberof System.Reactive.Notification$1.OnErrorNotification
         * @function getHasValue
         * @return  {boolean}
         */
        /**
         * Returns false.
         *
         * @instance
         * @function setHasValue
         */
        getHasValue: function () {
            return false;
        },
        /**
         * Returns NotificationKind.OnError.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnErrorNotification
         * @memberof System.Reactive.Notification$1.OnErrorNotification
         * @function getKind
         * @return  {System.Reactive.NotificationKind}
         */
        /**
         * Returns NotificationKind.OnError.
         *
         * @instance
         * @function setKind
         */
        getKind: function () {
            return System.Reactive.NotificationKind.OnError;
        },
        /**
         * Returns the hash code for this instance.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnErrorNotification
         * @memberof System.Reactive.Notification$1.OnErrorNotification
         * @return  {number}
         */
        getHashCode: function () {
            return Bridge.getHashCode(this.getException());
        },
        /**
         * Indicates whether this instance and other are equal.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnErrorNotification
         * @memberof System.Reactive.Notification$1.OnErrorNotification
         * @param   {System.Reactive.Notification$1}    other
         * @return  {boolean}
         */
        equalsT: function (other) {
            if (Bridge.referenceEquals(this, other)) {
                return true;
            }
            if (Bridge.referenceEquals(other, null)) {
                return false;
            }
            if (other.getKind() !== System.Reactive.NotificationKind.OnError) {
                return false;
            }
            return Bridge.equals(this.getException(), other.getException());
        },
        /**
         * Returns a string representation of this instance.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnErrorNotification
         * @memberof System.Reactive.Notification$1.OnErrorNotification
         * @return  {string}
         */
        toString: function () {
            return System.String.formatProvider(System.Globalization.CultureInfo.getCurrentCulture(), "OnError({0})", Bridge.Reflection.getTypeFullName(Bridge.getType(this.getException())));
        },
        /**
         * Invokes the observer's method corresponding to the notification.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnErrorNotification
         * @memberof System.Reactive.Notification$1.OnErrorNotification
         * @param   {System.IObserver$1}    observer    Observer to invoke the notification on.
         * @return  {void}
         */
        accept$3: function (observer) {
            if (observer == null) {
                throw new System.ArgumentNullException("observer");
            }

            observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](this.getException());
        },
        /**
         * Invokes the observer's method corresponding to the notification and returns the produced result.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnErrorNotification
         * @memberof System.Reactive.Notification$1.OnErrorNotification
         * @param   {Function}                       TResult     
         * @param   {System.Reactive.IObserver$2}    observer    Observer to invoke the notification on.
         * @return  {TResult}                                    Result produced by the observation.
         */
        accept: function (TResult, observer) {
            if (observer == null) {
                throw new System.ArgumentNullException("observer");
            }

            return observer["System$Reactive$IObserver$2$" + Bridge.getTypeAlias(T) + "$" + Bridge.getTypeAlias(TResult) + "$onError"](this.getException());
        },
        /**
         * Invokes the delegate corresponding to the notification.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnErrorNotification
         * @memberof System.Reactive.Notification$1.OnErrorNotification
         * @param   {System.Action}    onNext         Delegate to invoke for an OnNext notification.
         * @param   {System.Action}    onError        Delegate to invoke for an OnError notification.
         * @param   {System.Action}    onCompleted    Delegate to invoke for an OnCompleted notification.
         * @return  {void}
         */
        accept$2: function (onNext, onError, onCompleted) {
            if (Bridge.staticEquals(onNext, null)) {
                throw new System.ArgumentNullException("onNext");
            }
            if (Bridge.staticEquals(onError, null)) {
                throw new System.ArgumentNullException("onError");
            }
            if (Bridge.staticEquals(onCompleted, null)) {
                throw new System.ArgumentNullException("onCompleted");
            }

            onError(this.getException());
        },
        /**
         * Invokes the delegate corresponding to the notification and returns the produced result.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnErrorNotification
         * @memberof System.Reactive.Notification$1.OnErrorNotification
         * @param   {Function}       TResult        
         * @param   {System.Func}    onNext         Delegate to invoke for an OnNext notification.
         * @param   {System.Func}    onError        Delegate to invoke for an OnError notification.
         * @param   {System.Func}    onCompleted    Delegate to invoke for an OnCompleted notification.
         * @return  {TResult}                       Result produced by the observation.
         */
        accept$1: function (TResult, onNext, onError, onCompleted) {
            if (Bridge.staticEquals(onNext, null)) {
                throw new System.ArgumentNullException("onNext");
            }
            if (Bridge.staticEquals(onError, null)) {
                throw new System.ArgumentNullException("onError");
            }
            if (Bridge.staticEquals(onCompleted, null)) {
                throw new System.ArgumentNullException("onCompleted");
            }

            return onError(this.getException());
        }
    }; });

    /**
     * Represents an OnNext notification to an observer.
     *
     * @class System.Reactive.Notification$1.OnNextNotification
     * @augments System.Reactive.Notification$1
     */
    Bridge.define("System.Reactive.Notification$1.OnNextNotification", function (T) { return {
        inherits: [System.Reactive.Notification$1(T)],
        value: Bridge.getDefaultValue(T),
        config: {
            alias: [
            "equalsT", "System$IEquatable$1$System$Reactive$Notification$1$" + Bridge.getTypeAlias(T) + "$equalsT"
            ]
        },
        /**
         * Constructs a notification of a new value.
         *
         * @instance
         * @public
         * @this System.Reactive.Notification$1.OnNextNotification
         * @memberof System.Reactive.Notification$1.OnNextNotification
         * @param   {T}       value
         * @return  {void}
         */
        ctor: function (value) {
            this.$initialize();
            System.Reactive.Notification$1(T).ctor.call(this);
            this.value = value;
        },
        /**
         * Returns the value of an OnNext notification.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnNextNotification
         * @memberof System.Reactive.Notification$1.OnNextNotification
         * @function getValue
         * @return  {T}
         */
        /**
         * Returns the value of an OnNext notification.
         *
         * @instance
         * @function setValue
         */
        getValue: function () {
            return this.value;
        },
        /**
         * Returns null.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnNextNotification
         * @memberof System.Reactive.Notification$1.OnNextNotification
         * @function getException
         * @return  {System.Exception}
         */
        /**
         * Returns null.
         *
         * @instance
         * @function setException
         */
        getException: function () {
            return null;
        },
        /**
         * Returns true.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnNextNotification
         * @memberof System.Reactive.Notification$1.OnNextNotification
         * @function getHasValue
         * @return  {boolean}
         */
        /**
         * Returns true.
         *
         * @instance
         * @function setHasValue
         */
        getHasValue: function () {
            return true;
        },
        /**
         * Returns NotificationKind.OnNext.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnNextNotification
         * @memberof System.Reactive.Notification$1.OnNextNotification
         * @function getKind
         * @return  {System.Reactive.NotificationKind}
         */
        /**
         * Returns NotificationKind.OnNext.
         *
         * @instance
         * @function setKind
         */
        getKind: function () {
            return System.Reactive.NotificationKind.OnNext;
        },
        /**
         * Returns the hash code for this instance.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnNextNotification
         * @memberof System.Reactive.Notification$1.OnNextNotification
         * @return  {number}
         */
        getHashCode: function () {
            return System.Collections.Generic.EqualityComparer$1(T).def.getHashCode2(this.getValue());
        },
        /**
         * Indicates whether this instance and a specified object are equal.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnNextNotification
         * @memberof System.Reactive.Notification$1.OnNextNotification
         * @param   {System.Reactive.Notification$1}    other
         * @return  {boolean}
         */
        equalsT: function (other) {
            if (Bridge.referenceEquals(this, other)) {
                return true;
            }
            if (Bridge.referenceEquals(other, null)) {
                return false;
            }
            if (other.getKind() !== System.Reactive.NotificationKind.OnNext) {
                return false;
            }
            return System.Collections.Generic.EqualityComparer$1(T).def.equals2(this.getValue(), other.getValue());
        },
        /**
         * Returns a string representation of this instance.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnNextNotification
         * @memberof System.Reactive.Notification$1.OnNextNotification
         * @return  {string}
         */
        toString: function () {
            return System.String.formatProvider(System.Globalization.CultureInfo.getCurrentCulture(), "OnNext({0})", this.getValue());
        },
        /**
         * Invokes the observer's method corresponding to the notification.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnNextNotification
         * @memberof System.Reactive.Notification$1.OnNextNotification
         * @param   {System.IObserver$1}    observer    Observer to invoke the notification on.
         * @return  {void}
         */
        accept$3: function (observer) {
            if (observer == null) {
                throw new System.ArgumentNullException("observer");
            }

            observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](this.getValue());
        },
        /**
         * Invokes the observer's method corresponding to the notification and returns the produced result.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnNextNotification
         * @memberof System.Reactive.Notification$1.OnNextNotification
         * @param   {Function}                       TResult     
         * @param   {System.Reactive.IObserver$2}    observer    Observer to invoke the notification on.
         * @return  {TResult}                                    Result produced by the observation.
         */
        accept: function (TResult, observer) {
            if (observer == null) {
                throw new System.ArgumentNullException("observer");
            }

            return observer["System$Reactive$IObserver$2$" + Bridge.getTypeAlias(T) + "$" + Bridge.getTypeAlias(TResult) + "$onNext"](this.getValue());
        },
        /**
         * Invokes the delegate corresponding to the notification.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnNextNotification
         * @memberof System.Reactive.Notification$1.OnNextNotification
         * @param   {System.Action}    onNext         Delegate to invoke for an OnNext notification.
         * @param   {System.Action}    onError        Delegate to invoke for an OnError notification.
         * @param   {System.Action}    onCompleted    Delegate to invoke for an OnCompleted notification.
         * @return  {void}
         */
        accept$2: function (onNext, onError, onCompleted) {
            if (Bridge.staticEquals(onNext, null)) {
                throw new System.ArgumentNullException("onNext");
            }
            if (Bridge.staticEquals(onError, null)) {
                throw new System.ArgumentNullException("onError");
            }
            if (Bridge.staticEquals(onCompleted, null)) {
                throw new System.ArgumentNullException("onCompleted");
            }

            onNext(this.getValue());
        },
        /**
         * Invokes the delegate corresponding to the notification and returns the produced result.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Notification$1.OnNextNotification
         * @memberof System.Reactive.Notification$1.OnNextNotification
         * @param   {Function}       TResult        
         * @param   {System.Func}    onNext         Delegate to invoke for an OnNext notification.
         * @param   {System.Func}    onError        Delegate to invoke for an OnError notification.
         * @param   {System.Func}    onCompleted    Delegate to invoke for an OnCompleted notification.
         * @return  {TResult}                       Result produced by the observation.
         */
        accept$1: function (TResult, onNext, onError, onCompleted) {
            if (Bridge.staticEquals(onNext, null)) {
                throw new System.ArgumentNullException("onNext");
            }
            if (Bridge.staticEquals(onError, null)) {
                throw new System.ArgumentNullException("onError");
            }
            if (Bridge.staticEquals(onCompleted, null)) {
                throw new System.ArgumentNullException("onCompleted");
            }

            return onNext(this.getValue());
        }
    }; });

    Bridge.define("System.Reactive.Observer$1", function (T) { return {
        inherits: [System.IObserver$1(T)],
        _observers: null,
        config: {
            alias: [
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"
            ]
        },
        ctor: function (observers) {
            this.$initialize();
            this._observers = observers;
        },
        onCompleted: function () {
            var $t;
            $t = Bridge.getEnumerator(this._observers.getData());
            while ($t.moveNext()) {
                var observer = $t.getCurrent();
                observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
            }
        },
        onError: function (error) {
            var $t;
            $t = Bridge.getEnumerator(this._observers.getData());
            while ($t.moveNext()) {
                var observer = $t.getCurrent();
                observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](error);
            }
        },
        onNext: function (value) {
            var $t;
            $t = Bridge.getEnumerator(this._observers.getData());
            while ($t.moveNext()) {
                var observer = $t.getCurrent();
                observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](value);
            }
        },
        add: function (observer) {
            return new (System.Reactive.Observer$1(T))(this._observers.add(observer));
        },
        remove: function (observer) {
            var i = System.Array.indexOfT(this._observers.getData(), observer);
            if (i < 0) {
                return this;
            }

            if (this._observers.getData().length === 2) {
                return this._observers.getData()[((1 - i) | 0)];
            } else {
                return new (System.Reactive.Observer$1(T))(this._observers.remove(observer));
            }
        }
    }; });

    Bridge.define("System.Reactive.PlatformServices.DefaultExceptionServices", {
        inherits: [System.Reactive.PlatformServices.IExceptionServices],
        config: {
            alias: [
            "rethrow", "System$Reactive$PlatformServices$IExceptionServices$rethrow"
            ]
        },
        rethrow: function (exception) {
            throw exception;
        }
    });

    Bridge.define("System.Reactive.PlatformServices.DefaultPlatformEnlightenmentProvider", {
        inherits: [System.Reactive.PlatformServices.IPlatformEnlightenmentProvider],
        config: {
            alias: [
            "getService", "System$Reactive$PlatformServices$IPlatformEnlightenmentProvider$getService"
            ]
        },
        getService: function (T, args) {
            return null;
        }
    });

    /**
     * (Infrastructure) Provides access to the local system clock.
     *
     * @public
     * @class System.Reactive.PlatformServices.DefaultSystemClock
     * @implements  System.Reactive.PlatformServices.ISystemClock
     */
    Bridge.define("System.Reactive.PlatformServices.DefaultSystemClock", {
        inherits: [System.Reactive.PlatformServices.ISystemClock],
        config: {
            alias: [
            "getUtcNow", "System$Reactive$PlatformServices$ISystemClock$getUtcNow"
            ]
        },
        /**
         * Gets the current time.
         *
         * @instance
         * @public
         * @this System.Reactive.PlatformServices.DefaultSystemClock
         * @memberof System.Reactive.PlatformServices.DefaultSystemClock
         * @function getUtcNow
         * @return  {System.DateTimeOffset}
         */
        /**
         * Gets the current time.
         *
         * @instance
         * @function setUtcNow
         */
        getUtcNow: function () {
            return System.DateTimeOffset.getUtcNow().$clone();
        }
    });

    /**
     * (Infrastructure) Monitors for system clock changes based on a periodic timer.
     *
     * @public
     * @class System.Reactive.PlatformServices.PeriodicTimerSystemClockMonitor
     * @implements  System.Reactive.PlatformServices.INotifySystemClockChanged
     */
    Bridge.define("System.Reactive.PlatformServices.PeriodicTimerSystemClockMonitor", {
        inherits: [System.Reactive.PlatformServices.INotifySystemClockChanged],
        statics: {
            SYNC_MAXRETRIES: 100,
            SYNC_MAXDELTA: 10,
            MAXERROR: 100
        },
        _timer: null,
        _systemClockChanged: null,
        config: {
            alias: [
            "addSystemClockChanged", "System$Reactive$PlatformServices$INotifySystemClockChanged$addSystemClockChanged",
            "removeSystemClockChanged", "System$Reactive$PlatformServices$INotifySystemClockChanged$removeSystemClockChanged"
            ],
            init: function () {
                this._period = new System.TimeSpan();
                this._lastTime = new System.DateTimeOffset();
            }
        },
        /**
         * Creates a new monitor for system clock changes with the specified polling frequency.
         *
         * @instance
         * @public
         * @this System.Reactive.PlatformServices.PeriodicTimerSystemClockMonitor
         * @memberof System.Reactive.PlatformServices.PeriodicTimerSystemClockMonitor
         * @param   {System.TimeSpan}    period    Polling frequency for system clock changes.
         * @return  {void}
         */
        ctor: function (period) {
            this.$initialize();
            this._period = period;
            this._timer = new System.Reactive.Disposables.SerialDisposable();
        },
        /**
         * Event that gets raised when a system clock change is detected.
         *
         * @instance
         * @public
         * @memberof System.Reactive.PlatformServices.PeriodicTimerSystemClockMonitor
         * @event System.Reactive.PlatformServices.PeriodicTimerSystemClockMonitor#SystemClockChanged
         * @return  {System.EventHandler}
         */
        addSystemClockChanged: function (value) {
            this.newTimer();

            this._systemClockChanged = Bridge.fn.combine(this._systemClockChanged, value);
        },
        /**
         * Event that gets raised when a system clock change is detected.
         *
         * @instance
         * @public
         * @memberof System.Reactive.PlatformServices.PeriodicTimerSystemClockMonitor
         * @event System.Reactive.PlatformServices.PeriodicTimerSystemClockMonitor#SystemClockChanged
         * @return  {System.EventHandler}
         */
        removeSystemClockChanged: function (value) {
            this._systemClockChanged = Bridge.fn.remove(this._systemClockChanged, value);

            this._timer.setDisposable(System.Reactive.Disposables.Disposable.getEmpty());
        },
        newTimer: function () {
            this._timer.setDisposable(System.Reactive.Disposables.Disposable.getEmpty());

            var n = 0;
            do {
                this._lastTime = System.Reactive.PlatformServices.SystemClock.getUtcNow().$clone();
                this._timer.setDisposable(System.Reactive.Concurrency.ConcurrencyAbstractionLayer.getCurrent().System$Reactive$Concurrency$IConcurrencyAbstractionLayer$startPeriodicTimer(Bridge.fn.bind(this, this.timeChanged), this._period));
            } while (Math.abs((System.DateTimeOffset.op_Subtraction$1(System.Reactive.PlatformServices.SystemClock.getUtcNow(), this._lastTime)).getTotalMilliseconds()) > System.Reactive.PlatformServices.PeriodicTimerSystemClockMonitor.SYNC_MAXDELTA && ((n = (n + 1) | 0)) < System.Reactive.PlatformServices.PeriodicTimerSystemClockMonitor.SYNC_MAXRETRIES);

            if (n >= System.Reactive.PlatformServices.PeriodicTimerSystemClockMonitor.SYNC_MAXRETRIES) {
                throw new System.InvalidOperationException(System.Reactive.Strings_Core.FAILED_CLOCK_MONITORING);
            }
        },
        timeChanged: function () {
            var now = System.Reactive.PlatformServices.SystemClock.getUtcNow().$clone();
            var diff = System.DateTimeOffset.op_Subtraction$1(now, (System.DateTimeOffset.op_Addition(this._lastTime, this._period)));
            if (Math.abs(diff.getTotalMilliseconds()) >= System.Reactive.PlatformServices.PeriodicTimerSystemClockMonitor.MAXERROR) {
                var scc = this._systemClockChanged;
                if (!Bridge.staticEquals(scc, null)) {
                    scc(this, new System.Reactive.PlatformServices.SystemClockChangedEventArgs.$ctor1(System.DateTimeOffset.op_Addition(this._lastTime, this._period), now.$clone()));
                }

                this.newTimer();
            } else {
                this._lastTime = System.Reactive.PlatformServices.SystemClock.getUtcNow().$clone();
            }
        }
    });

    Bridge.define("System.Reactive.PushPullAdapter$2", function (T, R) { return {
        inherits: [System.IObserver$1(T),System.Collections.Generic.IEnumerator$1(R)],
        yield: null,
        dispose$1: null,
        moveNext$1: null,
        current: null,
        done: false,
        disposed: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted",
            "getCurrent", "System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(R) + "$getCurrent$1",
            "dispose", "System$IDisposable$dispose",
            "moveNext", "System$Collections$IEnumerator$moveNext",
            "reset", "System$Collections$IEnumerator$reset"
            ]
        },
        ctor: function ($yield, moveNext, dispose) {
            this.$initialize();
            this.yield = $yield;
            this.moveNext$1 = moveNext;
            this.dispose$1 = dispose;
        },
        getCurrent: function () {
            return this.current.getValue();
        },
        System$Collections$IEnumerator$getCurrent: function () {
            return this.getCurrent();
        },
        onNext: function (value) {
            this.yield(System.Reactive.Notification.createOnNext(T, value));
        },
        onError: function (exception) {
            this.yield(System.Reactive.Notification.createOnError(T, exception));
            this.dispose$1();
        },
        onCompleted: function () {
            this.yield(System.Reactive.Notification.createOnCompleted(T));
            this.dispose$1();
        },
        dispose: function () {
            this.disposed = true;
            this.dispose$1();
        },
        moveNext: function () {
            if (this.disposed) {
                throw new System.ObjectDisposedException("");
            }

            if (!this.done) {
                this.current = this.moveNext$1();
                this.done = this.current.getKind() !== System.Reactive.NotificationKind.OnNext;
            }

            System.Reactive.ExceptionHelpers.throwIfNotNull(this.current.getException());

            return this.current.getHasValue();
        },
        reset: function () {
            throw new System.NotSupportedException();
        }
    }; });

    Bridge.define("System.Reactive.SafeObserver$1", function (TSource) { return {
        inherits: [System.IObserver$1(TSource)],
        statics: {
            create: function (observer, disposable) {
                var a = Bridge.as(observer, System.Reactive.AnonymousObserver$1(TSource));
                if (a != null) {
                    return a.makeSafe(disposable);
                } else {
                    return new (System.Reactive.SafeObserver$1(TSource))(observer, disposable);
                }
            }
        },
        _observer: null,
        _disposable: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, disposable) {
            this.$initialize();
            this._observer = observer;
            this._disposable = disposable;
        },
        onNext: function (value) {
            var __noError = false;
            try {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
                __noError = true;
            }
            finally {
                if (!__noError) {
                    this._disposable.System$IDisposable$dispose();
                }
            }
        },
        onError: function (error) {
            try {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            }
            finally {
                this._disposable.System$IDisposable$dispose();
            }
        },
        onCompleted: function () {
            try {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            }
            finally {
                this._disposable.System$IDisposable$dispose();
            }
        }
    }; });

    Bridge.define("System.Reactive.Sink$1.Impl", function (TSource) { return {
        inherits: [System.IObserver$1(TSource)],
        _forward: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (forward) {
            this.$initialize();
            this._forward = forward;
        },
        onNext: function (value) {
            this._forward._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._forward._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            this._forward.dispose();
        },
        onCompleted: function () {
            this._forward._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            this._forward.dispose();
        }
    }; });

    /**
     * Represents an object that is both an observable sequence as well as an observer.
     *
     * @abstract
     * @public
     * @class System.Reactive.Subjects.ISubject$2
     * @implements  System.IObserver$1
     * @implements  System.IObservable$1
     * @param   {Function}    [name]    The type of the elements received by the subject.
     This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see Covariance and Contravariance in Generics.
     * @param   {Function}    [name]    The type of the elements produced by the subject.
     This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see Covariance and Contravariance in Generics.
     */
    Bridge.definei("System.Reactive.Subjects.ISubject$2", function (TSource, TResult) { return {
        inherits: [System.IObserver$1(TSource),System.IObservable$1(TResult)],
        $kind: "interface",
        $variance: [2,1]
    }; });

    Bridge.define("System.Reactive.Subjects.AsyncSubject$1.AwaitObserver", function (T) { return {
        inherits: [System.IObserver$1(T)],
        _callback: null,
        config: {
            alias: [
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"
            ]
        },
        ctor: function (callback, originalContext) {
            this.$initialize();

            this._callback = callback;
        },
        onCompleted: function () {
            this.invokeOnOriginalContext();
        },
        onError: function (error) {
            this.invokeOnOriginalContext();
        },
        onNext: function (value) {
        },
        invokeOnOriginalContext: function () {
            {
                this._callback();
            }
        }
    }; });

    /**
     * Represents an observable wrapper that can be connected and disconnected from its underlying observable sequence.
     *
     * @abstract
     * @public
     * @class System.Reactive.Subjects.IConnectableObservable$1
     * @implements  System.IObservable$1
     * @param   {Function}    [name]    The type of the elements in the sequence.
     This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see Covariance and Contravariance in Generics.
     */
    Bridge.definei("System.Reactive.Subjects.IConnectableObservable$1", function (T) { return {
        inherits: [System.IObservable$1(T)],
        $kind: "interface",
        $variance: [1]
    }; });

    /**
     * This class is a hack to facilitate Bridge.net compatibility, use at your own risk
     *
     * @class System.Threading.AutoResetEvent
     * @augments System.Threading.ManualResetEvent
     */
    Bridge.define("System.Threading.AutoResetEvent", {
        inherits: [System.Threading.ManualResetEvent],
        ctor: function (initial) {
            this.$initialize();
            System.Threading.ManualResetEvent.ctor.call(this, initial);
        },
        reset: function () {
            this._state = false;
        }
    });

    /**
     * Class to create an IObservable&lt;T&gt; instance from a delegate-based implementation of the Subscribe method.
     *
     * @public
     * @class System.Reactive.AnonymousObservable$1
     * @augments System.Reactive.ObservableBase$1
     * @param   {Function}    [name]    The type of the elements in the sequence.
     */
    Bridge.define("System.Reactive.AnonymousObservable$1", function (T) { return {
        inherits: [System.Reactive.ObservableBase$1(T)],
        _subscribe: null,
        /**
         * Creates an observable sequence object from the specified subscription function.
         *
         * @instance
         * @public
         * @this System.Reactive.AnonymousObservable$1
         * @memberof System.Reactive.AnonymousObservable$1
         * @throws <b /> is null.
         * @param   {System.Func}    subscribe    Subscribe method implementation.
         * @return  {void}
         */
        ctor: function (subscribe) {
            this.$initialize();
            System.Reactive.ObservableBase$1(T).ctor.call(this);
            if (Bridge.staticEquals(subscribe, null)) {
                throw new System.ArgumentNullException("subscribe");
            }

            this._subscribe = subscribe;
        },
        /**
         * Calls the subscription function that was supplied to the constructor.
         *
         * @instance
         * @protected
         * @override
         * @this System.Reactive.AnonymousObservable$1
         * @memberof System.Reactive.AnonymousObservable$1
         * @param   {System.IObserver$1}    observer    Observer to send notifications to.
         * @return  {System.IDisposable}                Disposable object representing an observer's subscription to the observable sequence.
         */
        subscribeCore: function (observer) {
            return this._subscribe(observer) || System.Reactive.Disposables.Disposable.getEmpty();
        }
    }; });

    /**
     * Class to create an IObserver&lt;T&gt; instance from delegate-based implementations of the On* methods.
     *
     * @public
     * @class System.Reactive.AnonymousObserver$1
     * @augments System.Reactive.ObserverBase$1
     * @param   {Function}    [name]    The type of the elements in the sequence.
     */
    Bridge.define("System.Reactive.AnonymousObserver$1", function (T) { return {
        inherits: [System.Reactive.ObserverBase$1(T)],
        _onNext: null,
        _onError: null,
        _onCompleted: null,
        /**
         * Creates an observer from the specified OnNext, OnError, and OnCompleted actions.
         *
         * @instance
         * @public
         * @this System.Reactive.AnonymousObserver$1
         * @memberof System.Reactive.AnonymousObserver$1
         * @throws <b /> or <b /> or <b /> is null.
         * @param   {System.Action}    onNext         Observer's OnNext action implementation.
         * @param   {System.Action}    onError        Observer's OnError action implementation.
         * @param   {System.Action}    onCompleted    Observer's OnCompleted action implementation.
         * @return  {void}
         */
        $ctor3: function (onNext, onError, onCompleted) {
            this.$initialize();
            System.Reactive.ObserverBase$1(T).ctor.call(this);
            if (Bridge.staticEquals(onNext, null)) {
                throw new System.ArgumentNullException("onNext");
            }
            if (Bridge.staticEquals(onError, null)) {
                throw new System.ArgumentNullException("onError");
            }
            if (Bridge.staticEquals(onCompleted, null)) {
                throw new System.ArgumentNullException("onCompleted");
            }

            this._onNext = onNext;
            this._onError = onError;
            this._onCompleted = onCompleted;
        },
        /**
         * Creates an observer from the specified OnNext action.
         *
         * @instance
         * @public
         * @this System.Reactive.AnonymousObserver$1
         * @memberof System.Reactive.AnonymousObserver$1
         * @throws <b /> is null.
         * @param   {System.Action}    onNext    Observer's OnNext action implementation.
         * @return  {void}
         */
        ctor: function (onNext) {
            System.Reactive.AnonymousObserver$1(T).$ctor3.call(this, onNext, System.Reactive.Stubs.throw, System.Reactive.Stubs.nop);
        },
        /**
         * Creates an observer from the specified OnNext and OnError actions.
         *
         * @instance
         * @public
         * @this System.Reactive.AnonymousObserver$1
         * @memberof System.Reactive.AnonymousObserver$1
         * @throws <b /> or <b /> is null.
         * @param   {System.Action}    onNext     Observer's OnNext action implementation.
         * @param   {System.Action}    onError    Observer's OnError action implementation.
         * @return  {void}
         */
        $ctor2: function (onNext, onError) {
            System.Reactive.AnonymousObserver$1(T).$ctor3.call(this, onNext, onError, System.Reactive.Stubs.nop);
        },
        /**
         * Creates an observer from the specified OnNext and OnCompleted actions.
         *
         * @instance
         * @public
         * @this System.Reactive.AnonymousObserver$1
         * @memberof System.Reactive.AnonymousObserver$1
         * @throws <b /> or <b /> is null.
         * @param   {System.Action}    onNext         Observer's OnNext action implementation.
         * @param   {System.Action}    onCompleted    Observer's OnCompleted action implementation.
         * @return  {void}
         */
        $ctor1: function (onNext, onCompleted) {
            System.Reactive.AnonymousObserver$1(T).$ctor3.call(this, onNext, System.Reactive.Stubs.throw, onCompleted);
        },
        /**
         * Calls the onNext action.
         *
         * @instance
         * @protected
         * @override
         * @this System.Reactive.AnonymousObserver$1
         * @memberof System.Reactive.AnonymousObserver$1
         * @param   {T}       value    Next element in the sequence.
         * @return  {void}
         */
        onNextCore: function (value) {
            this._onNext(value);
        },
        /**
         * Calls the onError action.
         *
         * @instance
         * @protected
         * @override
         * @this System.Reactive.AnonymousObserver$1
         * @memberof System.Reactive.AnonymousObserver$1
         * @param   {System.Exception}    error    The error that has occurred.
         * @return  {void}
         */
        onErrorCore: function (error) {
            this._onError(error);
        },
        /**
         * Calls the onCompleted action.
         *
         * @instance
         * @protected
         * @override
         * @this System.Reactive.AnonymousObserver$1
         * @memberof System.Reactive.AnonymousObserver$1
         * @return  {void}
         */
        onCompletedCore: function () {
            this._onCompleted();
        },
        makeSafe: function (disposable) {
            return new (System.Reactive.AnonymousSafeObserver$1(T))(this._onNext, this._onError, this._onCompleted, disposable);
        }
    }; });

    Bridge.define("System.Reactive.AsyncLockObserver$1", function (T) { return {
        inherits: [System.Reactive.ObserverBase$1(T)],
        _gate: null,
        _observer: null,
        ctor: function (observer, gate) {
            this.$initialize();
            System.Reactive.ObserverBase$1(T).ctor.call(this);
            this._gate = gate;
            this._observer = observer;
        },
        onNextCore: function (value) {
            this._gate.wait(Bridge.fn.bind(this, function () {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](value);
            }));
        },
        onErrorCore: function (exception) {
            this._gate.wait(Bridge.fn.bind(this, function () {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](exception);
            }));
        },
        onCompletedCore: function () {
            this._gate.wait(Bridge.fn.bind(this, function () {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
            }));
        }
    }; });

    Bridge.define("System.Reactive.AutoDetachObserver$1", function (T) { return {
        inherits: [System.Reactive.ObserverBase$1(T)],
        observer: null,
        m: null,
        config: {
            init: function () {
                this.m = new System.Reactive.Disposables.SingleAssignmentDisposable();
            }
        },
        ctor: function (observer) {
            this.$initialize();
            System.Reactive.ObserverBase$1(T).ctor.call(this);
            this.observer = observer;
        },
        setDisposable: function (value) {
            this.m.setDisposable(value);
        },
        onNextCore: function (value) {
            //
            // Safeguarding of the pipeline against rogue observers is required for proper
            // resource cleanup. Consider the following example:
            //
            //   var xs  = Observable.Interval(TimeSpan.FromSeconds(1));
            //   var ys  = <some random sequence>;
            //   var res = xs.CombineLatest(ys, (x, y) => x + y);
            //
            // The marble diagram of the query above looks as follows:
            //
            //   xs  -----0-----1-----2-----3-----4-----5-----6-----7-----8-----9---...
            //                  |     |     |     |     |     |     |     |     |
            //   ys  --------4--+--5--+-----+--2--+--1--+-----+-----+--0--+-----+---...
            //               |  |  |  |     |  |  |  |  |     |     |  |  |     |
            //               v  v  v  v     v  v  v  v  v     v     v  v  v     v
            //   res --------4--5--6--7-----8--5--6--5--6-----7-----8--7--8-----9---...
            //                                 |
            //                                @#&
            //
            // Notice the free-threaded nature of Rx, where messages on the resulting sequence
            // are produced by either of the two input sequences to CombineLatest.
            //
            // Now assume an exception happens in the OnNext callback for the observer of res,
            // at the indicated point marked with @#& above. The callback runs in the context
            // of ys, so the exception will take down the scheduler thread of ys. This by
            // itself is a problem (that can be mitigated by a Catch operator on IScheduler),
            // but notice how the timer that produces xs is kept alive.
            //
            // The safe-guarding code below ensures the acquired resources are disposed when
            // the user callback throws.
            //
            var __noError = false;
            try {
                this.observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](value);
                __noError = true;
            }
            finally {
                if (!__noError) {
                    this.dispose();
                }
            }
        },
        onErrorCore: function (exception) {
            try {
                this.observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](exception);
            }
            finally {
                this.dispose();
            }
        },
        onCompletedCore: function () {
            try {
                this.observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
            }
            finally {
                this.dispose();
            }
        },
        dispose$1: function (disposing) {
            System.Reactive.ObserverBase$1(T).prototype.dispose$1.call(this, disposing);

            if (disposing) {
                this.m.dispose();
            }
        }
    }; });

    Bridge.define("System.Reactive.ConcatSink$1", function (TSource) { return {
        inherits: [System.Reactive.TailRecursiveSink$1(TSource)],
        config: {
            alias: [
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.TailRecursiveSink$1(TSource).ctor.call(this, observer, cancel);
        },
        extract: function (source) {
            var concat = Bridge.as(source, System.Reactive.IConcatenatable$1(TSource));
            if (concat != null) {
                return concat["System$Reactive$IConcatenatable$1$" + Bridge.getTypeAlias(TSource) + "$getSources"]();
            }

            return null;
        },
        onCompleted: function () {
            this._recurse();
        }
    }; });

    Bridge.define("System.Reactive.Concurrency.CatchScheduler$1", function (TException) { return {
        inherits: [System.Reactive.Concurrency.SchedulerWrapper],
        _handler: null,
        ctor: function (scheduler, handler) {
            this.$initialize();
            System.Reactive.Concurrency.SchedulerWrapper.ctor.call(this, scheduler);
            this._handler = handler;
        },
        wrap: function (TState, action) {
            return Bridge.fn.bind(this, function (self, state) {
                try {
                    return action(this.getRecursiveWrapper(self), state);
                }
                catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    var exception;
                    if (Bridge.is($e1, TException)) {
                        exception = $e1;
                        if (!this._handler(exception)) {
                            throw $e1;
                        }

                        return System.Reactive.Disposables.Disposable.getEmpty();
                    } else {
                        throw $e1;
                    }
                }
            });
        },
        clone: function (scheduler) {
            return new (System.Reactive.Concurrency.CatchScheduler$1(TException))(scheduler, this._handler);
        },
        tryGetService: function (provider, serviceType, service) {
            service.v = provider.System$Reactive$IServiceProvider$getService(serviceType);

            if (service.v != null) {
                if (Bridge.referenceEquals(serviceType, System.Reactive.Concurrency.ISchedulerLongRunning)) {
                    service.v = new (System.Reactive.Concurrency.CatchScheduler$1.CatchSchedulerLongRunning(TException))(Bridge.cast(service.v, System.Reactive.Concurrency.ISchedulerLongRunning), this._handler);
                } else {
                    if (Bridge.referenceEquals(serviceType, System.Reactive.Concurrency.ISchedulerPeriodic)) {
                        service.v = new (System.Reactive.Concurrency.CatchScheduler$1.CatchSchedulerPeriodic(TException))(Bridge.cast(service.v, System.Reactive.Concurrency.ISchedulerPeriodic), this._handler);
                    }
                }
            }

            return true;
        }
    }; });

    Bridge.define("System.Reactive.Concurrency.CurrentThreadScheduler", {
        inherits: [System.Reactive.Concurrency.LocalScheduler],
        statics: {
            s_instance: null,
            config: {
                init: function () {
                    this.s_instance = new (System.Lazy$1(System.Reactive.Concurrency.CurrentThreadScheduler)).ctor($asm.$.System.Reactive.Concurrency.CurrentThreadScheduler.f1);
                }
            },
            getInstance: function () {
                return System.Reactive.Concurrency.CurrentThreadScheduler.s_instance.getValue();
            },
            getIsScheduleRequired: function () {
                return false;
            }
        },
        config: {
            alias: [
            "schedule$2", "System$Reactive$Concurrency$IScheduler$schedule$2"
            ]
        },
        ctor: function () {
            this.$initialize();
            System.Reactive.Concurrency.LocalScheduler.ctor.call(this);
        },
        schedule$2: function (TState, state, dueTime, action) {
            return System.Reactive.Concurrency.ImmediateScheduler.getInstance().schedule$2(TState, state, dueTime, action);
        }
    });

    Bridge.ns("System.Reactive.Concurrency.CurrentThreadScheduler", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Concurrency.CurrentThreadScheduler, {
        f1: function () {
            return new System.Reactive.Concurrency.CurrentThreadScheduler();
        }
    });

    /**
     * Represents an object that schedules units of work on the platform's default scheduler.
     *
     * @public
     * @class System.Reactive.Concurrency.DefaultScheduler
     * @augments System.Reactive.Concurrency.LocalScheduler
     * @implements  System.Reactive.Concurrency.ISchedulerPeriodic
     * @see {@link Scheduler.Default}
     */
    Bridge.define("System.Reactive.Concurrency.DefaultScheduler", {
        inherits: [System.Reactive.Concurrency.LocalScheduler,System.Reactive.Concurrency.ISchedulerPeriodic],
        statics: {
            s_instance: null,
            s_cal: null,
            config: {
                init: function () {
                    this.s_instance = new (System.Lazy$1(System.Reactive.Concurrency.DefaultScheduler)).ctor($asm.$.System.Reactive.Concurrency.DefaultScheduler.f1);
                    this.s_cal = System.Reactive.Concurrency.ConcurrencyAbstractionLayer.getCurrent();
                }
            },
            /**
             * Gets the singleton instance of the default scheduler.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.DefaultScheduler
             * @memberof System.Reactive.Concurrency.DefaultScheduler
             * @function getInstance
             * @return  {System.Reactive.Concurrency.DefaultScheduler}
             */
            /**
             * Gets the singleton instance of the default scheduler.
             *
             * @instance
             * @function setInstance
             */
            getInstance: function () {
                return System.Reactive.Concurrency.DefaultScheduler.s_instance.getValue();
            }
        },
        config: {
            alias: [
            "schedule", "System$Reactive$Concurrency$IScheduler$schedule",
            "schedule$2", "System$Reactive$Concurrency$IScheduler$schedule$2",
            "schedulePeriodic", "System$Reactive$Concurrency$ISchedulerPeriodic$schedulePeriodic"
            ]
        },
        ctor: function () {
            this.$initialize();
            System.Reactive.Concurrency.LocalScheduler.ctor.call(this);
        },
        /**
         * Schedules an action to be executed.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Concurrency.DefaultScheduler
         * @memberof System.Reactive.Concurrency.DefaultScheduler
         * @throws <b /> is null.
         * @param   {Function}              TState    The type of the state passed to the scheduled action.
         * @param   {TState}                state     State passed to the action to be executed.
         * @param   {System.Func}           action    Action to be executed.
         * @return  {System.IDisposable}              The disposable object used to cancel the scheduled action (best effort).
         */
        schedule: function (TState, state, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            var d = new System.Reactive.Disposables.SingleAssignmentDisposable();

            var cancel = System.Reactive.Concurrency.DefaultScheduler.s_cal.System$Reactive$Concurrency$IConcurrencyAbstractionLayer$queueUserWorkItem(Bridge.fn.bind(this, function (_) {
                if (!d.getIsDisposed()) {
                    d.setDisposable(action(this, state));
                }
            }), null);

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(d, cancel);
        },
        /**
         * Schedules an action to be executed after dueTime, using a System.Threading.Timer object.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Concurrency.DefaultScheduler
         * @memberof System.Reactive.Concurrency.DefaultScheduler
         * @throws <b /> is null.
         * @param   {Function}              TState     The type of the state passed to the scheduled action.
         * @param   {TState}                state      State passed to the action to be executed.
         * @param   {System.TimeSpan}       dueTime    Relative time after which to execute the action.
         * @param   {System.Func}           action     Action to be executed.
         * @return  {System.IDisposable}               The disposable object used to cancel the scheduled action (best effort).
         */
        schedule$2: function (TState, state, dueTime, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            var dt = System.Reactive.Concurrency.Scheduler.normalize(dueTime);
            if (dt.getTicks().equals(System.Int64(0))) {
                return this.schedule(TState, state, action);
            }

            var d = new System.Reactive.Disposables.SingleAssignmentDisposable();

            var cancel = System.Reactive.Concurrency.DefaultScheduler.s_cal.System$Reactive$Concurrency$IConcurrencyAbstractionLayer$startTimer(Bridge.fn.bind(this, function (_) {
                if (!d.getIsDisposed()) {
                    d.setDisposable(action(this, state));
                }
            }), null, dt);

            return System.Reactive.Disposables.StableCompositeDisposable.create$1(d, cancel);
        },
        /**
         * Schedules a periodic piece of work, using a System.Threading.Timer object.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.DefaultScheduler
         * @memberof System.Reactive.Concurrency.DefaultScheduler
         * @throws <b /> is less than TimeSpan.Zero.
         * @throws <b /> is null.
         * @param   {Function}              TState    The type of the state passed to the scheduled action.
         * @param   {TState}                state     Initial state passed to the action upon the first iteration.
         * @param   {System.TimeSpan}       period    Period for running the work periodically.
         * @param   {System.Func}           action    Action to be executed, potentially updating the state.
         * @return  {System.IDisposable}              The disposable object used to cancel the scheduled recurring action (best effort).
         */
        schedulePeriodic: function (TState, state, period, action) {
            if (System.TimeSpan.lt(period, System.TimeSpan.zero)) {
                throw new System.ArgumentOutOfRangeException("period");
            }
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            var state1 = state;
            var gate = new System.Reactive.Concurrency.AsyncLock();

            var cancel = System.Reactive.Concurrency.DefaultScheduler.s_cal.System$Reactive$Concurrency$IConcurrencyAbstractionLayer$startPeriodicTimer(function () {
                gate.wait(function () {
                    state1 = action(state1);
                });
            }, period);

            return System.Reactive.Disposables.Disposable.create(function () {
                cancel.System$IDisposable$dispose();
                gate.dispose();
                action = System.Reactive.Stubs$1(TState).i;
            });
        },
        /**
         * Discovers scheduler services by interface type.
         *
         * @instance
         * @protected
         * @override
         * @this System.Reactive.Concurrency.DefaultScheduler
         * @memberof System.Reactive.Concurrency.DefaultScheduler
         * @param   {Function}    serviceType    Scheduler service interface type to discover.
         * @return  {Object}                     Object implementing the requested service, if available; null otherwise.
         */
        getService: function (serviceType) {
            if (Bridge.referenceEquals(serviceType, System.Reactive.Concurrency.ISchedulerLongRunning)) {
                if (System.Reactive.Concurrency.DefaultScheduler.s_cal.System$Reactive$Concurrency$IConcurrencyAbstractionLayer$getSupportsLongRunning()) {
                    return System.Reactive.Concurrency.DefaultScheduler.LongRunning.instance;
                }
            }

            return System.Reactive.Concurrency.LocalScheduler.prototype.getService.call(this, serviceType);
        }
    });

    Bridge.ns("System.Reactive.Concurrency.DefaultScheduler", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Concurrency.DefaultScheduler, {
        f1: function () {
            return new System.Reactive.Concurrency.DefaultScheduler();
        }
    });

    Bridge.define("System.Reactive.Concurrency.DisableOptimizationsScheduler", {
        inherits: [System.Reactive.Concurrency.SchedulerWrapper],
        _optimizationInterfaces: null,
        ctor: function (scheduler) {
            this.$initialize();
            System.Reactive.Concurrency.SchedulerWrapper.ctor.call(this, scheduler);
            this._optimizationInterfaces = System.Reactive.Concurrency.Scheduler.OPTIMIZATIONS;
        },
        $ctor1: function (scheduler, optimizationInterfaces) {
            this.$initialize();
            System.Reactive.Concurrency.SchedulerWrapper.ctor.call(this, scheduler);
            this._optimizationInterfaces = optimizationInterfaces;
        },
        clone: function (scheduler) {
            return new System.Reactive.Concurrency.DisableOptimizationsScheduler.$ctor1(scheduler, this._optimizationInterfaces);
        },
        tryGetService: function (provider, serviceType, service) {
            service.v = null;
            return System.Array.contains(this._optimizationInterfaces, serviceType, Function);
        }
    });

    /**
     * Base class for historical schedulers, which are virtual time schedulers that use DateTimeOffset for absolute time and TimeSpan for relative time.
     *
     * @abstract
     * @public
     * @class System.Reactive.Concurrency.HistoricalSchedulerBase
     * @augments System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
     */
    Bridge.define("System.Reactive.Concurrency.HistoricalSchedulerBase", {
        inherits: [System.Reactive.Concurrency.VirtualTimeSchedulerBase$2(System.DateTimeOffset,System.TimeSpan)],
        /**
         * Creates a new historical scheduler with the minimum value of DateTimeOffset as the initial clock value.
         *
         * @instance
         * @protected
         * @this System.Reactive.Concurrency.HistoricalSchedulerBase
         * @memberof System.Reactive.Concurrency.HistoricalSchedulerBase
         * @return  {void}
         */
        ctor: function () {
            this.$initialize();
            System.Reactive.Concurrency.VirtualTimeSchedulerBase$2(System.DateTimeOffset,System.TimeSpan).$ctor1.call(this, System.DateTimeOffset.minValue.$clone(), new (System.Collections.Generic.Comparer$1(System.DateTimeOffset))(System.Collections.Generic.Comparer$1.$default.fn));
        },
        /**
         * Creates a new historical scheduler with the specified initial clock value.
         *
         * @instance
         * @protected
         * @this System.Reactive.Concurrency.HistoricalSchedulerBase
         * @memberof System.Reactive.Concurrency.HistoricalSchedulerBase
         * @param   {System.DateTimeOffset}    initialClock    Initial clock value.
         * @return  {void}
         */
        $ctor1: function (initialClock) {
            this.$initialize();
            System.Reactive.Concurrency.VirtualTimeSchedulerBase$2(System.DateTimeOffset,System.TimeSpan).$ctor1.call(this, initialClock, new (System.Collections.Generic.Comparer$1(System.DateTimeOffset))(System.Collections.Generic.Comparer$1.$default.fn));
        },
        /**
         * Creates a new historical scheduler with the specified initial clock value and absolute time comparer.
         *
         * @instance
         * @protected
         * @this System.Reactive.Concurrency.HistoricalSchedulerBase
         * @memberof System.Reactive.Concurrency.HistoricalSchedulerBase
         * @param   {System.DateTimeOffset}                     initialClock    Initial value for the clock.
         * @param   {System.Collections.Generic.IComparer$1}    comparer        Comparer to determine causality of events based on absolute time.
         * @return  {void}
         */
        $ctor2: function (initialClock, comparer) {
            this.$initialize();
            System.Reactive.Concurrency.VirtualTimeSchedulerBase$2(System.DateTimeOffset,System.TimeSpan).$ctor1.call(this, initialClock, comparer);
        },
        /**
         * Adds a relative time value to an absolute time value.
         *
         * @instance
         * @protected
         * @override
         * @this System.Reactive.Concurrency.HistoricalSchedulerBase
         * @memberof System.Reactive.Concurrency.HistoricalSchedulerBase
         * @param   {System.DateTimeOffset}    absolute    Absolute time value.
         * @param   {System.TimeSpan}          relative    Relative time value to add.
         * @return  {System.DateTimeOffset}                The resulting absolute time sum value.
         */
        add: function (absolute, relative) {
            return absolute.add(relative);
        },
        /**
         * Converts the absolute time value to a DateTimeOffset value.
         *
         * @instance
         * @protected
         * @override
         * @this System.Reactive.Concurrency.HistoricalSchedulerBase
         * @memberof System.Reactive.Concurrency.HistoricalSchedulerBase
         * @param   {System.DateTimeOffset}    absolute    Absolute time value to convert.
         * @return  {System.DateTimeOffset}                The corresponding DateTimeOffset value.
         */
        toDateTimeOffset: function (absolute) {
            return absolute.$clone();
        },
        /**
         * Converts the TimeSpan value to a relative time value.
         *
         * @instance
         * @protected
         * @override
         * @this System.Reactive.Concurrency.HistoricalSchedulerBase
         * @memberof System.Reactive.Concurrency.HistoricalSchedulerBase
         * @param   {System.TimeSpan}    timeSpan    TimeSpan value to convert.
         * @return  {System.TimeSpan}                The corresponding relative time value.
         */
        toRelative: function (timeSpan) {
            return timeSpan;
        }
    });

    /**
     * Represents an object that schedules units of work to run immediately on the current thread.
     *
     * @public
     * @class System.Reactive.Concurrency.ImmediateScheduler
     * @augments System.Reactive.Concurrency.LocalScheduler
     * @see {@link Scheduler.Immediate}
     */
    Bridge.define("System.Reactive.Concurrency.ImmediateScheduler", {
        inherits: [System.Reactive.Concurrency.LocalScheduler],
        statics: {
            s_instance: null,
            config: {
                init: function () {
                    this.s_instance = new (System.Lazy$1(System.Reactive.Concurrency.ImmediateScheduler)).ctor($asm.$.System.Reactive.Concurrency.ImmediateScheduler.f1);
                }
            },
            /**
             * Gets the singleton instance of the immediate scheduler.
             *
             * @static
             * @public
             * @this System.Reactive.Concurrency.ImmediateScheduler
             * @memberof System.Reactive.Concurrency.ImmediateScheduler
             * @function getInstance
             * @return  {System.Reactive.Concurrency.ImmediateScheduler}
             */
            /**
             * Gets the singleton instance of the immediate scheduler.
             *
             * @instance
             * @function setInstance
             */
            getInstance: function () {
                return System.Reactive.Concurrency.ImmediateScheduler.s_instance.getValue();
            }
        },
        config: {
            alias: [
            "schedule", "System$Reactive$Concurrency$IScheduler$schedule",
            "schedule$2", "System$Reactive$Concurrency$IScheduler$schedule$2"
            ]
        },
        ctor: function () {
            this.$initialize();
            System.Reactive.Concurrency.LocalScheduler.ctor.call(this);
        },
        /**
         * Schedules an action to be executed.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Concurrency.ImmediateScheduler
         * @memberof System.Reactive.Concurrency.ImmediateScheduler
         * @throws <b /> is null.
         * @param   {Function}              TState    The type of the state passed to the scheduled action.
         * @param   {TState}                state     State passed to the action to be executed.
         * @param   {System.Func}           action    Action to be executed.
         * @return  {System.IDisposable}              The disposable object used to cancel the scheduled action (best effort).
         */
        schedule: function (TState, state, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            return action(new System.Reactive.Concurrency.ImmediateScheduler.AsyncLockScheduler(), state);
        },
        /**
         * Schedules an action to be executed after dueTime.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Concurrency.ImmediateScheduler
         * @memberof System.Reactive.Concurrency.ImmediateScheduler
         * @throws <b /> is null.
         * @param   {Function}              TState     The type of the state passed to the scheduled action.
         * @param   {TState}                state      State passed to the action to be executed.
         * @param   {System.TimeSpan}       dueTime    Relative time after which to execute the action.
         * @param   {System.Func}           action     Action to be executed.
         * @return  {System.IDisposable}               The disposable object used to cancel the scheduled action (best effort).
         */
        schedule$2: function (TState, state, dueTime, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            var dt = System.Reactive.Concurrency.Scheduler.normalize(dueTime);
            if (dt.getTicks().gt(System.Int64(0))) {
                System.Reactive.Concurrency.ConcurrencyAbstractionLayer.getCurrent().System$Reactive$Concurrency$IConcurrencyAbstractionLayer$sleep(dt);
            }

            return action(new System.Reactive.Concurrency.ImmediateScheduler.AsyncLockScheduler(), state);
        }
    });

    Bridge.ns("System.Reactive.Concurrency.ImmediateScheduler", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Concurrency.ImmediateScheduler, {
        f1: function () {
            return new System.Reactive.Concurrency.ImmediateScheduler();
        }
    });

    Bridge.define("System.Reactive.Concurrency.ImmediateScheduler.AsyncLockScheduler", {
        inherits: [System.Reactive.Concurrency.LocalScheduler],
        asyncLock: null,
        config: {
            alias: [
            "schedule", "System$Reactive$Concurrency$IScheduler$schedule",
            "schedule$2", "System$Reactive$Concurrency$IScheduler$schedule$2"
            ]
        },
        schedule: function (TState, state, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            var m = new System.Reactive.Disposables.SingleAssignmentDisposable();

            if (this.asyncLock == null) {
                this.asyncLock = new System.Reactive.Concurrency.AsyncLock();
            }

            this.asyncLock.wait(Bridge.fn.bind(this, function () {
                if (!m.getIsDisposed()) {
                    m.setDisposable(action(this, state));
                }
            }));

            return m;
        },
        schedule$2: function (TState, state, dueTime, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            if (dueTime.getTicks().lte(System.Int64(0))) {
                return this.schedule(TState, state, action);
            }

            var timer = System.Reactive.Concurrency.ConcurrencyAbstractionLayer.getCurrent().System$Reactive$Concurrency$IConcurrencyAbstractionLayer$startStopwatch();

            var m = new System.Reactive.Disposables.SingleAssignmentDisposable();

            if (this.asyncLock == null) {
                this.asyncLock = new System.Reactive.Concurrency.AsyncLock();
            }

            this.asyncLock.wait(Bridge.fn.bind(this, function () {
                if (!m.getIsDisposed()) {
                    var sleep = System.TimeSpan.sub(dueTime, timer.System$Reactive$Concurrency$IStopwatch$getElapsed());
                    if (sleep.getTicks().gt(System.Int64(0))) {
                        System.Reactive.Concurrency.ConcurrencyAbstractionLayer.getCurrent().System$Reactive$Concurrency$IConcurrencyAbstractionLayer$sleep(sleep);
                    }
                    if (!m.getIsDisposed()) {
                        m.setDisposable(action(this, state));
                    }
                }
            }));

            return m;
        }
    });

    /**
     * Base class for implementation of query operators, providing performance benefits over the use of Observable.Create.
     *
     * @abstract
     * @class System.Reactive.Producer$1
     * @implements  System.Reactive.IProducer$1
     * @param   {Function}    [name]    Type of the resulting sequence's elements.
     */
    Bridge.define("System.Reactive.Producer$1", function (TSource) { return {
        inherits: [System.Reactive.IProducer$1(TSource)],
        config: {
            alias: [
            "subscribe", "System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$subscribe",
            "subscribeRaw", "System$Reactive$IProducer$1$" + Bridge.getTypeAlias(TSource) + "$subscribeRaw"
            ]
        },
        /**
         * Publicly visible Subscribe method.
         *
         * @instance
         * @public
         * @this System.Reactive.Producer$1
         * @memberof System.Reactive.Producer$1
         * @param   {System.IObserver$1}    observer    Observer to send notifications on. The implementation of a producer must ensure the correct message grammar on the observer.
         * @return  {System.IDisposable}                IDisposable to cancel the subscription. This causes the underlying sink to be notified of unsubscription, causing it to prevent further messages from being sent to the observer.
         */
        subscribe: function (observer) {
            if (observer == null) {
                throw new System.ArgumentNullException("observer");
            }

            return this.subscribeRaw(observer, true);
        },
        subscribeRaw: function (observer, enableSafeguard) {
            var state = new (System.Reactive.Producer$1.State(TSource))();
            state.observer = observer;
            state.sink = new System.Reactive.Disposables.SingleAssignmentDisposable();
            state.subscription = new System.Reactive.Disposables.SingleAssignmentDisposable();

            var d = System.Reactive.Disposables.StableCompositeDisposable.create$1(state.sink, state.subscription);

            //
            // See AutoDetachObserver.cs for more information on the safeguarding requirement and
            // its implementation aspects.
            //
            if (enableSafeguard) {
                state.observer = System.Reactive.SafeObserver$1(TSource).create(state.observer, d);
            }

            if (System.Reactive.Concurrency.CurrentThreadScheduler.getIsScheduleRequired()) {
                System.Reactive.Concurrency.CurrentThreadScheduler.getInstance().schedule(System.Reactive.Producer$1.State(TSource), state.$clone(), Bridge.fn.bind(this, this.run$1));
            } else {
                state.subscription.setDisposable(this.run(state.observer, state.subscription, Bridge.fn.bind(state, state.assign)));
            }

            return d;
        },
        run$1: function (_, x) {
            x.subscription.setDisposable(this.run(x.observer, x.subscription, Bridge.fn.bind(x, x.assign)));
            return System.Reactive.Disposables.Disposable.getEmpty();
        }
    }; });

    /**
     * Represents a scheduled work item based on the materialization of an IScheduler.Schedule method call.
     *
     * @public
     * @class System.Reactive.Concurrency.ScheduledItem$2
     * @augments System.Reactive.Concurrency.ScheduledItem$1
     * @param   {Function}    [name]    Absolute time representation type.
     * @param   {Function}    [name]    Type of the state passed to the scheduled action.
     */
    Bridge.define("System.Reactive.Concurrency.ScheduledItem$2", function (TAbsolute, TValue) { return {
        inherits: [System.Reactive.Concurrency.ScheduledItem$1(TAbsolute)],
        _scheduler: null,
        _state: Bridge.getDefaultValue(TValue),
        _action: null,
        /**
         * Creates a materialized work item.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.ScheduledItem$2
         * @memberof System.Reactive.Concurrency.ScheduledItem$2
         * @throws <b /> or <b /> or <b /> is null.
         * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Recursive scheduler to invoke the scheduled action with.
         * @param   {TValue}                                    state        State to pass to the scheduled action.
         * @param   {System.Func}                               action       Scheduled action.
         * @param   {TAbsolute}                                 dueTime      Time at which to run the scheduled action.
         * @param   {System.Collections.Generic.IComparer$1}    comparer     Comparer used to compare work items based on their scheduled time.
         * @return  {void}
         */
        $ctor1: function (scheduler, state, action, dueTime, comparer) {
            this.$initialize();
            System.Reactive.Concurrency.ScheduledItem$1(TAbsolute).ctor.call(this, dueTime, comparer);
            if (scheduler == null) {
                throw new System.ArgumentNullException("scheduler");
            }
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            this._scheduler = scheduler;
            this._state = state;
            this._action = action;
        },
        /**
         * Creates a materialized work item.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.ScheduledItem$2
         * @memberof System.Reactive.Concurrency.ScheduledItem$2
         * @throws <b /> or <b /> is null.
         * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Recursive scheduler to invoke the scheduled action with.
         * @param   {TValue}                                    state        State to pass to the scheduled action.
         * @param   {System.Func}                               action       Scheduled action.
         * @param   {TAbsolute}                                 dueTime      Time at which to run the scheduled action.
         * @return  {void}
         */
        ctor: function (scheduler, state, action, dueTime) {
            System.Reactive.Concurrency.ScheduledItem$2(TAbsolute,TValue).$ctor1.call(this, scheduler, state, action, dueTime, new (System.Collections.Generic.Comparer$1(TAbsolute))(System.Collections.Generic.Comparer$1.$default.fn));
        },
        /**
         * Invokes the scheduled action with the supplied recursive scheduler and state.
         *
         * @instance
         * @protected
         * @override
         * @this System.Reactive.Concurrency.ScheduledItem$2
         * @memberof System.Reactive.Concurrency.ScheduledItem$2
         * @return  {System.IDisposable}        Cancellation resource returned by the scheduled action.
         */
        invokeCore: function () {
            return this._action(this._scheduler, this._state);
        }
    }; });

    /**
     * Base class for virtual time schedulers using a priority queue for scheduled items.
     *
     * @abstract
     * @public
     * @class System.Reactive.Concurrency.VirtualTimeScheduler$2
     * @augments System.Reactive.Concurrency.VirtualTimeSchedulerBase$2
     * @param   {Function}    [name]    Absolute time representation type.
     * @param   {Function}    [name]    Relative time representation type.
     */
    Bridge.define("System.Reactive.Concurrency.VirtualTimeScheduler$2", function (TAbsolute, TRelative) { return {
        inherits: [System.Reactive.Concurrency.VirtualTimeSchedulerBase$2(TAbsolute,TRelative)],
        queue: null,
        config: {
            init: function () {
                this.queue = new (System.Reactive.Concurrency.SchedulerQueue$1(TAbsolute)).ctor();
            }
        },
        /**
         * Creates a new virtual time scheduler with the default value of TAbsolute as the initial clock value.
         *
         * @instance
         * @protected
         * @this System.Reactive.Concurrency.VirtualTimeScheduler$2
         * @memberof System.Reactive.Concurrency.VirtualTimeScheduler$2
         * @return  {void}
         */
        ctor: function () {
            this.$initialize();
            System.Reactive.Concurrency.VirtualTimeSchedulerBase$2(TAbsolute,TRelative).ctor.call(this);
        },
        /**
         * Creates a new virtual time scheduler.
         *
         * @instance
         * @protected
         * @this System.Reactive.Concurrency.VirtualTimeScheduler$2
         * @memberof System.Reactive.Concurrency.VirtualTimeScheduler$2
         * @throws <b /> is null.
         * @param   {TAbsolute}                                 initialClock    Initial value for the clock.
         * @param   {System.Collections.Generic.IComparer$1}    comparer        Comparer to determine causality of events based on absolute time.
         * @return  {void}
         */
        $ctor1: function (initialClock, comparer) {
            this.$initialize();
            System.Reactive.Concurrency.VirtualTimeSchedulerBase$2(TAbsolute,TRelative).$ctor1.call(this, initialClock, comparer);
        },
        /**
         * Gets the next scheduled item to be executed.
         *
         * @instance
         * @protected
         * @override
         * @this System.Reactive.Concurrency.VirtualTimeScheduler$2
         * @memberof System.Reactive.Concurrency.VirtualTimeScheduler$2
         * @return  {System.Reactive.Concurrency.IScheduledItem$1}        The next scheduled item.
         */
        getNext: function () {
            this.queue;
            {
                while (this.queue.getCount() > 0) {
                    var next = this.queue.peek();
                    if (next.getIsCanceled()) {
                        this.queue.dequeue();
                    } else {
                        return next;
                    }
                }
            }

            return null;
        },
        /**
         * Schedules an action to be executed at dueTime.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Concurrency.VirtualTimeScheduler$2
         * @memberof System.Reactive.Concurrency.VirtualTimeScheduler$2
         * @throws <b /> is null.
         * @param   {Function}              TState     The type of the state passed to the scheduled action.
         * @param   {TState}                state      State passed to the action to be executed.
         * @param   {TAbsolute}             dueTime    Absolute time at which to execute the action.
         * @param   {System.Func}           action     Action to be executed.
         * @return  {System.IDisposable}               The disposable object used to cancel the scheduled action (best effort).
         */
        scheduleAbsolute: function (TState, state, dueTime, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            var si = null;

            var run = Bridge.fn.bind(this, function (scheduler, state1) {
                this.queue;
                {
                    this.queue.remove(si);
                }

                return action(scheduler, state1);
            });

            si = new (System.Reactive.Concurrency.ScheduledItem$2(TAbsolute,TState)).$ctor1(this, state, run, dueTime, this.getComparer());

            this.queue;
            {
                this.queue.enqueue(si);
            }

            return System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(si, si.cancel));
        }
    }; });

    Bridge.define("System.Reactive.Disposables.StableCompositeDisposable.Binary", {
        inherits: [System.Reactive.Disposables.StableCompositeDisposable],
        _disposable1: null,
        _disposable2: null,
        config: {
            alias: [
            "getIsDisposed", "System$Reactive$Disposables$ICancelable$getIsDisposed",
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function (disposable1, disposable2) {
            this.$initialize();
            System.Reactive.Disposables.StableCompositeDisposable.ctor.call(this);
            this._disposable1 = disposable1;
            this._disposable2 = disposable2;
        },
        getIsDisposed: function () {
            return this._disposable1 == null;
        },
        dispose: function () {
            var old1 = System.Interlocked.exchange(System.IDisposable, Bridge.ref(this, "_disposable1"), null);
            if (old1 != null) {
                old1.System$IDisposable$dispose();
            }

            var old2 = System.Interlocked.exchange(System.IDisposable, Bridge.ref(this, "_disposable2"), null);
            if (old2 != null) {
                old2.System$IDisposable$dispose();
            }
        }
    });

    Bridge.define("System.Reactive.Disposables.StableCompositeDisposable.NAry", {
        inherits: [System.Reactive.Disposables.StableCompositeDisposable],
        _disposables: null,
        config: {
            alias: [
            "getIsDisposed", "System$Reactive$Disposables$ICancelable$getIsDisposed",
            "dispose", "System$IDisposable$dispose"
            ]
        },
        $ctor1: function (disposables) {
            System.Reactive.Disposables.StableCompositeDisposable.NAry.ctor.call(this, Bridge.cast(disposables, System.Collections.Generic.IEnumerable$1(System.IDisposable)));
        },
        ctor: function (disposables) {
            this.$initialize();
            System.Reactive.Disposables.StableCompositeDisposable.ctor.call(this);
            this._disposables = new (System.Collections.Generic.List$1(System.IDisposable))(disposables);

            //
            // Doing this on the list to avoid duplicate enumeration of disposables.
            //
            if (this._disposables.contains(null)) {
                throw new System.ArgumentException(System.Reactive.Strings_Core.DISPOSABLES_CANT_CONTAIN_NULL, "disposables");
            }
        },
        getIsDisposed: function () {
            return this._disposables == null;
        },
        dispose: function () {
            var $t;
            var old = System.Interlocked.exchange(System.Collections.Generic.List$1(System.IDisposable), Bridge.ref(this, "_disposables"), null);
            if (old != null) {
                $t = Bridge.getEnumerator(old);
                while ($t.moveNext()) {
                    var d = $t.getCurrent();
                    d.System$IDisposable$dispose();
                }
            }
        }
    });

    /**
     * Represents a .NET event invocation consisting of the weakly typed object that raised the event and the data that was generated by the event.
     *
     * @public
     * @class System.Reactive.EventPattern$1
     * @augments System.Reactive.EventPattern$2
     * @param   {Function}    [name]    The type of the event data generated by the event.
     */
    Bridge.define("System.Reactive.EventPattern$1", function (TEventArgs) { return {
        inherits: [System.Reactive.EventPattern$2(Object,TEventArgs)],
        /**
         * Creates a new data representation instance of a .NET event invocation with the given sender and event data.
         *
         * @instance
         * @public
         * @this System.Reactive.EventPattern$1
         * @memberof System.Reactive.EventPattern$1
         * @param   {Object}        sender    The sender object that raised the event.
         * @param   {TEventArgs}    e         The event data that was generated by the event.
         * @return  {void}
         */
        ctor: function (sender, e) {
            this.$initialize();
            System.Reactive.EventPattern$2(Object,TEventArgs).ctor.call(this, sender, e);
        }
    }; });

    Bridge.define("System.Reactive.Joins.JoinObserver$1", function (T) { return {
        inherits: [System.Reactive.ObserverBase$1(System.Reactive.Notification$1(T)),System.Reactive.Joins.IJoinObserver],
        gate: null,
        source: null,
        onError$1: null,
        activePlans: null,
        subscription: null,
        isDisposed: false,
        config: {
            properties: {
                Queue: null
            },
            alias: [
            "subscribe", "System$Reactive$Joins$IJoinObserver$subscribe",
            "dequeue", "System$Reactive$Joins$IJoinObserver$dequeue",
            "dispose", "System$IDisposable$dispose"
            ]
        },
        ctor: function (source, onError) {
            this.$initialize();
            System.Reactive.ObserverBase$1(System.Reactive.Notification$1(T)).ctor.call(this);
            this.source = source;
            this.onError$1 = onError;
            this.setQueue(new (System.Collections.Generic.Queue$1(System.Reactive.Notification$1(T))).ctor());
            this.subscription = new System.Reactive.Disposables.SingleAssignmentDisposable();
            this.activePlans = new (System.Collections.Generic.List$1(System.Reactive.Joins.ActivePlan))();
        },
        addActivePlan: function (activePlan) {
            this.activePlans.add(activePlan);
        },
        subscribe: function (gate) {
            this.gate = gate;
            this.subscription.setDisposable(System.ObservableExtensions.subscribeSafe(System.Reactive.Notification$1(T), System.Reactive.Linq.Observable.materialize(T, this.source), this));
        },
        dequeue: function () {
            this.getQueue().dequeue();
        },
        onNextCore: function (notification) {
            var $t;
            this.gate;
            {
                if (!this.isDisposed) {
                    if (notification.getKind() === System.Reactive.NotificationKind.OnError) {
                        this.onError$1(notification.getException());
                        return;
                    }

                    this.getQueue().enqueue(notification);
                    $t = Bridge.getEnumerator(this.activePlans.toArray());
                    while ($t.moveNext()) {
                        var activePlan = $t.getCurrent();
                        activePlan.match();
                    }
                }
            }
        },
        onErrorCore: function (exception) {
        },
        onCompletedCore: function () {
        },
        removeActivePlan: function (activePlan) {
            this.activePlans.remove(activePlan);
            if (this.activePlans.getCount() === 0) {
                this.dispose();
            }
        },
        dispose$1: function (disposing) {
            System.Reactive.ObserverBase$1(System.Reactive.Notification$1(T)).prototype.dispose$1.call(this, disposing);

            if (!this.isDisposed) {
                if (disposing) {
                    this.subscription.dispose();
                }

                this.isDisposed = true;
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.GroupedObservable$2", function (TKey, TElement) { return {
        inherits: [System.Reactive.ObservableBase$1(TElement),System.Reactive.Linq.IGroupedObservable$2(TKey,TElement)],
        _key: Bridge.getDefaultValue(TKey),
        _subject: null,
        _refCount: null,
        config: {
            alias: [
            "getKey", "System$Reactive$Linq$IGroupedObservable$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TElement) + "$getKey",
            "subscribe", "System$IObservable$1$" + Bridge.getTypeAlias(TElement) + "$subscribe"
            ]
        },
        $ctor1: function (key, subject, refCount) {
            this.$initialize();
            System.Reactive.ObservableBase$1(TElement).ctor.call(this);
            this._key = key;
            this._subject = subject;
            this._refCount = refCount;
        },
        ctor: function (key, subject) {
            this.$initialize();
            System.Reactive.ObservableBase$1(TElement).ctor.call(this);
            this._key = key;
            this._subject = subject;
        },
        getKey: function () {
            return this._key;
        },
        subscribeCore: function (observer) {
            if (this._refCount != null) {
                //
                // [OK] Use of unsafe Subscribe: called on a known subject implementation.
                //
                var release = this._refCount.getDisposable();
                var subscription = this._subject["System$IObservable$1$" + Bridge.getTypeAlias(TElement) + "$subscribe"](observer);
                return System.Reactive.Disposables.StableCompositeDisposable.create$1(release, subscription);
            } else {
                //
                // [OK] Use of unsafe Subscribe: called on a known subject implementation.
                //
                return this._subject["System$IObservable$1$" + Bridge.getTypeAlias(TElement) + "$subscribe"](observer);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Catch$1._", function (TSource) { return {
        inherits: [System.Reactive.TailRecursiveSink$1(TSource)],
        _lastException: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.TailRecursiveSink$1(TSource).ctor.call(this, observer, cancel);
        },
        extract: function (source) {
            var $catch = Bridge.as(source, System.Reactive.Linq.ObservableImpl.Catch$1(TSource));
            if ($catch != null) {
                return $catch._sources;
            }

            return null;
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._lastException = error;
            this._recurse();
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            System.Reactive.TailRecursiveSink$1(TSource).prototype.dispose.call(this);
        },
        done: function () {
            if (this._lastException != null) {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](this._lastException);
            } else {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"]();
            }

            System.Reactive.TailRecursiveSink$1(TSource).prototype.dispose.call(this);
        },
        fail: function (error) {
            //
            // Note that the invocation of _recurse in OnError will
            // cause the next MoveNext operation to be enqueued, so
            // we will still return to the caller immediately.
            //
            this.onError(error);
            return true;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Collect$2._", function (TSource, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.PushToPullSink$2(TSource,TResult)],
        _parent: null,
        _gate: null,
        _collector: Bridge.getDefaultValue(TResult),
        _hasFailed: false,
        _error: null,
        _hasCompleted: false,
        _done$1: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, subscription) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.PushToPullSink$2(TSource,TResult).ctor.call(this, subscription);
            this._parent = parent;
        },
        initialize: function () {
            this._gate = {  };
            this._collector = this._parent._getInitialCollector();
        },
        onNext: function (value) {
            this._gate;
            {
                try {
                    this._collector = this._parent._merge(this._collector, value);
                }
                catch (ex) {
                    ex = System.Exception.create(ex);
                    this._error = ex;
                    this._hasFailed = true;

                    this.dispose();
                }
            }
        },
        onError: function (error) {
            this.dispose();

            this._gate;
            {
                this._error = error;
                this._hasFailed = true;
            }
        },
        onCompleted: function () {
            this.dispose();

            this._gate;
            {
                this._hasCompleted = true;
            }
        },
        tryMoveNext: function (current) {
            this._gate;
            {
                if (this._hasFailed) {
                    current.v = Bridge.getDefaultValue(TResult);
                    System.Reactive.ExceptionHelpers.throw(this._error);
                } else {
                    if (this._hasCompleted) {
                        if (this._done$1) {
                            current.v = Bridge.getDefaultValue(TResult);
                            return false;
                        }

                        current.v = this._collector;
                        this._done$1 = true;
                    } else {
                        current.v = this._collector;

                        try {
                            this._collector = this._parent._getNewCollector(current.v);
                        }
                        catch ($e1) {
                            $e1 = System.Exception.create($e1);
                            this.dispose();
                            throw $e1;
                        }
                    }
                }

                return true;
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$10._", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        _observer9: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult).ctor.call(this, 9, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var subscriptions = System.Array.init(9, null);
            for (var i = 0; i < 9; i = (i + 1) | 0) {
                subscriptions[i] = new System.Reactive.Disposables.SingleAssignmentDisposable();
            }

            this._observer1 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T1))(this._gate, this, 0, subscriptions[0]);
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T2))(this._gate, this, 1, subscriptions[1]);
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T3))(this._gate, this, 2, subscriptions[2]);
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T4))(this._gate, this, 3, subscriptions[3]);
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T5))(this._gate, this, 4, subscriptions[4]);
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T6))(this._gate, this, 5, subscriptions[5]);
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T7))(this._gate, this, 6, subscriptions[6]);
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T8))(this._gate, this, 7, subscriptions[7]);
            this._observer9 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T9))(this._gate, this, 8, subscriptions[8]);

            subscriptions[0].setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            subscriptions[1].setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            subscriptions[2].setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            subscriptions[3].setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            subscriptions[4].setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            subscriptions[5].setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            subscriptions[6].setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            subscriptions[7].setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));
            subscriptions[8].setDisposable(System.ObservableExtensions.subscribeSafe(T9, this._parent._source9, this._observer9));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(subscriptions);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValue(), this._observer2.getValue(), this._observer3.getValue(), this._observer4.getValue(), this._observer5.getValue(), this._observer6.getValue(), this._observer7.getValue(), this._observer8.getValue(), this._observer9.getValue());
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$11._", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        _observer9: null,
        _observer10: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult).ctor.call(this, 10, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var subscriptions = System.Array.init(10, null);
            for (var i = 0; i < 10; i = (i + 1) | 0) {
                subscriptions[i] = new System.Reactive.Disposables.SingleAssignmentDisposable();
            }

            this._observer1 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T1))(this._gate, this, 0, subscriptions[0]);
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T2))(this._gate, this, 1, subscriptions[1]);
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T3))(this._gate, this, 2, subscriptions[2]);
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T4))(this._gate, this, 3, subscriptions[3]);
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T5))(this._gate, this, 4, subscriptions[4]);
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T6))(this._gate, this, 5, subscriptions[5]);
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T7))(this._gate, this, 6, subscriptions[6]);
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T8))(this._gate, this, 7, subscriptions[7]);
            this._observer9 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T9))(this._gate, this, 8, subscriptions[8]);
            this._observer10 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T10))(this._gate, this, 9, subscriptions[9]);

            subscriptions[0].setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            subscriptions[1].setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            subscriptions[2].setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            subscriptions[3].setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            subscriptions[4].setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            subscriptions[5].setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            subscriptions[6].setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            subscriptions[7].setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));
            subscriptions[8].setDisposable(System.ObservableExtensions.subscribeSafe(T9, this._parent._source9, this._observer9));
            subscriptions[9].setDisposable(System.ObservableExtensions.subscribeSafe(T10, this._parent._source10, this._observer10));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(subscriptions);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValue(), this._observer2.getValue(), this._observer3.getValue(), this._observer4.getValue(), this._observer5.getValue(), this._observer6.getValue(), this._observer7.getValue(), this._observer8.getValue(), this._observer9.getValue(), this._observer10.getValue());
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$12._", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        _observer9: null,
        _observer10: null,
        _observer11: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult).ctor.call(this, 11, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var subscriptions = System.Array.init(11, null);
            for (var i = 0; i < 11; i = (i + 1) | 0) {
                subscriptions[i] = new System.Reactive.Disposables.SingleAssignmentDisposable();
            }

            this._observer1 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T1))(this._gate, this, 0, subscriptions[0]);
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T2))(this._gate, this, 1, subscriptions[1]);
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T3))(this._gate, this, 2, subscriptions[2]);
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T4))(this._gate, this, 3, subscriptions[3]);
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T5))(this._gate, this, 4, subscriptions[4]);
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T6))(this._gate, this, 5, subscriptions[5]);
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T7))(this._gate, this, 6, subscriptions[6]);
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T8))(this._gate, this, 7, subscriptions[7]);
            this._observer9 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T9))(this._gate, this, 8, subscriptions[8]);
            this._observer10 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T10))(this._gate, this, 9, subscriptions[9]);
            this._observer11 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T11))(this._gate, this, 10, subscriptions[10]);

            subscriptions[0].setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            subscriptions[1].setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            subscriptions[2].setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            subscriptions[3].setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            subscriptions[4].setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            subscriptions[5].setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            subscriptions[6].setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            subscriptions[7].setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));
            subscriptions[8].setDisposable(System.ObservableExtensions.subscribeSafe(T9, this._parent._source9, this._observer9));
            subscriptions[9].setDisposable(System.ObservableExtensions.subscribeSafe(T10, this._parent._source10, this._observer10));
            subscriptions[10].setDisposable(System.ObservableExtensions.subscribeSafe(T11, this._parent._source11, this._observer11));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(subscriptions);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValue(), this._observer2.getValue(), this._observer3.getValue(), this._observer4.getValue(), this._observer5.getValue(), this._observer6.getValue(), this._observer7.getValue(), this._observer8.getValue(), this._observer9.getValue(), this._observer10.getValue(), this._observer11.getValue());
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$13._", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        _observer9: null,
        _observer10: null,
        _observer11: null,
        _observer12: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult).ctor.call(this, 12, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var subscriptions = System.Array.init(12, null);
            for (var i = 0; i < 12; i = (i + 1) | 0) {
                subscriptions[i] = new System.Reactive.Disposables.SingleAssignmentDisposable();
            }

            this._observer1 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T1))(this._gate, this, 0, subscriptions[0]);
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T2))(this._gate, this, 1, subscriptions[1]);
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T3))(this._gate, this, 2, subscriptions[2]);
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T4))(this._gate, this, 3, subscriptions[3]);
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T5))(this._gate, this, 4, subscriptions[4]);
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T6))(this._gate, this, 5, subscriptions[5]);
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T7))(this._gate, this, 6, subscriptions[6]);
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T8))(this._gate, this, 7, subscriptions[7]);
            this._observer9 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T9))(this._gate, this, 8, subscriptions[8]);
            this._observer10 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T10))(this._gate, this, 9, subscriptions[9]);
            this._observer11 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T11))(this._gate, this, 10, subscriptions[10]);
            this._observer12 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T12))(this._gate, this, 11, subscriptions[11]);

            subscriptions[0].setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            subscriptions[1].setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            subscriptions[2].setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            subscriptions[3].setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            subscriptions[4].setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            subscriptions[5].setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            subscriptions[6].setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            subscriptions[7].setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));
            subscriptions[8].setDisposable(System.ObservableExtensions.subscribeSafe(T9, this._parent._source9, this._observer9));
            subscriptions[9].setDisposable(System.ObservableExtensions.subscribeSafe(T10, this._parent._source10, this._observer10));
            subscriptions[10].setDisposable(System.ObservableExtensions.subscribeSafe(T11, this._parent._source11, this._observer11));
            subscriptions[11].setDisposable(System.ObservableExtensions.subscribeSafe(T12, this._parent._source12, this._observer12));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(subscriptions);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValue(), this._observer2.getValue(), this._observer3.getValue(), this._observer4.getValue(), this._observer5.getValue(), this._observer6.getValue(), this._observer7.getValue(), this._observer8.getValue(), this._observer9.getValue(), this._observer10.getValue(), this._observer11.getValue(), this._observer12.getValue());
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$14._", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        _observer9: null,
        _observer10: null,
        _observer11: null,
        _observer12: null,
        _observer13: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult).ctor.call(this, 13, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var subscriptions = System.Array.init(13, null);
            for (var i = 0; i < 13; i = (i + 1) | 0) {
                subscriptions[i] = new System.Reactive.Disposables.SingleAssignmentDisposable();
            }

            this._observer1 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T1))(this._gate, this, 0, subscriptions[0]);
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T2))(this._gate, this, 1, subscriptions[1]);
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T3))(this._gate, this, 2, subscriptions[2]);
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T4))(this._gate, this, 3, subscriptions[3]);
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T5))(this._gate, this, 4, subscriptions[4]);
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T6))(this._gate, this, 5, subscriptions[5]);
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T7))(this._gate, this, 6, subscriptions[6]);
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T8))(this._gate, this, 7, subscriptions[7]);
            this._observer9 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T9))(this._gate, this, 8, subscriptions[8]);
            this._observer10 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T10))(this._gate, this, 9, subscriptions[9]);
            this._observer11 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T11))(this._gate, this, 10, subscriptions[10]);
            this._observer12 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T12))(this._gate, this, 11, subscriptions[11]);
            this._observer13 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T13))(this._gate, this, 12, subscriptions[12]);

            subscriptions[0].setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            subscriptions[1].setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            subscriptions[2].setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            subscriptions[3].setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            subscriptions[4].setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            subscriptions[5].setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            subscriptions[6].setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            subscriptions[7].setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));
            subscriptions[8].setDisposable(System.ObservableExtensions.subscribeSafe(T9, this._parent._source9, this._observer9));
            subscriptions[9].setDisposable(System.ObservableExtensions.subscribeSafe(T10, this._parent._source10, this._observer10));
            subscriptions[10].setDisposable(System.ObservableExtensions.subscribeSafe(T11, this._parent._source11, this._observer11));
            subscriptions[11].setDisposable(System.ObservableExtensions.subscribeSafe(T12, this._parent._source12, this._observer12));
            subscriptions[12].setDisposable(System.ObservableExtensions.subscribeSafe(T13, this._parent._source13, this._observer13));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(subscriptions);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValue(), this._observer2.getValue(), this._observer3.getValue(), this._observer4.getValue(), this._observer5.getValue(), this._observer6.getValue(), this._observer7.getValue(), this._observer8.getValue(), this._observer9.getValue(), this._observer10.getValue(), this._observer11.getValue(), this._observer12.getValue(), this._observer13.getValue());
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$15._", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        _observer9: null,
        _observer10: null,
        _observer11: null,
        _observer12: null,
        _observer13: null,
        _observer14: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult).ctor.call(this, 14, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var subscriptions = System.Array.init(14, null);
            for (var i = 0; i < 14; i = (i + 1) | 0) {
                subscriptions[i] = new System.Reactive.Disposables.SingleAssignmentDisposable();
            }

            this._observer1 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T1))(this._gate, this, 0, subscriptions[0]);
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T2))(this._gate, this, 1, subscriptions[1]);
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T3))(this._gate, this, 2, subscriptions[2]);
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T4))(this._gate, this, 3, subscriptions[3]);
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T5))(this._gate, this, 4, subscriptions[4]);
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T6))(this._gate, this, 5, subscriptions[5]);
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T7))(this._gate, this, 6, subscriptions[6]);
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T8))(this._gate, this, 7, subscriptions[7]);
            this._observer9 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T9))(this._gate, this, 8, subscriptions[8]);
            this._observer10 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T10))(this._gate, this, 9, subscriptions[9]);
            this._observer11 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T11))(this._gate, this, 10, subscriptions[10]);
            this._observer12 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T12))(this._gate, this, 11, subscriptions[11]);
            this._observer13 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T13))(this._gate, this, 12, subscriptions[12]);
            this._observer14 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T14))(this._gate, this, 13, subscriptions[13]);

            subscriptions[0].setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            subscriptions[1].setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            subscriptions[2].setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            subscriptions[3].setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            subscriptions[4].setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            subscriptions[5].setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            subscriptions[6].setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            subscriptions[7].setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));
            subscriptions[8].setDisposable(System.ObservableExtensions.subscribeSafe(T9, this._parent._source9, this._observer9));
            subscriptions[9].setDisposable(System.ObservableExtensions.subscribeSafe(T10, this._parent._source10, this._observer10));
            subscriptions[10].setDisposable(System.ObservableExtensions.subscribeSafe(T11, this._parent._source11, this._observer11));
            subscriptions[11].setDisposable(System.ObservableExtensions.subscribeSafe(T12, this._parent._source12, this._observer12));
            subscriptions[12].setDisposable(System.ObservableExtensions.subscribeSafe(T13, this._parent._source13, this._observer13));
            subscriptions[13].setDisposable(System.ObservableExtensions.subscribeSafe(T14, this._parent._source14, this._observer14));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(subscriptions);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValue(), this._observer2.getValue(), this._observer3.getValue(), this._observer4.getValue(), this._observer5.getValue(), this._observer6.getValue(), this._observer7.getValue(), this._observer8.getValue(), this._observer9.getValue(), this._observer10.getValue(), this._observer11.getValue(), this._observer12.getValue(), this._observer13.getValue(), this._observer14.getValue());
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$16._", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        _observer9: null,
        _observer10: null,
        _observer11: null,
        _observer12: null,
        _observer13: null,
        _observer14: null,
        _observer15: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult).ctor.call(this, 15, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var subscriptions = System.Array.init(15, null);
            for (var i = 0; i < 15; i = (i + 1) | 0) {
                subscriptions[i] = new System.Reactive.Disposables.SingleAssignmentDisposable();
            }

            this._observer1 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T1))(this._gate, this, 0, subscriptions[0]);
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T2))(this._gate, this, 1, subscriptions[1]);
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T3))(this._gate, this, 2, subscriptions[2]);
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T4))(this._gate, this, 3, subscriptions[3]);
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T5))(this._gate, this, 4, subscriptions[4]);
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T6))(this._gate, this, 5, subscriptions[5]);
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T7))(this._gate, this, 6, subscriptions[6]);
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T8))(this._gate, this, 7, subscriptions[7]);
            this._observer9 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T9))(this._gate, this, 8, subscriptions[8]);
            this._observer10 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T10))(this._gate, this, 9, subscriptions[9]);
            this._observer11 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T11))(this._gate, this, 10, subscriptions[10]);
            this._observer12 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T12))(this._gate, this, 11, subscriptions[11]);
            this._observer13 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T13))(this._gate, this, 12, subscriptions[12]);
            this._observer14 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T14))(this._gate, this, 13, subscriptions[13]);
            this._observer15 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T15))(this._gate, this, 14, subscriptions[14]);

            subscriptions[0].setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            subscriptions[1].setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            subscriptions[2].setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            subscriptions[3].setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            subscriptions[4].setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            subscriptions[5].setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            subscriptions[6].setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            subscriptions[7].setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));
            subscriptions[8].setDisposable(System.ObservableExtensions.subscribeSafe(T9, this._parent._source9, this._observer9));
            subscriptions[9].setDisposable(System.ObservableExtensions.subscribeSafe(T10, this._parent._source10, this._observer10));
            subscriptions[10].setDisposable(System.ObservableExtensions.subscribeSafe(T11, this._parent._source11, this._observer11));
            subscriptions[11].setDisposable(System.ObservableExtensions.subscribeSafe(T12, this._parent._source12, this._observer12));
            subscriptions[12].setDisposable(System.ObservableExtensions.subscribeSafe(T13, this._parent._source13, this._observer13));
            subscriptions[13].setDisposable(System.ObservableExtensions.subscribeSafe(T14, this._parent._source14, this._observer14));
            subscriptions[14].setDisposable(System.ObservableExtensions.subscribeSafe(T15, this._parent._source15, this._observer15));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(subscriptions);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValue(), this._observer2.getValue(), this._observer3.getValue(), this._observer4.getValue(), this._observer5.getValue(), this._observer6.getValue(), this._observer7.getValue(), this._observer8.getValue(), this._observer9.getValue(), this._observer10.getValue(), this._observer11.getValue(), this._observer12.getValue(), this._observer13.getValue(), this._observer14.getValue(), this._observer15.getValue());
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$17._", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        _observer9: null,
        _observer10: null,
        _observer11: null,
        _observer12: null,
        _observer13: null,
        _observer14: null,
        _observer15: null,
        _observer16: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult).ctor.call(this, 16, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var subscriptions = System.Array.init(16, null);
            for (var i = 0; i < 16; i = (i + 1) | 0) {
                subscriptions[i] = new System.Reactive.Disposables.SingleAssignmentDisposable();
            }

            this._observer1 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T1))(this._gate, this, 0, subscriptions[0]);
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T2))(this._gate, this, 1, subscriptions[1]);
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T3))(this._gate, this, 2, subscriptions[2]);
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T4))(this._gate, this, 3, subscriptions[3]);
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T5))(this._gate, this, 4, subscriptions[4]);
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T6))(this._gate, this, 5, subscriptions[5]);
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T7))(this._gate, this, 6, subscriptions[6]);
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T8))(this._gate, this, 7, subscriptions[7]);
            this._observer9 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T9))(this._gate, this, 8, subscriptions[8]);
            this._observer10 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T10))(this._gate, this, 9, subscriptions[9]);
            this._observer11 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T11))(this._gate, this, 10, subscriptions[10]);
            this._observer12 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T12))(this._gate, this, 11, subscriptions[11]);
            this._observer13 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T13))(this._gate, this, 12, subscriptions[12]);
            this._observer14 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T14))(this._gate, this, 13, subscriptions[13]);
            this._observer15 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T15))(this._gate, this, 14, subscriptions[14]);
            this._observer16 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T16))(this._gate, this, 15, subscriptions[15]);

            subscriptions[0].setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            subscriptions[1].setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            subscriptions[2].setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            subscriptions[3].setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            subscriptions[4].setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            subscriptions[5].setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            subscriptions[6].setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            subscriptions[7].setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));
            subscriptions[8].setDisposable(System.ObservableExtensions.subscribeSafe(T9, this._parent._source9, this._observer9));
            subscriptions[9].setDisposable(System.ObservableExtensions.subscribeSafe(T10, this._parent._source10, this._observer10));
            subscriptions[10].setDisposable(System.ObservableExtensions.subscribeSafe(T11, this._parent._source11, this._observer11));
            subscriptions[11].setDisposable(System.ObservableExtensions.subscribeSafe(T12, this._parent._source12, this._observer12));
            subscriptions[12].setDisposable(System.ObservableExtensions.subscribeSafe(T13, this._parent._source13, this._observer13));
            subscriptions[13].setDisposable(System.ObservableExtensions.subscribeSafe(T14, this._parent._source14, this._observer14));
            subscriptions[14].setDisposable(System.ObservableExtensions.subscribeSafe(T15, this._parent._source15, this._observer15));
            subscriptions[15].setDisposable(System.ObservableExtensions.subscribeSafe(T16, this._parent._source16, this._observer16));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(subscriptions);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValue(), this._observer2.getValue(), this._observer3.getValue(), this._observer4.getValue(), this._observer5.getValue(), this._observer6.getValue(), this._observer7.getValue(), this._observer8.getValue(), this._observer9.getValue(), this._observer10.getValue(), this._observer11.getValue(), this._observer12.getValue(), this._observer13.getValue(), this._observer14.getValue(), this._observer15.getValue(), this._observer16.getValue());
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$4._", function (T1, T2, T3, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult).ctor.call(this, 3, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var subscriptions = System.Array.init(3, null);
            for (var i = 0; i < 3; i = (i + 1) | 0) {
                subscriptions[i] = new System.Reactive.Disposables.SingleAssignmentDisposable();
            }

            this._observer1 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T1))(this._gate, this, 0, subscriptions[0]);
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T2))(this._gate, this, 1, subscriptions[1]);
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T3))(this._gate, this, 2, subscriptions[2]);

            subscriptions[0].setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            subscriptions[1].setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            subscriptions[2].setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(subscriptions);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValue(), this._observer2.getValue(), this._observer3.getValue());
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$5._", function (T1, T2, T3, T4, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult).ctor.call(this, 4, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var subscriptions = System.Array.init(4, null);
            for (var i = 0; i < 4; i = (i + 1) | 0) {
                subscriptions[i] = new System.Reactive.Disposables.SingleAssignmentDisposable();
            }

            this._observer1 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T1))(this._gate, this, 0, subscriptions[0]);
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T2))(this._gate, this, 1, subscriptions[1]);
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T3))(this._gate, this, 2, subscriptions[2]);
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T4))(this._gate, this, 3, subscriptions[3]);

            subscriptions[0].setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            subscriptions[1].setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            subscriptions[2].setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            subscriptions[3].setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(subscriptions);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValue(), this._observer2.getValue(), this._observer3.getValue(), this._observer4.getValue());
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$6._", function (T1, T2, T3, T4, T5, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult).ctor.call(this, 5, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var subscriptions = System.Array.init(5, null);
            for (var i = 0; i < 5; i = (i + 1) | 0) {
                subscriptions[i] = new System.Reactive.Disposables.SingleAssignmentDisposable();
            }

            this._observer1 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T1))(this._gate, this, 0, subscriptions[0]);
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T2))(this._gate, this, 1, subscriptions[1]);
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T3))(this._gate, this, 2, subscriptions[2]);
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T4))(this._gate, this, 3, subscriptions[3]);
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T5))(this._gate, this, 4, subscriptions[4]);

            subscriptions[0].setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            subscriptions[1].setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            subscriptions[2].setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            subscriptions[3].setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            subscriptions[4].setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(subscriptions);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValue(), this._observer2.getValue(), this._observer3.getValue(), this._observer4.getValue(), this._observer5.getValue());
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$7._", function (T1, T2, T3, T4, T5, T6, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult).ctor.call(this, 6, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var subscriptions = System.Array.init(6, null);
            for (var i = 0; i < 6; i = (i + 1) | 0) {
                subscriptions[i] = new System.Reactive.Disposables.SingleAssignmentDisposable();
            }

            this._observer1 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T1))(this._gate, this, 0, subscriptions[0]);
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T2))(this._gate, this, 1, subscriptions[1]);
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T3))(this._gate, this, 2, subscriptions[2]);
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T4))(this._gate, this, 3, subscriptions[3]);
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T5))(this._gate, this, 4, subscriptions[4]);
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T6))(this._gate, this, 5, subscriptions[5]);

            subscriptions[0].setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            subscriptions[1].setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            subscriptions[2].setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            subscriptions[3].setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            subscriptions[4].setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            subscriptions[5].setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(subscriptions);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValue(), this._observer2.getValue(), this._observer3.getValue(), this._observer4.getValue(), this._observer5.getValue(), this._observer6.getValue());
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$8._", function (T1, T2, T3, T4, T5, T6, T7, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult).ctor.call(this, 7, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var subscriptions = System.Array.init(7, null);
            for (var i = 0; i < 7; i = (i + 1) | 0) {
                subscriptions[i] = new System.Reactive.Disposables.SingleAssignmentDisposable();
            }

            this._observer1 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T1))(this._gate, this, 0, subscriptions[0]);
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T2))(this._gate, this, 1, subscriptions[1]);
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T3))(this._gate, this, 2, subscriptions[2]);
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T4))(this._gate, this, 3, subscriptions[3]);
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T5))(this._gate, this, 4, subscriptions[4]);
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T6))(this._gate, this, 5, subscriptions[5]);
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T7))(this._gate, this, 6, subscriptions[6]);

            subscriptions[0].setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            subscriptions[1].setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            subscriptions[2].setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            subscriptions[3].setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            subscriptions[4].setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            subscriptions[5].setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            subscriptions[6].setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(subscriptions);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValue(), this._observer2.getValue(), this._observer3.getValue(), this._observer4.getValue(), this._observer5.getValue(), this._observer6.getValue(), this._observer7.getValue());
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$9._", function (T1, T2, T3, T4, T5, T6, T7, T8, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.CombineLatestSink$1(TResult).ctor.call(this, 8, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var subscriptions = System.Array.init(8, null);
            for (var i = 0; i < 8; i = (i + 1) | 0) {
                subscriptions[i] = new System.Reactive.Disposables.SingleAssignmentDisposable();
            }

            this._observer1 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T1))(this._gate, this, 0, subscriptions[0]);
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T2))(this._gate, this, 1, subscriptions[1]);
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T3))(this._gate, this, 2, subscriptions[2]);
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T4))(this._gate, this, 3, subscriptions[3]);
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T5))(this._gate, this, 4, subscriptions[4]);
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T6))(this._gate, this, 5, subscriptions[5]);
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T7))(this._gate, this, 6, subscriptions[6]);
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.CombineLatestObserver$1(T8))(this._gate, this, 7, subscriptions[7]);

            subscriptions[0].setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            subscriptions[1].setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            subscriptions[2].setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            subscriptions[3].setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            subscriptions[4].setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            subscriptions[5].setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            subscriptions[6].setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            subscriptions[7].setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(subscriptions);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValue(), this._observer2.getValue(), this._observer3.getValue(), this._observer4.getValue(), this._observer5.getValue(), this._observer6.getValue(), this._observer7.getValue(), this._observer8.getValue());
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.GroupBy$3._", function (TSource, TKey, TElement) { return {
        inherits: [System.Reactive.Sink$1(System.Reactive.Linq.IGroupedObservable$2(TKey,TElement)),System.IObserver$1(TSource)],
        _parent: null,
        _map: null,
        _null: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Reactive.Linq.IGroupedObservable$2(TKey,TElement)).ctor.call(this, observer, cancel);
            this._parent = parent;

            if (System.Nullable.hasValue(this._parent._capacity)) {
                this._map = new (System.Collections.Generic.Dictionary$2(TKey, System.Reactive.Subjects.ISubject$1(TElement)))(null, this._parent._comparer);
            } else {
                this._map = new (System.Collections.Generic.Dictionary$2(TKey, System.Reactive.Subjects.ISubject$1(TElement)))(null, this._parent._comparer);
            }
        },
        onNext: function (value) {
            var key = Bridge.getDefaultValue(TKey);
            try {
                key = this._parent._keySelector(value);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this.error(exception);
                return;
            }

            var fireNewMapEntry = false;
            var writer = { v : null };
            try {
                //
                // Note: The box instruction in the IL will be erased by the JIT in case T is
                //       a value type. In fact, the whole if block will go away and we'll end
                //       up with nothing but the TryGetValue check below.
                //
                //       // var fireNewMapEntry = false;
                //       C:\Projects\Rx\Rx\Experimental\Main\Source\Rx\System.Reactive.Linq\Reactive\Linq\Observable\GroupBy.cs @ 67:
                //       000007fb`6d544b80 48c7452800000000 mov     qword ptr [rbp+28h],0
                //
                //       // var writer = default(ISubject<TElement>);
                //       C:\Projects\Rx\Rx\Experimental\Main\Source\Rx\System.Reactive.Linq\Reactive\Linq\Observable\GroupBy.cs @ 66:
                //       000007fb`6d544b88 c6453400        mov     byte ptr [rbp+34h],0
                //
                //       // if (!_map.TryGetValue(key, out writer))
                //       C:\Projects\Rx\Rx\Experimental\Main\Source\Rx\System.Reactive.Linq\Reactive\Linq\Observable\GroupBy.cs @ 86:
                //       000007fb`6d544b8c 488b4560        mov     rax,qword ptr [rbp+60h]
                //       ...
                //
                if (key == null) {
                    if (this._null == null) {
                        this._null = new (System.Reactive.Subjects.Subject$1(TElement))();
                        fireNewMapEntry = true;
                    }

                    writer.v = this._null;
                } else {
                    if (!this._map.tryGetValue(key, writer)) {
                        writer.v = new (System.Reactive.Subjects.Subject$1(TElement))();
                        this._map.add(key, writer.v);
                        fireNewMapEntry = true;
                    }
                }
            }
            catch (exception1) {
                exception1 = System.Exception.create(exception1);
                this.error(exception1);
                return;
            }

            if (fireNewMapEntry) {
                var group = new (System.Reactive.Linq.GroupedObservable$2(TKey,TElement)).$ctor1(key, writer.v, this._parent._refCountDisposable);
                this._observer["System$IObserver$1$System$Reactive$Linq$IGroupedObservable$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TElement) + "$onNext"](group);
            }

            var element = Bridge.getDefaultValue(TElement);
            try {
                element = this._parent._elementSelector(value);
            }
            catch (exception2) {
                exception2 = System.Exception.create(exception2);
                this.error(exception2);
                return;
            }

            writer.v["System$IObserver$1$" + Bridge.getTypeAlias(TElement) + "$onNext"](element);
        },
        onError: function (error) {
            this.error(error);
        },
        onCompleted: function () {
            var $t;
            if (this._null != null) {
                this._null["System$IObserver$1$" + Bridge.getTypeAlias(TElement) + "$onCompleted"]();
            }

            $t = Bridge.getEnumerator(this._map.getValues(), System.Reactive.Subjects.ISubject$1(TElement));
            while ($t.moveNext()) {
                var w = $t.getCurrent();
                w["System$IObserver$1$" + Bridge.getTypeAlias(TElement) + "$onCompleted"]();
            }

            this._observer["System$IObserver$1$System$Reactive$Linq$IGroupedObservable$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TElement) + "$onCompleted"]();
            System.Reactive.Sink$1(System.Reactive.Linq.IGroupedObservable$2(TKey,TElement)).prototype.dispose.call(this);
        },
        error: function (exception) {
            var $t;
            if (this._null != null) {
                this._null["System$IObserver$1$" + Bridge.getTypeAlias(TElement) + "$onError"](exception);
            }

            $t = Bridge.getEnumerator(this._map.getValues(), System.Reactive.Subjects.ISubject$1(TElement));
            while ($t.moveNext()) {
                var w = $t.getCurrent();
                w["System$IObserver$1$" + Bridge.getTypeAlias(TElement) + "$onError"](exception);
            }

            this._observer["System$IObserver$1$System$Reactive$Linq$IGroupedObservable$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TElement) + "$onError"](exception);
            System.Reactive.Sink$1(System.Reactive.Linq.IGroupedObservable$2(TKey,TElement)).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.GroupByUntil$4._", function (TSource, TKey, TElement, TDuration) { return {
        inherits: [System.Reactive.Sink$1(System.Reactive.Linq.IGroupedObservable$2(TKey,TElement)),System.IObserver$1(TSource)],
        _parent: null,
        _map: null,
        _null: null,
        _nullGate: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Sink$1(System.Reactive.Linq.IGroupedObservable$2(TKey,TElement)).ctor.call(this, observer, cancel);
            this._parent = parent;
            this._map = new (System.Reactive.Linq.ObservableImpl.Map$2(TKey,System.Reactive.Subjects.ISubject$1(TElement)))(this._parent._capacity, this._parent._comparer);
            this._nullGate = {  };
        },
        newSubject: function () {
            var sub = new (System.Reactive.Subjects.Subject$1(TElement))();

            return System.Reactive.Subjects.Subject.system.reactive.subjects.subject.create(new (System.Reactive.AsyncLockObserver$1(TElement))(sub, new System.Reactive.Concurrency.AsyncLock()), sub);
        },
        onNext: function (value) {
            var key = Bridge.getDefaultValue(TKey);
            try {
                key = this._parent._keySelector(value);
            }
            catch (exception) {
                exception = System.Exception.create(exception);
                this.error(exception);
                return;
            }

            var fireNewMapEntry = { v : false };
            var writer = null;
            try {
                //
                // Note: The box instruction in the IL will be erased by the JIT in case T is
                //       a value type. In fact, the whole if block will go away and we'll end
                //       up with nothing but the GetOrAdd call below.
                //
                //       See GroupBy for more information and confirmation of this fact using
                //       the SOS debugger extension.
                //
                if (key == null) {
                    this._nullGate;
                    {
                        if (this._null == null) {
                            this._null = this.newSubject();
                            fireNewMapEntry.v = true;
                        }

                        writer = this._null;
                    }
                } else {
                    writer = this._map.getOrAdd(key, Bridge.fn.bind(this, this.newSubject), fireNewMapEntry);
                }
            }
            catch (exception1) {
                exception1 = System.Exception.create(exception1);
                this.error(exception1);
                return;
            }

            if (fireNewMapEntry.v) {
                var group = new (System.Reactive.Linq.GroupedObservable$2(TKey,TElement)).$ctor1(key, writer, this._parent._refCountDisposable);

                var duration = null;

                var durationGroup = new (System.Reactive.Linq.GroupedObservable$2(TKey,TElement)).ctor(key, writer);
                try {
                    duration = this._parent._durationSelector(durationGroup);
                }
                catch (exception2) {
                    exception2 = System.Exception.create(exception2);
                    this.error(exception2);
                    return;
                }

                this._observer;
                this._observer["System$IObserver$1$System$Reactive$Linq$IGroupedObservable$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TElement) + "$onNext"](group);

                var md = new System.Reactive.Disposables.SingleAssignmentDisposable();
                this._parent._groupDisposable.add(md);
                md.setDisposable(System.ObservableExtensions.subscribeSafe(TDuration, duration, new (System.Reactive.Linq.ObservableImpl.GroupByUntil$4._.Delta(TSource,TKey,TElement,TDuration))(this, key, writer, md)));
            }

            var element = Bridge.getDefaultValue(TElement);
            try {
                element = this._parent._elementSelector(value);
            }
            catch (exception3) {
                exception3 = System.Exception.create(exception3);
                this.error(exception3);
                return;
            }

            //
            // ISSUE: Rx v1.x shipped without proper handling of the case where the duration
            //        sequence fires concurrently with the OnNext code path here. In such a
            //        case, the subject can be completed before we get a chance to send out
            //        a new element. However, a resurrected group for the same key won't get
            //        to see the element either. To guard against this case, we'd have to
            //        check whether the OnNext call below lost the race, and resurrect a new
            //        group if needed. Unfortunately, this complicates matters when the
            //        duration selector triggers synchronously (e.g. Return or Empty), which
            //        causes the group to terminate immediately. We should not get stuck in
            //        this case, repeatedly trying to resurrect a group that always ends
            //        before we can send the element into it. Also, users may expect this
            //        base case to mean no elements will ever be produced, so sending the
            //        element into the group before starting the duration sequence may not
            //        be a good idea either. For the time being, we'll leave this as-is and
            //        revisit the behavior for vNext. Nonetheless, we'll add synchronization
            //        to ensure no concurrent calls to the subject are made.
            //
            writer["System$IObserver$1$" + Bridge.getTypeAlias(TElement) + "$onNext"](element);
        },
        onError: function (error) {
            this.error(error);
        },
        onCompleted: function () {
            var $t;
            //
            // NOTE: A race with OnCompleted triggered by a duration selector is fine when
            //       using Subject<T>. It will transition into a terminal state, making one
            //       of the two calls a no-op by swapping in a DoneObserver<T>.
            //
            var $null = null;
            this._nullGate;
            $null = this._null;

            if ($null != null) {
                $null["System$IObserver$1$" + Bridge.getTypeAlias(TElement) + "$onCompleted"]();
            }

            $t = Bridge.getEnumerator(this._map.getValues(), System.Reactive.Subjects.ISubject$1(TElement));
            while ($t.moveNext()) {
                var w = $t.getCurrent();
                w["System$IObserver$1$" + Bridge.getTypeAlias(TElement) + "$onCompleted"]();
            }

            this._observer;
            this._observer["System$IObserver$1$System$Reactive$Linq$IGroupedObservable$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TElement) + "$onCompleted"]();

            System.Reactive.Sink$1(System.Reactive.Linq.IGroupedObservable$2(TKey,TElement)).prototype.dispose.call(this);
        },
        error: function (exception) {
            var $t;
            //
            // NOTE: A race with OnCompleted triggered by a duration selector is fine when
            //       using Subject<T>. It will transition into a terminal state, making one
            //       of the two calls a no-op by swapping in a DoneObserver<T>.
            //
            var $null = null;
            this._nullGate;
            $null = this._null;

            if ($null != null) {
                $null["System$IObserver$1$" + Bridge.getTypeAlias(TElement) + "$onError"](exception);
            }

            $t = Bridge.getEnumerator(this._map.getValues(), System.Reactive.Subjects.ISubject$1(TElement));
            while ($t.moveNext()) {
                var w = $t.getCurrent();
                w["System$IObserver$1$" + Bridge.getTypeAlias(TElement) + "$onError"](exception);
            }

            this._observer;
            this._observer["System$IObserver$1$System$Reactive$Linq$IGroupedObservable$2$" + Bridge.getTypeAlias(TKey) + "$" + Bridge.getTypeAlias(TElement) + "$onError"](exception);

            System.Reactive.Sink$1(System.Reactive.Linq.IGroupedObservable$2(TKey,TElement)).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Latest$1._", function (TSource) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.PushToPullSink$2(TSource,TSource)],
        _gate: null,
        _semaphore: null,
        _notificationAvailable: false,
        _kind: 0,
        _value: Bridge.getDefaultValue(TSource),
        _error: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (subscription) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.PushToPullSink$2(TSource,TSource).ctor.call(this, subscription);
            this._gate = {  };

            this._semaphore = new System.Reactive.Threading.Semaphore(0, 1);
        },
        onNext: function (value) {
            var lackedValue = false;
            this._gate;
            {
                lackedValue = !this._notificationAvailable;
                this._notificationAvailable = true;
                this._kind = System.Reactive.NotificationKind.OnNext;
                this._value = value;
            }

            if (lackedValue) {
                this._semaphore.release();
            }
        },
        onError: function (error) {
            this.dispose();

            var lackedValue = false;
            this._gate;
            {
                lackedValue = !this._notificationAvailable;
                this._notificationAvailable = true;
                this._kind = System.Reactive.NotificationKind.OnError;
                this._error = error;
            }

            if (lackedValue) {
                this._semaphore.release();
            }
        },
        onCompleted: function () {
            this.dispose();

            var lackedValue = false;
            this._gate;
            {
                lackedValue = !this._notificationAvailable;
                this._notificationAvailable = true;
                this._kind = System.Reactive.NotificationKind.OnCompleted;
            }

            if (lackedValue) {
                this._semaphore.release();
            }
        },
        tryMoveNext: function (current) {
            var kind = 0;
            var value = Bridge.getDefaultValue(TSource);
            var error = null;

            this._semaphore.waitOne();

            this._gate;
            {
                kind = this._kind;

                switch (kind) {
                    case System.Reactive.NotificationKind.OnNext: 
                        value = this._value;
                        break;
                    case System.Reactive.NotificationKind.OnError: 
                        error = this._error;
                        break;
                }

                this._notificationAvailable = false;
            }

            switch (kind) {
                case System.Reactive.NotificationKind.OnNext: 
                    current.v = this._value;
                    return true;
                case System.Reactive.NotificationKind.OnError: 
                    System.Reactive.ExceptionHelpers.throw(error);
                    break;
                case System.Reactive.NotificationKind.OnCompleted: 
                    break;
            }

            current.v = Bridge.getDefaultValue(TSource);
            return false;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MostRecent$1._", function (TSource) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.PushToPullSink$2(TSource,TSource)],
        _kind: 0,
        _value: Bridge.getDefaultValue(TSource),
        _error: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (initialValue, subscription) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.PushToPullSink$2(TSource,TSource).ctor.call(this, subscription);
            this._kind = System.Reactive.NotificationKind.OnNext;
            this._value = initialValue;
        },
        onNext: function (value) {
            this._value = value;
            this._kind = System.Reactive.NotificationKind.OnNext; // Write last!
        },
        onError: function (error) {
            this.dispose();

            this._error = error;
            this._kind = System.Reactive.NotificationKind.OnError; // Write last!
        },
        onCompleted: function () {
            this.dispose();

            this._kind = System.Reactive.NotificationKind.OnCompleted; // Write last!
        },
        tryMoveNext: function (current) {
            //
            // Notice the _kind field is marked volatile and read before the other fields.
            //
            // In case of a concurrent change, we may read a stale OnNext value, which is
            // fine because this push-to-pull adapter is about sampling.
            //
            switch (this._kind) {
                case System.Reactive.NotificationKind.OnNext: 
                    current.v = this._value;
                    return true;
                case System.Reactive.NotificationKind.OnError: 
                    System.Reactive.ExceptionHelpers.throw(this._error);
                    break;
                case System.Reactive.NotificationKind.OnCompleted: 
                    break;
            }

            current.v = Bridge.getDefaultValue(TSource);
            return false;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Next$1._", function (TSource) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.PushToPullSink$2(TSource,TSource)],
        _gate: null,
        _semaphore: null,
        _waiting: false,
        _kind: 0,
        _value: Bridge.getDefaultValue(TSource),
        _error: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (subscription) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.PushToPullSink$2(TSource,TSource).ctor.call(this, subscription);
            this._gate = {  };

            this._semaphore = new System.Reactive.Threading.Semaphore(0, 1);
        },
        onNext: function (value) {
            this._gate;
            {
                if (this._waiting) {
                    this._value = value;
                    this._kind = System.Reactive.NotificationKind.OnNext;
                    this._semaphore.release();
                }

                this._waiting = false;
            }
        },
        onError: function (error) {
            this.dispose();

            this._gate;
            {
                //
                // BREAKING CHANGE v2 > v1.x - Next doesn't block indefinitely when it reaches the end.
                //
                this._error = error;
                this._kind = System.Reactive.NotificationKind.OnError;

                if (this._waiting) {
                    this._semaphore.release();
                }

                this._waiting = false;
            }
        },
        onCompleted: function () {
            this.dispose();

            this._gate;
            {
                //
                // BREAKING CHANGE v2 > v1.x - Next doesn't block indefinitely when it reaches the end.
                //
                this._kind = System.Reactive.NotificationKind.OnCompleted;

                if (this._waiting) {
                    this._semaphore.release();
                }

                this._waiting = false;
            }
        },
        tryMoveNext: function (current) {
            var done = false;

            this._gate;
            {
                this._waiting = true;

                //
                // BREAKING CHANGE v2 > v1.x - Next doesn't block indefinitely when it reaches the end.
                //
                done = this._kind !== System.Reactive.NotificationKind.OnNext;
            }

            if (!done) {
                this._semaphore.waitOne();
            }

            //
            // When we reach this point, we released the lock and got the next notification
            // from the observer. We assume no concurrent calls to the TryMoveNext method
            // are made (per general guidance on usage of IEnumerable<T>). If the observer
            // enters the lock again, it should have quit it first, causing _waiting to be
            // set to false, hence future accesses of the lock won't set the _kind, _value,
            // and _error fields, until TryMoveNext is entered again and _waiting is reset
            // to true. In conclusion, the fields are stable for read below.
            //
            // Notice we rely on memory barrier acquire/release behavior due to the use of
            // the semaphore, not the lock (we're still under the lock when we release the
            // semaphore in the On* methods!).
            //
            switch (this._kind) {
                case System.Reactive.NotificationKind.OnNext: 
                    current.v = this._value;
                    return true;
                case System.Reactive.NotificationKind.OnError: 
                    System.Reactive.ExceptionHelpers.throw(this._error);
                    break;
                case System.Reactive.NotificationKind.OnCompleted: 
                    break;
            }

            current.v = Bridge.getDefaultValue(TSource);
            return false;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.OnErrorResumeNext$1._", function (TSource) { return {
        inherits: [System.Reactive.TailRecursiveSink$1(TSource)],
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onCompleted"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.TailRecursiveSink$1(TSource).ctor.call(this, observer, cancel);
        },
        extract: function (source) {
            var oern = Bridge.as(source, System.Reactive.Linq.ObservableImpl.OnErrorResumeNext$1(TSource));
            if (oern != null) {
                return oern._sources;
            }

            return null;
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._recurse();
        },
        onCompleted: function () {
            this._recurse();
        },
        fail: function (error) {
            //
            // Note that the invocation of _recurse in OnError will
            // cause the next MoveNext operation to be enqueued, so
            // we will still return to the caller immediately.
            //
            this.onError(error);
            return true;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$10._", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        _observer9: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult).ctor.call(this, 9, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var disposables = System.Array.init(10, null);

            var d1 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[0] = d1;
            this._observer1 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T1))(this._gate, this, 0, d1);
            this.getQueues()[0] = this._observer1.getValues();

            var d2 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[1] = d2;
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T2))(this._gate, this, 1, d2);
            this.getQueues()[1] = this._observer2.getValues();

            var d3 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[2] = d3;
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T3))(this._gate, this, 2, d3);
            this.getQueues()[2] = this._observer3.getValues();

            var d4 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[3] = d4;
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T4))(this._gate, this, 3, d4);
            this.getQueues()[3] = this._observer4.getValues();

            var d5 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[4] = d5;
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T5))(this._gate, this, 4, d5);
            this.getQueues()[4] = this._observer5.getValues();

            var d6 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[5] = d6;
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T6))(this._gate, this, 5, d6);
            this.getQueues()[5] = this._observer6.getValues();

            var d7 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[6] = d7;
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T7))(this._gate, this, 6, d7);
            this.getQueues()[6] = this._observer7.getValues();

            var d8 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[7] = d8;
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T8))(this._gate, this, 7, d8);
            this.getQueues()[7] = this._observer8.getValues();

            var d9 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[8] = d9;
            this._observer9 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T9))(this._gate, this, 8, d9);
            this.getQueues()[8] = this._observer9.getValues();

            d1.setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            d2.setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            d3.setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            d4.setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            d5.setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            d6.setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            d7.setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            d8.setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));
            d9.setDisposable(System.ObservableExtensions.subscribeSafe(T9, this._parent._source9, this._observer9));

            disposables[9] = System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Zip$10._.f1));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(disposables);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValues().dequeue(), this._observer2.getValues().dequeue(), this._observer3.getValues().dequeue(), this._observer4.getValues().dequeue(), this._observer5.getValues().dequeue(), this._observer6.getValues().dequeue(), this._observer7.getValues().dequeue(), this._observer8.getValues().dequeue(), this._observer9.getValues().dequeue());
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Zip$10._", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Zip$10._, {
        f1: function () {
            this._observer1.getValues().clear();
            this._observer2.getValues().clear();
            this._observer3.getValues().clear();
            this._observer4.getValues().clear();
            this._observer5.getValues().clear();
            this._observer6.getValues().clear();
            this._observer7.getValues().clear();
            this._observer8.getValues().clear();
            this._observer9.getValues().clear();
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$11._", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        _observer9: null,
        _observer10: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult).ctor.call(this, 10, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var disposables = System.Array.init(11, null);

            var d1 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[0] = d1;
            this._observer1 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T1))(this._gate, this, 0, d1);
            this.getQueues()[0] = this._observer1.getValues();

            var d2 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[1] = d2;
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T2))(this._gate, this, 1, d2);
            this.getQueues()[1] = this._observer2.getValues();

            var d3 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[2] = d3;
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T3))(this._gate, this, 2, d3);
            this.getQueues()[2] = this._observer3.getValues();

            var d4 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[3] = d4;
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T4))(this._gate, this, 3, d4);
            this.getQueues()[3] = this._observer4.getValues();

            var d5 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[4] = d5;
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T5))(this._gate, this, 4, d5);
            this.getQueues()[4] = this._observer5.getValues();

            var d6 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[5] = d6;
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T6))(this._gate, this, 5, d6);
            this.getQueues()[5] = this._observer6.getValues();

            var d7 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[6] = d7;
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T7))(this._gate, this, 6, d7);
            this.getQueues()[6] = this._observer7.getValues();

            var d8 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[7] = d8;
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T8))(this._gate, this, 7, d8);
            this.getQueues()[7] = this._observer8.getValues();

            var d9 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[8] = d9;
            this._observer9 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T9))(this._gate, this, 8, d9);
            this.getQueues()[8] = this._observer9.getValues();

            var d10 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[9] = d10;
            this._observer10 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T10))(this._gate, this, 9, d10);
            this.getQueues()[9] = this._observer10.getValues();

            d1.setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            d2.setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            d3.setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            d4.setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            d5.setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            d6.setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            d7.setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            d8.setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));
            d9.setDisposable(System.ObservableExtensions.subscribeSafe(T9, this._parent._source9, this._observer9));
            d10.setDisposable(System.ObservableExtensions.subscribeSafe(T10, this._parent._source10, this._observer10));

            disposables[10] = System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Zip$11._.f1));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(disposables);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValues().dequeue(), this._observer2.getValues().dequeue(), this._observer3.getValues().dequeue(), this._observer4.getValues().dequeue(), this._observer5.getValues().dequeue(), this._observer6.getValues().dequeue(), this._observer7.getValues().dequeue(), this._observer8.getValues().dequeue(), this._observer9.getValues().dequeue(), this._observer10.getValues().dequeue());
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Zip$11._", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Zip$11._, {
        f1: function () {
            this._observer1.getValues().clear();
            this._observer2.getValues().clear();
            this._observer3.getValues().clear();
            this._observer4.getValues().clear();
            this._observer5.getValues().clear();
            this._observer6.getValues().clear();
            this._observer7.getValues().clear();
            this._observer8.getValues().clear();
            this._observer9.getValues().clear();
            this._observer10.getValues().clear();
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$12._", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        _observer9: null,
        _observer10: null,
        _observer11: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult).ctor.call(this, 11, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var disposables = System.Array.init(12, null);

            var d1 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[0] = d1;
            this._observer1 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T1))(this._gate, this, 0, d1);
            this.getQueues()[0] = this._observer1.getValues();

            var d2 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[1] = d2;
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T2))(this._gate, this, 1, d2);
            this.getQueues()[1] = this._observer2.getValues();

            var d3 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[2] = d3;
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T3))(this._gate, this, 2, d3);
            this.getQueues()[2] = this._observer3.getValues();

            var d4 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[3] = d4;
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T4))(this._gate, this, 3, d4);
            this.getQueues()[3] = this._observer4.getValues();

            var d5 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[4] = d5;
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T5))(this._gate, this, 4, d5);
            this.getQueues()[4] = this._observer5.getValues();

            var d6 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[5] = d6;
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T6))(this._gate, this, 5, d6);
            this.getQueues()[5] = this._observer6.getValues();

            var d7 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[6] = d7;
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T7))(this._gate, this, 6, d7);
            this.getQueues()[6] = this._observer7.getValues();

            var d8 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[7] = d8;
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T8))(this._gate, this, 7, d8);
            this.getQueues()[7] = this._observer8.getValues();

            var d9 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[8] = d9;
            this._observer9 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T9))(this._gate, this, 8, d9);
            this.getQueues()[8] = this._observer9.getValues();

            var d10 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[9] = d10;
            this._observer10 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T10))(this._gate, this, 9, d10);
            this.getQueues()[9] = this._observer10.getValues();

            var d11 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[10] = d11;
            this._observer11 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T11))(this._gate, this, 10, d11);
            this.getQueues()[10] = this._observer11.getValues();

            d1.setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            d2.setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            d3.setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            d4.setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            d5.setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            d6.setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            d7.setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            d8.setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));
            d9.setDisposable(System.ObservableExtensions.subscribeSafe(T9, this._parent._source9, this._observer9));
            d10.setDisposable(System.ObservableExtensions.subscribeSafe(T10, this._parent._source10, this._observer10));
            d11.setDisposable(System.ObservableExtensions.subscribeSafe(T11, this._parent._source11, this._observer11));

            disposables[11] = System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Zip$12._.f1));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(disposables);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValues().dequeue(), this._observer2.getValues().dequeue(), this._observer3.getValues().dequeue(), this._observer4.getValues().dequeue(), this._observer5.getValues().dequeue(), this._observer6.getValues().dequeue(), this._observer7.getValues().dequeue(), this._observer8.getValues().dequeue(), this._observer9.getValues().dequeue(), this._observer10.getValues().dequeue(), this._observer11.getValues().dequeue());
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Zip$12._", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Zip$12._, {
        f1: function () {
            this._observer1.getValues().clear();
            this._observer2.getValues().clear();
            this._observer3.getValues().clear();
            this._observer4.getValues().clear();
            this._observer5.getValues().clear();
            this._observer6.getValues().clear();
            this._observer7.getValues().clear();
            this._observer8.getValues().clear();
            this._observer9.getValues().clear();
            this._observer10.getValues().clear();
            this._observer11.getValues().clear();
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$13._", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        _observer9: null,
        _observer10: null,
        _observer11: null,
        _observer12: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult).ctor.call(this, 12, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var disposables = System.Array.init(13, null);

            var d1 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[0] = d1;
            this._observer1 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T1))(this._gate, this, 0, d1);
            this.getQueues()[0] = this._observer1.getValues();

            var d2 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[1] = d2;
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T2))(this._gate, this, 1, d2);
            this.getQueues()[1] = this._observer2.getValues();

            var d3 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[2] = d3;
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T3))(this._gate, this, 2, d3);
            this.getQueues()[2] = this._observer3.getValues();

            var d4 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[3] = d4;
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T4))(this._gate, this, 3, d4);
            this.getQueues()[3] = this._observer4.getValues();

            var d5 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[4] = d5;
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T5))(this._gate, this, 4, d5);
            this.getQueues()[4] = this._observer5.getValues();

            var d6 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[5] = d6;
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T6))(this._gate, this, 5, d6);
            this.getQueues()[5] = this._observer6.getValues();

            var d7 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[6] = d7;
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T7))(this._gate, this, 6, d7);
            this.getQueues()[6] = this._observer7.getValues();

            var d8 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[7] = d8;
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T8))(this._gate, this, 7, d8);
            this.getQueues()[7] = this._observer8.getValues();

            var d9 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[8] = d9;
            this._observer9 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T9))(this._gate, this, 8, d9);
            this.getQueues()[8] = this._observer9.getValues();

            var d10 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[9] = d10;
            this._observer10 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T10))(this._gate, this, 9, d10);
            this.getQueues()[9] = this._observer10.getValues();

            var d11 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[10] = d11;
            this._observer11 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T11))(this._gate, this, 10, d11);
            this.getQueues()[10] = this._observer11.getValues();

            var d12 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[11] = d12;
            this._observer12 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T12))(this._gate, this, 11, d12);
            this.getQueues()[11] = this._observer12.getValues();

            d1.setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            d2.setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            d3.setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            d4.setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            d5.setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            d6.setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            d7.setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            d8.setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));
            d9.setDisposable(System.ObservableExtensions.subscribeSafe(T9, this._parent._source9, this._observer9));
            d10.setDisposable(System.ObservableExtensions.subscribeSafe(T10, this._parent._source10, this._observer10));
            d11.setDisposable(System.ObservableExtensions.subscribeSafe(T11, this._parent._source11, this._observer11));
            d12.setDisposable(System.ObservableExtensions.subscribeSafe(T12, this._parent._source12, this._observer12));

            disposables[12] = System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Zip$13._.f1));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(disposables);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValues().dequeue(), this._observer2.getValues().dequeue(), this._observer3.getValues().dequeue(), this._observer4.getValues().dequeue(), this._observer5.getValues().dequeue(), this._observer6.getValues().dequeue(), this._observer7.getValues().dequeue(), this._observer8.getValues().dequeue(), this._observer9.getValues().dequeue(), this._observer10.getValues().dequeue(), this._observer11.getValues().dequeue(), this._observer12.getValues().dequeue());
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Zip$13._", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Zip$13._, {
        f1: function () {
            this._observer1.getValues().clear();
            this._observer2.getValues().clear();
            this._observer3.getValues().clear();
            this._observer4.getValues().clear();
            this._observer5.getValues().clear();
            this._observer6.getValues().clear();
            this._observer7.getValues().clear();
            this._observer8.getValues().clear();
            this._observer9.getValues().clear();
            this._observer10.getValues().clear();
            this._observer11.getValues().clear();
            this._observer12.getValues().clear();
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$14._", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        _observer9: null,
        _observer10: null,
        _observer11: null,
        _observer12: null,
        _observer13: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult).ctor.call(this, 13, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var disposables = System.Array.init(14, null);

            var d1 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[0] = d1;
            this._observer1 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T1))(this._gate, this, 0, d1);
            this.getQueues()[0] = this._observer1.getValues();

            var d2 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[1] = d2;
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T2))(this._gate, this, 1, d2);
            this.getQueues()[1] = this._observer2.getValues();

            var d3 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[2] = d3;
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T3))(this._gate, this, 2, d3);
            this.getQueues()[2] = this._observer3.getValues();

            var d4 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[3] = d4;
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T4))(this._gate, this, 3, d4);
            this.getQueues()[3] = this._observer4.getValues();

            var d5 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[4] = d5;
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T5))(this._gate, this, 4, d5);
            this.getQueues()[4] = this._observer5.getValues();

            var d6 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[5] = d6;
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T6))(this._gate, this, 5, d6);
            this.getQueues()[5] = this._observer6.getValues();

            var d7 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[6] = d7;
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T7))(this._gate, this, 6, d7);
            this.getQueues()[6] = this._observer7.getValues();

            var d8 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[7] = d8;
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T8))(this._gate, this, 7, d8);
            this.getQueues()[7] = this._observer8.getValues();

            var d9 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[8] = d9;
            this._observer9 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T9))(this._gate, this, 8, d9);
            this.getQueues()[8] = this._observer9.getValues();

            var d10 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[9] = d10;
            this._observer10 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T10))(this._gate, this, 9, d10);
            this.getQueues()[9] = this._observer10.getValues();

            var d11 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[10] = d11;
            this._observer11 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T11))(this._gate, this, 10, d11);
            this.getQueues()[10] = this._observer11.getValues();

            var d12 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[11] = d12;
            this._observer12 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T12))(this._gate, this, 11, d12);
            this.getQueues()[11] = this._observer12.getValues();

            var d13 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[12] = d13;
            this._observer13 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T13))(this._gate, this, 12, d13);
            this.getQueues()[12] = this._observer13.getValues();

            d1.setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            d2.setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            d3.setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            d4.setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            d5.setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            d6.setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            d7.setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            d8.setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));
            d9.setDisposable(System.ObservableExtensions.subscribeSafe(T9, this._parent._source9, this._observer9));
            d10.setDisposable(System.ObservableExtensions.subscribeSafe(T10, this._parent._source10, this._observer10));
            d11.setDisposable(System.ObservableExtensions.subscribeSafe(T11, this._parent._source11, this._observer11));
            d12.setDisposable(System.ObservableExtensions.subscribeSafe(T12, this._parent._source12, this._observer12));
            d13.setDisposable(System.ObservableExtensions.subscribeSafe(T13, this._parent._source13, this._observer13));

            disposables[13] = System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Zip$14._.f1));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(disposables);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValues().dequeue(), this._observer2.getValues().dequeue(), this._observer3.getValues().dequeue(), this._observer4.getValues().dequeue(), this._observer5.getValues().dequeue(), this._observer6.getValues().dequeue(), this._observer7.getValues().dequeue(), this._observer8.getValues().dequeue(), this._observer9.getValues().dequeue(), this._observer10.getValues().dequeue(), this._observer11.getValues().dequeue(), this._observer12.getValues().dequeue(), this._observer13.getValues().dequeue());
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Zip$14._", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Zip$14._, {
        f1: function () {
            this._observer1.getValues().clear();
            this._observer2.getValues().clear();
            this._observer3.getValues().clear();
            this._observer4.getValues().clear();
            this._observer5.getValues().clear();
            this._observer6.getValues().clear();
            this._observer7.getValues().clear();
            this._observer8.getValues().clear();
            this._observer9.getValues().clear();
            this._observer10.getValues().clear();
            this._observer11.getValues().clear();
            this._observer12.getValues().clear();
            this._observer13.getValues().clear();
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$15._", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        _observer9: null,
        _observer10: null,
        _observer11: null,
        _observer12: null,
        _observer13: null,
        _observer14: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult).ctor.call(this, 14, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var disposables = System.Array.init(15, null);

            var d1 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[0] = d1;
            this._observer1 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T1))(this._gate, this, 0, d1);
            this.getQueues()[0] = this._observer1.getValues();

            var d2 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[1] = d2;
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T2))(this._gate, this, 1, d2);
            this.getQueues()[1] = this._observer2.getValues();

            var d3 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[2] = d3;
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T3))(this._gate, this, 2, d3);
            this.getQueues()[2] = this._observer3.getValues();

            var d4 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[3] = d4;
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T4))(this._gate, this, 3, d4);
            this.getQueues()[3] = this._observer4.getValues();

            var d5 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[4] = d5;
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T5))(this._gate, this, 4, d5);
            this.getQueues()[4] = this._observer5.getValues();

            var d6 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[5] = d6;
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T6))(this._gate, this, 5, d6);
            this.getQueues()[5] = this._observer6.getValues();

            var d7 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[6] = d7;
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T7))(this._gate, this, 6, d7);
            this.getQueues()[6] = this._observer7.getValues();

            var d8 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[7] = d8;
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T8))(this._gate, this, 7, d8);
            this.getQueues()[7] = this._observer8.getValues();

            var d9 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[8] = d9;
            this._observer9 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T9))(this._gate, this, 8, d9);
            this.getQueues()[8] = this._observer9.getValues();

            var d10 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[9] = d10;
            this._observer10 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T10))(this._gate, this, 9, d10);
            this.getQueues()[9] = this._observer10.getValues();

            var d11 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[10] = d11;
            this._observer11 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T11))(this._gate, this, 10, d11);
            this.getQueues()[10] = this._observer11.getValues();

            var d12 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[11] = d12;
            this._observer12 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T12))(this._gate, this, 11, d12);
            this.getQueues()[11] = this._observer12.getValues();

            var d13 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[12] = d13;
            this._observer13 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T13))(this._gate, this, 12, d13);
            this.getQueues()[12] = this._observer13.getValues();

            var d14 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[13] = d14;
            this._observer14 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T14))(this._gate, this, 13, d14);
            this.getQueues()[13] = this._observer14.getValues();

            d1.setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            d2.setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            d3.setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            d4.setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            d5.setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            d6.setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            d7.setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            d8.setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));
            d9.setDisposable(System.ObservableExtensions.subscribeSafe(T9, this._parent._source9, this._observer9));
            d10.setDisposable(System.ObservableExtensions.subscribeSafe(T10, this._parent._source10, this._observer10));
            d11.setDisposable(System.ObservableExtensions.subscribeSafe(T11, this._parent._source11, this._observer11));
            d12.setDisposable(System.ObservableExtensions.subscribeSafe(T12, this._parent._source12, this._observer12));
            d13.setDisposable(System.ObservableExtensions.subscribeSafe(T13, this._parent._source13, this._observer13));
            d14.setDisposable(System.ObservableExtensions.subscribeSafe(T14, this._parent._source14, this._observer14));

            disposables[14] = System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Zip$15._.f1));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(disposables);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValues().dequeue(), this._observer2.getValues().dequeue(), this._observer3.getValues().dequeue(), this._observer4.getValues().dequeue(), this._observer5.getValues().dequeue(), this._observer6.getValues().dequeue(), this._observer7.getValues().dequeue(), this._observer8.getValues().dequeue(), this._observer9.getValues().dequeue(), this._observer10.getValues().dequeue(), this._observer11.getValues().dequeue(), this._observer12.getValues().dequeue(), this._observer13.getValues().dequeue(), this._observer14.getValues().dequeue());
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Zip$15._", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Zip$15._, {
        f1: function () {
            this._observer1.getValues().clear();
            this._observer2.getValues().clear();
            this._observer3.getValues().clear();
            this._observer4.getValues().clear();
            this._observer5.getValues().clear();
            this._observer6.getValues().clear();
            this._observer7.getValues().clear();
            this._observer8.getValues().clear();
            this._observer9.getValues().clear();
            this._observer10.getValues().clear();
            this._observer11.getValues().clear();
            this._observer12.getValues().clear();
            this._observer13.getValues().clear();
            this._observer14.getValues().clear();
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$16._", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        _observer9: null,
        _observer10: null,
        _observer11: null,
        _observer12: null,
        _observer13: null,
        _observer14: null,
        _observer15: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult).ctor.call(this, 15, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var disposables = System.Array.init(16, null);

            var d1 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[0] = d1;
            this._observer1 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T1))(this._gate, this, 0, d1);
            this.getQueues()[0] = this._observer1.getValues();

            var d2 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[1] = d2;
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T2))(this._gate, this, 1, d2);
            this.getQueues()[1] = this._observer2.getValues();

            var d3 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[2] = d3;
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T3))(this._gate, this, 2, d3);
            this.getQueues()[2] = this._observer3.getValues();

            var d4 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[3] = d4;
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T4))(this._gate, this, 3, d4);
            this.getQueues()[3] = this._observer4.getValues();

            var d5 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[4] = d5;
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T5))(this._gate, this, 4, d5);
            this.getQueues()[4] = this._observer5.getValues();

            var d6 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[5] = d6;
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T6))(this._gate, this, 5, d6);
            this.getQueues()[5] = this._observer6.getValues();

            var d7 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[6] = d7;
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T7))(this._gate, this, 6, d7);
            this.getQueues()[6] = this._observer7.getValues();

            var d8 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[7] = d8;
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T8))(this._gate, this, 7, d8);
            this.getQueues()[7] = this._observer8.getValues();

            var d9 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[8] = d9;
            this._observer9 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T9))(this._gate, this, 8, d9);
            this.getQueues()[8] = this._observer9.getValues();

            var d10 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[9] = d10;
            this._observer10 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T10))(this._gate, this, 9, d10);
            this.getQueues()[9] = this._observer10.getValues();

            var d11 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[10] = d11;
            this._observer11 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T11))(this._gate, this, 10, d11);
            this.getQueues()[10] = this._observer11.getValues();

            var d12 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[11] = d12;
            this._observer12 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T12))(this._gate, this, 11, d12);
            this.getQueues()[11] = this._observer12.getValues();

            var d13 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[12] = d13;
            this._observer13 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T13))(this._gate, this, 12, d13);
            this.getQueues()[12] = this._observer13.getValues();

            var d14 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[13] = d14;
            this._observer14 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T14))(this._gate, this, 13, d14);
            this.getQueues()[13] = this._observer14.getValues();

            var d15 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[14] = d15;
            this._observer15 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T15))(this._gate, this, 14, d15);
            this.getQueues()[14] = this._observer15.getValues();

            d1.setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            d2.setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            d3.setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            d4.setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            d5.setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            d6.setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            d7.setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            d8.setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));
            d9.setDisposable(System.ObservableExtensions.subscribeSafe(T9, this._parent._source9, this._observer9));
            d10.setDisposable(System.ObservableExtensions.subscribeSafe(T10, this._parent._source10, this._observer10));
            d11.setDisposable(System.ObservableExtensions.subscribeSafe(T11, this._parent._source11, this._observer11));
            d12.setDisposable(System.ObservableExtensions.subscribeSafe(T12, this._parent._source12, this._observer12));
            d13.setDisposable(System.ObservableExtensions.subscribeSafe(T13, this._parent._source13, this._observer13));
            d14.setDisposable(System.ObservableExtensions.subscribeSafe(T14, this._parent._source14, this._observer14));
            d15.setDisposable(System.ObservableExtensions.subscribeSafe(T15, this._parent._source15, this._observer15));

            disposables[15] = System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Zip$16._.f1));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(disposables);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValues().dequeue(), this._observer2.getValues().dequeue(), this._observer3.getValues().dequeue(), this._observer4.getValues().dequeue(), this._observer5.getValues().dequeue(), this._observer6.getValues().dequeue(), this._observer7.getValues().dequeue(), this._observer8.getValues().dequeue(), this._observer9.getValues().dequeue(), this._observer10.getValues().dequeue(), this._observer11.getValues().dequeue(), this._observer12.getValues().dequeue(), this._observer13.getValues().dequeue(), this._observer14.getValues().dequeue(), this._observer15.getValues().dequeue());
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Zip$16._", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Zip$16._, {
        f1: function () {
            this._observer1.getValues().clear();
            this._observer2.getValues().clear();
            this._observer3.getValues().clear();
            this._observer4.getValues().clear();
            this._observer5.getValues().clear();
            this._observer6.getValues().clear();
            this._observer7.getValues().clear();
            this._observer8.getValues().clear();
            this._observer9.getValues().clear();
            this._observer10.getValues().clear();
            this._observer11.getValues().clear();
            this._observer12.getValues().clear();
            this._observer13.getValues().clear();
            this._observer14.getValues().clear();
            this._observer15.getValues().clear();
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$17._", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        _observer9: null,
        _observer10: null,
        _observer11: null,
        _observer12: null,
        _observer13: null,
        _observer14: null,
        _observer15: null,
        _observer16: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult).ctor.call(this, 16, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var disposables = System.Array.init(17, null);

            var d1 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[0] = d1;
            this._observer1 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T1))(this._gate, this, 0, d1);
            this.getQueues()[0] = this._observer1.getValues();

            var d2 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[1] = d2;
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T2))(this._gate, this, 1, d2);
            this.getQueues()[1] = this._observer2.getValues();

            var d3 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[2] = d3;
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T3))(this._gate, this, 2, d3);
            this.getQueues()[2] = this._observer3.getValues();

            var d4 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[3] = d4;
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T4))(this._gate, this, 3, d4);
            this.getQueues()[3] = this._observer4.getValues();

            var d5 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[4] = d5;
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T5))(this._gate, this, 4, d5);
            this.getQueues()[4] = this._observer5.getValues();

            var d6 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[5] = d6;
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T6))(this._gate, this, 5, d6);
            this.getQueues()[5] = this._observer6.getValues();

            var d7 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[6] = d7;
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T7))(this._gate, this, 6, d7);
            this.getQueues()[6] = this._observer7.getValues();

            var d8 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[7] = d8;
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T8))(this._gate, this, 7, d8);
            this.getQueues()[7] = this._observer8.getValues();

            var d9 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[8] = d9;
            this._observer9 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T9))(this._gate, this, 8, d9);
            this.getQueues()[8] = this._observer9.getValues();

            var d10 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[9] = d10;
            this._observer10 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T10))(this._gate, this, 9, d10);
            this.getQueues()[9] = this._observer10.getValues();

            var d11 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[10] = d11;
            this._observer11 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T11))(this._gate, this, 10, d11);
            this.getQueues()[10] = this._observer11.getValues();

            var d12 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[11] = d12;
            this._observer12 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T12))(this._gate, this, 11, d12);
            this.getQueues()[11] = this._observer12.getValues();

            var d13 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[12] = d13;
            this._observer13 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T13))(this._gate, this, 12, d13);
            this.getQueues()[12] = this._observer13.getValues();

            var d14 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[13] = d14;
            this._observer14 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T14))(this._gate, this, 13, d14);
            this.getQueues()[13] = this._observer14.getValues();

            var d15 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[14] = d15;
            this._observer15 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T15))(this._gate, this, 14, d15);
            this.getQueues()[14] = this._observer15.getValues();

            var d16 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[15] = d16;
            this._observer16 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T16))(this._gate, this, 15, d16);
            this.getQueues()[15] = this._observer16.getValues();

            d1.setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            d2.setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            d3.setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            d4.setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            d5.setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            d6.setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            d7.setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            d8.setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));
            d9.setDisposable(System.ObservableExtensions.subscribeSafe(T9, this._parent._source9, this._observer9));
            d10.setDisposable(System.ObservableExtensions.subscribeSafe(T10, this._parent._source10, this._observer10));
            d11.setDisposable(System.ObservableExtensions.subscribeSafe(T11, this._parent._source11, this._observer11));
            d12.setDisposable(System.ObservableExtensions.subscribeSafe(T12, this._parent._source12, this._observer12));
            d13.setDisposable(System.ObservableExtensions.subscribeSafe(T13, this._parent._source13, this._observer13));
            d14.setDisposable(System.ObservableExtensions.subscribeSafe(T14, this._parent._source14, this._observer14));
            d15.setDisposable(System.ObservableExtensions.subscribeSafe(T15, this._parent._source15, this._observer15));
            d16.setDisposable(System.ObservableExtensions.subscribeSafe(T16, this._parent._source16, this._observer16));

            disposables[16] = System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Zip$17._.f1));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(disposables);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValues().dequeue(), this._observer2.getValues().dequeue(), this._observer3.getValues().dequeue(), this._observer4.getValues().dequeue(), this._observer5.getValues().dequeue(), this._observer6.getValues().dequeue(), this._observer7.getValues().dequeue(), this._observer8.getValues().dequeue(), this._observer9.getValues().dequeue(), this._observer10.getValues().dequeue(), this._observer11.getValues().dequeue(), this._observer12.getValues().dequeue(), this._observer13.getValues().dequeue(), this._observer14.getValues().dequeue(), this._observer15.getValues().dequeue(), this._observer16.getValues().dequeue());
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Zip$17._", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Zip$17._, {
        f1: function () {
            this._observer1.getValues().clear();
            this._observer2.getValues().clear();
            this._observer3.getValues().clear();
            this._observer4.getValues().clear();
            this._observer5.getValues().clear();
            this._observer6.getValues().clear();
            this._observer7.getValues().clear();
            this._observer8.getValues().clear();
            this._observer9.getValues().clear();
            this._observer10.getValues().clear();
            this._observer11.getValues().clear();
            this._observer12.getValues().clear();
            this._observer13.getValues().clear();
            this._observer14.getValues().clear();
            this._observer15.getValues().clear();
            this._observer16.getValues().clear();
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$4._", function (T1, T2, T3, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult).ctor.call(this, 3, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var disposables = System.Array.init(4, null);

            var d1 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[0] = d1;
            this._observer1 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T1))(this._gate, this, 0, d1);
            this.getQueues()[0] = this._observer1.getValues();

            var d2 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[1] = d2;
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T2))(this._gate, this, 1, d2);
            this.getQueues()[1] = this._observer2.getValues();

            var d3 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[2] = d3;
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T3))(this._gate, this, 2, d3);
            this.getQueues()[2] = this._observer3.getValues();

            d1.setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            d2.setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            d3.setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));

            disposables[3] = System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Zip$4._.f1));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(disposables);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValues().dequeue(), this._observer2.getValues().dequeue(), this._observer3.getValues().dequeue());
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Zip$4._", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Zip$4._, {
        f1: function () {
            this._observer1.getValues().clear();
            this._observer2.getValues().clear();
            this._observer3.getValues().clear();
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$5._", function (T1, T2, T3, T4, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult).ctor.call(this, 4, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var disposables = System.Array.init(5, null);

            var d1 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[0] = d1;
            this._observer1 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T1))(this._gate, this, 0, d1);
            this.getQueues()[0] = this._observer1.getValues();

            var d2 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[1] = d2;
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T2))(this._gate, this, 1, d2);
            this.getQueues()[1] = this._observer2.getValues();

            var d3 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[2] = d3;
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T3))(this._gate, this, 2, d3);
            this.getQueues()[2] = this._observer3.getValues();

            var d4 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[3] = d4;
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T4))(this._gate, this, 3, d4);
            this.getQueues()[3] = this._observer4.getValues();

            d1.setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            d2.setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            d3.setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            d4.setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));

            disposables[4] = System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Zip$5._.f1));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(disposables);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValues().dequeue(), this._observer2.getValues().dequeue(), this._observer3.getValues().dequeue(), this._observer4.getValues().dequeue());
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Zip$5._", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Zip$5._, {
        f1: function () {
            this._observer1.getValues().clear();
            this._observer2.getValues().clear();
            this._observer3.getValues().clear();
            this._observer4.getValues().clear();
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$6._", function (T1, T2, T3, T4, T5, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult).ctor.call(this, 5, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var disposables = System.Array.init(6, null);

            var d1 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[0] = d1;
            this._observer1 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T1))(this._gate, this, 0, d1);
            this.getQueues()[0] = this._observer1.getValues();

            var d2 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[1] = d2;
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T2))(this._gate, this, 1, d2);
            this.getQueues()[1] = this._observer2.getValues();

            var d3 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[2] = d3;
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T3))(this._gate, this, 2, d3);
            this.getQueues()[2] = this._observer3.getValues();

            var d4 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[3] = d4;
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T4))(this._gate, this, 3, d4);
            this.getQueues()[3] = this._observer4.getValues();

            var d5 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[4] = d5;
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T5))(this._gate, this, 4, d5);
            this.getQueues()[4] = this._observer5.getValues();

            d1.setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            d2.setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            d3.setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            d4.setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            d5.setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));

            disposables[5] = System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Zip$6._.f1));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(disposables);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValues().dequeue(), this._observer2.getValues().dequeue(), this._observer3.getValues().dequeue(), this._observer4.getValues().dequeue(), this._observer5.getValues().dequeue());
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Zip$6._", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Zip$6._, {
        f1: function () {
            this._observer1.getValues().clear();
            this._observer2.getValues().clear();
            this._observer3.getValues().clear();
            this._observer4.getValues().clear();
            this._observer5.getValues().clear();
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$7._", function (T1, T2, T3, T4, T5, T6, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult).ctor.call(this, 6, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var disposables = System.Array.init(7, null);

            var d1 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[0] = d1;
            this._observer1 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T1))(this._gate, this, 0, d1);
            this.getQueues()[0] = this._observer1.getValues();

            var d2 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[1] = d2;
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T2))(this._gate, this, 1, d2);
            this.getQueues()[1] = this._observer2.getValues();

            var d3 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[2] = d3;
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T3))(this._gate, this, 2, d3);
            this.getQueues()[2] = this._observer3.getValues();

            var d4 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[3] = d4;
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T4))(this._gate, this, 3, d4);
            this.getQueues()[3] = this._observer4.getValues();

            var d5 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[4] = d5;
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T5))(this._gate, this, 4, d5);
            this.getQueues()[4] = this._observer5.getValues();

            var d6 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[5] = d6;
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T6))(this._gate, this, 5, d6);
            this.getQueues()[5] = this._observer6.getValues();

            d1.setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            d2.setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            d3.setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            d4.setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            d5.setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            d6.setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));

            disposables[6] = System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Zip$7._.f1));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(disposables);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValues().dequeue(), this._observer2.getValues().dequeue(), this._observer3.getValues().dequeue(), this._observer4.getValues().dequeue(), this._observer5.getValues().dequeue(), this._observer6.getValues().dequeue());
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Zip$7._", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Zip$7._, {
        f1: function () {
            this._observer1.getValues().clear();
            this._observer2.getValues().clear();
            this._observer3.getValues().clear();
            this._observer4.getValues().clear();
            this._observer5.getValues().clear();
            this._observer6.getValues().clear();
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$8._", function (T1, T2, T3, T4, T5, T6, T7, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult).ctor.call(this, 7, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var disposables = System.Array.init(8, null);

            var d1 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[0] = d1;
            this._observer1 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T1))(this._gate, this, 0, d1);
            this.getQueues()[0] = this._observer1.getValues();

            var d2 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[1] = d2;
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T2))(this._gate, this, 1, d2);
            this.getQueues()[1] = this._observer2.getValues();

            var d3 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[2] = d3;
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T3))(this._gate, this, 2, d3);
            this.getQueues()[2] = this._observer3.getValues();

            var d4 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[3] = d4;
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T4))(this._gate, this, 3, d4);
            this.getQueues()[3] = this._observer4.getValues();

            var d5 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[4] = d5;
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T5))(this._gate, this, 4, d5);
            this.getQueues()[4] = this._observer5.getValues();

            var d6 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[5] = d6;
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T6))(this._gate, this, 5, d6);
            this.getQueues()[5] = this._observer6.getValues();

            var d7 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[6] = d7;
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T7))(this._gate, this, 6, d7);
            this.getQueues()[6] = this._observer7.getValues();

            d1.setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            d2.setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            d3.setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            d4.setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            d5.setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            d6.setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            d7.setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));

            disposables[7] = System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Zip$8._.f1));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(disposables);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValues().dequeue(), this._observer2.getValues().dequeue(), this._observer3.getValues().dequeue(), this._observer4.getValues().dequeue(), this._observer5.getValues().dequeue(), this._observer6.getValues().dequeue(), this._observer7.getValues().dequeue());
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Zip$8._", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Zip$8._, {
        f1: function () {
            this._observer1.getValues().clear();
            this._observer2.getValues().clear();
            this._observer3.getValues().clear();
            this._observer4.getValues().clear();
            this._observer5.getValues().clear();
            this._observer6.getValues().clear();
            this._observer7.getValues().clear();
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$9._", function (T1, T2, T3, T4, T5, T6, T7, T8, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult)],
        _parent: null,
        _observer1: null,
        _observer2: null,
        _observer3: null,
        _observer4: null,
        _observer5: null,
        _observer6: null,
        _observer7: null,
        _observer8: null,
        ctor: function (parent, observer, cancel) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ZipSink$1(TResult).ctor.call(this, 8, observer, cancel);
            this._parent = parent;
        },
        run: function () {
            var disposables = System.Array.init(9, null);

            var d1 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[0] = d1;
            this._observer1 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T1))(this._gate, this, 0, d1);
            this.getQueues()[0] = this._observer1.getValues();

            var d2 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[1] = d2;
            this._observer2 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T2))(this._gate, this, 1, d2);
            this.getQueues()[1] = this._observer2.getValues();

            var d3 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[2] = d3;
            this._observer3 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T3))(this._gate, this, 2, d3);
            this.getQueues()[2] = this._observer3.getValues();

            var d4 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[3] = d4;
            this._observer4 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T4))(this._gate, this, 3, d4);
            this.getQueues()[3] = this._observer4.getValues();

            var d5 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[4] = d5;
            this._observer5 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T5))(this._gate, this, 4, d5);
            this.getQueues()[4] = this._observer5.getValues();

            var d6 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[5] = d6;
            this._observer6 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T6))(this._gate, this, 5, d6);
            this.getQueues()[5] = this._observer6.getValues();

            var d7 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[6] = d7;
            this._observer7 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T7))(this._gate, this, 6, d7);
            this.getQueues()[6] = this._observer7.getValues();

            var d8 = new System.Reactive.Disposables.SingleAssignmentDisposable();
            disposables[7] = d8;
            this._observer8 = new (System.Reactive.Linq.ObservableImpl.ZipObserver$1(T8))(this._gate, this, 7, d8);
            this.getQueues()[7] = this._observer8.getValues();

            d1.setDisposable(System.ObservableExtensions.subscribeSafe(T1, this._parent._source1, this._observer1));
            d2.setDisposable(System.ObservableExtensions.subscribeSafe(T2, this._parent._source2, this._observer2));
            d3.setDisposable(System.ObservableExtensions.subscribeSafe(T3, this._parent._source3, this._observer3));
            d4.setDisposable(System.ObservableExtensions.subscribeSafe(T4, this._parent._source4, this._observer4));
            d5.setDisposable(System.ObservableExtensions.subscribeSafe(T5, this._parent._source5, this._observer5));
            d6.setDisposable(System.ObservableExtensions.subscribeSafe(T6, this._parent._source6, this._observer6));
            d7.setDisposable(System.ObservableExtensions.subscribeSafe(T7, this._parent._source7, this._observer7));
            d8.setDisposable(System.ObservableExtensions.subscribeSafe(T8, this._parent._source8, this._observer8));

            disposables[8] = System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, $asm.$.System.Reactive.Linq.ObservableImpl.Zip$9._.f1));

            return System.Reactive.Disposables.StableCompositeDisposable.create$2(disposables);
        },
        getResult: function () {
            return this._parent._resultSelector(this._observer1.getValues().dequeue(), this._observer2.getValues().dequeue(), this._observer3.getValues().dequeue(), this._observer4.getValues().dequeue(), this._observer5.getValues().dequeue(), this._observer6.getValues().dequeue(), this._observer7.getValues().dequeue(), this._observer8.getValues().dequeue());
        }
    }; });

    Bridge.ns("System.Reactive.Linq.ObservableImpl.Zip$9._", $asm.$);

    Bridge.apply($asm.$.System.Reactive.Linq.ObservableImpl.Zip$9._, {
        f1: function () {
            this._observer1.getValues().clear();
            this._observer2.getValues().clear();
            this._observer3.getValues().clear();
            this._observer4.getValues().clear();
            this._observer5.getValues().clear();
            this._observer6.getValues().clear();
            this._observer7.getValues().clear();
            this._observer8.getValues().clear();
        }
    });

    Bridge.define("System.Reactive.ScheduledObserver$1", function (T) { return {
        inherits: [System.Reactive.ObserverBase$1(T),System.Reactive.IScheduledObserver$1(T)],
        _isAcquired: false,
        _hasFaulted: false,
        _queue: null,
        _observer: null,
        _scheduler: null,
        _disposable: null,
        config: {
            alias: [
            "ensureActive$1", "System$Reactive$IScheduledObserver$1$" + Bridge.getTypeAlias(T) + "$ensureActive$1",
            "ensureActive", "System$Reactive$IScheduledObserver$1$" + Bridge.getTypeAlias(T) + "$ensureActive",
            "dispose", "System$IDisposable$dispose"
            ],
            init: function () {
                this._queue = new (System.Collections.Generic.Queue$1(Function)).ctor();
                this._disposable = new System.Reactive.Disposables.SerialDisposable();
            }
        },
        ctor: function (scheduler, observer) {
            this.$initialize();
            System.Reactive.ObserverBase$1(T).ctor.call(this);
            this._scheduler = scheduler;
            this._observer = observer;
        },
        ensureActive$1: function (n) {
            this.ensureActive();
        },
        ensureActive: function () {
            var isOwner = false;

            this._queue;
            {
                if (!this._hasFaulted && this._queue.getCount() > 0) {
                    isOwner = !this._isAcquired;
                    this._isAcquired = true;
                }
            }

            if (isOwner) {
                this._disposable.setDisposable(System.Reactive.Concurrency.Scheduler.schedule$6(Object, this._scheduler, null, Bridge.fn.bind(this, this.run)));
            }
        },
        run: function (state, recurse) {
            var work = null;
            this._queue;
            {
                if (this._queue.getCount() > 0) {
                    work = this._queue.dequeue();
                } else {
                    this._isAcquired = false;
                    return;
                }
            }

            try {
                work();
            }
            catch ($e1) {
                $e1 = System.Exception.create($e1);
                this._queue;
                {
                    this._queue.clear();
                    this._hasFaulted = true;
                }
                throw $e1;
            }

            recurse(state);
        },
        onNextCore: function (value) {
            this._queue;
            this._queue.enqueue(Bridge.fn.bind(this, function () {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](value);
            }));
        },
        onErrorCore: function (exception) {
            this._queue;
            this._queue.enqueue(Bridge.fn.bind(this, function () {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](exception);
            }));
        },
        onCompletedCore: function () {
            this._queue;
            this._queue.enqueue(Bridge.fn.bind(this, function () {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
            }));
        },
        dispose$1: function (disposing) {
            System.Reactive.ObserverBase$1(T).prototype.dispose$1.call(this, disposing);

            if (disposing) {
                this._disposable.dispose();
            }
        }
    }; });

    Bridge.define("System.Reactive.PlatformServices.DefaultSystemClockMonitor", {
        inherits: [System.Reactive.PlatformServices.PeriodicTimerSystemClockMonitor],
        statics: {
            config: {
                init: function () {
                    this.DEFAULT_PERIOD = System.TimeSpan.fromSeconds(1) || new System.TimeSpan();
                }
            }
        },
        ctor: function () {
            this.$initialize();
            System.Reactive.PlatformServices.PeriodicTimerSystemClockMonitor.ctor.call(this, System.Reactive.PlatformServices.DefaultSystemClockMonitor.DEFAULT_PERIOD);
        }
    });

    /**
     * Represents an object that is both an observable sequence as well as an observer.
     *
     * @abstract
     * @public
     * @class System.Reactive.Subjects.ISubject$1
     * @implements  System.Reactive.Subjects.ISubject$2
     * @param   {Function}    [name]    The type of the elements processed by the subject.
     */
    Bridge.definei("System.Reactive.Subjects.ISubject$1", function (T) { return {
        inherits: [System.Reactive.Subjects.ISubject$2(T,T)],
        $kind: "interface"
    }; });

    /**
     * Represents an observable wrapper that can be connected and disconnected from its underlying observable sequence.
     *
     * @class System.Reactive.Subjects.ConnectableObservable$2
     * @implements  System.Reactive.Subjects.IConnectableObservable$1
     * @param   {Function}    [name]    The type of the elements in the source sequence.
     * @param   {Function}    [name]    The type of the elements in the resulting sequence, after transformation through the subject.
     */
    Bridge.define("System.Reactive.Subjects.ConnectableObservable$2", function (TSource, TResult) { return {
        inherits: [System.Reactive.Subjects.IConnectableObservable$1(TResult)],
        _subject: null,
        _source: null,
        _gate: null,
        _connection: null,
        config: {
            alias: [
            "connect", "System$Reactive$Subjects$IConnectableObservable$1$" + Bridge.getTypeAlias(TResult) + "$connect",
            "subscribe", "System$IObservable$1$" + Bridge.getTypeAlias(TResult) + "$subscribe"
            ]
        },
        /**
         * Creates an observable that can be connected and disconnected from its source.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.ConnectableObservable$2
         * @memberof System.Reactive.Subjects.ConnectableObservable$2
         * @param   {System.IObservable$1}                   source     Underlying observable source sequence that can be connected and disconnected from the wrapper.
         * @param   {System.Reactive.Subjects.ISubject$2}    subject    Subject exposed by the connectable observable, receiving data from the underlying source sequence upon connection.
         * @return  {void}
         */
        ctor: function (source, subject) {
            this.$initialize();
            this._subject = subject;
            this._source = System.Reactive.Linq.Observable.asObservable(TSource, source); // This gets us auto-detach behavior; otherwise, we'd have to roll our own, including trampoline installation.
            this._gate = {  };
        },
        /**
         * Connects the observable wrapper to its source. All subscribed observers will receive values from the underlying observable sequence as long as the connection is established.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.ConnectableObservable$2
         * @memberof System.Reactive.Subjects.ConnectableObservable$2
         * @return  {System.IDisposable}        Disposable object used to disconnect the observable wrapper from its source, causing subscribed observer to stop receiving values from the underlying observable sequence.
         */
        connect: function () {
            this._gate;
            {
                if (this._connection == null) {
                    var subscription = System.ObservableExtensions.subscribeSafe(TSource, this._source, this._subject);
                    this._connection = new (System.Reactive.Subjects.ConnectableObservable$2.Connection(TSource,TResult))(this, subscription);
                }

                return this._connection;
            }
        },
        /**
         * Subscribes an observer to the observable sequence. No values from the underlying observable source will be received unless a connection was established through the Connect method.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.ConnectableObservable$2
         * @memberof System.Reactive.Subjects.ConnectableObservable$2
         * @param   {System.IObserver$1}    observer    Observer that will receive values from the underlying observable source when the current ConnectableObservable instance is connected through a call to Connect.
         * @return  {System.IDisposable}                Disposable used to unsubscribe from the observable sequence.
         */
        subscribe: function (observer) {
            if (observer == null) {
                throw new System.ArgumentNullException("observer");
            }

            return System.ObservableExtensions.subscribeSafe(TResult, this._subject, observer);
        }
    }; });

    /**
     * Specialized scheduled observer similar to a scheduled observer for the immediate scheduler.
     *
     * @class System.Reactive.Subjects.FastImmediateObserver$1
     * @implements  System.Reactive.IScheduledObserver$1
     * @param   {Function}    [name]    Type of the elements processed by the observer.
     */
    Bridge.define("System.Reactive.Subjects.FastImmediateObserver$1", function (T) { return {
        inherits: [System.Reactive.IScheduledObserver$1(T)],
        /**
         * Gate to control ownership transfer and protect data structures.
         *
         * @instance
         */
        _gate: null,
        /**
         * Observer to forward notifications to.
         *
         * @instance
         */
        _observer: null,
        /**
         * Queue to enqueue OnNext notifications into.
         *
         * @instance
         */
        _queue: null,
        /**
         * Standby queue to swap out for _queue when transferring ownership. This allows to reuse
         queues in case of busy subjects where the initial replay doesn't suffice to catch up.
         *
         * @instance
         */
        _queue2: null,
        /**
         * Exception passed to an OnError notification, if any.
         *
         * @instance
         */
        _error: null,
        /**
         * Indicates whether an OnCompleted notification was received.
         *
         * @instance
         */
        _done: false,
        /**
         * Indicates whether the observer is busy, i.e. some thread is actively draining the
         notifications that were queued up.
         *
         * @instance
         */
        _busy: false,
        /**
         * Indicates whether a failure occurred when the owner was draining the queue. This will
         prevent future work to be processed.
         *
         * @instance
         */
        _hasFaulted: false,
        config: {
            alias: [
            "dispose", "System$IDisposable$dispose",
            "ensureActive$1", "System$Reactive$IScheduledObserver$1$" + Bridge.getTypeAlias(T) + "$ensureActive",
            "ensureActive", "System$Reactive$IScheduledObserver$1$" + Bridge.getTypeAlias(T) + "$ensureActive$1",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"
            ],
            init: function () {
                this._gate = {  };
                this._queue = new (System.Collections.Generic.Queue$1(T)).ctor();
            }
        },
        /**
         * Creates a new scheduled observer that proxies to the specified observer.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.FastImmediateObserver$1
         * @memberof System.Reactive.Subjects.FastImmediateObserver$1
         * @param   {System.IObserver$1}    observer    Observer to forward notifications to.
         * @return  {void}
         */
        ctor: function (observer) {
            this.$initialize();
            this._observer = observer;
        },
        /**
         * Disposes the observer.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.FastImmediateObserver$1
         * @memberof System.Reactive.Subjects.FastImmediateObserver$1
         * @return  {void}
         */
        dispose: function () {
            this.done();
        },
        /**
         * Notifies the observer of pending work. This will either cause the current owner to
         process the newly enqueued notifications, or it will cause the calling thread to
         become the owner and start processing the notification queue.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.FastImmediateObserver$1
         * @memberof System.Reactive.Subjects.FastImmediateObserver$1
         * @return  {void}
         */
        ensureActive$1: function () {
            this.ensureActive(1);
        },
        /**
         * Notifies the observer of pending work. This will either cause the current owner to
         process the newly enqueued notifications, or it will cause the calling thread to
         become the owner and start processing the notification queue.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.FastImmediateObserver$1
         * @memberof System.Reactive.Subjects.FastImmediateObserver$1
         * @param   {number}    count    The number of enqueued notifications to process (ignored).
         * @return  {void}
         */
        ensureActive: function (count) {
            var isOwner = false;

            this._gate;
            {
                //
                // If we failed to process work in the past, we'll simply drop it.
                //
                if (!this._hasFaulted) {
                    //
                    // If no-one is processing the notification queue, become the owner.
                    //
                    if (!this._busy) {
                        isOwner = true;
                        this._busy = true;
                    }
                }
            }

            if (isOwner) {
                while (true) {
                    var queue = null;
                    var error = null;
                    var done = false;

                    //
                    // Steal notifications from the producer side to drain them to the observer.
                    //
                    this._gate;
                    {
                        //
                        // Do we have any OnNext notifications to process?
                        //
                        if (this._queue.getCount() > 0) {
                            if (this._queue2 == null) {
                                this._queue2 = new (System.Collections.Generic.Queue$1(T)).ctor();
                            }

                            //
                            // Swap out the current queue for a fresh or recycled one. The standby
                            // queue is set to null; when notifications are sent out the processed
                            // queue will become the new standby.
                            //
                            queue = this._queue;
                            this._queue = this._queue2;
                            this._queue2 = null;
                        }

                        //
                        // Do we have any terminal notifications to process?
                        //
                        if (this._error != null) {
                            error = this._error;
                        } else if (this._done) {
                            done = true;
                        } else if (queue == null) {
                            //
                            // No work left; quit the loop and let another thread become the
                            // owner in the future.
                            //
                            this._busy = false;
                            break;
                        }
                    }

                    try {
                        //
                        // Process OnNext notifications, if any.
                        //
                        if (queue != null) {
                            //
                            // Drain the stolen OnNext notification queue.
                            //
                            while (queue.getCount() > 0) {
                                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](queue.dequeue());
                            }

                            //
                            // The queue is now empty, so we can reuse it by making it the standby
                            // queue for a future swap.
                            //
                            this._gate;
                            {
                                this._queue2 = queue;
                            }
                        }

                        //
                        // Process terminal notifications, if any. Notice we don't release ownership
                        // after processing these notifications; we simply quit from the loop. This
                        // will cause all processing of the scheduler observer to cease.
                        //
                        if (error != null) {
                            var observer = this.done();
                            observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](error);
                            break;
                        } else if (done) {
                            var observer1 = this.done();
                            observer1["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
                            break;
                        }
                    }
                    catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        this._gate;
                        {
                            this._hasFaulted = true;
                            this._queue.clear();
                        }

                        throw $e1;
                    }
                }
            }
        },
        /**
         * Enqueues an OnCompleted notification.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.FastImmediateObserver$1
         * @memberof System.Reactive.Subjects.FastImmediateObserver$1
         * @return  {void}
         */
        onCompleted: function () {
            this._gate;
            {
                if (!this._hasFaulted) {
                    this._done = true;
                }
            }
        },
        /**
         * Enqueues an OnError notification.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.FastImmediateObserver$1
         * @memberof System.Reactive.Subjects.FastImmediateObserver$1
         * @param   {System.Exception}    error    Error of the notification.
         * @return  {void}
         */
        onError: function (error) {
            this._gate;
            {
                if (!this._hasFaulted) {
                    this._error = error;
                }
            }
        },
        /**
         * Enqueues an OnNext notification.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.FastImmediateObserver$1
         * @memberof System.Reactive.Subjects.FastImmediateObserver$1
         * @param   {T}       value    Value of the notification.
         * @return  {void}
         */
        onNext: function (value) {
            this._gate;
            {
                if (!this._hasFaulted) {
                    this._queue.enqueue(value);
                }
            }
        },
        /**
         * Terminates the observer upon receiving terminal notifications, thus preventing
         future notifications to go out.
         *
         * @instance
         * @private
         * @this System.Reactive.Subjects.FastImmediateObserver$1
         * @memberof System.Reactive.Subjects.FastImmediateObserver$1
         * @return  {System.IObserver$1}        Observer to send terminal notifications to.
         */
        done: function () {
            return System.Interlocked.exchange(System.IObserver$1(T), Bridge.ref(this, "_observer"), System.Reactive.NopObserver$1(T).instance);
        }
    }; });

    Bridge.define("System.Reactive.Subjects.Subject.AnonymousSubject$2", function (T, U) { return {
        inherits: [System.Reactive.Subjects.ISubject$2(T,U)],
        _observer: null,
        _observable: null,
        config: {
            alias: [
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext",
            "subscribe", "System$IObservable$1$" + Bridge.getTypeAlias(U) + "$subscribe"
            ]
        },
        ctor: function (observer, observable) {
            this.$initialize();
            this._observer = observer;
            this._observable = observable;
        },
        onCompleted: function () {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
        },
        onError: function (error) {
            if (error == null) {
                throw new System.ArgumentNullException("error");
            }

            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](error);
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](value);
        },
        subscribe: function (observer) {
            if (observer == null) {
                throw new System.ArgumentNullException("observer");
            }

            //
            // [OK] Use of unsafe Subscribe: non-pretentious wrapping of an observable sequence.
            //
            return this._observable["System$IObservable$1$" + Bridge.getTypeAlias(U) + "$subscribe"](observer);
        }
    }; });

    Bridge.define("System.Reactive.SynchronizedObserver$1", function (T) { return {
        inherits: [System.Reactive.ObserverBase$1(T)],
        _gate: null,
        _observer: null,
        ctor: function (observer, gate) {
            this.$initialize();
            System.Reactive.ObserverBase$1(T).ctor.call(this);
            this._gate = gate;
            this._observer = observer;
        },
        onNextCore: function (value) {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](value);
            }
        },
        onErrorCore: function (exception) {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](exception);
            }
        },
        onCompletedCore: function () {
            this._gate;
            {
                this._observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
            }
        }
    }; });

    /**
     * Provides a virtual time scheduler that uses DateTimeOffset for absolute time and TimeSpan for relative time.
     *
     * @public
     * @class System.Reactive.Concurrency.HistoricalScheduler
     * @augments System.Reactive.Concurrency.HistoricalSchedulerBase
     */
    Bridge.define("System.Reactive.Concurrency.HistoricalScheduler", {
        inherits: [System.Reactive.Concurrency.HistoricalSchedulerBase],
        queue: null,
        config: {
            init: function () {
                this.queue = new (System.Reactive.Concurrency.SchedulerQueue$1(System.DateTimeOffset)).ctor();
            }
        },
        /**
         * Creates a new historical scheduler with the minimum value of DateTimeOffset as the initial clock value.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.HistoricalScheduler
         * @memberof System.Reactive.Concurrency.HistoricalScheduler
         * @return  {void}
         */
        ctor: function () {
            this.$initialize();
            System.Reactive.Concurrency.HistoricalSchedulerBase.ctor.call(this);
        },
        /**
         * Creates a new historical scheduler with the specified initial clock value.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.HistoricalScheduler
         * @memberof System.Reactive.Concurrency.HistoricalScheduler
         * @param   {System.DateTimeOffset}    initialClock    Initial value for the clock.
         * @return  {void}
         */
        $ctor1: function (initialClock) {
            this.$initialize();
            System.Reactive.Concurrency.HistoricalSchedulerBase.$ctor1.call(this, initialClock);
        },
        /**
         * Creates a new historical scheduler with the specified initial clock value.
         *
         * @instance
         * @public
         * @this System.Reactive.Concurrency.HistoricalScheduler
         * @memberof System.Reactive.Concurrency.HistoricalScheduler
         * @throws <b /> is null.
         * @param   {System.DateTimeOffset}                     initialClock    Initial value for the clock.
         * @param   {System.Collections.Generic.IComparer$1}    comparer        Comparer to determine causality of events based on absolute time.
         * @return  {void}
         */
        $ctor2: function (initialClock, comparer) {
            this.$initialize();
            System.Reactive.Concurrency.HistoricalSchedulerBase.$ctor2.call(this, initialClock, comparer);
        },
        /**
         * Gets the next scheduled item to be executed.
         *
         * @instance
         * @protected
         * @override
         * @this System.Reactive.Concurrency.HistoricalScheduler
         * @memberof System.Reactive.Concurrency.HistoricalScheduler
         * @return  {System.Reactive.Concurrency.IScheduledItem$1}        The next scheduled item.
         */
        getNext: function () {
            while (this.queue.getCount() > 0) {
                var next = this.queue.peek();
                if (next.getIsCanceled()) {
                    this.queue.dequeue();
                } else {
                    return next;
                }
            }
            return null;
        },
        /**
         * Schedules an action to be executed at dueTime.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Concurrency.HistoricalScheduler
         * @memberof System.Reactive.Concurrency.HistoricalScheduler
         * @throws <b /> is null.
         * @param   {Function}                 TState     The type of the state passed to the scheduled action.
         * @param   {TState}                   state      State passed to the action to be executed.
         * @param   {System.DateTimeOffset}    dueTime    Absolute time at which to execute the action.
         * @param   {System.Func}              action     Action to be executed.
         * @return  {System.IDisposable}                  The disposable object used to cancel the scheduled action (best effort).
         */
        scheduleAbsolute: function (TState, state, dueTime, action) {
            if (Bridge.staticEquals(action, null)) {
                throw new System.ArgumentNullException("action");
            }

            var si = null;

            var run = Bridge.fn.bind(this, function (scheduler, state1) {
                this.queue.remove(si);
                return action(scheduler, state1);
            });

            si = new (System.Reactive.Concurrency.ScheduledItem$2(System.DateTimeOffset,TState)).$ctor1(this, state, run, dueTime.$clone(), this.getComparer());
            this.queue.enqueue(si);

            return System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(si, si.cancel));
        }
    });

    Bridge.define("System.Reactive.Concurrency.ObserveOn$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _scheduler: null,
        ctor: function (source, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            {
                var sink = new (System.Reactive.ObserveOnObserver$1(TSource))(this._scheduler, observer, cancel);
                setSink(sink);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
            }
        }
    }; });

    Bridge.define("System.Reactive.Concurrency.Synchronize$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _gate: null,
        $ctor1: function (source, gate) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._gate = gate;
        },
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Concurrency.Synchronize$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AddRef$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _refCount: null,
        ctor: function (source, refCount) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._refCount = refCount;
        },
        run: function (observer, cancel, setSink) {
            var d = System.Reactive.Disposables.StableCompositeDisposable.create$1(this._refCount.getDisposable(), cancel);

            var sink = new (System.Reactive.Linq.ObservableImpl.AddRef$1._(TSource))(observer, d);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Aggregate$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _accumulator: null,
        ctor: function (source, accumulator) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._accumulator = accumulator;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Aggregate$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Aggregate$3", function (TSource, TAccumulate, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source: null,
        _seed: Bridge.getDefaultValue(TAccumulate),
        _accumulator: null,
        _resultSelector: null,
        ctor: function (source, seed, accumulator, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source = source;
            this._seed = seed;
            this._accumulator = accumulator;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Aggregate$3._(TSource,TAccumulate,TResult))(this, observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.All$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(Boolean)],
        _source: null,
        _predicate: null,
        ctor: function (source, predicate) {
            this.$initialize();
            System.Reactive.Producer$1(Boolean).ctor.call(this);
            this._source = source;
            this._predicate = predicate;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.All$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Amb$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _left: null,
        _right: null,
        ctor: function (left, right) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._left = left;
            this._right = right;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Amb$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Any$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(Boolean)],
        _source: null,
        _predicate: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(Boolean).ctor.call(this);
            this._source = source;
        },
        $ctor1: function (source, predicate) {
            this.$initialize();
            System.Reactive.Producer$1(Boolean).ctor.call(this);
            this._source = source;
            this._predicate = predicate;
        },
        run: function (observer, cancel, setSink) {
            if (!Bridge.staticEquals(this._predicate, null)) {
                var sink = new (System.Reactive.Linq.ObservableImpl.Any$1.AnyImpl(TSource))(this, observer, cancel);
                setSink(sink);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.Any$1._(TSource))(observer, cancel);
                setSink(sink1);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink1);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AsObservable$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource),System.Reactive.IEvaluatableObservable$1(TSource)],
        _source: null,
        config: {
            alias: [
            "eval", "System$Reactive$IEvaluatableObservable$1$" + Bridge.getTypeAlias(TSource) + "$eval"
            ]
        },
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
        },
        omega: function () {
            return this;
        },
        eval: function () {
            return this._source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.AsObservable$1._(TSource))(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageDecimal", {
        inherits: [System.Reactive.Producer$1(System.Decimal)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Decimal).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.AverageDecimal._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Decimal, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageDecimalNullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Decimal))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Decimal)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.AverageDecimalNullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Decimal), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageDouble", {
        inherits: [System.Reactive.Producer$1(System.Double)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Double).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.AverageDouble._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Double, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageDoubleNullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Double))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Double)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.AverageDoubleNullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Double), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageInt32", {
        inherits: [System.Reactive.Producer$1(System.Double)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Double).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.AverageInt32._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Int32, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageInt32Nullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Double))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Double)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.AverageInt32Nullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Int32), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageInt64", {
        inherits: [System.Reactive.Producer$1(System.Double)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Double).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.AverageInt64._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Int64, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageInt64Nullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Double))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Double)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.AverageInt64Nullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Int64), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageSingle", {
        inherits: [System.Reactive.Producer$1(System.Single)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Single).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.AverageSingle._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Single, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.AverageSingleNullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Single))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Single)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.AverageSingleNullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Single), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Buffer$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource))],
        _source: null,
        _count: 0,
        _skip: 0,
        _scheduler: null,
        config: {
            init: function () {
                this._timeSpan = new System.TimeSpan();
                this._timeShift = new System.TimeSpan();
            }
        },
        ctor: function (source, count, skip) {
            this.$initialize();
            System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this);
            this._source = source;
            this._count = count;
            this._skip = skip;
        },
        $ctor2: function (source, timeSpan, timeShift, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this);
            this._source = source;
            this._timeSpan = timeSpan;
            this._timeShift = timeShift;
            this._scheduler = scheduler;
        },
        $ctor1: function (source, timeSpan, count, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this);
            this._source = source;
            this._timeSpan = timeSpan;
            this._count = count;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            if (this._scheduler == null) {
                var sink = new (System.Reactive.Linq.ObservableImpl.Buffer$1._(TSource))(this, observer, cancel);
                setSink(sink);
                return sink.run();
            } else if (this._count > 0) {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.Buffer$1.Impl(TSource))(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            } else {
                if (System.TimeSpan.eq(this._timeSpan, this._timeShift)) {
                    var sink2 = new (System.Reactive.Linq.ObservableImpl.Buffer$1.BufferTimeShift(TSource))(this, observer, cancel);
                    setSink(sink2);
                    return sink2.run();
                } else {
                    var sink3 = new (System.Reactive.Linq.ObservableImpl.Buffer$1.BufferImpl(TSource))(this, observer, cancel);
                    setSink(sink3);
                    return sink3.run();
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Buffer$2", function (TSource, TBufferClosing) { return {
        inherits: [System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource))],
        _source: null,
        _bufferClosingSelector: null,
        _bufferBoundaries: null,
        ctor: function (source, bufferClosingSelector) {
            this.$initialize();
            System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this);
            this._source = source;
            this._bufferClosingSelector = bufferClosingSelector;
        },
        $ctor1: function (source, bufferBoundaries) {
            this.$initialize();
            System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this);
            this._source = source;
            this._bufferBoundaries = bufferBoundaries;
        },
        run: function (observer, cancel, setSink) {
            if (!Bridge.staticEquals(this._bufferClosingSelector, null)) {
                var sink = new (System.Reactive.Linq.ObservableImpl.Buffer$2._(TSource,TBufferClosing))(this, observer, cancel);
                setSink(sink);
                return sink.run();
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.Buffer$2.Beta(TSource,TBufferClosing))(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Case$2", function (TValue, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult),System.Reactive.IEvaluatableObservable$1(TResult)],
        _selector: null,
        _sources: null,
        _defaultSource: null,
        config: {
            alias: [
            "eval", "System$Reactive$IEvaluatableObservable$1$" + Bridge.getTypeAlias(TResult) + "$eval"
            ]
        },
        ctor: function (selector, sources, defaultSource) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._selector = selector;
            this._sources = sources;
            this._defaultSource = defaultSource;
        },
        eval: function () {
            var res = { v : null };
            if (this._sources["System$Collections$Generic$IDictionary$2$" + Bridge.getTypeAlias(TValue) + "$System$IObservable$1$" + Bridge.getTypeAlias(TResult) + "$tryGetValue"](this._selector(), res)) {
                return res.v;
            }

            return this._defaultSource;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Case$2._(TValue,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Cast$2", function (TSource, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Cast$2._(TSource,TResult))(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Catch$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _sources: null,
        ctor: function (sources) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._sources = sources;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Catch$1._(TSource))(observer, cancel);
            setSink(sink);
            return sink.run(this._sources);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Catch$2", function (TSource, TException) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _handler: null,
        ctor: function (source, handler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._handler = handler;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Catch$2._(TSource,TException))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.EventProducer$2", function (TDelegate, TArgs) { return {
        inherits: [System.Reactive.Producer$1(TArgs)],
        _scheduler: null,
        _gate: null,
        _session: null,
        ctor: function (scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TArgs).ctor.call(this);
            this._scheduler = scheduler;
            this._gate = {  };
        },
        run: function (observer, cancel, setSink) {
            var connection = null;

            this._gate;
            {
                //
                // A session object holds on to a single handler to the underlying event, feeding
                // into a subject. It also ref counts the number of connections to the subject.
                //
                // When the ref count goes back to zero, the event handler is unregistered, and
                // the session will reach out to reset the _session field to null under the _gate
                // lock. Future subscriptions will cause a new session to be created.
                //
                if (this._session == null) {
                    this._session = new (System.Reactive.Linq.ObservableImpl.EventProducer$2.Session(TDelegate,TArgs))(this);
                }

                connection = this._session.connect(observer);
            }

            return connection;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$10", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _source9: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, source9, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._source9 = source9;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.CombineLatest$10._(T1,T2,T3,T4,T5,T6,T7,T8,T9,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$11", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _source9: null,
        _source10: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._source9 = source9;
            this._source10 = source10;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.CombineLatest$11._(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$12", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _source9: null,
        _source10: null,
        _source11: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._source9 = source9;
            this._source10 = source10;
            this._source11 = source11;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.CombineLatest$12._(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$13", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _source9: null,
        _source10: null,
        _source11: null,
        _source12: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._source9 = source9;
            this._source10 = source10;
            this._source11 = source11;
            this._source12 = source12;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.CombineLatest$13._(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$14", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _source9: null,
        _source10: null,
        _source11: null,
        _source12: null,
        _source13: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._source9 = source9;
            this._source10 = source10;
            this._source11 = source11;
            this._source12 = source12;
            this._source13 = source13;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.CombineLatest$14._(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$15", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _source9: null,
        _source10: null,
        _source11: null,
        _source12: null,
        _source13: null,
        _source14: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._source9 = source9;
            this._source10 = source10;
            this._source11 = source11;
            this._source12 = source12;
            this._source13 = source13;
            this._source14 = source14;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.CombineLatest$15._(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$16", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _source9: null,
        _source10: null,
        _source11: null,
        _source12: null,
        _source13: null,
        _source14: null,
        _source15: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._source9 = source9;
            this._source10 = source10;
            this._source11 = source11;
            this._source12 = source12;
            this._source13 = source13;
            this._source14 = source14;
            this._source15 = source15;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.CombineLatest$16._(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$17", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _source9: null,
        _source10: null,
        _source11: null,
        _source12: null,
        _source13: null,
        _source14: null,
        _source15: null,
        _source16: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, source16, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._source9 = source9;
            this._source10 = source10;
            this._source11 = source11;
            this._source12 = source12;
            this._source13 = source13;
            this._source14 = source14;
            this._source15 = source15;
            this._source16 = source16;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.CombineLatest$17._(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$2", function (TSource, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _sources: null,
        _resultSelector: null,
        ctor: function (sources, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._sources = sources;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.CombineLatest$2._(TSource,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$3", function (TFirst, TSecond, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _first: null,
        _second: null,
        _resultSelector: null,
        ctor: function (first, second, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._first = first;
            this._second = second;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.CombineLatest$3._(TFirst,TSecond,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$4", function (T1, T2, T3, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.CombineLatest$4._(T1,T2,T3,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$5", function (T1, T2, T3, T4, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.CombineLatest$5._(T1,T2,T3,T4,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$6", function (T1, T2, T3, T4, T5, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.CombineLatest$6._(T1,T2,T3,T4,T5,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$7", function (T1, T2, T3, T4, T5, T6, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.CombineLatest$7._(T1,T2,T3,T4,T5,T6,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$8", function (T1, T2, T3, T4, T5, T6, T7, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.CombineLatest$8._(T1,T2,T3,T4,T5,T6,T7,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.CombineLatest$9", function (T1, T2, T3, T4, T5, T6, T7, T8, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.CombineLatest$9._(T1,T2,T3,T4,T5,T6,T7,T8,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Concat$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource),System.Reactive.IConcatenatable$1(TSource)],
        _sources: null,
        config: {
            alias: [
            "getSources", "System$Reactive$IConcatenatable$1$" + Bridge.getTypeAlias(TSource) + "$getSources"
            ]
        },
        ctor: function (sources) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._sources = sources;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Concat$1._(TSource))(observer, cancel);
            setSink(sink);
            return sink.run(this._sources);
        },
        getSources: function () {
            return this._sources;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Concat$1._", function (TSource) { return {
        inherits: [System.Reactive.ConcatSink$1(TSource)],
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.ConcatSink$1(TSource).ctor.call(this, observer, cancel);
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.ConcatSink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Contains$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(Boolean)],
        _source: null,
        _value: Bridge.getDefaultValue(TSource),
        _comparer: null,
        ctor: function (source, value, comparer) {
            this.$initialize();
            System.Reactive.Producer$1(Boolean).ctor.call(this);
            this._source = source;
            this._value = value;
            this._comparer = comparer;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Contains$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Count$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(System.Int32)],
        _source: null,
        _predicate: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Int32).ctor.call(this);
            this._source = source;
        },
        $ctor1: function (source, predicate) {
            this.$initialize();
            System.Reactive.Producer$1(System.Int32).ctor.call(this);
            this._source = source;
            this._predicate = predicate;
        },
        run: function (observer, cancel, setSink) {
            if (Bridge.staticEquals(this._predicate, null)) {
                var sink = new (System.Reactive.Linq.ObservableImpl.Count$1._(TSource))(observer, cancel);
                setSink(sink);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.Count$1.CountImpl(TSource))(this, observer, cancel);
                setSink(sink1);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink1);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.DefaultIfEmpty$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _defaultValue: Bridge.getDefaultValue(TSource),
        ctor: function (source, defaultValue) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._defaultValue = defaultValue;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.DefaultIfEmpty$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Defer$1", function (TValue) { return {
        inherits: [System.Reactive.Producer$1(TValue),System.Reactive.IEvaluatableObservable$1(TValue)],
        _observableFactory: null,
        config: {
            alias: [
            "eval", "System$Reactive$IEvaluatableObservable$1$" + Bridge.getTypeAlias(TValue) + "$eval"
            ]
        },
        ctor: function (observableFactory) {
            this.$initialize();
            System.Reactive.Producer$1(TValue).ctor.call(this);
            this._observableFactory = observableFactory;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Defer$1._(TValue))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        },
        eval: function () {
            return this._observableFactory();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Delay$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _dueTimeR: null,
        _dueTimeA: null,
        _scheduler: null,
        $ctor1: function (source, dueTime, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._dueTimeR = dueTime;
            this._scheduler = scheduler;
        },
        ctor: function (source, dueTime, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._dueTimeA = dueTime.$clone();
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            if (System.Reactive.Concurrency.Scheduler.asLongRunning(this._scheduler) != null) {
                var sink = new (System.Reactive.Linq.ObservableImpl.Delay$1.LongRunningImpl(TSource))(this, observer, cancel);
                setSink(sink);
                return sink.run();
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.Delay$1._(TSource))(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Delay$2", function (TSource, TDelay) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _subscriptionDelay: null,
        _delaySelector: null,
        ctor: function (source, subscriptionDelay, delaySelector) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._subscriptionDelay = subscriptionDelay;
            this._delaySelector = delaySelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Delay$2._(TSource,TDelay))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.DelaySubscription$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _dueTimeA: null,
        _dueTimeR: null,
        _scheduler: null,
        ctor: function (source, dueTime, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._dueTimeA = dueTime.$clone();
            this._scheduler = scheduler;
        },
        $ctor1: function (source, dueTime, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._dueTimeR = dueTime;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.DelaySubscription$1._(TSource))(observer, cancel);
            setSink(sink);

            if (System.Nullable.hasValue(this._dueTimeA)) {
                return this._scheduler.System$Reactive$Concurrency$IScheduler$schedule$1(System.Reactive.Linq.ObservableImpl.DelaySubscription$1._(TSource), sink, System.Nullable.getValue(this._dueTimeA), Bridge.fn.bind(this, this.subscribe$1));
            } else {
                return this._scheduler.System$Reactive$Concurrency$IScheduler$schedule$2(System.Reactive.Linq.ObservableImpl.DelaySubscription$1._(TSource), sink, System.Nullable.getValue(this._dueTimeR), Bridge.fn.bind(this, this.subscribe$1));
            }
        },
        subscribe$1: function (_, sink) {
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Dematerialize$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Dematerialize$1._(TSource))(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Reactive.Notification$1(TSource), this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Distinct$2", function (TSource, TKey) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _keySelector: null,
        _comparer: null,
        ctor: function (source, keySelector, comparer) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._keySelector = keySelector;
            this._comparer = comparer;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Distinct$2._(TSource,TKey))(this, observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.DistinctUntilChanged$2", function (TSource, TKey) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _keySelector: null,
        _comparer: null,
        ctor: function (source, keySelector, comparer) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._keySelector = keySelector;
            this._comparer = comparer;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.DistinctUntilChanged$2._(TSource,TKey))(this, observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Do$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _onNext: null,
        _onError: null,
        _onCompleted: null,
        ctor: function (source, onNext, onError, onCompleted) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._onNext = onNext;
            this._onError = onError;
            this._onCompleted = onCompleted;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Do$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.DoWhile$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource),System.Reactive.IConcatenatable$1(TSource)],
        _source: null,
        _condition: null,
        config: {
            alias: [
            "getSources", "System$Reactive$IConcatenatable$1$" + Bridge.getTypeAlias(TSource) + "$getSources"
            ]
        },
        ctor: function (source, condition) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._condition = condition;
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.DoWhile$1._(TSource))(observer, cancel);
            setSink(sink);
            return sink.run(this.getSources());
        },
        getSources: function () {
            var $yield = [];
            $yield.push(this._source);
            while (this._condition()) {
                $yield.push(this._source);
            }
            return System.Array.toEnumerable($yield);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.DoWhile$1._", function (TSource) { return {
        inherits: [System.Reactive.ConcatSink$1(TSource)],
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.ConcatSink$1(TSource).ctor.call(this, observer, cancel);
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.ConcatSink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ElementAt$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _index: 0,
        _throwOnEmpty: false,
        ctor: function (source, index, throwOnEmpty) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._index = index;
            this._throwOnEmpty = throwOnEmpty;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.ElementAt$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Empty$1", function (TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _scheduler: null,
        ctor: function (scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Empty$1._(TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Finally$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _finallyAction: null,
        ctor: function (source, finallyAction) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._finallyAction = finallyAction;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Finally$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.FirstAsync$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _predicate: null,
        _throwOnEmpty: false,
        ctor: function (source, predicate, throwOnEmpty) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._predicate = predicate;
            this._throwOnEmpty = throwOnEmpty;
        },
        run: function (observer, cancel, setSink) {
            if (!Bridge.staticEquals(this._predicate, null)) {
                var sink = new (System.Reactive.Linq.ObservableImpl.FirstAsync$1.FirstAsyncImpl(TSource))(this, observer, cancel);
                setSink(sink);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.FirstAsync$1._(TSource))(this, observer, cancel);
                setSink(sink1);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink1);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.For$2", function (TSource, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult),System.Reactive.IConcatenatable$1(TResult)],
        _source: null,
        _resultSelector: null,
        config: {
            alias: [
            "getSources", "System$Reactive$IConcatenatable$1$" + Bridge.getTypeAlias(TResult) + "$getSources"
            ]
        },
        ctor: function (source, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source = source;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.For$2._(TSource,TResult))(observer, cancel);
            setSink(sink);
            return sink.run(this.getSources());
        },
        getSources: function () {
            var $t;
            var $yield = [];
            $t = Bridge.getEnumerator(this._source, TSource);
            while ($t.moveNext()) {
                var item = $t.getCurrent();
                $yield.push(this._resultSelector(item));
            }
            return System.Array.toEnumerable($yield);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.For$2._", function (TSource, TResult) { return {
        inherits: [System.Reactive.ConcatSink$1(TResult)],
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.ConcatSink$1(TResult).ctor.call(this, observer, cancel);
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onNext"](value);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TResult) + "$onError"](error);
            System.Reactive.ConcatSink$1(TResult).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Generate$2", function (TState, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _initialState: Bridge.getDefaultValue(TState),
        _condition: null,
        _iterate: null,
        _resultSelector: null,
        _timeSelectorA: null,
        _timeSelectorR: null,
        _scheduler: null,
        $ctor2: function (initialState, condition, iterate, resultSelector, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._initialState = initialState;
            this._condition = condition;
            this._iterate = iterate;
            this._resultSelector = resultSelector;
            this._scheduler = scheduler;
        },
        ctor: function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._initialState = initialState;
            this._condition = condition;
            this._iterate = iterate;
            this._resultSelector = resultSelector;
            this._timeSelectorA = timeSelector;
            this._scheduler = scheduler;
        },
        $ctor1: function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._initialState = initialState;
            this._condition = condition;
            this._iterate = iterate;
            this._resultSelector = resultSelector;
            this._timeSelectorR = timeSelector;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            if (!Bridge.staticEquals(this._timeSelectorA, null)) {
                var sink = new (System.Reactive.Linq.ObservableImpl.Generate$2.SelectorA(TState,TResult))(this, observer, cancel);
                setSink(sink);
                return sink.run();
            } else if (!Bridge.staticEquals(this._timeSelectorR, null)) {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.Generate$2.Delta(TState,TResult))(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            } else {
                var sink2 = new (System.Reactive.Linq.ObservableImpl.Generate$2._(TState,TResult))(this, observer, cancel);
                setSink(sink2);
                return sink2.run();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.GroupBy$3", function (TSource, TKey, TElement) { return {
        inherits: [System.Reactive.Producer$1(System.Reactive.Linq.IGroupedObservable$2(TKey,TElement))],
        _source: null,
        _keySelector: null,
        _elementSelector: null,
        _capacity: null,
        _comparer: null,
        _groupDisposable: null,
        _refCountDisposable: null,
        ctor: function (source, keySelector, elementSelector, capacity, comparer) {
            this.$initialize();
            System.Reactive.Producer$1(System.Reactive.Linq.IGroupedObservable$2(TKey,TElement)).ctor.call(this);
            this._source = source;
            this._keySelector = keySelector;
            this._elementSelector = elementSelector;
            this._capacity = capacity;
            this._comparer = comparer;
        },
        run: function (observer, cancel, setSink) {
            this._groupDisposable = new System.Reactive.Disposables.CompositeDisposable.ctor();
            this._refCountDisposable = new System.Reactive.Disposables.RefCountDisposable.ctor(this._groupDisposable);

            var sink = new (System.Reactive.Linq.ObservableImpl.GroupBy$3._(TSource,TKey,TElement))(this, observer, cancel);
            setSink(sink);
            this._groupDisposable.add(System.ObservableExtensions.subscribeSafe(TSource, this._source, sink));

            return this._refCountDisposable;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.GroupByUntil$4", function (TSource, TKey, TElement, TDuration) { return {
        inherits: [System.Reactive.Producer$1(System.Reactive.Linq.IGroupedObservable$2(TKey,TElement))],
        _source: null,
        _keySelector: null,
        _elementSelector: null,
        _durationSelector: null,
        _capacity: null,
        _comparer: null,
        _groupDisposable: null,
        _refCountDisposable: null,
        ctor: function (source, keySelector, elementSelector, durationSelector, capacity, comparer) {
            this.$initialize();
            System.Reactive.Producer$1(System.Reactive.Linq.IGroupedObservable$2(TKey,TElement)).ctor.call(this);
            this._source = source;
            this._keySelector = keySelector;
            this._elementSelector = elementSelector;
            this._durationSelector = durationSelector;
            this._capacity = capacity;
            this._comparer = comparer;
        },
        run: function (observer, cancel, setSink) {
            this._groupDisposable = new System.Reactive.Disposables.CompositeDisposable.ctor();
            this._refCountDisposable = new System.Reactive.Disposables.RefCountDisposable.ctor(this._groupDisposable);

            var sink = new (System.Reactive.Linq.ObservableImpl.GroupByUntil$4._(TSource,TKey,TElement,TDuration))(this, observer, cancel);
            setSink(sink);
            this._groupDisposable.add(System.ObservableExtensions.subscribeSafe(TSource, this._source, sink));

            return this._refCountDisposable;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.GroupJoin$5", function (TLeft, TRight, TLeftDuration, TRightDuration, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _left: null,
        _right: null,
        _leftDurationSelector: null,
        _rightDurationSelector: null,
        _resultSelector: null,
        ctor: function (left, right, leftDurationSelector, rightDurationSelector, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._left = left;
            this._right = right;
            this._leftDurationSelector = leftDurationSelector;
            this._rightDurationSelector = rightDurationSelector;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.GroupJoin$5._(TLeft,TRight,TLeftDuration,TRightDuration,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.If$1", function (TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult),System.Reactive.IEvaluatableObservable$1(TResult)],
        _condition: null,
        _thenSource: null,
        _elseSource: null,
        config: {
            alias: [
            "eval", "System$Reactive$IEvaluatableObservable$1$" + Bridge.getTypeAlias(TResult) + "$eval"
            ]
        },
        ctor: function (condition, thenSource, elseSource) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._condition = condition;
            this._thenSource = thenSource;
            this._elseSource = elseSource;
        },
        eval: function () {
            return this._condition() ? this._thenSource : this._elseSource;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.If$1._(TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.IgnoreElements$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
        },
        omega: function () {
            return this;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.IgnoreElements$1._(TSource))(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.IsEmpty$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(Boolean)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(Boolean).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.IsEmpty$1._(TSource))(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Join$5", function (TLeft, TRight, TLeftDuration, TRightDuration, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _left: null,
        _right: null,
        _leftDurationSelector: null,
        _rightDurationSelector: null,
        _resultSelector: null,
        ctor: function (left, right, leftDurationSelector, rightDurationSelector, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._left = left;
            this._right = right;
            this._leftDurationSelector = leftDurationSelector;
            this._rightDurationSelector = rightDurationSelector;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Join$5._(TLeft,TRight,TLeftDuration,TRightDuration,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.LastAsync$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _predicate: null,
        _throwOnEmpty: false,
        ctor: function (source, predicate, throwOnEmpty) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._predicate = predicate;
            this._throwOnEmpty = throwOnEmpty;
        },
        run: function (observer, cancel, setSink) {
            if (!Bridge.staticEquals(this._predicate, null)) {
                var sink = new (System.Reactive.Linq.ObservableImpl.LastAsync$1.LastAsyncImpl(TSource))(this, observer, cancel);
                setSink(sink);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.LastAsync$1._(TSource))(this, observer, cancel);
                setSink(sink1);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink1);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.LongCount$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(System.Int64)],
        _source: null,
        _predicate: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Int64).ctor.call(this);
            this._source = source;
        },
        $ctor1: function (source, predicate) {
            this.$initialize();
            System.Reactive.Producer$1(System.Int64).ctor.call(this);
            this._source = source;
            this._predicate = predicate;
        },
        run: function (observer, cancel, setSink) {
            if (Bridge.staticEquals(this._predicate, null)) {
                var sink = new (System.Reactive.Linq.ObservableImpl.LongCount$1._(TSource))(observer, cancel);
                setSink(sink);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.LongCount$1.LongCountImpl(TSource))(this, observer, cancel);
                setSink(sink1);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink1);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Materialize$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(System.Reactive.Notification$1(TSource))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Reactive.Notification$1(TSource)).ctor.call(this);
            this._source = source;
        },
        dematerialize: function () {
            return System.Reactive.Linq.Observable.asObservable(TSource, this._source);
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Materialize$1._(TSource))(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Max$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _comparer: null,
        ctor: function (source, comparer) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._comparer = comparer;
        },
        run: function (observer, cancel, setSink) {
            // LINQ to Objects makes this distinction in order to make [Max|Max] of an empty collection of reference type objects equal to null.
            if (Bridge.getDefaultValue(TSource) == null) {
                var sink = new (System.Reactive.Linq.ObservableImpl.Max$1._(TSource))(this, observer, cancel);
                setSink(sink);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.Max$1.Delta(TSource))(this, observer, cancel);
                setSink(sink1);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink1);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxBy$2", function (TSource, TKey) { return {
        inherits: [System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource))],
        _source: null,
        _keySelector: null,
        _comparer: null,
        ctor: function (source, keySelector, comparer) {
            this.$initialize();
            System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this);
            this._source = source;
            this._keySelector = keySelector;
            this._comparer = comparer;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.MaxBy$2._(TSource,TKey))(this, observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxDecimal", {
        inherits: [System.Reactive.Producer$1(System.Decimal)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Decimal).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MaxDecimal._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Decimal, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxDecimalNullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Decimal))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Decimal)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MaxDecimalNullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Decimal), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxDouble", {
        inherits: [System.Reactive.Producer$1(System.Double)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Double).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MaxDouble._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Double, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxDoubleNullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Double))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Double)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MaxDoubleNullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Double), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxInt32", {
        inherits: [System.Reactive.Producer$1(System.Int32)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Int32).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MaxInt32._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Int32, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxInt32Nullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Int32))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Int32)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MaxInt32Nullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Int32), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxInt64", {
        inherits: [System.Reactive.Producer$1(System.Int64)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Int64).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MaxInt64._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Int64, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxInt64Nullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Int64))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Int64)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MaxInt64Nullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Int64), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxSingle", {
        inherits: [System.Reactive.Producer$1(System.Single)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Single).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MaxSingle._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Single, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MaxSingleNullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Single))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Single)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MaxSingleNullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Single), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Merge$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _sources: null,
        _maxConcurrent: 0,
        ctor: function (sources) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._sources = sources;
        },
        $ctor1: function (sources, maxConcurrent) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._sources = sources;
            this._maxConcurrent = maxConcurrent;
        },
        run: function (observer, cancel, setSink) {
            if (this._maxConcurrent > 0) {
                var sink = new (System.Reactive.Linq.ObservableImpl.Merge$1.MergeConcurrent(TSource))(this, observer, cancel);
                setSink(sink);
                return sink.run();
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.Merge$1._(TSource))(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Min$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _comparer: null,
        ctor: function (source, comparer) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._comparer = comparer;
        },
        run: function (observer, cancel, setSink) {
            // LINQ to Objects makes this distinction in order to make [Min|Max] of an empty collection of reference type objects equal to null.
            if (Bridge.getDefaultValue(TSource) == null) {
                var sink = new (System.Reactive.Linq.ObservableImpl.Min$1._(TSource))(this, observer, cancel);
                setSink(sink);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.Min$1.Delta(TSource))(this, observer, cancel);
                setSink(sink1);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink1);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinBy$2", function (TSource, TKey) { return {
        inherits: [System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource))],
        _source: null,
        _keySelector: null,
        _comparer: null,
        ctor: function (source, keySelector, comparer) {
            this.$initialize();
            System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this);
            this._source = source;
            this._keySelector = keySelector;
            this._comparer = comparer;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.MinBy$2._(TSource,TKey))(this, observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinDecimal", {
        inherits: [System.Reactive.Producer$1(System.Decimal)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Decimal).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MinDecimal._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Decimal, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinDecimalNullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Decimal))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Decimal)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MinDecimalNullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Decimal), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinDouble", {
        inherits: [System.Reactive.Producer$1(System.Double)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Double).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MinDouble._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Double, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinDoubleNullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Double))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Double)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MinDoubleNullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Double), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinInt32", {
        inherits: [System.Reactive.Producer$1(System.Int32)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Int32).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MinInt32._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Int32, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinInt32Nullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Int32))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Int32)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MinInt32Nullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Int32), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinInt64", {
        inherits: [System.Reactive.Producer$1(System.Int64)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Int64).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MinInt64._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Int64, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinInt64Nullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Int64))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Int64)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MinInt64Nullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Int64), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinSingle", {
        inherits: [System.Reactive.Producer$1(System.Single)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Single).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MinSingle._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Single, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.MinSingleNullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Single))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Single)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.MinSingleNullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Single), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Multicast$3", function (TSource, TIntermediate, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source: null,
        _subjectSelector: null,
        _selector: null,
        ctor: function (source, subjectSelector, selector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source = source;
            this._subjectSelector = subjectSelector;
            this._selector = selector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Multicast$3._(TSource,TIntermediate,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ObserveOn$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _scheduler: null,
        ctor: function (source, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            {
                var sink = new (System.Reactive.ObserveOnObserver$1(TSource))(this._scheduler, observer, cancel);
                setSink(sink);
                return this._source["System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$subscribe"](sink);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.OfType$2", function (TSource, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.OfType$2._(TSource,TResult))(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.OnErrorResumeNext$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _sources: null,
        ctor: function (sources) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._sources = sources;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.OnErrorResumeNext$1._(TSource))(observer, cancel);
            setSink(sink);
            return sink.run(this._sources);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Range", {
        inherits: [System.Reactive.Producer$1(System.Int32)],
        _start: 0,
        _count: 0,
        _scheduler: null,
        ctor: function (start, count, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(System.Int32).ctor.call(this);
            this._start = start;
            this._count = count;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.Range._(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.RefCount$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _gate: null,
        _count: 0,
        _connectableSubscription: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._gate = {  };
            this._count = 0;
            this._connectableSubscription = null;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.RefCount$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Repeat$1", function (TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _value: Bridge.getDefaultValue(TResult),
        _repeatCount: null,
        _scheduler: null,
        ctor: function (value, repeatCount, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._value = value;
            this._repeatCount = repeatCount;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Repeat$1._(TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Return$1", function (TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _value: Bridge.getDefaultValue(TResult),
        _scheduler: null,
        ctor: function (value, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._value = value;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Return$1._(TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Sample$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _scheduler: null,
        config: {
            init: function () {
                this._interval = new System.TimeSpan();
            }
        },
        ctor: function (source, interval, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._interval = interval;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Sample$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Sample$2", function (TSource, TSample) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _sampler: null,
        ctor: function (source, sampler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._sampler = sampler;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Sample$2._(TSource,TSample))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Scan$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _accumulator: null,
        ctor: function (source, accumulator) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._accumulator = accumulator;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Scan$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Scan$2", function (TSource, TAccumulate) { return {
        inherits: [System.Reactive.Producer$1(TAccumulate)],
        _source: null,
        _seed: Bridge.getDefaultValue(TAccumulate),
        _accumulator: null,
        ctor: function (source, seed, accumulator) {
            this.$initialize();
            System.Reactive.Producer$1(TAccumulate).ctor.call(this);
            this._source = source;
            this._seed = seed;
            this._accumulator = accumulator;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Scan$2._(TSource,TAccumulate))(this, observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Select$2", function (TSource, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source: null,
        _selector: null,
        _selectorI: null,
        ctor: function (source, selector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source = source;
            this._selector = selector;
        },
        $ctor1: function (source, selector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source = source;
            this._selectorI = selector;
        },
        run: function (observer, cancel, setSink) {
            if (!Bridge.staticEquals(this._selector, null)) {
                var sink = new (System.Reactive.Linq.ObservableImpl.Select$2._(TSource,TResult))(this, observer, cancel);
                setSink(sink);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.Select$2.SelectImpl(TSource,TResult))(this, observer, cancel);
                setSink(sink1);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink1);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SelectMany$2", function (TSource, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source: null,
        _selector: null,
        _selectorI: null,
        _selectorOnError: null,
        _selectorOnCompleted: null,
        _selectorE: null,
        _selectorEI: null,
        $ctor1: function (source, selector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source = source;
            this._selector = selector;
        },
        $ctor4: function (source, selector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source = source;
            this._selectorI = selector;
        },
        $ctor2: function (source, selector, selectorOnError, selectorOnCompleted) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source = source;
            this._selector = selector;
            this._selectorOnError = selectorOnError;
            this._selectorOnCompleted = selectorOnCompleted;
        },
        $ctor5: function (source, selector, selectorOnError, selectorOnCompleted) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source = source;
            this._selectorI = selector;
            this._selectorOnError = selectorOnError;
            this._selectorOnCompleted = selectorOnCompleted;
        },
        ctor: function (source, selector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source = source;
            this._selectorE = selector;
        },
        $ctor3: function (source, selector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source = source;
            this._selectorEI = selector;
        },
        run: function (observer, cancel, setSink) {
            if (!Bridge.staticEquals(this._selector, null)) {
                var sink = new (System.Reactive.Linq.ObservableImpl.SelectMany$2._(TSource,TResult))(this, observer, cancel);
                setSink(sink);
                return sink.run();
            } else if (!Bridge.staticEquals(this._selectorI, null)) {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.SelectMany$2.IndexSelectorImpl(TSource,TResult))(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            } else if (!Bridge.staticEquals(this._selectorE, null)) {
                var sink2 = new (System.Reactive.Linq.ObservableImpl.SelectMany$2.NoSelectorImpl(TSource,TResult))(this, observer, cancel);
                setSink(sink2);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink2);
            } else {
                var sink3 = new (System.Reactive.Linq.ObservableImpl.SelectMany$2.Omega(TSource,TResult))(this, observer, cancel);
                setSink(sink3);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink3);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SelectMany$3", function (TSource, TCollection, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source: null,
        _collectionSelector: null,
        _collectionSelectorI: null,
        _collectionSelectorE: null,
        _collectionSelectorEI: null,
        _resultSelector: null,
        _resultSelectorI: null,
        $ctor1: function (source, collectionSelector, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source = source;
            this._collectionSelector = collectionSelector;
            this._resultSelector = resultSelector;
        },
        $ctor3: function (source, collectionSelector, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source = source;
            this._collectionSelectorI = collectionSelector;
            this._resultSelectorI = resultSelector;
        },
        ctor: function (source, collectionSelector, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source = source;
            this._collectionSelectorE = collectionSelector;
            this._resultSelector = resultSelector;
        },
        $ctor2: function (source, collectionSelector, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source = source;
            this._collectionSelectorEI = collectionSelector;
            this._resultSelectorI = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            if (!Bridge.staticEquals(this._collectionSelector, null)) {
                var sink = new (System.Reactive.Linq.ObservableImpl.SelectMany$3._(TSource,TCollection,TResult))(this, observer, cancel);
                setSink(sink);
                return sink.run();
            } else if (!Bridge.staticEquals(this._collectionSelectorI, null)) {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.SelectMany$3.IndexSelectorImpl(TSource,TCollection,TResult))(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            } else if (!Bridge.staticEquals(this._collectionSelectorE, null)) {
                var sink2 = new (System.Reactive.Linq.ObservableImpl.SelectMany$3.NoSelectorImpl(TSource,TCollection,TResult))(this, observer, cancel);
                setSink(sink2);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink2);
            } else {
                var sink3 = new (System.Reactive.Linq.ObservableImpl.SelectMany$3.Omega(TSource,TCollection,TResult))(this, observer, cancel);
                setSink(sink3);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink3);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SequenceEqual$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(Boolean)],
        _first: null,
        _second: null,
        _secondE: null,
        _comparer: null,
        $ctor1: function (first, second, comparer) {
            this.$initialize();
            System.Reactive.Producer$1(Boolean).ctor.call(this);
            this._first = first;
            this._second = second;
            this._comparer = comparer;
        },
        ctor: function (first, second, comparer) {
            this.$initialize();
            System.Reactive.Producer$1(Boolean).ctor.call(this);
            this._first = first;
            this._secondE = second;
            this._comparer = comparer;
        },
        run: function (observer, cancel, setSink) {
            if (this._second != null) {
                var sink = new (System.Reactive.Linq.ObservableImpl.SequenceEqual$1._(TSource))(this, observer, cancel);
                setSink(sink);
                return sink.run();
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.SequenceEqual$1.SequenceEqualImpl(TSource))(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SingleAsync$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _predicate: null,
        _throwOnEmpty: false,
        ctor: function (source, predicate, throwOnEmpty) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._predicate = predicate;
            this._throwOnEmpty = throwOnEmpty;
        },
        run: function (observer, cancel, setSink) {
            if (!Bridge.staticEquals(this._predicate, null)) {
                var sink = new (System.Reactive.Linq.ObservableImpl.SingleAsync$1.SingleAsyncImpl(TSource))(this, observer, cancel);
                setSink(sink);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.SingleAsync$1._(TSource))(this, observer, cancel);
                setSink(sink1);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink1);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Skip$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _count: 0,
        _scheduler: null,
        config: {
            init: function () {
                this._duration = new System.TimeSpan();
            }
        },
        ctor: function (source, count) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._count = count;
        },
        $ctor1: function (source, duration, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._duration = duration;
            this._scheduler = scheduler;
        },
        omega: function (count) {
            //
            // Sum semantics:
            //
            //   xs                    --o--o--o--o--o--o--|      xs                    --o--o--o--o--o--o--|
            //   xs.Skip(2)            --x--x--o--o--o--o--|      xs.Skip(3)            --x--x--x--o--o--o--|
            //   xs.Skip(2).Skip(3)    --------x--x--x--o--|      xs.Skip(3).Skip(2)    -----------x--x--o--|
            //
            return new (System.Reactive.Linq.ObservableImpl.Skip$1(TSource)).ctor(this._source, ((this._count + count) | 0));
        },
        omega$1: function (duration) {
            //
            // Maximum semantics:
            //
            //   t                     0--1--2--3--4--5--6--7->   t                     0--1--2--3--4--5--6--7->
            //                                                    
            //   xs                    --o--o--o--o--o--o--|      xs                    --o--o--o--o--o--o--|
            //   xs.Skip(2s)           xxxxxxx-o--o--o--o--|      xs.Skip(3s)           xxxxxxxxxx-o--o--o--|
            //   xs.Skip(2s).Skip(3s)  xxxxxxxxxx-o--o--o--|      xs.Skip(3s).Skip(2s)  xxxxxxx----o--o--o--|
            //
            if (System.TimeSpan.lte(duration, this._duration)) {
                return this;
            } else {
                return new (System.Reactive.Linq.ObservableImpl.Skip$1(TSource)).$ctor1(this._source, duration, this._scheduler);
            }
        },
        run: function (observer, cancel, setSink) {
            if (this._scheduler == null) {
                var sink = new (System.Reactive.Linq.ObservableImpl.Skip$1._(TSource))(this, observer, cancel);
                setSink(sink);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.Skip$1.SkipImpl(TSource))(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SkipLast$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _count: 0,
        _scheduler: null,
        config: {
            init: function () {
                this._duration = new System.TimeSpan();
            }
        },
        ctor: function (source, count) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._count = count;
        },
        $ctor1: function (source, duration, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._duration = duration;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            if (this._scheduler == null) {
                var sink = new (System.Reactive.Linq.ObservableImpl.SkipLast$1._(TSource))(this, observer, cancel);
                setSink(sink);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.SkipLast$1.SkipLastImpl(TSource))(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SkipUntil$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _scheduler: null,
        config: {
            init: function () {
                this._startTime = new System.DateTimeOffset();
            }
        },
        ctor: function (source, startTime, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._startTime = startTime.$clone();
            this._scheduler = scheduler;
        },
        omega: function (startTime) {
            //
            // Maximum semantics:
            //
            //   t                     0--1--2--3--4--5--6--7->   t                     0--1--2--3--4--5--6--7->
            //
            //   xs                    --o--o--o--o--o--o--|      xs                    --o--o--o--o--o--o--|
            //   xs.SU(5AM)            xxxxxxxxxxxxxxxx-o--|      xs.SU(3AM)            xxxxxxxxxx-o--o--o--|
            //   xs.SU(5AM).SU(3AM)    xxxxxxxxx--------o--|      xs.SU(3AM).SU(5AM)    xxxxxxxxxxxxxxxx-o--|
            //
            if (System.DateTimeOffset.op_LessThanOrEqual(startTime, this._startTime)) {
                return this;
            } else {
                return new (System.Reactive.Linq.ObservableImpl.SkipUntil$1(TSource))(this._source, startTime.$clone(), this._scheduler);
            }
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.SkipUntil$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SkipUntil$2", function (TSource, TOther) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _other: null,
        ctor: function (source, other) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._other = other;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.SkipUntil$2._(TSource,TOther))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SkipWhile$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _predicate: null,
        _predicateI: null,
        ctor: function (source, predicate) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._predicate = predicate;
        },
        $ctor1: function (source, predicate) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._predicateI = predicate;
        },
        run: function (observer, cancel, setSink) {
            if (!Bridge.staticEquals(this._predicate, null)) {
                var sink = new (System.Reactive.Linq.ObservableImpl.SkipWhile$1._(TSource))(this, observer, cancel);
                setSink(sink);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.SkipWhile$1.SkipWhileImpl(TSource))(this, observer, cancel);
                setSink(sink1);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink1);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumDecimal", {
        inherits: [System.Reactive.Producer$1(System.Decimal)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Decimal).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.SumDecimal._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Decimal, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumDecimalNullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Decimal))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Decimal)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.SumDecimalNullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Decimal), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumDouble", {
        inherits: [System.Reactive.Producer$1(System.Double)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Double).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.SumDouble._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Double, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumDoubleNullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Double))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Double)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.SumDoubleNullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Double), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumInt32", {
        inherits: [System.Reactive.Producer$1(System.Int32)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Int32).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.SumInt32._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Int32, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumInt32Nullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Int32))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Int32)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.SumInt32Nullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Int32), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumInt64", {
        inherits: [System.Reactive.Producer$1(System.Int64)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Int64).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.SumInt64._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Int64, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumInt64Nullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Int64))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Int64)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.SumInt64Nullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Int64), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumSingle", {
        inherits: [System.Reactive.Producer$1(System.Single)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Single).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.SumSingle._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Single, this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.SumSingleNullable", {
        inherits: [System.Reactive.Producer$1(System.Nullable$1(System.Single))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Nullable$1(System.Single)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new System.Reactive.Linq.ObservableImpl.SumSingleNullable._(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(System.Nullable$1(System.Single), this._source, sink);
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Switch$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _sources: null,
        ctor: function (sources) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._sources = sources;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Switch$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Synchronize$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _gate: null,
        $ctor1: function (source, gate) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._gate = gate;
        },
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Synchronize$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return this._source["System$IObservable$1$" + Bridge.getTypeAlias(TSource) + "$subscribe"](sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Take$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _count: 0,
        _scheduler: null,
        config: {
            init: function () {
                this._duration = new System.TimeSpan();
            }
        },
        ctor: function (source, count) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._count = count;
        },
        $ctor1: function (source, duration, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._duration = duration;
            this._scheduler = scheduler;
        },
        omega: function (count) {
            //
            // Minimum semantics:
            //
            //   xs                    --o--o--o--o--o--o--|      xs                    --o--o--o--o--o--o--|
            //   xs.Take(5)            --o--o--o--o--o|           xs.Take(3)            --o--o--o|
            //   xs.Take(5).Take(3)    --o--o--o|                 xs.Take(3).Take(5)    --o--o--o|
            //
            if (this._count <= count) {
                return this;
            } else {
                return new (System.Reactive.Linq.ObservableImpl.Take$1(TSource)).ctor(this._source, count);
            }
        },
        omega$1: function (duration) {
            //
            // Minimum semantics:
            //
            //   t                     0--1--2--3--4--5--6--7->   t                     0--1--2--3--4--5--6--7->
            //                                                    
            //   xs                    --o--o--o--o--o--o--|      xs                    --o--o--o--o--o--o--|
            //   xs.Take(5s)           --o--o--o--o--o|           xs.Take(3s)           --o--o--o|
            //   xs.Take(5s).Take(3s)  --o--o--o|                 xs.Take(3s).Take(5s)  --o--o--o|
            //
            if (System.TimeSpan.lte(this._duration, duration)) {
                return this;
            } else {
                return new (System.Reactive.Linq.ObservableImpl.Take$1(TSource)).$ctor1(this._source, duration, this._scheduler);
            }
        },
        run: function (observer, cancel, setSink) {
            if (this._scheduler == null) {
                var sink = new (System.Reactive.Linq.ObservableImpl.Take$1._(TSource))(this, observer, cancel);
                setSink(sink);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.Take$1.TakeImpl(TSource))(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.TakeLast$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _count: 0,
        _scheduler: null,
        _loopScheduler: null,
        config: {
            init: function () {
                this._duration = new System.TimeSpan();
            }
        },
        ctor: function (source, count, loopScheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._count = count;
            this._loopScheduler = loopScheduler;
        },
        $ctor1: function (source, duration, scheduler, loopScheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._duration = duration;
            this._scheduler = scheduler;
            this._loopScheduler = loopScheduler;
        },
        run: function (observer, cancel, setSink) {
            if (this._scheduler == null) {
                var sink = new (System.Reactive.Linq.ObservableImpl.TakeLast$1._(TSource))(this, observer, cancel);
                setSink(sink);
                return sink.run();
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.TakeLast$1.TakeLastImpl(TSource))(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.TakeLastBuffer$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource))],
        _source: null,
        _count: 0,
        _scheduler: null,
        config: {
            init: function () {
                this._duration = new System.TimeSpan();
            }
        },
        ctor: function (source, count) {
            this.$initialize();
            System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this);
            this._source = source;
            this._count = count;
        },
        $ctor1: function (source, duration, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this);
            this._source = source;
            this._duration = duration;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            if (this._scheduler == null) {
                var sink = new (System.Reactive.Linq.ObservableImpl.TakeLastBuffer$1._(TSource))(this, observer, cancel);
                setSink(sink);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.TakeLastBuffer$1.Impl(TSource))(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.TakeUntil$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _scheduler: null,
        config: {
            init: function () {
                this._endTime = new System.DateTimeOffset();
            }
        },
        ctor: function (source, endTime, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._endTime = endTime.$clone();
            this._scheduler = scheduler;
        },
        omega: function (endTime) {
            //
            // Minimum semantics:
            //
            //   t                     0--1--2--3--4--5--6--7->   t                     0--1--2--3--4--5--6--7->
            //
            //   xs                    --o--o--o--o--o--o--|      xs                    --o--o--o--o--o--o--|
            //   xs.TU(5AM)            --o--o--o--o--o|           xs.TU(3AM)            --o--o--o|
            //   xs.TU(5AM).TU(3AM)    --o--o--o|                 xs.TU(3AM).TU(5AM)    --o--o--o|
            //
            if (System.DateTimeOffset.op_LessThanOrEqual(this._endTime, endTime)) {
                return this;
            } else {
                return new (System.Reactive.Linq.ObservableImpl.TakeUntil$1(TSource))(this._source, endTime.$clone(), this._scheduler);
            }
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.TakeUntil$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.TakeUntil$2", function (TSource, TOther) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _other: null,
        ctor: function (source, other) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._other = other;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.TakeUntil$2._(TSource,TOther))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.TakeWhile$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _predicate: null,
        _predicateI: null,
        ctor: function (source, predicate) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._predicate = predicate;
        },
        $ctor1: function (source, predicate) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._predicateI = predicate;
        },
        run: function (observer, cancel, setSink) {
            if (!Bridge.staticEquals(this._predicate, null)) {
                var sink = new (System.Reactive.Linq.ObservableImpl.TakeWhile$1._(TSource))(this, observer, cancel);
                setSink(sink);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.TakeWhile$1.TakeWhileImpl(TSource))(this, observer, cancel);
                setSink(sink1);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink1);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Throttle$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _scheduler: null,
        config: {
            init: function () {
                this._dueTime = new System.TimeSpan();
            }
        },
        ctor: function (source, dueTime, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._dueTime = dueTime;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Throttle$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Throttle$2", function (TSource, TThrottle) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _throttleSelector: null,
        ctor: function (source, throttleSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._throttleSelector = throttleSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Throttle$2._(TSource,TThrottle))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Throw$1", function (TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _exception: null,
        _scheduler: null,
        ctor: function (exception, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._exception = exception;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Throw$1._(TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.TimeInterval$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(System.Reactive.TimeInterval$1(TSource))],
        _source: null,
        _scheduler: null,
        ctor: function (source, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(System.Reactive.TimeInterval$1(TSource)).ctor.call(this);
            this._source = source;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.TimeInterval$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Timeout$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _dueTimeR: null,
        _dueTimeA: null,
        _other: null,
        _scheduler: null,
        $ctor1: function (source, dueTime, other, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._dueTimeR = dueTime;
            this._other = other;
            this._scheduler = scheduler;
        },
        ctor: function (source, dueTime, other, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._dueTimeA = dueTime.$clone();
            this._other = other;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            if (System.Nullable.hasValue(this._dueTimeA)) {
                var sink = new (System.Reactive.Linq.ObservableImpl.Timeout$1.TimeA(TSource))(this, observer, cancel);
                setSink(sink);
                return sink.run();
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.Timeout$1.TimeR(TSource))(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Timeout$2", function (TSource, TTimeout) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _firstTimeout: null,
        _timeoutSelector: null,
        _other: null,
        ctor: function (source, firstTimeout, timeoutSelector, other) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._firstTimeout = firstTimeout;
            this._timeoutSelector = timeoutSelector;
            this._other = other;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Timeout$2._(TSource,TTimeout))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Timer", {
        inherits: [System.Reactive.Producer$1(System.Int64)],
        _dueTimeA: null,
        _dueTimeR: null,
        _period: null,
        _scheduler: null,
        ctor: function (dueTime, period, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(System.Int64).ctor.call(this);
            this._dueTimeA = dueTime.$clone();
            this._period = period;
            this._scheduler = scheduler;
        },
        $ctor1: function (dueTime, period, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(System.Int64).ctor.call(this);
            this._dueTimeR = dueTime;
            this._period = period;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            if (System.Nullable.hasValue(this._period)) {
                var sink = new System.Reactive.Linq.ObservableImpl.Timer.TimerImpl(this, observer, cancel);
                setSink(sink);
                return sink.run();
            } else {
                var sink1 = new System.Reactive.Linq.ObservableImpl.Timer._(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            }
        }
    });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Timestamp$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(System.Reactive.Timestamped$1(TSource))],
        _source: null,
        _scheduler: null,
        ctor: function (source, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(System.Reactive.Timestamped$1(TSource)).ctor.call(this);
            this._source = source;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Timestamp$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ToArray$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(Array)],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(Array).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.ToArray$1._(TSource))(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ToDictionary$3", function (TSource, TKey, TElement) { return {
        inherits: [System.Reactive.Producer$1(System.Collections.Generic.IDictionary$2(TKey,TElement))],
        _source: null,
        _keySelector: null,
        _elementSelector: null,
        _comparer: null,
        ctor: function (source, keySelector, elementSelector, comparer) {
            this.$initialize();
            System.Reactive.Producer$1(System.Collections.Generic.IDictionary$2(TKey,TElement)).ctor.call(this);
            this._source = source;
            this._keySelector = keySelector;
            this._elementSelector = elementSelector;
            this._comparer = comparer;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.ToDictionary$3._(TSource,TKey,TElement))(this, observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ToList$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource))],
        _source: null,
        ctor: function (source) {
            this.$initialize();
            System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this);
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.ToList$1._(TSource))(observer, cancel);
            setSink(sink);
            return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ToObservable$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _scheduler: null,
        ctor: function (source, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.ToObservable$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Using$2", function (TSource, TResource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _resourceFactory: null,
        _observableFactory: null,
        ctor: function (resourceFactory, observableFactory) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._resourceFactory = resourceFactory;
            this._observableFactory = observableFactory;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Using$2._(TSource,TResource))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Where$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource)],
        _source: null,
        _predicate: null,
        _predicateI: null,
        ctor: function (source, predicate) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._predicate = predicate;
        },
        $ctor1: function (source, predicate) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._source = source;
            this._predicateI = predicate;
        },
        omega: function (predicate) {
            if (!Bridge.staticEquals(this._predicate, null)) {
                return new (System.Reactive.Linq.ObservableImpl.Where$1(TSource)).ctor(this._source, Bridge.fn.bind(this, function (x) {
                    return this._predicate(x) && predicate(x);
                }));
            } else {
                return new (System.Reactive.Linq.ObservableImpl.Where$1(TSource)).ctor(this, predicate);
            }
        },
        run: function (observer, cancel, setSink) {
            if (!Bridge.staticEquals(this._predicate, null)) {
                var sink = new (System.Reactive.Linq.ObservableImpl.Where$1._(TSource))(this, observer, cancel);
                setSink(sink);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink);
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.Where$1.WhereImpl(TSource))(this, observer, cancel);
                setSink(sink1);
                return System.ObservableExtensions.subscribeSafe(TSource, this._source, sink1);
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.While$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(TSource),System.Reactive.IConcatenatable$1(TSource)],
        _condition: null,
        _source: null,
        config: {
            alias: [
            "getSources", "System$Reactive$IConcatenatable$1$" + Bridge.getTypeAlias(TSource) + "$getSources"
            ]
        },
        ctor: function (condition, source) {
            this.$initialize();
            System.Reactive.Producer$1(TSource).ctor.call(this);
            this._condition = condition;
            this._source = source;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.While$1._(TSource))(observer, cancel);
            setSink(sink);
            return sink.run(this.getSources());
        },
        getSources: function () {
            var $yield = [];
            while (this._condition()) {
                $yield.push(this._source);
            }
            return System.Array.toEnumerable($yield);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.While$1._", function (TSource) { return {
        inherits: [System.Reactive.ConcatSink$1(TSource)],
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"
            ]
        },
        ctor: function (observer, cancel) {
            this.$initialize();
            System.Reactive.ConcatSink$1(TSource).ctor.call(this, observer, cancel);
        },
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onNext"](value);
        },
        onError: function (error) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(TSource) + "$onError"](error);
            System.Reactive.ConcatSink$1(TSource).prototype.dispose.call(this);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Window$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(System.IObservable$1(TSource))],
        _source: null,
        _count: 0,
        _skip: 0,
        _scheduler: null,
        config: {
            init: function () {
                this._timeSpan = new System.TimeSpan();
                this._timeShift = new System.TimeSpan();
            }
        },
        ctor: function (source, count, skip) {
            this.$initialize();
            System.Reactive.Producer$1(System.IObservable$1(TSource)).ctor.call(this);
            this._source = source;
            this._count = count;
            this._skip = skip;
        },
        $ctor2: function (source, timeSpan, timeShift, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(System.IObservable$1(TSource)).ctor.call(this);
            this._source = source;
            this._timeSpan = timeSpan;
            this._timeShift = timeShift;
            this._scheduler = scheduler;
        },
        $ctor1: function (source, timeSpan, count, scheduler) {
            this.$initialize();
            System.Reactive.Producer$1(System.IObservable$1(TSource)).ctor.call(this);
            this._source = source;
            this._timeSpan = timeSpan;
            this._count = count;
            this._scheduler = scheduler;
        },
        run: function (observer, cancel, setSink) {
            if (this._scheduler == null) {
                var sink = new (System.Reactive.Linq.ObservableImpl.Window$1._(TSource))(this, observer, cancel);
                setSink(sink);
                return sink.run();
            } else if (this._count > 0) {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.Window$1.BoundedWindowImpl(TSource))(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            } else {
                if (System.TimeSpan.eq(this._timeSpan, this._timeShift)) {
                    var sink2 = new (System.Reactive.Linq.ObservableImpl.Window$1.TimeShiftImpl(TSource))(this, observer, cancel);
                    setSink(sink2);
                    return sink2.run();
                } else {
                    var sink3 = new (System.Reactive.Linq.ObservableImpl.Window$1.WindowImpl(TSource))(this, observer, cancel);
                    setSink(sink3);
                    return sink3.run();
                }
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Window$2", function (TSource, TWindowClosing) { return {
        inherits: [System.Reactive.Producer$1(System.IObservable$1(TSource))],
        _source: null,
        _windowClosingSelector: null,
        _windowBoundaries: null,
        ctor: function (source, windowClosingSelector) {
            this.$initialize();
            System.Reactive.Producer$1(System.IObservable$1(TSource)).ctor.call(this);
            this._source = source;
            this._windowClosingSelector = windowClosingSelector;
        },
        $ctor1: function (source, windowBoundaries) {
            this.$initialize();
            System.Reactive.Producer$1(System.IObservable$1(TSource)).ctor.call(this);
            this._source = source;
            this._windowBoundaries = windowBoundaries;
        },
        run: function (observer, cancel, setSink) {
            if (!Bridge.staticEquals(this._windowClosingSelector, null)) {
                var sink = new (System.Reactive.Linq.ObservableImpl.Window$2._(TSource,TWindowClosing))(this, observer, cancel);
                setSink(sink);
                return sink.run();
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.Window$2.Beta(TSource,TWindowClosing))(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.WithLatestFrom$3", function (TFirst, TSecond, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _first: null,
        _second: null,
        _resultSelector: null,
        ctor: function (first, second, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._first = first;
            this._second = second;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.WithLatestFrom$3._(TFirst,TSecond,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$1", function (TSource) { return {
        inherits: [System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource))],
        _sources: null,
        ctor: function (sources) {
            this.$initialize();
            System.Reactive.Producer$1(System.Collections.Generic.IList$1(TSource)).ctor.call(this);
            this._sources = sources;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Zip$1._(TSource))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$10", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _source9: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, source9, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._source9 = source9;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Zip$10._(T1,T2,T3,T4,T5,T6,T7,T8,T9,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$11", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _source9: null,
        _source10: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._source9 = source9;
            this._source10 = source10;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Zip$11._(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$12", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _source9: null,
        _source10: null,
        _source11: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._source9 = source9;
            this._source10 = source10;
            this._source11 = source11;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Zip$12._(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$13", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _source9: null,
        _source10: null,
        _source11: null,
        _source12: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._source9 = source9;
            this._source10 = source10;
            this._source11 = source11;
            this._source12 = source12;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Zip$13._(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$14", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _source9: null,
        _source10: null,
        _source11: null,
        _source12: null,
        _source13: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._source9 = source9;
            this._source10 = source10;
            this._source11 = source11;
            this._source12 = source12;
            this._source13 = source13;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Zip$14._(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$15", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _source9: null,
        _source10: null,
        _source11: null,
        _source12: null,
        _source13: null,
        _source14: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._source9 = source9;
            this._source10 = source10;
            this._source11 = source11;
            this._source12 = source12;
            this._source13 = source13;
            this._source14 = source14;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Zip$15._(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$16", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _source9: null,
        _source10: null,
        _source11: null,
        _source12: null,
        _source13: null,
        _source14: null,
        _source15: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._source9 = source9;
            this._source10 = source10;
            this._source11 = source11;
            this._source12 = source12;
            this._source13 = source13;
            this._source14 = source14;
            this._source15 = source15;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Zip$16._(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$17", function (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _source9: null,
        _source10: null,
        _source11: null,
        _source12: null,
        _source13: null,
        _source14: null,
        _source15: null,
        _source16: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, source9, source10, source11, source12, source13, source14, source15, source16, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._source9 = source9;
            this._source10 = source10;
            this._source11 = source11;
            this._source12 = source12;
            this._source13 = source13;
            this._source14 = source14;
            this._source15 = source15;
            this._source16 = source16;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Zip$17._(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$3", function (TFirst, TSecond, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _first: null,
        _second: null,
        _secondE: null,
        _resultSelector: null,
        $ctor1: function (first, second, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._first = first;
            this._second = second;
            this._resultSelector = resultSelector;
        },
        ctor: function (first, second, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._first = first;
            this._secondE = second;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            if (this._second != null) {
                var sink = new (System.Reactive.Linq.ObservableImpl.Zip$3._(TFirst,TSecond,TResult))(this, observer, cancel);
                setSink(sink);
                return sink.run();
            } else {
                var sink1 = new (System.Reactive.Linq.ObservableImpl.Zip$3.ZipImpl(TFirst,TSecond,TResult))(this, observer, cancel);
                setSink(sink1);
                return sink1.run();
            }
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$4", function (T1, T2, T3, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Zip$4._(T1,T2,T3,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$5", function (T1, T2, T3, T4, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Zip$5._(T1,T2,T3,T4,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$6", function (T1, T2, T3, T4, T5, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Zip$6._(T1,T2,T3,T4,T5,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$7", function (T1, T2, T3, T4, T5, T6, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Zip$7._(T1,T2,T3,T4,T5,T6,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$8", function (T1, T2, T3, T4, T5, T6, T7, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Zip$8._(T1,T2,T3,T4,T5,T6,T7,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.Zip$9", function (T1, T2, T3, T4, T5, T6, T7, T8, TResult) { return {
        inherits: [System.Reactive.Producer$1(TResult)],
        _source1: null,
        _source2: null,
        _source3: null,
        _source4: null,
        _source5: null,
        _source6: null,
        _source7: null,
        _source8: null,
        _resultSelector: null,
        ctor: function (source1, source2, source3, source4, source5, source6, source7, source8, resultSelector) {
            this.$initialize();
            System.Reactive.Producer$1(TResult).ctor.call(this);
            this._source1 = source1;
            this._source2 = source2;
            this._source3 = source3;
            this._source4 = source4;
            this._source5 = source5;
            this._source6 = source6;
            this._source7 = source7;
            this._source8 = source8;
            this._resultSelector = resultSelector;
        },
        run: function (observer, cancel, setSink) {
            var sink = new (System.Reactive.Linq.ObservableImpl.Zip$9._(T1,T2,T3,T4,T5,T6,T7,T8,TResult))(this, observer, cancel);
            setSink(sink);
            return sink.run();
        }
    }; });

    Bridge.define("System.Reactive.ObserveOnObserver$1", function (T) { return {
        inherits: [System.Reactive.ScheduledObserver$1(T)],
        _cancel: null,
        ctor: function (scheduler, observer, cancel) {
            this.$initialize();
            System.Reactive.ScheduledObserver$1(T).ctor.call(this, scheduler, observer);
            this._cancel = cancel;
        },
        onNextCore: function (value) {
            System.Reactive.ScheduledObserver$1(T).prototype.onNextCore.call(this, value);
            this.ensureActive();
        },
        onErrorCore: function (exception) {
            System.Reactive.ScheduledObserver$1(T).prototype.onErrorCore.call(this, exception);
            this.ensureActive();
        },
        onCompletedCore: function () {
            System.Reactive.ScheduledObserver$1(T).prototype.onCompletedCore.call(this);
            this.ensureActive();
        },
        dispose$1: function (disposing) {
            System.Reactive.ScheduledObserver$1(T).prototype.dispose$1.call(this, disposing);

            if (disposing) {
                var cancel = System.Interlocked.exchange(System.IDisposable, Bridge.ref(this, "_cancel"), null);
                if (cancel != null) {
                    cancel.System$IDisposable$dispose();
                }
            }
        }
    }; });

    /**
     * Base calss for objects that are both an observable sequence as well as an observer.
     *
     * @abstract
     * @public
     * @class System.Reactive.Subjects.SubjectBase$1
     * @implements  System.Reactive.Subjects.ISubject$1
     * @implements  System.IDisposable
     * @param   {Function}    [name]    The type of the elements processed by the subject.
     */
    Bridge.define("System.Reactive.Subjects.SubjectBase$1", function (T) { return {
        inherits: [System.Reactive.Subjects.ISubject$1(T),System.IDisposable]
    }; });

    Bridge.define("System.Reactive.Subjects.Subject.AnonymousSubject$1", function (T) { return {
        inherits: [System.Reactive.Subjects.Subject.AnonymousSubject$2(T,T),System.Reactive.Subjects.ISubject$1(T)],
        ctor: function (observer, observable) {
            this.$initialize();
            System.Reactive.Subjects.Subject.AnonymousSubject$2(T,T).ctor.call(this, observer, observable);
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.ClassicEventProducer$2", function (TDelegate, TArgs) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.EventProducer$2(TDelegate,TArgs)],
        _addHandler: null,
        _removeHandler: null,
        ctor: function (addHandler, removeHandler, scheduler) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.EventProducer$2(TDelegate,TArgs).ctor.call(this, scheduler);
            this._addHandler = addHandler;
            this._removeHandler = removeHandler;
        },
        addHandler: function (handler) {
            this._addHandler(handler);
            return System.Reactive.Disposables.Disposable.create(Bridge.fn.bind(this, function () {
                this._removeHandler(handler);
            }));
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.FromEventPattern.Handler$3", function (TSender, TEventArgs, TResult) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.EventProducer$2(Function,TResult)],
        _target: null,
        _delegateType: null,
        _addMethod: null,
        _removeMethod: null,
        _getResult: null,
        ctor: function (target, delegateType, addMethod, removeMethod, getResult, isWinRT, scheduler) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.EventProducer$2(Function,TResult).ctor.call(this, scheduler);
            this._target = target;
            this._delegateType = delegateType;
            this._addMethod = addMethod;
            this._removeMethod = removeMethod;
            this._getResult = getResult;
        },
        getHandler: function (onNext) {
            var h = Bridge.fn.bind(this, function (sender, eventArgs) {
                onNext(this._getResult(sender, eventArgs));
            });
            return System.Reactive.ReflectionUtils.createDelegate$1(this._delegateType, h, Bridge.Reflection.getMembers(Function, 8, 284, "Invoke"));
        },
        addHandler: function (handler) {
            var removeHandler = null;

            try {
                {
                    Bridge.Reflection.midel(this._addMethod, this._target).apply(null, [handler]);
                    removeHandler = Bridge.fn.bind(this, function () {
                        Bridge.Reflection.midel(this._removeMethod, this._target).apply(null, [handler]);
                    });
                }
            }
            catch ($e1) {
                $e1 = System.Exception.create($e1);
                var tie;
                if (Bridge.is($e1, System.TargetInvocationException)) {
                    tie = $e1;
                    throw tie.getInnerException();
                } else {
                    throw $e1;
                }
            }

            return System.Reactive.Disposables.Disposable.create(function () {
                try {
                    removeHandler();
                }
                catch ($e2) {
                    $e2 = System.Exception.create($e2);
                    var tie;
                    if (Bridge.is($e2, System.TargetInvocationException)) {
                        tie = $e2;
                        throw tie.getInnerException();
                    } else {
                        throw $e2;
                    }
                }
            });
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.WindowObservable$1", function (TSource) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.AddRef$1(TSource)],
        ctor: function (source, refCount) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.AddRef$1(TSource).ctor.call(this, source, refCount);
        }
    }; });

    /**
     * Represents the result of an asynchronous operation.
     The last value before the OnCompleted notification, or the error received through OnError, is sent to all subscribed observers.
     *
     * @public
     * @class System.Reactive.Subjects.AsyncSubject$1
     * @augments System.Reactive.Subjects.SubjectBase$1
     * @implements  System.IDisposable
     * @param   {Function}    [name]    The type of the elements processed by the subject.
     */
    Bridge.define("System.Reactive.Subjects.AsyncSubject$1", function (T) { return {
        inherits: [System.Reactive.Subjects.SubjectBase$1(T),System.IDisposable],
        _gate: null,
        _observers: null,
        _isDisposed: false,
        _isStopped: false,
        _value: Bridge.getDefaultValue(T),
        _hasValue: false,
        _exception: null,
        config: {
            alias: [
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext",
            "subscribe", "System$IObservable$1$" + Bridge.getTypeAlias(T) + "$subscribe",
            "dispose", "System$IDisposable$dispose"
            ],
            init: function () {
                this._gate = {  };
            }
        },
        /**
         * Creates a subject that can only receive one value and that value is cached for all future observations.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.AsyncSubject$1
         * @memberof System.Reactive.Subjects.AsyncSubject$1
         * @return  {void}
         */
        ctor: function () {
            this.$initialize();
            System.Reactive.Subjects.SubjectBase$1(T).ctor.call(this);
            this._observers = System.Reactive.ImmutableList$1(System.IObserver$1(T)).empty;
        },
        /**
         * Indicates whether the subject has observers subscribed to it.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.AsyncSubject$1
         * @memberof System.Reactive.Subjects.AsyncSubject$1
         * @function getHasObservers
         * @return  {boolean}
         */
        /**
         * Indicates whether the subject has observers subscribed to it.
         *
         * @instance
         * @function setHasObservers
         */
        getHasObservers: function () {
            var observers = this._observers;
            return observers != null && observers.getData().length > 0;
        },
        /**
         * Indicates whether the subject has been disposed.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.AsyncSubject$1
         * @memberof System.Reactive.Subjects.AsyncSubject$1
         * @function getIsDisposed
         * @return  {boolean}
         */
        /**
         * Indicates whether the subject has been disposed.
         *
         * @instance
         * @function setIsDisposed
         */
        getIsDisposed: function () {
            this._gate;
            {
                return this._isDisposed;
            }
        },
        /**
         * Gets whether the AsyncSubject has completed.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.AsyncSubject$1
         * @memberof System.Reactive.Subjects.AsyncSubject$1
         * @function getIsCompleted
         * @return  {boolean}
         */
        /**
         * Gets whether the AsyncSubject has completed.
         *
         * @instance
         * @function setIsCompleted
         */
        getIsCompleted: function () {
            return this._isStopped;
        },
        /**
         * Notifies all subscribed observers about the end of the sequence, also causing the last received value to be sent out (if any).
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.AsyncSubject$1
         * @memberof System.Reactive.Subjects.AsyncSubject$1
         * @return  {void}
         */
        onCompleted: function () {
            var $t, $t1;
            var os = null;

            var v = Bridge.getDefaultValue(T);
            var hv = false;
            this._gate;
            {
                this.checkDisposed();

                if (!this._isStopped) {
                    os = this._observers.getData();
                    this._observers = System.Reactive.ImmutableList$1(System.IObserver$1(T)).empty;
                    this._isStopped = true;
                    v = this._value;
                    hv = this._hasValue;
                }
            }

            if (os != null) {
                if (hv) {
                    $t = Bridge.getEnumerator(os);
                    while ($t.moveNext()) {
                        var o = $t.getCurrent();
                        o["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](v);
                        o["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
                    }
                } else {
                    $t1 = Bridge.getEnumerator(os);
                    while ($t1.moveNext()) {
                        var o1 = $t1.getCurrent();
                        o1["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
                    }
                }
            }
        },
        onCompleted$1: function (continuation, originalContext) {
            //
            // [OK] Use of unsafe Subscribe: this type's Subscribe implementation is safe.
            //
            this.subscribe(new (System.Reactive.Subjects.AsyncSubject$1.AwaitObserver(T))(continuation, originalContext));
        },
        /**
         * Notifies all subscribed observers about the exception.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.AsyncSubject$1
         * @memberof System.Reactive.Subjects.AsyncSubject$1
         * @throws <b /> is null.
         * @param   {System.Exception}    error    The exception to send to all observers.
         * @return  {void}
         */
        onError: function (error) {
            var $t;
            if (error == null) {
                throw new System.ArgumentNullException("error");
            }

            var os = null;
            this._gate;
            {
                this.checkDisposed();

                if (!this._isStopped) {
                    os = this._observers.getData();
                    this._observers = System.Reactive.ImmutableList$1(System.IObserver$1(T)).empty;
                    this._isStopped = true;
                    this._exception = error;
                }
            }

            if (os != null) {
                $t = Bridge.getEnumerator(os);
                while ($t.moveNext()) {
                    var o = $t.getCurrent();
                    o["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](error);
                }
            }
        },
        /**
         * Sends a value to the subject. The last value received before successful termination will be sent to all subscribed and future observers.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.AsyncSubject$1
         * @memberof System.Reactive.Subjects.AsyncSubject$1
         * @param   {T}       value    The value to store in the subject.
         * @return  {void}
         */
        onNext: function (value) {
            this._gate;
            {
                this.checkDisposed();

                if (!this._isStopped) {
                    this._value = value;
                    this._hasValue = true;
                }
            }
        },
        /**
         * Subscribes an observer to the subject.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.AsyncSubject$1
         * @memberof System.Reactive.Subjects.AsyncSubject$1
         * @throws <b /> is null.
         * @param   {System.IObserver$1}    observer    Observer to subscribe to the subject.
         * @return  {System.IDisposable}                Disposable object that can be used to unsubscribe the observer from the subject.
         */
        subscribe: function (observer) {
            if (observer == null) {
                throw new System.ArgumentNullException("observer");
            }

            var ex = null;
            var v = Bridge.getDefaultValue(T);
            var hv = false;

            this._gate;
            {
                this.checkDisposed();

                if (!this._isStopped) {
                    this._observers = this._observers.add(observer);
                    return new (System.Reactive.Subjects.AsyncSubject$1.Subscription(T))(this, observer);
                }

                ex = this._exception;
                hv = this._hasValue;
                v = this._value;
            }

            if (ex != null) {
                observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](ex);
            } else if (hv) {
                observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](v);
                observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
            } else {
                observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
            }

            return System.Reactive.Disposables.Disposable.getEmpty();
        },
        checkDisposed: function () {
            if (this._isDisposed) {
                throw new System.ObjectDisposedException("");
            }
        },
        /**
         * Unsubscribe all observers and release resources.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.AsyncSubject$1
         * @memberof System.Reactive.Subjects.AsyncSubject$1
         * @return  {void}
         */
        dispose: function () {
            this._gate;
            {
                this._isDisposed = true;
                this._observers = null;
                this._exception = null;
                this._value = Bridge.getDefaultValue(T);
            }
        },
        /**
         * Gets the last element of the subject, potentially blocking until the subject completes successfully or exceptionally.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.AsyncSubject$1
         * @memberof System.Reactive.Subjects.AsyncSubject$1
         * @throws The source sequence is empty.
         * @return  {T}        The last element of the subject. Throws an InvalidOperationException if no element was received.
         */
        getResult: function () {
            if (!this._isStopped) {
                var e = new System.Threading.ManualResetEvent(false);
                this.onCompleted$1(function () {
                    e.set();
                }, false);
                e.waitOne();
            }

            System.Reactive.ExceptionHelpers.throwIfNotNull(this._exception);

            if (!this._hasValue) {
                throw new System.InvalidOperationException(System.Reactive.Strings_Linq.NO_ELEMENTS);
            }

            return this._value;
        }
    }; });

    /**
     * Represents a value that changes over time.
     Observers can subscribe to the subject to receive the last (or initial) value and all subsequent notifications.
     *
     * @public
     * @class System.Reactive.Subjects.BehaviorSubject$1
     * @augments System.Reactive.Subjects.SubjectBase$1
     * @implements  System.IDisposable
     * @param   {Function}    [name]    The type of the elements processed by the subject.
     */
    Bridge.define("System.Reactive.Subjects.BehaviorSubject$1", function (T) { return {
        inherits: [System.Reactive.Subjects.SubjectBase$1(T),System.IDisposable],
        _gate: null,
        _observers: null,
        _isStopped: false,
        _value: Bridge.getDefaultValue(T),
        _exception: null,
        _isDisposed: false,
        config: {
            alias: [
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext",
            "subscribe", "System$IObservable$1$" + Bridge.getTypeAlias(T) + "$subscribe",
            "dispose", "System$IDisposable$dispose"
            ],
            init: function () {
                this._gate = {  };
            }
        },
        /**
         * Initializes a new instance of the {@link } class which creates a subject that caches its last value and starts with the specified value.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.BehaviorSubject$1
         * @memberof System.Reactive.Subjects.BehaviorSubject$1
         * @param   {T}       value    Initial value sent to observers when no other value has been received by the subject yet.
         * @return  {void}
         */
        ctor: function (value) {
            this.$initialize();
            System.Reactive.Subjects.SubjectBase$1(T).ctor.call(this);
            this._value = value;
            this._observers = System.Reactive.ImmutableList$1(System.IObserver$1(T)).empty;
        },
        /**
         * Indicates whether the subject has observers subscribed to it.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.BehaviorSubject$1
         * @memberof System.Reactive.Subjects.BehaviorSubject$1
         * @function getHasObservers
         * @return  {boolean}
         */
        /**
         * Indicates whether the subject has observers subscribed to it.
         *
         * @instance
         * @function setHasObservers
         */
        getHasObservers: function () {
            var observers = this._observers;
            return observers != null && observers.getData().length > 0;
        },
        /**
         * Indicates whether the subject has been disposed.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.BehaviorSubject$1
         * @memberof System.Reactive.Subjects.BehaviorSubject$1
         * @function getIsDisposed
         * @return  {boolean}
         */
        /**
         * Indicates whether the subject has been disposed.
         *
         * @instance
         * @function setIsDisposed
         */
        getIsDisposed: function () {
            this._gate;
            {
                return this._isDisposed;
            }
        },
        /**
         * Gets the current value or throws an exception.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.BehaviorSubject$1
         * @memberof System.Reactive.Subjects.BehaviorSubject$1
         * @function getValue
         * @throws Dispose was called.
         * @return  {T}
         */
        /**
         * Gets the current value or throws an exception.
         *
         * @instance
         * @function setValue
         * @throws Dispose was called.
         */
        getValue: function () {
            this._gate;
            {
                this.checkDisposed();

                if (this._exception != null) {
                    throw this._exception;
                }

                return this._value;
            }
        },
        /**
         * Tries to get the current value or throws an exception.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.BehaviorSubject$1
         * @memberof System.Reactive.Subjects.BehaviorSubject$1
         * @param   {T}          value    The initial value passed to the constructor until {@link } is called; after which, the last value passed to {@link }.
         * @return  {boolean}             true if a value is available; false if the subject was disposed.
         */
        tryGetValue: function (value) {
            this._gate;
            {
                if (this._isDisposed) {
                    value.v = Bridge.getDefaultValue(T);
                    return false;
                } else if (this._exception != null) {
                    throw this._exception;
                } else {
                    value.v = this._value;
                    return true;
                }
            }
        },
        /**
         * Notifies all subscribed observers about the end of the sequence.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.BehaviorSubject$1
         * @memberof System.Reactive.Subjects.BehaviorSubject$1
         * @return  {void}
         */
        onCompleted: function () {
            var $t;
            var os = null;
            this._gate;
            {
                this.checkDisposed();

                if (!this._isStopped) {
                    os = this._observers.getData();
                    this._observers = System.Reactive.ImmutableList$1(System.IObserver$1(T)).empty;
                    this._isStopped = true;
                }
            }

            if (os != null) {
                $t = Bridge.getEnumerator(os);
                while ($t.moveNext()) {
                    var o = $t.getCurrent();
                    o["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
                }
            }
        },
        /**
         * Notifies all subscribed observers about the exception.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.BehaviorSubject$1
         * @memberof System.Reactive.Subjects.BehaviorSubject$1
         * @throws <b /> is null.
         * @param   {System.Exception}    error    The exception to send to all observers.
         * @return  {void}
         */
        onError: function (error) {
            var $t;
            if (error == null) {
                throw new System.ArgumentNullException("error");
            }

            var os = null;
            this._gate;
            {
                this.checkDisposed();

                if (!this._isStopped) {
                    os = this._observers.getData();
                    this._observers = System.Reactive.ImmutableList$1(System.IObserver$1(T)).empty;
                    this._isStopped = true;
                    this._exception = error;
                }
            }

            if (os != null) {
                $t = Bridge.getEnumerator(os);
                while ($t.moveNext()) {
                    var o = $t.getCurrent();
                    o["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](error);
                }
            }
        },
        /**
         * Notifies all subscribed observers about the arrival of the specified element in the sequence.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.BehaviorSubject$1
         * @memberof System.Reactive.Subjects.BehaviorSubject$1
         * @param   {T}       value    The value to send to all observers.
         * @return  {void}
         */
        onNext: function (value) {
            var $t;
            var os = null;
            this._gate;
            {
                this.checkDisposed();

                if (!this._isStopped) {
                    this._value = value;
                    os = this._observers.getData();
                }
            }

            if (os != null) {
                $t = Bridge.getEnumerator(os);
                while ($t.moveNext()) {
                    var o = $t.getCurrent();
                    o["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](value);
                }
            }
        },
        /**
         * Subscribes an observer to the subject.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.BehaviorSubject$1
         * @memberof System.Reactive.Subjects.BehaviorSubject$1
         * @throws <b /> is null.
         * @param   {System.IObserver$1}    observer    Observer to subscribe to the subject.
         * @return  {System.IDisposable}                Disposable object that can be used to unsubscribe the observer from the subject.
         */
        subscribe: function (observer) {
            if (observer == null) {
                throw new System.ArgumentNullException("observer");
            }

            var ex = null;

            this._gate;
            {
                this.checkDisposed();

                if (!this._isStopped) {
                    this._observers = this._observers.add(observer);
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](this._value);
                    return new (System.Reactive.Subjects.BehaviorSubject$1.Subscription(T))(this, observer);
                }

                ex = this._exception;
            }

            if (ex != null) {
                observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](ex);
            } else {
                observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
            }

            return System.Reactive.Disposables.Disposable.getEmpty();
        },
        /**
         * Unsubscribe all observers and release resources.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.BehaviorSubject$1
         * @memberof System.Reactive.Subjects.BehaviorSubject$1
         * @return  {void}
         */
        dispose: function () {
            this._gate;
            {
                this._isDisposed = true;
                this._observers = null;
                this._value = Bridge.getDefaultValue(T);
                this._exception = null;
            }
        },
        checkDisposed: function () {
            if (this._isDisposed) {
                throw new System.ObjectDisposedException("");
            }
        }
    }; });

    /**
     * Represents an object that is both an observable sequence as well as an observer.
     Each notification is broadcasted to all subscribed and future observers, subject to buffer trimming policies.
     *
     * @public
     * @class System.Reactive.Subjects.ReplaySubject$1
     * @augments System.Reactive.Subjects.SubjectBase$1
     * @implements  System.IDisposable
     * @param   {Function}    [name]    The type of the elements processed by the subject.
     */
    Bridge.define("System.Reactive.Subjects.ReplaySubject$1", function (T) { return {
        inherits: [System.Reactive.Subjects.SubjectBase$1(T),System.IDisposable],
        /**
         * Underlying optimized implementation of the replay subject.
         *
         * @instance
         */
        _implementation: null,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted",
            "subscribe", "System$IObservable$1$" + Bridge.getTypeAlias(T) + "$subscribe",
            "dispose", "System$IDisposable$dispose"
            ]
        },
        /**
         * Initializes a new instance of the {@link } class.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.ReplaySubject$1
         * @memberof System.Reactive.Subjects.ReplaySubject$1
         * @return  {void}
         */
        ctor: function () {
            System.Reactive.Subjects.ReplaySubject$1(T).$ctor1.call(this, 2147483647);
        },
        /**
         * Initializes a new instance of the {@link } class with the specified scheduler.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.ReplaySubject$1
         * @memberof System.Reactive.Subjects.ReplaySubject$1
         * @throws <b /> is null.
         * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler the observers are invoked on.
         * @return  {void}
         */
        $ctor5: function (scheduler) {
            this.$initialize();
            System.Reactive.Subjects.SubjectBase$1(T).ctor.call(this);
            this._implementation = new (System.Reactive.Subjects.ReplaySubject$1.ReplayByTime(T)).$ctor3(scheduler);
        },
        /**
         * Initializes a new instance of the {@link } class with the specified buffer size.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.ReplaySubject$1
         * @memberof System.Reactive.Subjects.ReplaySubject$1
         * @throws <b /> is less than zero.
         * @param   {number}    bufferSize    Maximum element count of the replay buffer.
         * @return  {void}
         */
        $ctor1: function (bufferSize) {
            this.$initialize();
            System.Reactive.Subjects.SubjectBase$1(T).ctor.call(this);
            switch (bufferSize) {
                case 1: 
                    this._implementation = new (System.Reactive.Subjects.ReplaySubject$1.ReplayOne(T))();
                    break;
                case 2147483647: 
                    this._implementation = new (System.Reactive.Subjects.ReplaySubject$1.ReplayAll(T))();
                    break;
                default: 
                    this._implementation = new (System.Reactive.Subjects.ReplaySubject$1.ReplayMany(T))(bufferSize);
                    break;
            }
        },
        /**
         * Initializes a new instance of the {@link } class with the specified buffer size and scheduler.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.ReplaySubject$1
         * @memberof System.Reactive.Subjects.ReplaySubject$1
         * @throws <b /> is null.
         * @throws <b /> is less than zero.
         * @param   {number}                                    bufferSize    Maximum element count of the replay buffer.
         * @param   {System.Reactive.Concurrency.IScheduler}    scheduler     Scheduler the observers are invoked on.
         * @return  {void}
         */
        $ctor2: function (bufferSize, scheduler) {
            this.$initialize();
            System.Reactive.Subjects.SubjectBase$1(T).ctor.call(this);
            this._implementation = new (System.Reactive.Subjects.ReplaySubject$1.ReplayByTime(T)).ctor(bufferSize, scheduler);
        },
        /**
         * Initializes a new instance of the {@link } class with the specified window.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.ReplaySubject$1
         * @memberof System.Reactive.Subjects.ReplaySubject$1
         * @throws <b /> is less than TimeSpan.Zero.
         * @param   {System.TimeSpan}    window    Maximum time length of the replay buffer.
         * @return  {void}
         */
        $ctor6: function ($window) {
            this.$initialize();
            System.Reactive.Subjects.SubjectBase$1(T).ctor.call(this);
            this._implementation = new (System.Reactive.Subjects.ReplaySubject$1.ReplayByTime(T)).$ctor4($window);
        },
        /**
         * Initializes a new instance of the {@link } class with the specified window and scheduler.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.ReplaySubject$1
         * @memberof System.Reactive.Subjects.ReplaySubject$1
         * @throws <b /> is null.
         * @throws <b /> is less than TimeSpan.Zero.
         * @param   {System.TimeSpan}                           window       Maximum time length of the replay buffer.
         * @param   {System.Reactive.Concurrency.IScheduler}    scheduler    Scheduler the observers are invoked on.
         * @return  {void}
         */
        $ctor7: function ($window, scheduler) {
            this.$initialize();
            System.Reactive.Subjects.SubjectBase$1(T).ctor.call(this);
            this._implementation = new (System.Reactive.Subjects.ReplaySubject$1.ReplayByTime(T)).$ctor5($window, scheduler);
        },
        /**
         * Initializes a new instance of the {@link } class with the specified buffer size and window.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.ReplaySubject$1
         * @memberof System.Reactive.Subjects.ReplaySubject$1
         * @throws <b /> is less than zero. -or- <b /> is less than TimeSpan.Zero.
         * @param   {number}             bufferSize    Maximum element count of the replay buffer.
         * @param   {System.TimeSpan}    window        Maximum time length of the replay buffer.
         * @return  {void}
         */
        $ctor3: function (bufferSize, $window) {
            this.$initialize();
            System.Reactive.Subjects.SubjectBase$1(T).ctor.call(this);
            this._implementation = new (System.Reactive.Subjects.ReplaySubject$1.ReplayByTime(T)).$ctor1(bufferSize, $window);
        },
        /**
         * Initializes a new instance of the {@link } class with the specified buffer size, window and scheduler.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.ReplaySubject$1
         * @memberof System.Reactive.Subjects.ReplaySubject$1
         * @throws <b /> is less than zero. -or- <b /> is less than TimeSpan.Zero.
         * @throws <b /> is null.
         * @param   {number}                                    bufferSize    Maximum element count of the replay buffer.
         * @param   {System.TimeSpan}                           window        Maximum time length of the replay buffer.
         * @param   {System.Reactive.Concurrency.IScheduler}    scheduler     Scheduler the observers are invoked on.
         * @return  {void}
         */
        $ctor4: function (bufferSize, $window, scheduler) {
            this.$initialize();
            System.Reactive.Subjects.SubjectBase$1(T).ctor.call(this);
            this._implementation = new (System.Reactive.Subjects.ReplaySubject$1.ReplayByTime(T)).$ctor2(bufferSize, $window, scheduler);
        },
        /**
         * Indicates whether the subject has observers subscribed to it.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.ReplaySubject$1
         * @memberof System.Reactive.Subjects.ReplaySubject$1
         * @function getHasObservers
         * @return  {boolean}
         */
        /**
         * Indicates whether the subject has observers subscribed to it.
         *
         * @instance
         * @function setHasObservers
         */
        getHasObservers: function () {
            return this._implementation.getHasObservers();
        },
        /**
         * Indicates whether the subject has been disposed.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.ReplaySubject$1
         * @memberof System.Reactive.Subjects.ReplaySubject$1
         * @function getIsDisposed
         * @return  {boolean}
         */
        /**
         * Indicates whether the subject has been disposed.
         *
         * @instance
         * @function setIsDisposed
         */
        getIsDisposed: function () {
            return this._implementation.getIsDisposed();
        },
        /**
         * Notifies all subscribed and future observers about the arrival of the specified element in the sequence.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.ReplaySubject$1
         * @memberof System.Reactive.Subjects.ReplaySubject$1
         * @param   {T}       value    The value to send to all observers.
         * @return  {void}
         */
        onNext: function (value) {
            this._implementation.onNext(value);
        },
        /**
         * Notifies all subscribed and future observers about the specified exception.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.ReplaySubject$1
         * @memberof System.Reactive.Subjects.ReplaySubject$1
         * @throws <b /> is null.
         * @param   {System.Exception}    error    The exception to send to all observers.
         * @return  {void}
         */
        onError: function (error) {
            if (error == null) {
                throw new System.ArgumentNullException("error");
            }

            this._implementation.onError(error);
        },
        /**
         * Notifies all subscribed and future observers about the end of the sequence.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.ReplaySubject$1
         * @memberof System.Reactive.Subjects.ReplaySubject$1
         * @return  {void}
         */
        onCompleted: function () {
            this._implementation.onCompleted();
        },
        /**
         * Subscribes an observer to the subject.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.ReplaySubject$1
         * @memberof System.Reactive.Subjects.ReplaySubject$1
         * @throws <b /> is null.
         * @param   {System.IObserver$1}    observer    Observer to subscribe to the subject.
         * @return  {System.IDisposable}                Disposable object that can be used to unsubscribe the observer from the subject.
         */
        subscribe: function (observer) {
            if (observer == null) {
                throw new System.ArgumentNullException("observer");
            }

            return this._implementation.subscribe(observer);
        },
        /**
         * Releases all resources used by the current instance of the {@link } class and unsubscribe all observers.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.ReplaySubject$1
         * @memberof System.Reactive.Subjects.ReplaySubject$1
         * @return  {void}
         */
        dispose: function () {
            this._implementation.dispose();
        }
    }; });

    Bridge.define("System.Reactive.Subjects.ReplaySubject$1.ReplayBase", function (T) { return {
        inherits: [System.Reactive.Subjects.SubjectBase$1(T)],
        _gate: null,
        _observers: null,
        _isStopped: false,
        _error: null,
        _isDisposed: false,
        config: {
            alias: [
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted",
            "subscribe", "System$IObservable$1$" + Bridge.getTypeAlias(T) + "$subscribe",
            "dispose", "System$IDisposable$dispose"
            ],
            init: function () {
                this._gate = {  };
            }
        },
        ctor: function () {
            this.$initialize();
            System.Reactive.Subjects.SubjectBase$1(T).ctor.call(this);
            this._observers = System.Reactive.ImmutableList$1(System.Reactive.IScheduledObserver$1(T)).empty;

            this._isStopped = false;
            this._error = null;
        },
        getHasObservers: function () {
            var observers = this._observers;
            return observers != null && observers.getData().length > 0;
        },
        getIsDisposed: function () {
            this._gate;
            {
                return this._isDisposed;
            }
        },
        onNext: function (value) {
            var $t, $t1;
            var o = null;
            this._gate;
            {
                this.checkDisposed();

                if (!this._isStopped) {
                    this.next(value);
                    this.trim();

                    o = this._observers.getData();
                    $t = Bridge.getEnumerator(o);
                    while ($t.moveNext()) {
                        var observer = $t.getCurrent();
                        observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](value);
                    }
                }
            }

            if (o != null) {
                $t1 = Bridge.getEnumerator(o);
                while ($t1.moveNext()) {
                    var observer1 = $t1.getCurrent();
                    observer1["System$Reactive$IScheduledObserver$1$" + Bridge.getTypeAlias(T) + "$ensureActive"]();
                }
            }
        },
        onError: function (error) {
            var $t, $t1;
            var o = null;
            this._gate;
            {
                this.checkDisposed();

                if (!this._isStopped) {
                    this._isStopped = true;
                    this._error = error;
                    this.trim();

                    o = this._observers.getData();
                    $t = Bridge.getEnumerator(o);
                    while ($t.moveNext()) {
                        var observer = $t.getCurrent();
                        observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](error);
                    }

                    this._observers = System.Reactive.ImmutableList$1(System.Reactive.IScheduledObserver$1(T)).empty;
                }
            }

            if (o != null) {
                $t1 = Bridge.getEnumerator(o);
                while ($t1.moveNext()) {
                    var observer1 = $t1.getCurrent();
                    observer1["System$Reactive$IScheduledObserver$1$" + Bridge.getTypeAlias(T) + "$ensureActive"]();
                }
            }
        },
        onCompleted: function () {
            var $t, $t1;
            var o = null;
            this._gate;
            {
                this.checkDisposed();

                if (!this._isStopped) {
                    this._isStopped = true;
                    this.trim();

                    o = this._observers.getData();
                    $t = Bridge.getEnumerator(o);
                    while ($t.moveNext()) {
                        var observer = $t.getCurrent();
                        observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
                    }

                    this._observers = System.Reactive.ImmutableList$1(System.Reactive.IScheduledObserver$1(T)).empty;
                }
            }

            if (o != null) {
                $t1 = Bridge.getEnumerator(o);
                while ($t1.moveNext()) {
                    var observer1 = $t1.getCurrent();
                    observer1["System$Reactive$IScheduledObserver$1$" + Bridge.getTypeAlias(T) + "$ensureActive"]();
                }
            }
        },
        subscribe: function (observer) {
            var so = this.createScheduledObserver(observer);

            var n = 0;

            var subscription = System.Reactive.Disposables.Disposable.getEmpty();

            this._gate;
            {
                this.checkDisposed();

                //
                // Notice the v1.x behavior of always calling Trim is preserved here.
                //
                // This may be subject (pun intended) of debate: should this policy
                // only be applied while the sequence is active? With the current
                // behavior, a sequence will "die out" after it has terminated by
                // continuing to drop OnNext notifications from the queue.
                //
                // In v1.x, this behavior was due to trimming based on the clock value
                // returned by scheduler.Now, applied to all but the terminal message
                // in the queue. Using the IStopwatch has the same effect. Either way,
                // we guarantee the final notification will be observed, but there's
                // no way to retain the buffer directly. One approach is to use the
                // time-based TakeLast operator and apply an unbounded ReplaySubject
                // to it.
                //
                // To conclude, we're keeping the behavior as-is for compatibility
                // reasons with v1.x.
                //
                this.trim();

                n = this.replay(so);

                if (this._error != null) {
                    n = (n + 1) | 0;
                    so["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](this._error);
                } else if (this._isStopped) {
                    n = (n + 1) | 0;
                    so["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
                }

                if (!this._isStopped) {
                    subscription = new (System.Reactive.Subjects.ReplaySubject$1.ReplayBase.Subscription(T))(this, so);
                    this._observers = this._observers.add(so);
                }
            }

            so["System$Reactive$IScheduledObserver$1$" + Bridge.getTypeAlias(T) + "$ensureActive$1"](n);

            return subscription;
        },
        dispose: function () {
            this._gate;
            {
                this._isDisposed = true;
                this._observers = null;
                this.disposeCore();
            }
        },
        checkDisposed: function () {
            if (this._isDisposed) {
                throw new System.ObjectDisposedException("");
            }
        },
        unsubscribe: function (observer) {
            this._gate;
            {
                if (!this._isDisposed) {
                    this._observers = this._observers.remove(observer);
                }
            }
        }
    }; });

    /**
     * Represents an object that is both an observable sequence as well as an observer.
     Each notification is broadcasted to all subscribed observers.
     *
     * @public
     * @class System.Reactive.Subjects.Subject$1
     * @augments System.Reactive.Subjects.SubjectBase$1
     * @implements  System.IDisposable
     * @param   {Function}    [name]    The type of the elements processed by the subject.
     */
    Bridge.define("System.Reactive.Subjects.Subject$1", function (T) { return {
        inherits: [System.Reactive.Subjects.SubjectBase$1(T),System.IDisposable],
        _observer: null,
        config: {
            alias: [
            "onCompleted", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted",
            "onError", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError",
            "onNext", "System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext",
            "subscribe", "System$IObservable$1$" + Bridge.getTypeAlias(T) + "$subscribe",
            "dispose", "System$IDisposable$dispose"
            ]
        },
        /**
         * Creates a subject.
         *
         * @instance
         * @public
         * @this System.Reactive.Subjects.Subject$1
         * @memberof System.Reactive.Subjects.Subject$1
         * @return  {void}
         */
        ctor: function () {
            this.$initialize();
            System.Reactive.Subjects.SubjectBase$1(T).ctor.call(this);
            this._observer = System.Reactive.NopObserver$1(T).instance;
        },
        /**
         * Indicates whether the subject has observers subscribed to it.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.Subject$1
         * @memberof System.Reactive.Subjects.Subject$1
         * @function getHasObservers
         * @return  {boolean}
         */
        /**
         * Indicates whether the subject has observers subscribed to it.
         *
         * @instance
         * @function setHasObservers
         */
        getHasObservers: function () {
            return !Bridge.referenceEquals(this._observer, System.Reactive.NopObserver$1(T).instance) && !(Bridge.is(this._observer, System.Reactive.DoneObserver$1(T))) && !Bridge.referenceEquals(this._observer, System.Reactive.DisposedObserver$1(T).instance);
        },
        /**
         * Indicates whether the subject has been disposed.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.Subject$1
         * @memberof System.Reactive.Subjects.Subject$1
         * @function getIsDisposed
         * @return  {boolean}
         */
        /**
         * Indicates whether the subject has been disposed.
         *
         * @instance
         * @function setIsDisposed
         */
        getIsDisposed: function () {
            return Bridge.is(this._observer, System.Reactive.DisposedObserver$1(T));
        },
        /**
         * Notifies all subscribed observers about the end of the sequence.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.Subject$1
         * @memberof System.Reactive.Subjects.Subject$1
         * @return  {void}
         */
        onCompleted: function () {
            var oldObserver = null;
            var newObserver = System.Reactive.DoneObserver$1(T).completed;

            do {
                oldObserver = this._observer;

                if (Bridge.referenceEquals(oldObserver, System.Reactive.DisposedObserver$1(T).instance) || Bridge.is(oldObserver, System.Reactive.DoneObserver$1(T))) {
                    break;
                }
            } while (!Bridge.referenceEquals(System.Interlocked.compareExchange(System.IObserver$1(T), Bridge.ref(this, "_observer"), newObserver, oldObserver), oldObserver));

            oldObserver["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
        },
        /**
         * Notifies all subscribed observers about the specified exception.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.Subject$1
         * @memberof System.Reactive.Subjects.Subject$1
         * @throws <b /> is null.
         * @param   {System.Exception}    error    The exception to send to all currently subscribed observers.
         * @return  {void}
         */
        onError: function (error) {
            if (error == null) {
                throw new System.ArgumentNullException("error");
            }

            var oldObserver = null;
            var newObserver = Bridge.merge(new (System.Reactive.DoneObserver$1(T))(), {
                setException: error
            } );

            do {
                oldObserver = this._observer;

                if (Bridge.referenceEquals(oldObserver, System.Reactive.DisposedObserver$1(T).instance) || Bridge.is(oldObserver, System.Reactive.DoneObserver$1(T))) {
                    break;
                }
            } while (!Bridge.referenceEquals(System.Interlocked.compareExchange(System.IObserver$1(T), Bridge.ref(this, "_observer"), newObserver, oldObserver), oldObserver));

            oldObserver["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](error);
        },
        /**
         * Notifies all subscribed observers about the arrival of the specified element in the sequence.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.Subject$1
         * @memberof System.Reactive.Subjects.Subject$1
         * @param   {T}       value    The value to send to all currently subscribed observers.
         * @return  {void}
         */
        onNext: function (value) {
            this._observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](value);
        },
        /**
         * Subscribes an observer to the subject.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.Subject$1
         * @memberof System.Reactive.Subjects.Subject$1
         * @throws <b /> is null.
         * @param   {System.IObserver$1}    observer    Observer to subscribe to the subject.
         * @return  {System.IDisposable}                Disposable object that can be used to unsubscribe the observer from the subject.
         */
        subscribe: function (observer) {
            if (observer == null) {
                throw new System.ArgumentNullException("observer");
            }

            var oldObserver = null;
            var newObserver = null;

            do {
                oldObserver = this._observer;

                if (Bridge.referenceEquals(oldObserver, System.Reactive.DisposedObserver$1(T).instance)) {
                    throw new System.ObjectDisposedException("");
                }

                if (Bridge.referenceEquals(oldObserver, System.Reactive.DoneObserver$1(T).completed)) {
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onCompleted"]();
                    return System.Reactive.Disposables.Disposable.getEmpty();
                }

                var done = Bridge.as(oldObserver, System.Reactive.DoneObserver$1(T));
                if (done != null) {
                    observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onError"](done.getException());
                    return System.Reactive.Disposables.Disposable.getEmpty();
                }

                if (Bridge.referenceEquals(oldObserver, System.Reactive.NopObserver$1(T).instance)) {
                    newObserver = observer;
                } else {
                    var obs = Bridge.as(oldObserver, System.Reactive.Observer$1(T));
                    if (obs != null) {
                        newObserver = obs.add(observer);
                    } else {
                        newObserver = new (System.Reactive.Observer$1(T))(new (System.Reactive.ImmutableList$1(System.IObserver$1(T))).$ctor1([oldObserver, observer]));
                    }
                }
            } while (!Bridge.referenceEquals(System.Interlocked.compareExchange(System.IObserver$1(T), Bridge.ref(this, "_observer"), newObserver, oldObserver), oldObserver));

            return new (System.Reactive.Subjects.Subject$1.Subscription(T))(this, observer);
        },
        unsubscribe: function (observer) {
            var oldObserver = null;
            var newObserver = null;

            do {
                oldObserver = this._observer;

                if (Bridge.referenceEquals(oldObserver, System.Reactive.DisposedObserver$1(T).instance) || Bridge.is(oldObserver, System.Reactive.DoneObserver$1(T))) {
                    return;
                }

                var obs = Bridge.as(oldObserver, System.Reactive.Observer$1(T));
                if (obs != null) {
                    newObserver = obs.remove(observer);
                } else {
                    if (!Bridge.referenceEquals(oldObserver, observer)) {
                        return;
                    }

                    newObserver = System.Reactive.NopObserver$1(T).instance;
                }
            } while (!Bridge.referenceEquals(System.Interlocked.compareExchange(System.IObserver$1(T), Bridge.ref(this, "_observer"), newObserver, oldObserver), oldObserver));
        },
        /**
         * Releases all resources used by the current instance of the {@link } class and unsubscribes all observers.
         *
         * @instance
         * @public
         * @override
         * @this System.Reactive.Subjects.Subject$1
         * @memberof System.Reactive.Subjects.Subject$1
         * @return  {void}
         */
        dispose: function () {
            this._observer = System.Reactive.DisposedObserver$1(T).instance;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.FromEvent$2", function (TDelegate, TEventArgs) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.ClassicEventProducer$2(TDelegate,TEventArgs)],
        _conversion: null,
        ctor: function (addHandler, removeHandler, scheduler) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ClassicEventProducer$2(TDelegate,TEventArgs).ctor.call(this, addHandler, removeHandler, scheduler);
        },
        $ctor1: function (conversion, addHandler, removeHandler, scheduler) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ClassicEventProducer$2(TDelegate,TEventArgs).ctor.call(this, addHandler, removeHandler, scheduler);
            this._conversion = conversion;
        },
        getHandler: function (onNext) {
            var handler = Bridge.getDefaultValue(TDelegate);

            if (Bridge.staticEquals(this._conversion, null)) {
                handler = System.Reactive.ReflectionUtils.createDelegate(TDelegate, onNext, Bridge.Reflection.getMembers(Function, 8, 284, "Invoke"));
            } else {
                handler = this._conversion(onNext);
            }

            return handler;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.FromEventPattern.Impl$2", function (TDelegate, TEventArgs) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.ClassicEventProducer$2(TDelegate,System.Reactive.EventPattern$1(TEventArgs))],
        _conversion: null,
        ctor: function (addHandler, removeHandler, scheduler) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ClassicEventProducer$2(TDelegate,System.Reactive.EventPattern$1(TEventArgs)).ctor.call(this, addHandler, removeHandler, scheduler);
        },
        $ctor1: function (conversion, addHandler, removeHandler, scheduler) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ClassicEventProducer$2(TDelegate,System.Reactive.EventPattern$1(TEventArgs)).ctor.call(this, addHandler, removeHandler, scheduler);
            this._conversion = conversion;
        },
        getHandler: function (onNext) {
            var handler = Bridge.getDefaultValue(TDelegate);

            if (Bridge.staticEquals(this._conversion, null)) {
                var h = function (sender, eventArgs) {
                    onNext(new (System.Reactive.EventPattern$1(TEventArgs))(sender, eventArgs));
                };
                handler = System.Reactive.ReflectionUtils.createDelegate(TDelegate, h, Bridge.Reflection.getMembers(Function, 8, 284, "Invoke"));
            } else {
                handler = this._conversion(function (sender, eventArgs) {
                    onNext(new (System.Reactive.EventPattern$1(TEventArgs))(sender, eventArgs));
                });
            }

            return handler;
        }
    }; });

    Bridge.define("System.Reactive.Linq.ObservableImpl.FromEventPattern.Impl$3", function (TDelegate, TSender, TEventArgs) { return {
        inherits: [System.Reactive.Linq.ObservableImpl.ClassicEventProducer$2(TDelegate,System.Reactive.EventPattern$2(TSender,TEventArgs))],
        ctor: function (addHandler, removeHandler, scheduler) {
            this.$initialize();
            System.Reactive.Linq.ObservableImpl.ClassicEventProducer$2(TDelegate,System.Reactive.EventPattern$2(TSender,TEventArgs)).ctor.call(this, addHandler, removeHandler, scheduler);
        },
        getHandler: function (onNext) {
            var h = function (sender, eventArgs) {
                onNext(new (System.Reactive.EventPattern$2(TSender,TEventArgs))(sender, eventArgs));
            };
            return System.Reactive.ReflectionUtils.createDelegate(TDelegate, h, Bridge.Reflection.getMembers(Function, 8, 284, "Invoke"));
        }
    }; });

    Bridge.define("System.Reactive.Subjects.ReplaySubject$1.ReplayBufferBase", function (T) { return {
        inherits: [System.Reactive.Subjects.ReplaySubject$1.ReplayBase(T)],
        createScheduledObserver: function (observer) {
            return new (System.Reactive.Subjects.FastImmediateObserver$1(T))(observer);
        },
        disposeCore: function () {
        }
    }; });

    /**
     * Original implementation of the ReplaySubject with time based operations (Scheduling, Stopwatch, buffer-by-time).
     *
     * @private
     * @class System.Reactive.Subjects.ReplaySubject$1.ReplayByTime
     * @augments System.Reactive.Subjects.ReplaySubject$1.ReplayBase
     */
    Bridge.define("System.Reactive.Subjects.ReplaySubject$1.ReplayByTime", function (T) { return {
        inherits: [System.Reactive.Subjects.ReplaySubject$1.ReplayBase(T)],
        statics: {
            InfiniteBufferSize: 2147483647
        },
        _bufferSize: 0,
        _scheduler: null,
        _stopwatch: null,
        _queue: null,
        config: {
            init: function () {
                this._window = new System.TimeSpan();
            }
        },
        $ctor2: function (bufferSize, $window, scheduler) {
            this.$initialize();
            System.Reactive.Subjects.ReplaySubject$1.ReplayBase(T).ctor.call(this);
            if (bufferSize < 0) {
                throw new System.ArgumentOutOfRangeException("bufferSize");
            }
            if (System.TimeSpan.lt($window, System.TimeSpan.zero)) {
                throw new System.ArgumentOutOfRangeException("window");
            }
            if (scheduler == null) {
                throw new System.ArgumentNullException("scheduler");
            }

            this._bufferSize = bufferSize;
            this._window = $window;
            this._scheduler = scheduler;

            this._stopwatch = System.Reactive.Concurrency.Scheduler.startStopwatch(this._scheduler);
            this._queue = new (System.Collections.Generic.Queue$1(System.Reactive.TimeInterval$1(T))).ctor();
        },
        $ctor1: function (bufferSize, $window) {
            System.Reactive.Subjects.ReplaySubject$1.ReplayByTime(T).$ctor2.call(this, bufferSize, $window, System.Reactive.Concurrency.SchedulerDefaults.getIteration());
        },
        $ctor3: function (scheduler) {
            System.Reactive.Subjects.ReplaySubject$1.ReplayByTime(T).$ctor2.call(this, System.Reactive.Subjects.ReplaySubject$1.ReplayByTime(T).InfiniteBufferSize, System.TimeSpan.maxValue, scheduler);
        },
        ctor: function (bufferSize, scheduler) {
            System.Reactive.Subjects.ReplaySubject$1.ReplayByTime(T).$ctor2.call(this, bufferSize, System.TimeSpan.maxValue, scheduler);
        },
        $ctor5: function ($window, scheduler) {
            System.Reactive.Subjects.ReplaySubject$1.ReplayByTime(T).$ctor2.call(this, System.Reactive.Subjects.ReplaySubject$1.ReplayByTime(T).InfiniteBufferSize, $window, scheduler);
        },
        $ctor4: function ($window) {
            System.Reactive.Subjects.ReplaySubject$1.ReplayByTime(T).$ctor2.call(this, System.Reactive.Subjects.ReplaySubject$1.ReplayByTime(T).InfiniteBufferSize, $window, System.Reactive.Concurrency.SchedulerDefaults.getIteration());
        },
        createScheduledObserver: function (observer) {
            return new (System.Reactive.ScheduledObserver$1(T))(this._scheduler, observer);
        },
        disposeCore: function () {
            this._queue.clear();
        },
        next: function (value) {
            var now = this._stopwatch.System$Reactive$Concurrency$IStopwatch$getElapsed();

            this._queue.enqueue(new (System.Reactive.TimeInterval$1(T)).$ctor1(value, now));
        },
        replay: function (observer) {
            var $t;
            var n = this._queue.getCount();

            $t = Bridge.getEnumerator(this._queue);
            while ($t.moveNext()) {
                var item = $t.getCurrent();
                observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](item.getValue());
            }

            return n;
        },
        trim: function () {
            var now = this._stopwatch.System$Reactive$Concurrency$IStopwatch$getElapsed();

            while (this._queue.getCount() > this._bufferSize) {
                this._queue.dequeue();
            }
            while (this._queue.getCount() > 0 && now.subtract(this._queue.peek().getInterval()).compareTo(this._window) > 0) {
                this._queue.dequeue();
            }
        }
    }; });

    Bridge.define("System.Reactive.Subjects.ReplaySubject$1.ReplayManyBase", function (T) { return {
        inherits: [System.Reactive.Subjects.ReplaySubject$1.ReplayBufferBase(T)],
        _queue: null,
        ctor: function (queueSize) {
            this.$initialize();
            System.Reactive.Subjects.ReplaySubject$1.ReplayBufferBase(T).ctor.call(this);
            this._queue = new (System.Collections.Generic.Queue$1(T)).$ctor2(Math.min(queueSize, 64));
        },
        next: function (value) {
            this._queue.enqueue(value);
        },
        replay: function (observer) {
            var $t;
            var n = this._queue.getCount();

            $t = Bridge.getEnumerator(this._queue);
            while ($t.moveNext()) {
                var item = $t.getCurrent();
                observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](item);
            }

            return n;
        },
        disposeCore: function () {
            this._queue.clear();
        }
    }; });

    Bridge.define("System.Reactive.Subjects.ReplaySubject$1.ReplayOne", function (T) { return {
        inherits: [System.Reactive.Subjects.ReplaySubject$1.ReplayBufferBase(T)],
        _hasValue: false,
        _value: Bridge.getDefaultValue(T),
        trim: function () {
            //
            // No need to trim.
            //
        },
        next: function (value) {
            this._hasValue = true;
            this._value = value;
        },
        replay: function (observer) {
            var n = 0;

            if (this._hasValue) {
                n = 1;
                observer["System$IObserver$1$" + Bridge.getTypeAlias(T) + "$onNext"](this._value);
            }

            return n;
        },
        disposeCore: function () {
            this._value = Bridge.getDefaultValue(T);
        }
    }; });

    Bridge.define("System.Reactive.Subjects.ReplaySubject$1.ReplayAll", function (T) { return {
        inherits: [System.Reactive.Subjects.ReplaySubject$1.ReplayManyBase(T)],
        ctor: function () {
            this.$initialize();
            System.Reactive.Subjects.ReplaySubject$1.ReplayManyBase(T).ctor.call(this, 0);
        },
        trim: function () {
            //
            // Don't trim, keep all values.
            //
        }
    }; });

    Bridge.define("System.Reactive.Subjects.ReplaySubject$1.ReplayMany", function (T) { return {
        inherits: [System.Reactive.Subjects.ReplaySubject$1.ReplayManyBase(T)],
        _bufferSize: 0,
        ctor: function (bufferSize) {
            this.$initialize();
            System.Reactive.Subjects.ReplaySubject$1.ReplayManyBase(T).ctor.call(this, bufferSize);
            this._bufferSize = bufferSize;
        },
        trim: function () {
            while (this._queue.getCount() > this._bufferSize) {
                this._queue.dequeue();
            }
        }
    }; });

    var $m = Bridge.setMetadata,
        $n = [System.Reactive.Concurrency,System.Reactive.Disposables,System.Reactive.Joins,System.Reactive.Linq,System.Reactive,System.Reactive.PlatformServices,System.Reactive.Subjects];
    $m($n[0].NamespaceDoc, function () { return {"at":[new System.Runtime.CompilerServices.CompilerGeneratedAttribute()]}; });
    $m($n[1].NamespaceDoc, function () { return {"at":[new System.Runtime.CompilerServices.CompilerGeneratedAttribute()]}; });
    $m($n[2].NamespaceDoc, function () { return {"at":[new System.Runtime.CompilerServices.CompilerGeneratedAttribute()]}; });
    $m($n[3].LocalQueryMethodImplementationTypeAttribute, function () { return {"ni":true}; });
    $m($n[3].NamespaceDoc, function () { return {"at":[new System.Runtime.CompilerServices.CompilerGeneratedAttribute()]}; });
    $m($n[4].NamespaceDoc, function () { return {"at":[new System.Runtime.CompilerServices.CompilerGeneratedAttribute()]}; });
    $m($n[5].NamespaceDoc, function () { return {"at":[new System.Runtime.CompilerServices.CompilerGeneratedAttribute()]}; });
    $m($n[6].NamespaceDoc, function () { return {"at":[new System.Runtime.CompilerServices.CompilerGeneratedAttribute()]}; });
});
